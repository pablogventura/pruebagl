<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head><title>Computabilidad y logica</title> 
<meta charset='utf-8' /> 
<meta name='generator' content='TeX4ht (http://www.tug.org/tex4ht/)' /> 
<meta name='viewport' content='width=device-width,initial-scale=1' /> 
<link href='apunte.css' rel='stylesheet' type='text/css' /> 
<meta name='src' content='apunte.tex' /> 
 <script type='text/x-mathjax-config'> MathJax.Hub.Config({ 'fast-preview': {disabled: true}, TeX: { extensions: ["color.js","AMSmath.js"], equationNumbers: { autoNumber: "AMS" } }, extensions: ["tex2jax.js"], tex2jax: {  inlineMath: [ ["\\\(","\\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true, processEnvironments: true } }); </script> 
 <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML'></script>  
</head><body>
   <div class='maketitle'>



<h2 class='titleHead'>Computabilidad y logica</h2>
<div class='author'></div><br />
<div class='date'><span class='cmr-12'>August 26, 2021</span></div>
   </div>
   <h3 class='likesectionHead'><a id='x1-1000'></a>Contents</h3>
   <div class='tableofcontents'>
   <span class='sectionToc'>1 <a id='QQ2-1-2' href='#x1-20001'>Notacion y conceptos basicos</a></span>
<br />    <span class='subsectionToc'>1.1 <a id='QQ2-1-3' href='#x1-30001.1'>Conjuntos</a></span>
<br />    <span class='subsectionToc'>1.2 <a id='QQ2-1-4' href='#x1-40001.2'>Producto carteciano</a></span>
<br />    <span class='subsectionToc'>1.3 <a id='QQ2-1-5' href='#x1-50001.3'>Alfabetos</a></span>
<br />     <span class='subsubsectionToc'>1.3.1 <a id='QQ2-1-6' href='#x1-60001.3.1'>Ocurrencias</a></span>
<br />    <span class='subsectionToc'>1.4 <a id='QQ2-1-7' href='#x1-70001.4'>Matematica orientada a objetos</a></span>
<br />    <span class='subsectionToc'>1.5 <a id='QQ2-1-8' href='#x1-80001.5'>El concepto de funcion</a></span>
<br />     <span class='subsubsectionToc'>1.5.1 <a id='QQ2-1-10' href='#x1-100001.5.1'>Funcion identidad</a></span>
<br />     <span class='subsubsectionToc'>1.5.2 <a id='QQ2-1-11' href='#x1-110001.5.2'>Composicion de funciones</a></span>
<br />     <span class='subsubsectionToc'>1.5.3 <a id='QQ2-1-12' href='#x1-120001.5.3'>Funciones inyectivas, suryectivas y biyectivas</a></span>
<br />     <span class='subsubsectionToc'>1.5.4 <a id='QQ2-1-13' href='#x1-130001.5.4'>El nucleo de una funcion</a></span>
<br />     <span class='subsubsectionToc'>1.5.5 <a id='QQ2-1-14' href='#x1-140001.5.5'>Funcion caracteristica de un subconjunto</a></span>
<br />     <span class='subsubsectionToc'>1.5.6 <a id='QQ2-1-15' href='#x1-150001.5.6'>Restriccion de una funcion</a></span>
<br />     <span class='subsubsectionToc'>1.5.7 <a id='QQ2-1-16' href='#x1-160001.5.7'>Funciones de la forma \([f_{1},...,f_{n}]\)</a></span>
<br />     <span class='subsubsectionToc'>1.5.8 <a id='QQ2-1-17' href='#x1-170001.5.8'>Union de funciones con dominios disjuntos</a></span>
<br />    <span class='subsectionToc'>1.6 <a id='QQ2-1-18' href='#x1-180001.6'>Relaciones binarias</a></span>
<br />     <span class='subsubsectionToc'>1.6.1 <a id='QQ2-1-19' href='#x1-190001.6.1'>Propiedades notables de relaciones binarias</a></span>
<br />     <span class='subsubsectionToc'>1.6.2 <a id='QQ2-1-20' href='#x1-200001.6.2'>Ordenes parciales</a></span>
<br />     <span class='subsubsectionToc'>1.6.3 <a id='QQ2-1-23' href='#x1-230001.6.3'>Relaciones de equivalencia</a></span>
<br />    <span class='subsectionToc'>1.7 <a id='QQ2-1-26' href='#x1-260001.7'>Operaciones \(n\)-arias sobre un conjunto</a></span>
<br />    <span class='subsectionToc'>1.8 <a id='QQ2-1-27' href='#x1-270001.8'>Relaciones \(n\)-arias sobre un conjunto</a></span>
<br />    <span class='subsectionToc'>1.9 <a id='QQ2-1-28' href='#x1-280001.9'>Funciones \(\Sigma \)-mixtas</a></span>
<br />     <span class='subsubsectionToc'>1.9.1 <a id='QQ2-1-30' href='#x1-300001.9.1'>Funciones \(Suc\) y \(Pred\)</a></span>
<br />     <span class='subsubsectionToc'>1.9.2 <a id='QQ2-1-31' href='#x1-310001.9.2'>Las funciones \(d_{a}\)</a></span>
<br />     <span class='subsubsectionToc'>1.9.3 <a id='QQ2-1-32' href='#x1-320001.9.3'>Las funciones \(p_{i}^{n,m}\)</a></span>

<br />     <span class='subsubsectionToc'>1.9.4 <a id='QQ2-1-33' href='#x1-330001.9.4'>Las funciones \(C_{k}^{n,m}\) y \(C_{\alpha }^{n,m}\)</a></span>
<br />     <span class='subsubsectionToc'>1.9.5 <a id='QQ2-1-34' href='#x1-340001.9.5'>La funcion \(pr\)</a></span>
<br />     <span class='subsubsectionToc'>1.9.6 <a id='QQ2-1-35' href='#x1-350001.9.6'>El tipo de una funcion mixta</a></span>
<br />     <span class='subsubsectionToc'>1.9.7 <a id='QQ2-1-36' href='#x1-360001.9.7'>Funciones con imagen contenida en \(\omega ^{n}\times \Sigma ^{\ast m}\)</a></span>
<br />     <span class='subsubsectionToc'>1.9.8 <a id='QQ2-1-37' href='#x1-370001.9.8'>Predicados \(\Sigma \)-mixtos</a></span>
<br />     <span class='subsubsectionToc'>1.9.9 <a id='QQ2-1-39' href='#x1-390001.9.9'>Familias \(\Sigma \)-indexadas de funciones</a></span>
<br />    <span class='subsectionToc'>1.10 <a id='QQ2-1-40' href='#x1-400001.10'>Conjuntos \(\Sigma \)-mixtos</a></span>
<br />     <span class='subsubsectionToc'>1.10.1 <a id='QQ2-1-41' href='#x1-410001.10.1'>El tipo de un conjunto mixto</a></span>
<br />     <span class='subsubsectionToc'>1.10.2 <a id='QQ2-1-42' href='#x1-420001.10.2'>Conjuntos rectangulares</a></span>
<br />    <span class='subsectionToc'>1.11 <a id='QQ2-1-43' href='#x1-430001.11'>Notacion lambda</a></span>
<br />    <span class='subsectionToc'>1.12 <a id='QQ2-1-45' href='#x1-450001.12'>Ordenes naturales sobre \(\Sigma ^{\ast }\)</a></span>
<br />     <span class='subsubsectionToc'>1.12.1 <a id='QQ2-1-46' href='#x1-460001.12.1'>Prueba de las propiedades (S) e (I)</a></span>
<br />    <span class='subsectionToc'>1.13 <a id='QQ2-1-47' href='#x1-470001.13'>El caso general</a></span>
<br />     <span class='subsubsectionToc'>1.13.1 <a id='QQ2-1-48' href='#x1-480001.13.1'>Caracter recursivo de las funciones \(s^{\leq }\), \(\ast ^{\leq }\) y \(#^{\leq }\)</a></span>
<br />     <span class='subsubsectionToc'>1.13.2 <a id='QQ2-1-49' href='#x1-490001.13.2'>Extension del orden total de \(\Sigma \) a \(\Sigma ^{\ast }\)</a></span>
<br />    <span class='subsectionToc'>1.14 <a id='QQ2-1-50' href='#x1-500001.14'>Codificacion de infinituplas de numeros</a></span>
<br />   <span class='sectionToc'>2 <a id='QQ2-1-51' href='#x1-510002'>Procedimientos efectivos</a></span>
<br />    <span class='subsectionToc'>2.1 <a id='QQ2-1-52' href='#x1-520002.1'>Funciones \(\Sigma \)-efectivamente computables</a></span>
<br />     <span class='subsubsectionToc'>2.1.1 <a id='QQ2-1-53' href='#x1-530002.1.1'>Constructores de funciones</a></span>
<br />     <span class='subsubsectionToc'>2.1.2 <a id='QQ2-1-54' href='#x1-540002.1.2'>Composicion</a></span>
<br />     <span class='subsubsectionToc'>2.1.3 <a id='QQ2-1-55' href='#x1-550002.1.3'>Lema de division por casos para funciones \(\Sigma \)-efectivamente computables</a></span>
<br />    <span class='subsectionToc'>2.2 <a id='QQ2-1-56' href='#x1-560002.2'>Conjuntos \(\Sigma \)-efectivamente computables</a></span>
<br />    <span class='subsectionToc'>2.3 <a id='QQ2-1-57' href='#x1-570002.3'>Conjuntos \(\Sigma \)-efectivamente enumerables</a></span>
<br />    <span class='subsectionToc'>2.4 <a id='QQ2-1-58' href='#x1-580002.4'>Independencia del alfabeto</a></span>
<br />   <span class='sectionToc'>3 <a id='QQ2-1-59' href='#x1-590003'>Tres modelos matematicos de la computabilidad efectiva</a></span>
<br />    <span class='subsectionToc'>3.1 <a id='QQ2-1-60' href='#x1-600003.1'>El paradigma de Turing</a></span>
<br />     <span class='subsubsectionToc'>3.1.1 <a id='QQ2-1-61' href='#x1-610003.1.1'>Descripcion informal de las maquinas de Turing</a></span>
<br />     <span class='subsubsectionToc'>3.1.2 <a id='QQ2-1-62' href='#x1-620003.1.2'>Definicion matematica de maquina de Turing</a></span>
<br />     <span class='subsubsectionToc'>3.1.3 <a id='QQ2-1-69' href='#x1-690003.1.3'>Funciones \(\Sigma \)-Turing computables</a></span>
<br />     <span class='subsubsectionToc'>3.1.4 <a id='QQ2-1-70' href='#x1-700003.1.4'>Conjuntos \(\Sigma \)-Turing enumerables</a></span>
<br />     <span class='subsubsectionToc'>3.1.5 <a id='QQ2-1-71' href='#x1-710003.1.5'>Conjuntos \(\Sigma \)-Turing computables</a></span>
<br />    <span class='subsectionToc'>3.2 <a id='QQ2-1-72' href='#x1-720003.2'>El paradigma de Godel: Funciones \(\Sigma \)-recursivas</a></span>
<br />     <span class='subsubsectionToc'>3.2.1 <a id='QQ2-1-73' href='#x1-730003.2.1'>Funciones \(\Sigma \)-recursivas primitivas</a></span>
<br />     <span class='subsubsectionToc'>3.2.2 <a id='QQ2-1-87' href='#x1-870003.2.2'>Minimizacion y funciones \(\Sigma \)-recursivas</a></span>
<br />     <span class='subsubsectionToc'>3.2.3 <a id='QQ2-1-93' href='#x1-930003.2.3'>Conjuntos \(\Sigma \)-recursivamente enumerables</a></span>
<br />     <span class='subsubsectionToc'>3.2.4 <a id='QQ2-1-94' href='#x1-940003.2.4'>Conjuntos \(\Sigma \)-recursivos</a></span>
<br />     <span class='subsubsectionToc'>3.2.5 <a id='QQ2-1-95' href='#x1-950003.2.5'>Algunos resultados basicos</a></span>
<br />     <span class='subsubsectionToc'>3.2.6 <a id='QQ2-1-96' href='#x1-960003.2.6'>Recursion primitiva sobre valores anteriores</a></span>
<br />     <span class='subsubsectionToc'>3.2.7 <a id='QQ2-1-97' href='#x1-970003.2.7'>Independencia del alfabeto</a></span>
<br />    <span class='subsectionToc'>3.3 <a id='QQ2-1-98' href='#x1-980003.3'>El paradigma imperativo de Neumann: El lenguaje \(\mathcal{S}^{\Sigma }\)</a></span>
<br />     <span class='subsubsectionToc'>3.3.1 <a id='QQ2-1-99' href='#x1-990003.3.1'>Sintaxis de \(\mathcal{S}^{\Sigma }\)</a></span>
<br />     <span class='subsubsectionToc'>3.3.2 <a id='QQ2-1-100' href='#x1-1000003.3.2'>Semantica de \(\mathcal{S}^{\Sigma }\)</a></span>
<br />     <span class='subsubsectionToc'>3.3.3 <a id='QQ2-1-103' href='#x1-1030003.3.3'>Funciones \(\Sigma \)-computables</a></span>
<br />     <span class='subsubsectionToc'>3.3.4 <a id='QQ2-1-104' href='#x1-1040003.3.4'>Macros</a></span>
<br />     <span class='subsubsectionToc'>3.3.5 <a id='QQ2-1-108' href='#x1-1080003.3.5'>Conjuntos \(\Sigma \)-enumerables</a></span>
<br />     <span class='subsubsectionToc'>3.3.6 <a id='QQ2-1-109' href='#x1-1090003.3.6'>Conjuntos \(\Sigma \)-computables</a></span>

<br />    <span class='subsectionToc'>3.4 <a id='QQ2-1-111' href='#x1-1110003.4'>Batallas entre paradigmas</a></span>
<br />     <span class='subsubsectionToc'>3.4.1 <a id='QQ2-1-112' href='#x1-1120003.4.1'>Neumann vence a Godel</a></span>
<br />     <span class='subsubsectionToc'>3.4.2 <a id='QQ2-1-114' href='#x1-1140003.4.2'>Godel vence a Neumann</a></span>
<br />     <span class='subsubsectionToc'>3.4.3 <a id='QQ2-1-123' href='#x1-1230003.4.3'>Godel vence a Turing</a></span>
<br />     <span class='subsubsectionToc'>3.4.4 <a id='QQ2-1-124' href='#x1-1240003.4.4'>Turing vence a Neumann</a></span>
<br />    <span class='subsectionToc'>3.5 <a id='QQ2-1-131' href='#x1-1310003.5'>Conclusiones: La tesis de Church</a></span>
<br />    <span class='subsectionToc'>3.6 <a id='QQ2-1-132' href='#x1-1320003.6'>Resultados basicos presentados en paradigma recursivo</a></span>
<br />     <span class='subsubsectionToc'>3.6.1 <a id='QQ2-1-133' href='#x1-1330003.6.1'>Lema de division por casos para funciones \(\Sigma \)-recursivas</a></span>
<br />     <span class='subsubsectionToc'>3.6.2 <a id='QQ2-1-134' href='#x1-1340003.6.2'>Conjuntos \(\Sigma \)-recursivos y \(\Sigma \)-recursivamente enumerables</a></span>
<br />     <span class='subsubsectionToc'>3.6.3 <a id='QQ2-1-135' href='#x1-1350003.6.3'>El halting problem y los conjuntos \(A\) y \(N\)</a></span>
<br />   <span class='sectionToc'>4 <a id='QQ2-1-136' href='#x1-1360004'>Estructuras algebraicas ordenadas</a></span>
<br />    <span class='subsectionToc'>4.1 <a id='QQ2-1-137' href='#x1-1370004.1'>Conjuntos parcialmente ordenados</a></span>
<br />     <span class='subsubsectionToc'>4.1.1 <a id='QQ2-1-138' href='#x1-1380004.1.1'>Diagramas de Hasse</a></span>
<br />     <span class='subsubsectionToc'>4.1.2 <a id='QQ2-1-139' href='#x1-1390004.1.2'>Elementos maximales, maximos, minimales y minimos</a></span>
<br />     <span class='subsubsectionToc'>4.1.3 <a id='QQ2-1-140' href='#x1-1400004.1.3'>Supremos</a></span>
<br />     <span class='subsubsectionToc'>4.1.4 <a id='QQ2-1-141' href='#x1-1410004.1.4'>Infimos</a></span>
<br />     <span class='subsubsectionToc'>4.1.5 <a id='QQ2-1-142' href='#x1-1420004.1.5'>Homomorfismos de posets</a></span>
<br />     <span class='subsubsectionToc'>4.1.6 <a id='QQ2-1-143' href='#x1-1430004.1.6'>Version geometrica del concepto de reticulado</a></span>
<br />    <span class='subsectionToc'>4.2 <a id='QQ2-1-144' href='#x1-1440004.2'>Version algebraica del concepto de reticulado</a></span>
<br />     <span class='subsubsectionToc'>4.2.1 <a id='QQ2-1-145' href='#x1-1450004.2.1'>El orden asociado a un reticulado</a></span>
<br />     <span class='subsubsectionToc'>4.2.2 <a id='QQ2-1-146' href='#x1-1460004.2.2'>Notacion</a></span>
<br />     <span class='subsubsectionToc'>4.2.3 <a id='QQ2-1-147' href='#x1-1470004.2.3'>Subreticulados</a></span>
<br />     <span class='subsubsectionToc'>4.2.4 <a id='QQ2-1-148' href='#x1-1480004.2.4'>Homomorfismos de reticulados</a></span>
<br />     <span class='subsubsectionToc'>4.2.5 <a id='QQ2-1-149' href='#x1-1490004.2.5'>Congruencias de reticulados</a></span>
<br />    <span class='subsectionToc'>4.3 <a id='QQ2-1-150' href='#x1-1500004.3'>Reticulados acotados</a></span>
<br />     <span class='subsubsectionToc'>4.3.1 <a id='QQ2-1-151' href='#x1-1510004.3.1'>Subreticulados acotados</a></span>
<br />     <span class='subsubsectionToc'>4.3.2 <a id='QQ2-1-152' href='#x1-1520004.3.2'>Homomorfismos de reticulados acotados</a></span>
<br />     <span class='subsubsectionToc'>4.3.3 <a id='QQ2-1-153' href='#x1-1530004.3.3'>Congruencias de reticulados acotados</a></span>
<br />    <span class='subsectionToc'>4.4 <a id='QQ2-1-154' href='#x1-1540004.4'>Reticulados complementados</a></span>
<br />     <span class='subsubsectionToc'>4.4.1 <a id='QQ2-1-155' href='#x1-1550004.4.1'>Subreticulados complementados</a></span>
<br />     <span class='subsubsectionToc'>4.4.2 <a id='QQ2-1-156' href='#x1-1560004.4.2'>Homomorfismos de reticulados complementados</a></span>
<br />     <span class='subsubsectionToc'>4.4.3 <a id='QQ2-1-157' href='#x1-1570004.4.3'>Congruencias de reticulados complementados</a></span>
<br />    <span class='subsectionToc'>4.5 <a id='QQ2-1-158' href='#x1-1580004.5'>Algebras de Boole</a></span>
<br />    <span class='subsectionToc'>4.6 <a id='QQ2-1-159' href='#x1-1590004.6'>Teoremas del filtro primo y de Rasiowa Sikorski</a></span>
<br />   <span class='sectionToc'>5 <a id='QQ2-1-160' href='#x1-1600005'>Sintaxis de la logica de primer orden</a></span>
<br />    <span class='subsectionToc'>5.1 <a id='QQ2-1-161' href='#x1-1610005.1'>Variables</a></span>
<br />    <span class='subsectionToc'>5.2 <a id='QQ2-1-162' href='#x1-1620005.2'>Tipos</a></span>
<br />    <span class='subsectionToc'>5.3 <a id='QQ2-1-163' href='#x1-1630005.3'>Terminos</a></span>
<br />     <span class='subsubsectionToc'>5.3.1 <a id='QQ2-1-164' href='#x1-1640005.3.1'>Unicidad de la lectura de terminos</a></span>
<br />     <span class='subsubsectionToc'>5.3.2 <a id='QQ2-1-165' href='#x1-1650005.3.2'>Subterminos</a></span>
<br />    <span class='subsectionToc'>5.4 <a id='QQ2-1-166' href='#x1-1660005.4'>Formulas</a></span>
<br />     <span class='subsubsectionToc'>5.4.1 <a id='QQ2-1-167' href='#x1-1670005.4.1'>Unicidad de la lectura de formulas</a></span>
<br />     <span class='subsubsectionToc'>5.4.2 <a id='QQ2-1-168' href='#x1-1680005.4.2'>Subformulas</a></span>
<br />    <span class='subsectionToc'>5.5 <a id='QQ2-1-169' href='#x1-1690005.5'>Variables libres</a></span>
<br />   <span class='sectionToc'>6 <a id='QQ2-1-170' href='#x1-1700006'>Semantica de la logica de primer orden</a></span>
<br />    <span class='subsectionToc'>6.1 <a id='QQ2-1-171' href='#x1-1710006.1'>Estructuras de tipo \(\tau \)</a></span>

<br />     <span class='subsubsectionToc'>6.1.1 <a id='QQ2-1-172' href='#x1-1720006.1.1'>El valor de un termino en una estructura</a></span>
<br />     <span class='subsubsectionToc'>6.1.2 <a id='QQ2-1-173' href='#x1-1730006.1.2'>El valor de verdad de una formula en una estructura</a></span>
<br />    <span class='subsectionToc'>6.2 <a id='QQ2-1-174' href='#x1-1740006.2'>Equivalencia de formulas</a></span>
<br />    <span class='subsectionToc'>6.3 <a id='QQ2-1-175' href='#x1-1750006.3'>Homomorfismos</a></span>
<br />    <span class='subsectionToc'>6.4 <a id='QQ2-1-176' href='#x1-1760006.4'>Algebras</a></span>
<br />     <span class='subsubsectionToc'>6.4.1 <a id='QQ2-1-177' href='#x1-1770006.4.1'>Subalgebras</a></span>
<br />     <span class='subsubsectionToc'>6.4.2 <a id='QQ2-1-178' href='#x1-1780006.4.2'>Congruencias</a></span>
<br />     <span class='subsubsectionToc'>6.4.3 <a id='QQ2-1-179' href='#x1-1790006.4.3'>Producto directo de algebras</a></span>
<br />   <span class='sectionToc'>7 <a id='QQ2-1-180' href='#x1-1800007'>Dos teoremas de reemplazo</a></span>
<br />    <span class='subsectionToc'>7.1 <a id='QQ2-1-181' href='#x1-1810007.1'>Notacion declaratoria para terminos</a></span>
<br />    <span class='subsectionToc'>7.2 <a id='QQ2-1-182' href='#x1-1820007.2'>Teorema de reemplazo para terminos</a></span>
<br />    <span class='subsectionToc'>7.3 <a id='QQ2-1-183' href='#x1-1830007.3'>Notacion declaratoria para formulas</a></span>
<br />    <span class='subsectionToc'>7.4 <a id='QQ2-1-184' href='#x1-1840007.4'>Alcance de la ocurrencia de un cuantificador en una formula</a></span>
<br />    <span class='subsectionToc'>7.5 <a id='QQ2-1-185' href='#x1-1850007.5'>Sustitucion de variables libres</a></span>
<br />    <span class='subsectionToc'>7.6 <a id='QQ2-1-186' href='#x1-1860007.6'>Teorema de reemplazo para formulas</a></span>
<br />   <span class='sectionToc'>8 <a id='QQ2-1-187' href='#x1-1870008'>Teorias de primer orden</a></span>
<br />    <span class='subsectionToc'>8.1 <a id='QQ2-1-188' href='#x1-1880008.1'>Definicion del concepto de prueba formal</a></span>
<br />     <span class='subsubsectionToc'>8.1.1 <a id='QQ2-1-189' href='#x1-1890008.1.1'>Reglas</a></span>
<br />     <span class='subsubsectionToc'>8.1.2 <a id='QQ2-1-190' href='#x1-1900008.1.2'>Axiomas logicos</a></span>
<br />     <span class='subsubsectionToc'>8.1.3 <a id='QQ2-1-191' href='#x1-1910008.1.3'>Justificaciones</a></span>
<br />     <span class='subsubsectionToc'>8.1.4 <a id='QQ2-1-193' href='#x1-1930008.1.4'>Pares adecuados</a></span>
<br />     <span class='subsubsectionToc'>8.1.5 <a id='QQ2-1-195' href='#x1-1950008.1.5'>Definicion de prueba</a></span>
<br />    <span class='subsectionToc'>8.2 <a id='QQ2-1-196' href='#x1-1960008.2'>El concepto de teorema</a></span>
<br />    <span class='subsectionToc'>8.3 <a id='QQ2-1-197' href='#x1-1970008.3'>Propiedades basicas de pruebas y teoremas</a></span>
<br />    <span class='subsectionToc'>8.4 <a id='QQ2-1-198' href='#x1-1980008.4'>Consistencia</a></span>
<br />    <span class='subsectionToc'>8.5 <a id='QQ2-1-199' href='#x1-1990008.5'>El teorema de correccion</a></span>
<br />    <span class='subsectionToc'>8.6 <a id='QQ2-1-200' href='#x1-2000008.6'>El algebra de Lindenbaum</a></span>
<br />    <span class='subsectionToc'>8.7 <a id='QQ2-1-201' href='#x1-2010008.7'>Teorema de completitud</a></span>
<br />    <span class='subsectionToc'>8.8 <a id='QQ2-1-202' href='#x1-2020008.8'>Interpretacion semantica del algebra de Lindembaum</a></span>
<br />    <span class='subsectionToc'>8.9 <a id='QQ2-1-203' href='#x1-2030008.9'>Teorias completas</a></span>
<br />    <span class='subsectionToc'>8.10 <a id='QQ2-1-204' href='#x1-2040008.10'>La aritmetica de Peano</a></span>
<br />    <span class='subsectionToc'>8.11 <a id='QQ2-1-205' href='#x1-2050008.11'>Logica ecuacional</a></span>
<br />     <span class='subsubsectionToc'>8.11.1 <a id='QQ2-1-206' href='#x1-2060008.11.1'>Pruebas ecuacionales</a></span>
<br />     <span class='subsubsectionToc'>8.11.2 <a id='QQ2-1-208' href='#x1-2080008.11.2'>Correccion ecuacional</a></span>
<br />     <span class='subsubsectionToc'>8.11.3 <a id='QQ2-1-209' href='#x1-2090008.11.3'>Completitud ecuacional</a></span>
<br />    <span class='subsectionToc'>8.12 <a id='QQ2-1-211' href='#x1-2110008.12'>Teorema de incompletitud</a></span>
<br />     <span class='subsubsectionToc'>8.12.1 <a id='QQ2-1-212' href='#x1-2120008.12.1'>Analisis de recursividad del lenguaje de primer orden</a></span>
<br />     <span class='subsubsectionToc'>8.12.2 <a id='QQ2-1-213' href='#x1-2130008.12.2'>Funciones representables</a></span>
<br />     <span class='subsubsectionToc'>8.12.3 <a id='QQ2-1-214' href='#x1-2140008.12.3'>Prueba del teorema de incompletitud</a></span>
   </div>

<!-- l. 131 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>1   </span> <a id='x1-20001'></a>Notacion y conceptos basicos</h3>
<!-- l. 133 --><p class='noindent'>Usaremos \(\mathbf{R}\) para denotar el conjunto de los numeros reales, \(\mathbf{Z}\) para denotar el conjunto
de los numeros enteros, \(\mathbf{N}\) para denotar el conjunto de los numeros naturales y \(\omega \) para
denotar al conjunto \(\mathbf{N}\cup \{0\}\).
</p><!-- l. 138 --><p class='indent'>   Dado un conjunto \(A\), usaremos \(\mathcal{P}(A)\) para denotar el conjunto formado por todos los
subconjuntos de \(A\), es decir: \[ \mathcal{P}(A)=\{S:S\subseteq A\} \] Si \(A\) es un conjunto finito, entonces \(\left \vert A\right \vert \) denotara la cantidad
de elementos de \(A\).
</p><!-- l. 146 --><p class='indent'>   Para \(x,y\in \omega \), definamos \[ x\dot{-}y=\left \{ \begin{array}{lll} x-y &amp; &amp; \text{si }x\geq y\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \] Dados \(x,y\in \omega \) diremos que \(x\) <span class='cmti-10'>divide a</span> \(y\) cuando haya un \(z\in \omega \) tal que \(y=z.x\). Notar
que \(0\) divide a \(0\), \(3\) divide a \(0\) y \(0\) no divide a \(23\). Escribiremos \(x\mid y\) para expresar que \(x\) divide a \(y\).
Dados \(x,y\in \omega \), diremos que \(x\) e \(y\) son <span class='cmti-10'>coprimos </span>cuando \(1\) sea el unico elemento de \(\omega \) que divide a
ambos. Notese que \(x\) e \(y\) no son son coprimos sii existe un numero primo \(p\in \omega \) que los divide
a ambos
</p><!-- l. 162 --><p class='indent'>   Si bien no hay una definicion natural en matematica de cuanto vale \(0^{0}\) (\(0\) elevado a la
\(0\)), por convencion para nosotros \(0^{0}=1\)
</p><!-- l. 165 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.1   </span> <a id='x1-30001.1'></a>Conjuntos</h4>
<!-- l. 167 --><p class='noindent'>Supondremos que el lector sabe las nociones basicas sobre conjuntos, aunque
resaltaremos algunas de las mas importantes para que el lector las repase.
</p><!-- l. 171 --><p class='indent'>   La propiedad de <span class='cmti-10'>extensionalidad </span>nos dice que, dados conjuntos \(A,B\), se tiene
que \(A=B\) si y solo si para cada objeto \(x\) se da que \[ x\in A\text{ si y solo si }x\in B \] Esta propiedad es importante
metodologicamente ya que a la hora de probar que dos conjuntos \(A,B\) son iguales,
extensionalidad nos asegura que basta con ver que se dan las dos inclusiones \(A\subseteq B\) y
\(B\subseteq A\).
</p><!-- l. 182 --><p class='indent'>   Otro tema importante es manejar correctamente la notacion cuando definimos un
conjunto usando llaves y mediante propiedades que caracterizan la pertenencia al
mismo. Algunos ejemplos
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-3001x1.1'>\(\{x\in \mathbf{N}:x=1\) o \(x\geq 5\}\)
     </li>
     <li class='enumerate' id='x1-3002x1.1'>\(\{x:x\in \mathbf{R}\) y \(x^{2}\geq 100\}\)
     </li>
     <li class='enumerate' id='x1-3003x1.1'>\(\{x:x=100\}\)
     </li>
     <li class='enumerate' id='x1-3004x1.1'>\(\{x^{2}+1:x\in \omega \}\)
     </li>
     <li class='enumerate' id='x1-3005x1.1'>\(\{x+y+z:x,y,z\in \{1,2\}\}\)</li></ol>

<!-- l. 192 --><p class='noindent'>Dejamos al lector la tarea de entender en forma precisa que conjunto se esta denotando
en cada caso.
</p><!-- l. 195 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.2   </span> <a id='x1-40001.2'></a>Producto carteciano</h4>
<!-- l. 197 --><p class='noindent'>Dados conjuntos \(A_{1},...,A_{n}\), con \(n\geq 2\), usaremos \(A_{1}\times ...\times A_{n}\) para denotar el <span class='cmti-10'>producto Cartesiano </span>de \(A_{1},...,A_{n}\), es decir
el conjunto formado por todas las \(n\)-uplas \((a_{1},...,a_{n})\) tales que \(a_{1}\in A_{1},...,a_{n}\in A_{n}\). Si \(A_{1}=...=A_{n}=A\), con \(n\geq 2\), entonces escribiremos \(A^{n}\)
en lugar de \(A_{1}\times ...\times A_{n}\). Para \(n=1\), definimos \(A^{n}=A\), es decir \(A^{1}=A\). Usaremos \(\Diamond \) para denotar la unica \(0\)-upla.
Definimos entonces \(A^{0}=\{\Diamond \}\). Si \(A\) es un conjunto denotaremos con \(A^{\mathbf{N}}\) al conjunto formado por
todas las infinituplas \((a_{1},a_{2},...)\) tales que \(a_{i}\in A\) para cada \(i\in \mathbf{N}\). Por ejemplo \[ (1,2,3,4,...)\in \omega ^{\mathbf{N}} \] donde \((1,2,3,4,...)\) es una forma
intuitiva de denotar la infinitupla cuyo \(i\)-esimo elemento es el numero natural
\(i\).
</p><!-- l. 213 --><p class='indent'>   Si \((A_{1},A_{2},...)\) es una infinitupla de conjuntos, entonces usaremos \(\bigcup \nolimits _{i=1}^{\infty }A_{i}\) o \(\bigcup \nolimits _{i\geq 1}A_{i}\) para denotar al
conjunto \[ \{a:a\in A_{i}\mathrm{,\ para\ algun\ }i\in \mathbf{N}\} \]
</p><!-- l. 223 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.3   </span> <a id='x1-50001.3'></a>Alfabetos</h4>
<!-- l. 225 --><p class='noindent'>Un <span class='cmti-10'>alfabeto </span>es un conjunto finito de simbolos. Notese que \(\emptyset \) es un alfabeto. Si \(\Sigma \) es un
alfabeto, entonces \(\Sigma ^{\ast }\) denotara el conjunto de todas las palabras formadas con simbolos
de \(\Sigma \). La unica palabra de longitud \(0\) es denotada con \(\varepsilon \). Ya que en \(\varepsilon \) no ocurren simbolos,
tenemos que \(\varepsilon \in \Sigma ^{\ast }\), para cualquier alfabeto, mas aun notese que \(\emptyset ^{\ast }=\{\varepsilon \}\). Usaremos \(\left \vert \alpha \right \vert \) para denotar
la longitud de la palabra \(\alpha \). Usaremos \(\Sigma ^{+}\) para denotar al conjunto \(\Sigma ^{\ast }-\{\varepsilon \}\). Notese que
funciones, \(n\)-uplas y palabras son objetos de distinto tipo, por lo cual \(\emptyset \), \(\Diamond \) y \(\varepsilon \) son tres
objetos matematicos diferentes.
</p><!-- l. 244 --><p class='indent'>   Si \(\alpha _{1},...,\alpha _{n}\in \Sigma ^{\ast }\), con \(n\geq 0\), usaremos \(\alpha _{1}...\alpha _{n}\) para denotar la <span class='cmti-10'>concatenacion </span>de las palabras \(\alpha _{1},...,\alpha _{n}\) (notese que
cuando \(n=0\), resulta que \(\alpha _{1}...\alpha _{n}=\varepsilon \)). Si \(\alpha _{1}=...=\alpha _{n}=\alpha \), entonces escribiremos \(\alpha ^{n}\) en lugar de \(\alpha _{1}...\alpha _{n}\). O sea que
\(\alpha ^{0}=\varepsilon \).
</p><!-- l. 251 --><p class='indent'>   Diremos que \(\alpha \) <span class='cmti-10'>es subpalabra (propia) de</span> \(\beta \) cuando (\(\alpha \notin \{\varepsilon ,\beta \}\) y) existan palabras \(\delta ,\gamma \) tales que \(\beta =\delta \alpha \gamma \).
Diremos que \(\beta \) es un <span class='cmti-10'>tramo inicial (propio) </span>de \(\alpha \) si hay una palabra \(\gamma \) tal que \(\alpha =\beta \gamma \) (y \(\beta \notin \{\varepsilon ,\alpha \}\)). En
forma similar se define <span class='cmti-10'>tramo final (propio).</span>
</p><!-- l. 258 --><p class='indent'>   Dados \(i\in \omega \) y \(\alpha \in \Sigma ^{\ast }\) definamos \[ \left [\alpha \right ]_{i}=\left \{ \begin{array}{lll} i\text{-esimo elemento de }\alpha &amp; &amp; \text{si }1\leq i\leq \left \vert \alpha \right \vert \\ \varepsilon &amp; &amp; \text{caso contrario} \end{array}\right . \] Dada \(\gamma \in \Sigma ^{\ast }\), definamos \[ \gamma ^{R}=\left \{ \begin{array}{lll} [\gamma ]_{\left \vert \gamma \right \vert }[\gamma ]_{\left \vert \gamma \right \vert -1}...[\gamma ]_{1} &amp; &amp; \text{si }\left \vert \gamma \right \vert \geq 1\\ \varepsilon &amp; &amp; \text{caso contrario} \end{array}\right . \] La palabra \(\gamma ^{R}\) es llamada la <span class='cmti-10'>resiproca </span>de
\(\gamma \).
</p><!-- l. 274 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.3.1   </span> <a id='x1-60001.3.1'></a>Ocurrencias</h5>
<!-- l. 276 --><p class='noindent'>Dadas palabras \(\alpha ,\beta \in \Sigma ^{\ast }\), con \(\left \vert \alpha \right \vert ,\left \vert \beta \right \vert \geq 1\), y un natural \(i\in \{1,...,\left \vert \beta \right \vert \}\), se dice que \(\alpha \) <span class='cmti-10'>ocurre a partir de</span> \(i\) <span class='cmti-10'>en</span> \(\beta \) cuando se de
que existan palabras \(\delta ,\gamma \) tales que \(\beta =\delta \alpha \gamma \) y \(\left \vert \delta \right \vert =i-1\).
</p><!-- l. 282 --><p class='indent'>   Notese que una palabra \(\alpha \) puede ocurrir en \(\beta \), a partir de \(i\), y tambien a partir de \(j\),
con \(i\neq j\). En virtud de esto, hablaremos de las distintas ocurrencias de \(\alpha \) en \(\beta \). Por ejemplo

hay dos ocurrencias de la palabra \(aba\) en la palabra \[ cccccccabaccccabaccccc \] y tambien hay dos ocurrencias de la
palabra \(aba\) en la palabra \[ cccccccababacccccccccc \] En el primer caso diremos que dichas ocurrencias de \(aba\) son
<span class='cmti-10'>disjuntas</span>, en cambio en el segundo caso puede apreciarse que las dos ocurrencias se
superponen en una posicion. No definiremos en forma matematica precisa el concepto
de ocurrencia pero el lector no tendra problemas en comprenderlo y manejarlo en
forma correcta.
</p><!-- l. 299 --><p class='indent'>   A veces diremos que una ocurrencia esta <span class='cmti-10'>contenida </span>o <span class='cmti-10'>sucede </span>dentro de otra. Por
ejemplo la segunda ocurrencia de \(ab\) en \(babbbfabcccfabccc\) esta contenida en la primer ocurrencia de \(fabc\) en \(babbbfabcccfabccc\).
Tambien haremos <span class='cmti-10'>reemplazos </span>de ocurrencias por palabras. Por ejemplo el resultado
de reemplazar la primer ocurrencia de \(abb\) en \(ccabbgfgabbgg\) por \(oolala\) es la palabra \(ccoolalagfgabbgg\). El resultado de
reemplazar todas las ocurrencias de \(aba\) en \(ccabagfgabaggaba\) por \(\$\$\) es la palabra \(cc\$\$gfg\$\$gg\$\$\). En algunos casos
deberemos especificar que los reemplazos se hagan <span class='cmti-10'>simultaneamente</span>. Por ejemplo
hablaremos del resultado de reemplazar en \(\gamma \), simultaneamente, todas las ocurrencias
de \(\alpha _{1}\) por \(\beta _{1}\) y todas las de \(\alpha _{2}\) por \(\beta _{2}\). Aqui la aclaracion de simultaneidad es importante ya
que si primero reemplazaramos las ocurrencias de \(\alpha _{1}\) por \(\beta _{1}\) y despues las de \(\alpha _{2}\) por \(\beta _{2}\), el
resultado puede cambiar porque en \(\beta _{1}\) puede haber ocurrencias de \(\alpha _{2}\). Dejamos al lector
dar un ejemplo en el cual el reemplazo secuencial y el simultaneo dan distintos
resultados.
</p><!-- l. 317 --><p class='indent'>   Si \(\alpha \in \Sigma ^{\ast }\) y \(\sigma \in \Sigma \), usaremos \(\left \vert \alpha \right \vert _{\sigma }\) para denotar la cantidad de ocurrencias del simbolo \(\sigma \) en
\(\alpha \).
</p><!-- l. 323 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.4   </span> <a id='x1-70001.4'></a>Matematica orientada a objetos</h4>
<!-- l. 325 --><p class='noindent'>Nuestro estilo o enfoque matematico pondra enfasis en los objetos, es decir haremos
matematica prestando atencion a los distintos objetos matematicos involucrados, los
cuales siempre seran definidos en forma precisa en terminos de objetos mas
primitivos. Hay ciertos objetos matematicos los cuales no definiremos y supondremos
que el lector tiene una idea clara y precisa de los mismos. Por ejemplo un tipo de
objeto matematico, quizas el mas famoso, son los <span class='cmti-10'>numeros</span>. No diremos que es un
numero pero supondremos que el lector tiene una intuicion clara acerca
de este tipo de objetos y de sus propiedades basicas. Otro tipo de objeto
que no definiremos y que sera clave para nuestro enfoque son los <span class='cmti-10'>conjuntos</span>.
Nuevamente, no diremos que es un conjunto pero supondremos que el lector
tiene una intuicion clara acerca de estos objetos y sus propiedades basicas.
Es importante que en nuestro enfoque, numeros y conjuntos son objetos
de distinta naturaleza por lo cual nunca un numero es un conjunto ni un
conjunto es un numero. En particular esto nos dice que el numero \(0\) y el conjunto
\(\emptyset \) son objetos distintos. Otro tipo de objeto matematico muy importante
para la matematica discreta son los <span class='cmti-10'>simbolos</span>. No discutiremos que es un
simbolo sino que aceptaremos este concepto en forma primitiva. Tambien
constituyen un tipo de objeto matematico las <span class='cmti-10'>palabras</span>, las cuales intuitivamente
hablando son juxtaposiciones de simbolos. Otro tipo de objeto matematico

muy importante son los <span class='cmti-10'>pares ordenados </span>o 2-<span class='cmti-10'>uplas</span>, es decir los objetos de la
forma \((a,b)\), donde \(a\) y \(b\) son objetos matematicos cualesquiera. Tambien son objetos
matematicos y de distinta naturaleza las 3-<span class='cmti-10'>uplas</span>, las 4-<span class='cmti-10'>uplas </span>y en general las
\(n\)-<span class='cmti-10'>uplas </span>para \(n\) un numero natural mayor o igual a \(2\). Cabe destacar que en
nuestro enfoque no habra 1-uplas. Sin envargo, si bien hay una sola 0-<span class='cmti-10'>upla</span>, ella
constituye un tipo de objeto matematico distinto a los antes mensionados.
El ultimo tipo de objeto matematico que consideraremos es aquel de las
<span class='cmti-10'>infinituplas</span>.
</p><!-- l. 357 --><p class='indent'>   Tenemos entonces dividido nuestro universo matematico en las distintas
categorias de objetos:
</p>
   <div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \mathrm{NUMERO}\\ &amp; &amp; \mathrm{CONJUNTO}\\ &amp; &amp; \mathrm{PALABRA}\\ &amp; &amp; 0\mathrm{-UPLA}\\ &amp; &amp; 2\mathrm{-UPLA}\\ &amp; &amp; 3\mathrm{-UPLA}\\ &amp; &amp; \ \ \ \ \ \ \ \ \vdots \\ &amp; &amp; \mathrm{INFINITUPLA} \end{eqnarray*}
</div>(Notar que los simbolos quedan contenidos en la categoria de las palabras). Es
importante entender que las anteriores categorias o tipos de objetos son
disjuntas entre si, es decir nunca un numero sera una palabra o una palabra sera
una 3-upla etc. Esto nos permite definir una funcion \(Ti\) la cual a un objeto
matematico le asigna su tipo de objeto matematico segun la lista anterior. Por
ejemplo:
   <div class='eqnarray'>\begin{eqnarray*} Ti(\pi ) &amp; = &amp; \mathrm{NUMERO}\\ Ti(\mathbf{N}) &amp; = &amp; \mathrm{CONJUNTO}\\ Ti(\mathcal{P}(\mathbf{N})) &amp; = &amp; \mathrm{CONJUNTO}\\ Ti((1,2,3)) &amp; = &amp; 3\mathrm{-UPLA}\\ Ti(\mathbf{\emptyset }) &amp; = &amp; \mathrm{CONJUNTO}\\ Ti(\varepsilon ) &amp; = &amp; \mathrm{PALABRA}\\ Ti(\Diamond ) &amp; = &amp; 0\mathrm{-UPLA}\\ Ti(\alpha ) &amp; = &amp; \mathrm{PALABRA}\text{, si }\alpha \text{ es un simbolo}\\ Ti(f) &amp; = &amp; \mathrm{CONJUNTO}\text{, si }f\text{ es una funcion} \end{eqnarray*}
</div>
<!-- l. 393 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.5   </span> <a id='x1-80001.5'></a>El concepto de funcion</h4>
<!-- l. 395 --><p class='noindent'>Asumiremos que el lector tiene una idea intuitiva del concepto de funcion. Daremos
aqui una definicion matematica de dicho concepto. Una <span class='cmti-10'>funcion </span>es un conjunto \(f\) de
pares ordenados con la siguiente propiedad
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-8001x1.5'>Si \((x,y)\in f\) y \((x,z)\in f\), entonces \(y=z\).</li></ol>
<!-- l. 410 --><p class='indent'>   Por ejemplo, si tomamos \(f=\{(x,x^{2}):x\in \omega \}\) se puede ver facilmente que \(f\) cumple la propiedad (F).
Dada una funcion \(f\), definamos </p><div class='eqnarray'>\begin{eqnarray*} D_{f} &amp; = &amp; \text{ dominio de }f=\{x:(x,y)\in f\text{ para algun }y\}\\ I_{f} &amp; = &amp; \text{ imagen de }f=\{y:(x,y)\in f\text{ para algun }x\} \end{eqnarray*}
</div>A veces escribiremos \(\mathrm{Dom}(f)\) y \(\mathrm{Im}(f)\) para denotar, respectivamente, el dominio y la imagen de
una funcion \(f\). Como es usual dado \(x\in D_{f}\), usaremos \(f(x)\) para denotar al unico \(y\in I_{f}\) tal que \((x,y)\in f\). Notese
que \(\emptyset \) es una funcion y que \(D_{\emptyset }=I_{\emptyset }=\emptyset \). Por ejemplo para \(f=\{(x,x^{2}):x\in \omega \}\) se tiene que \(D_{f}=\omega \) y \(I_{f}=\{y:y=x^{2}\) para algun \(x\in \omega \}\). Ademas
notese que \(f(x)=x^{2}\), para cada \(x\in D_{f}\).
<!-- l. 426 --><p class='indent'>   Escribiremos \(f:S\subseteq A\rightarrow B\) para expresar que \(f\) es una funcion tal que \(D_{f}=S\subseteq A\) y \(I_{f}\subseteq B\). Tambien escribiremos
\(f:A\rightarrow B\) para expresar que \(f\) es una funcion tal que \(D_{f}=A\) y \(I_{f}\subseteq B\). En tal contexto llamaremos a \(B\)
<span class='cmti-10'>conjunto de llegada</span>. Por supuesto \(B\) no esta determinado por \(f\) ya que solo debe cumplir
\(I_{f}\subseteq B\).
</p><!-- l. 433 --><p class='indent'>   Muchas veces para definir una funcion \(f\), lo haremos dando su dominio y su regla
de asignacion, es decir especificaremos en forma precisa que conjunto es el dominio de
\(f\) y ademas especificaremos en forma presisa quien es \(f(x)\) para cada \(x\) de dicho dominio.
Obviamente esto determina por completo a la funcion \(f\) ya que \(f=\{(x,f(x)):x\in D_{f}\}\). Por ejemplo si

decimos que \(f\) es la funcion dada por: </p><div class='eqnarray'>\begin{eqnarray*} D_{f} &amp; = &amp; \omega \\ f(x) &amp; = &amp; 23x^{2} \end{eqnarray*}
</div>nos estaremos refiriendo a la funcion \(\{(x,23x^{2}):x\in \omega \}\). Tambien escribiremos \[ \begin{array}{rll} f:\omega &amp; \rightarrow &amp; \omega \\ x &amp; \rightarrow &amp; 23x^{2} \end{array} \] para describir a \(f\). Es
decir, a veces para hacer mas intuitiva aun la descripcion de la funcion, tambien
incluiremos un conjunto de llegada de dicha funcion y a la regla de asignacion la
escribiremos usando una flecha. Para dar otro ejemplo, si escribimos sea \(f\) dada por: \[ \begin{array}{rll} f:\mathbf{N} &amp; \rightarrow &amp; \omega \\ x &amp; \rightarrow &amp; \left \{ \begin{array}{ccc} x+1 &amp; &amp; \text{si }x\text{ es par}\\ x^{2} &amp; &amp; \text{si }x\text{ es impar} \end{array}\right . \end{array} \]
estaremos diciendo que \(f\) es la funcion \[ \{(x,x+1):x\text{ es par y }x\in \mathbf{N}\}\cup \{(x,x^{2}):x\text{ es impar y }x\in \mathbf{N}\} \]
<!-- l. 471 --><p class='noindent'>
</p>
   <h5 class='likesubsubsectionHead'><a id='x1-90001.5'></a>Igualdad de funciones</h5>
<!-- l. 473 --><p class='noindent'>Sean \(f\) y \(g\) dos funciones. Ya que las mismas son conjuntos, tendremos que \(f\) sera igual a \(g\)
si y solo si para cada par \((a,b)\), se tiene que \((a,b)\in f\) sii \((a,b)\in g\). Muchas veces sera util el siguiente
criterio de igualdad de funciones:
</p>
   <div class='newtheorem'>
<!-- l. 477 --><p class='noindent'><span class='head'>
<a id='x1-9001r1'></a>
<span class='cmbx-10'>Lema 1.</span>  </span><span class='cmti-10'>Sean</span> \(f\) <span class='cmti-10'>y</span> \(g\) <span class='cmti-10'>funciones. Entonces</span> \(f=g\) <span class='cmti-10'>sii</span> \(D_{f}=D_{g}\) <span class='cmti-10'>y para cada</span> \(x\in D_{f}\) <span class='cmti-10'>se tiene que</span> \(f(x)=g(x)\)
</p>
   </div>
<!-- l. 485 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.5.1   </span> <a id='x1-100001.5.1'></a>Funcion identidad</h5>
<!-- l. 487 --><p class='noindent'>Dado un conjunto \(A\), a la funcion \[ \begin{array}{rll} A &amp; \rightarrow &amp; A\\ a &amp; \rightarrow &amp; a \end{array} \] La denotaremos con \(Id_{A}\) y la llamaremos la funcion
<span class='cmti-10'>identidad sobre</span> \(A\). Notese que \(Id_{A}=\{(a,a):a\in A\}\).
</p><!-- l. 497 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.5.2   </span> <a id='x1-110001.5.2'></a>Composicion de funciones</h5>
<!-- l. 499 --><p class='noindent'>Dadas funciones \(f\) y \(g\) definamos la funcion \(f\circ g\) de la siguiente manera: </p><div class='eqnarray'>\begin{eqnarray*} D_{f\circ g} &amp; = &amp; \{e\in D_{g}:g(e)\in D_{f}\}\\ f\circ g(e) &amp; = &amp; f(g(e)) \end{eqnarray*}
</div>Notar que \(f\circ g=\{(u,v):\) existe \(z\) tal que \((u,z)\in g\) y \((z,v)\in f\}\). Notese que \(f\circ g\neq \emptyset \) si y solo si \(I_{g}\cap D_{f}\neq \emptyset \), lo cual nos dice que muchas
veces sucedera que \(f\circ g=\emptyset \)

<!-- l. 513 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.5.3   </span> <a id='x1-120001.5.3'></a>Funciones inyectivas, suryectivas y biyectivas</h5>
<!-- l. 515 --><p class='noindent'>Una funcion \(f\) es <span class='cmti-10'>inyectiva </span>cuando no se da que \(f(a)=f(b)\) para algun par de lementos distintos \(a,b\in D_{f}\).
Dada una funcion \(f:A\rightarrow B\) diremos que \(f\) es <span class='cmti-10'>suryectiva </span>cuando \(I_{f}=B\). Debe notarse que el concepto
de suryectividad depende de un conjunto de llegada previamente fijado, es decir que
no tiene sentido hablar de la suryectividad de una funcion \(f\) si no decimos respecto de
que conjunto de llegada lo es. Muchas veces diremos que una funcion \(f\) es <span class='cmti-10'>sobre </span>para
expresar que es suryectiva.
</p><!-- l. 524 --><p class='indent'>   Dada una funcion \(f:A\rightarrow B\) diremos que \(f\) es <span class='cmti-10'>biyectiva </span>cuando \(f\) sea inyectiva y suryectiva.
Notese que si \(f:A\rightarrow B\) es biyectiva, entonces podemos definir una nueva funcion \(f^{-1}:B\rightarrow A\),
de la siguiente manera: \[ f^{-1}(b)=\text{ unico }a\in A\text{ tal que }f(a)=b \] La funcion \(f^{-1}\) sera llamada la <span class='cmti-10'>inversa de</span> \(f\). Notese
que \(f\circ f^{-1}=Id_{B}\) y \(f^{-1}\circ f=Id_{A}\). El siguiente lema muestra que esta ultima propiedad caracteriza la
inversa.
</p>
   <div class='newtheorem'>
<!-- l. 534 --><p class='noindent'><span class='head'>
<a id='x1-12001r2'></a>
<span class='cmbx-10'>Lema 2.</span>  </span><span class='cmti-10'>Supongamos</span> \(f:A\rightarrow B\) <span class='cmti-10'>y</span> \(g:B\rightarrow A\) <span class='cmti-10'>son tales que</span> \(f\circ g=Id_{B}\) <span class='cmti-10'>y</span> \(g\circ f=Id_{A}\)<span class='cmti-10'>. Entonces</span> \(f\) <span class='cmti-10'>y</span> \(g\) <span class='cmti-10'>son biyectivas,</span> \(f^{-1}=g\) <span class='cmti-10'>y</span> \(g^{-1}=f\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 543 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.5.4   </span> <a id='x1-130001.5.4'></a>El nucleo de una funcion</h5>
<!-- l. 545 --><p class='noindent'>Dada una funcion \(f:A\rightarrow B\), definamos: \[ \ker (f)=\{(a,b)\in A^{2}:f(a)=f(b)\} \] El conjunto \(\ker (f)\) sera llamado el <span class='cmti-10'>nucleo </span>de \(f\). Notese que \(f\)
es inyectiva si y solo si \(\ker (f)=\{(a,a):a\in A\}\).
</p><!-- l. 552 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.5.5   </span> <a id='x1-140001.5.5'></a>Funcion caracteristica de un subconjunto</h5>
<!-- l. 554 --><p class='noindent'>Sea \(X\) un conjunto cualquiera y sea \(S\subseteq X\). Usaremos \(\chi _{S}^{X}\) para denotar la funcion \[ \begin{array}{rcl} \chi _{S}^{X}:X &amp; \rightarrow &amp; \omega \\ x &amp; \rightarrow &amp; \left \{ \begin{array}{c} 1\text{ si }x\in S\\ 0\text{ si }x\notin S \end{array}\right . \end{array} \]
Llamaremos a \(\chi _{S}^{X}\) la <span class='cmti-10'>funcion caracteristica de</span> \(S\)<span class='cmti-10'> con respecto a</span> \(X\). Muchas veces
cuando el conjunto \(X\) este fijo y sea claro el contexto, escribiremos \(\chi _{S}\) en lugar de
\(\chi _{S}^{X}\).

</p><!-- l. 570 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.5.6   </span> <a id='x1-150001.5.6'></a>Restriccion de una funcion</h5>
<!-- l. 572 --><p class='noindent'>Dada una funcion \(f\) y un conjunto \(S\subseteq D_{f}\), usaremos \(f|_{S}\) para denotar la <span class='cmti-10'>restriccion </span>de \(f\) al
conjunto \(S\), i.e. \(f|_{S}=f\cap (S\times I_{f})\). Notese que \(f|_{S}\) es la funcion dada por </p><div class='eqnarray'>\begin{eqnarray*} D_{f|_{S}} &amp; = &amp; S\\ f|_{S}(e) &amp; = &amp; f(e)\text{, para cada }e\in S \end{eqnarray*}
</div>Notese que cualesquiera sea la funcion \(f\) tenemos que \(f|_{\emptyset }=\emptyset \) y \(f|_{D_{f}}=f\).
<!-- l. 583 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.5.7   </span> <a id='x1-160001.5.7'></a>Funciones de la forma \([f_{1},...,f_{n}]\)</h5>
<!-- l. 585 --><p class='noindent'>Dadas funciones \(f_{1},...,f_{n}\), con \(n\geq 2\), definamos la funcion \([f_{1},...,f_{n}]\) de la siguiente manera: </p><div class='eqnarray'>\begin{eqnarray*} D_{[f_{1},...,f_{n}]} &amp; = &amp; D_{f_{1}}\cap ...\cap D_{f_{n}}\\{} [f_{1},...,f_{n}](e) &amp; = &amp; (f_{1}(e),...,f_{n}(e)) \end{eqnarray*}
</div>Notese que \(I_{[f_{1},...,f_{n}]}\subseteq I_{f_{1}}\times \cdots \times I_{f_{n}}\). Por conveniencia notacional (que el lector entendera mas adelante)
definiremos \([f_{1}]=f_{1}\). Es decir que hemos definido para cada sucecion de funciones \(f_{1},...,f_{n}\), con \(n\geq 1\), una
nueva funcion la cual denotamos con \([f_{1},...,f_{n}]\).
<!-- l. 597 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.5.8   </span> <a id='x1-170001.5.8'></a>Union de funciones con dominios disjuntos</h5>
<!-- l. 599 --><p class='noindent'>Una observacion interesante es que si \(f_{i}:A_{i}\rightarrow B_{i}\), \(i=1,...,k\), son funciones tales que \(A_{i}\cap A_{j}=\emptyset \) para \(i\neq j\), entonces \(f_{1}\cup ...\cup f_{k}\) es la
funcion \[ \begin{array}{rll} A_{1}\cup ...\cup A_{k} &amp; \rightarrow &amp; B_{1}\cup ...\cup B_{k}\\ e &amp; \rightarrow &amp; \left \{ \begin{array}{clc} f_{1}(e) &amp; &amp; \text{si }e\in A_{1}\\ \vdots &amp; &amp; \vdots \\ f_{k}(e) &amp; &amp; \text{si }e\in A_{k} \end{array}\right . \end{array} \]
</p><!-- l. 614 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.6   </span> <a id='x1-180001.6'></a>Relaciones binarias</h4>
<!-- l. 616 --><p class='noindent'>Sea \(A\) un conjunto. Por una <span class='cmti-10'>relacion binaria sobre</span> \(A\) entenderemos una relacion binaria
que es un subconjunto de \(A^{2}\). Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-18001x1.6'>Sea \(R=\{(1,2),(2,3)\}\). Entonces \(R\) es una relacion binaria sobre \(\mathbf{N}\).
     </li>
     <li class='enumerate' id='x1-18002x1.6'>Sea \(R=\{(x,y)\in \omega ^{2}:\) \(x\) divide a \(y\}\). Entonces \(R\) es una relacion binaria sobre \(\omega \).
     </li>
     <li class='enumerate' id='x1-18003x1.6'>Sea \(R=\{(r,t)\in \mathbf{R}^{2}:r\leq t\}\). Entonces \(R\) es una relacion binaria sobre \(\mathbf{R}\)
     </li>
     <li class='enumerate' id='x1-18004x1.6'>\(\emptyset \) es una relacion binaria sobre \(A\), cualesquiera sea el conjunto \(A\).
     </li>
     <li class='enumerate' id='x1-18005x1.6'>Sea \(R=\{(x,y)\in \omega ^{2}:x&lt;y\) o \(y=0\}\). Entonces \(R\) es una relacion binaria sobre \(\omega \)</li></ol>

<!-- l. 631 --><p class='noindent'>Notese que si \(R\) es una relacion binaria sobre \(A\) y \(A\subseteq B\) entonces \(R\) es una relacion binaria sobre \(B\).
Por ejemplo las relaciones dadas en los ejemplos (E1), (E2), (E4) y (E5) tambien son
relaciones binarias sobre \(\mathbf{R}\)
</p><!-- l. 636 --><p class='indent'>   Como es usual, cuando \(R\) sea una relacion binaria sobre un conjunto \(A\), algunas veces
escribiremos \(aRb\) en lugar de \((a,b)\in R\).
</p><!-- l. 639 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.6.1   </span> <a id='x1-190001.6.1'></a>Propiedades notables de relaciones binarias</h5>
<!-- l. 641 --><p class='noindent'>Hay algunas propiedades que pueden tener o no las relaciones binarias sobre un
conjunto \(A\), las cuales son muy importantes en matematica. Algunas de estas
son:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-19001x1.6.1'>\(xRx\), cualesquiera sea \(x\in A\)
     </li>
     <li class='enumerate' id='x1-19002x1.6.1'>\(xRy\) y \(yRz\) implica \(xRz\), cualesquiera sean \(x,y,z\in A\)
     </li>
     <li class='enumerate' id='x1-19003x1.6.1'>\(xRy\) implica \(yRx\), cualesquiera sean \(x,y\in A\)
     </li>
     <li class='enumerate' id='x1-19004x1.6.1'>\(xRy\) y \(yRx\) implica \(x=y\), cualesquiera sean \(x,y\in A\)</li></ol>
<!-- l. 650 --><p class='noindent'>Cuando \(R\) cumpla la primer propiedad diremos que \(R\) es <span class='cmti-10'>reflexiva, con respecto a</span> \(A\).
Analogamente diremos que \(R\) es <span class='cmti-10'>transitiva, simetrica o antisimetrica, con respecto a</span>
\(A\), cuando se den, respectivamente las otras propiedades. Notese que estas
propiedades dependen del conjunto \(A\), por ejemplo si tomamos \(R=\{(r,t)\in \mathbf{N}^{2}:r\leq t\}\) entonces \(R\) es una
relacion binaria sobre \(\mathbf{N}\) y tambien es una relacion binaria sobre \(\omega \), pero es
relexiva con respepcto a \(\mathbf{N}\) y no lo es con respecto a \(\omega \) ya que \((0,0)\) no pertenece a \(R\).
Sin envargo \(R\) es transitiva con respecto a \(\mathbf{N}\) y tambien lo es con respecto a
\(\omega \).
</p><!-- l. 661 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.6.2   </span> <a id='x1-200001.6.2'></a>Ordenes parciales</h5>
<!-- l. 663 --><p class='noindent'>Una relacion binaria \(R\) sobre un conjunto \(A\) sera llamada un <span class='cmti-10'>orden parcial sobre</span> \(A\)<span class='cmti-10'> </span>si es
reflexiva, transitiva y antisimetrica respecto de \(A\). Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-20001x1.6.2'>Sea \(R=\{(r,t)\in \mathbf{R}^{2}:r\leq t\}\). Entonces \(R\) es un orden parcial sobre \(\mathbf{R}\), llamado el orden usual de \(\mathbf{R}\)
     </li>
     <li class='enumerate' id='x1-20002x1.6.2'>Sea \(R=\{(1,2),(1,3),(1,1),(2,2),(3,3)\}\). Entonces \(R\) es un orden parcial sobre \(\{1,2,3\}\)

     </li>
     <li class='enumerate' id='x1-20003x1.6.2'>Sea \(R=\{(S,T)\in \mathcal{P}(\omega )^{2}:S\subseteq T\}\). Entonces \(R\) es un orden parcial sobre \(\mathcal{P}(\omega )\)
     </li>
     <li class='enumerate' id='x1-20004x1.6.2'>Sea \(R=\{(x,y)\in \omega ^{2}:\) \(x\leq y\}\). Entonces \(R\) es un orden parcial sobre \(\omega \).
     </li>
     <li class='enumerate' id='x1-20005x1.6.2'>Sea \(R=\{(1,1)\}\). Entonces \(R\) es un orden parcial sobre \(\{1\}\).
     </li>
     <li class='enumerate' id='x1-20006x1.6.2'>\(\{(a,b):a=b\}\) es un orden parcial sobre \(A\), cualesquira sea el conjunto \(A\)
     </li>
     <li class='enumerate' id='x1-20007x1.6.2'>Sea \(\mathrm{\leq }=\{(n,m)\in \mathbf{N}^{2}:n\mid m\}\). Es facil ver que \(\leq \) es un orden parcial sobre \(\mathbf{N}\)</li></ol>
<!-- l. 681 --><p class='noindent'>Notese que las relaciones dadas en (E1) y (E4) son distintas, ademas la relacion dada en
(E4) no es un orden parcial sobre \(\mathbf{R}\) (por que?).
</p><!-- l. 685 --><p class='indent'>   Muchas veces denotaremos con \(\leq \) a una relacion binaria que sea un orden parcial.
Esto hace mas intuitiva nuestra escritura pero siempre hay que tener en cuenta que \(\leq \)
en estos casos esta denotando cierto conjunto de pares ordenados previamente
definido.
</p><!-- l. 690 --><p class='indent'>   Usaremos la siguiente
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-20008x1.6.2'>Si hemos denotado con \(\leq \) a cierto orden parcial sobre un conjunto \(A\),
     entonces
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-20010x1'>Denotaremos con \(&lt;\) a la relacion binaria \(\{(a,b)\in A^{2}:a\leq b\) y \(a\neq b\}\). Es decir que \(\mathrm{&lt;}=\{(a,b)\in A^{2}:a\leq b\) y \(a\neq b\}\). Cuando
         se de \(a&lt;b\) diremos que \(a\) <span class='cmti-10'>es menor que</span> \(b\) o que \(b\) <span class='cmti-10'>es mayor que</span> \(a\) (<span class='cmti-10'>respecto de</span>
         \(\leq \))
         </li>
         <li class='enumerate' id='x1-20012x2'>Denotaremos con \(\prec \) a la relacion binaria \[ \{(a,b)\in A^{2}:a&lt;b\text{ y no existe }z\text{ tal que }a&lt;z&lt;b\} \] Cuando se de \(a\prec b\) diremos que \(a\)
         <span class='cmti-10'>es cubierto por</span> \(b\) o que \(b\) <span class='cmti-10'>cubre a</span> \(a\) (<span class='cmti-10'>respecto de</span> \(\leq \))</li></ol>
     </li></ol>
<!-- l. 708 --><p class='noindent'>Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-20013x1.6.2'>Si \(A=\mathbf{R}\) y \(\mathrm{\leq }=\{(r,t)\in \mathbf{R}^{2}:r=t\}\), entonces \(\mathrm{&lt;}=\emptyset \)
     </li>
     <li class='enumerate' id='x1-20014x1.6.2'>Si \(A=\{1,2,3,4\}\) y \(\mathrm{\leq }=\{(1,2),(2,3),(1,3),(1,1),(2,2),(3,3),(4,4)\}\), entonces \(\mathrm{&lt;}=\{(1,2),(2,3),(1,3)\}\) y \(\mathrm{\prec }=\{(1,2),(2,3)\}\). En particular tenemos que \(1\prec 2\), \(1&lt;3\) pero no se da que \(1\prec 3\).
     </li>
     <li class='enumerate' id='x1-20015x1.6.2'>Si \(A=\mathcal{P}(\omega )\) y \(\mathrm{\leq }=\{(S,T)\in \mathcal{P}(\omega )^{2}:S\subseteq T\}\), entonces \(\mathrm{&lt;}=\{(S,T)\in \mathcal{P}(\omega )^{2}:S\subsetneq T\}\) y \(S\prec T\) sii hay un \(n\in T-S\) tal que \(T=S\cup \{n\}\)</li></ol>

<!-- l. 722 --><p class='noindent'><span class='paragraphHead'><a id='x1-210001.6.2'></a><span class='cmbx-10'>Ordenes totales sobre un conjunto</span></span>
   Sea \(A\) un conjunto cualquiera. Por un <span class='cmti-10'>orden total sobre</span> \(A\) entenderemos un orden
parcial \(\leq \) sobre \(A\) el cual cumpla:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-21001x1.6.2'>\(a\leq b\) o \(b\leq a\), cualesquiera sean \(a,b\in A\)</li></ol>
<!-- l. 729 --><p class='noindent'>Supongamos \(A\) es finito no vacio y \(\leq \) es un orden total sobre \(A\). La propiedad (C) nos
permite probar que para cada conjunto no vacio \(S\subseteq A\), hay un elemento \(s\in S\) el cual
cumple \(s\leq s^{\prime }\) para cada \(s^{\prime }\in S\). Por supuesto, \(s\) es unico (por que?) y habitualmente es
llamado el <span class='cmti-10'>menor elemento de</span> \(S\), ya que es menor que todo otro elemento de
\(S\).
</p><!-- l. 736 --><p class='indent'>   Si \(A\) es finito no vacio y \(\leq \) es un orden total sobre \(A\), podemos definir recursivamente
una funcion \(f:\{1,...,\left \vert A\right \vert \}\rightarrow A\) de la siguiente manera:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-21002x1.6.2'>\(f(1)=\) menor elemento de \(A\)
     </li>
     <li class='enumerate' id='x1-21003x1.6.2'>Si \(i\in \{1,...,\left \vert A\right \vert -1\}\), entonces
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-21004x1.6.2'>\(f(i+1)=\) menor elemento de \(A-\{f(1),...,f(i)\}\)</li></ol>
     </li></ol>
<!-- l. 746 --><p class='noindent'>Como es habitual, \(f(i)\) es llamado el \(i\)<span class='cmti-10'>-esimo elemento de</span> \(A\).
</p><!-- l. 749 --><p class='indent'>   Muchas veces para dar un orden total sobre un conjunto finito \(A\), daremos
simplemente sus elementos en forma creciente ya que esto determina el orden por
completo. Por ejemplo si \(A=\{1,2,3\}\), el orden total dado por \(2&lt;1&lt;3\) es la relacion \(\mathrm{\leq }=\{(2,1),(1,3),(2,3),(1,1),(2,2),(3,3)\}\).
</p><!-- l. 754 --><p class='indent'>   Un concepto importante relativo a los ordenes totales es el de <span class='cmti-10'>sucesor</span>. Si \(\leq \) es un
orden total sobre \(A\) y \(a,b\in A\), diremos que \(b\) <span class='cmti-10'>es el sucesor de</span> \(a\) cuando se de que \(a&lt;b\) y \(b\leq c\), para cada \(c\in A\)
tal que \(a&lt;c\), i.e., \(b\) es el menor elemento del conjunto \(\{c\in A:\) tal que \(a&lt;c\}\). No siempre existe el
sucesor de un elemento. Por ejemplo si \(\leq \) es el orden usual de \(\mathbf{R}\), entonces ningun
elemento tiene sucesor (justifique).
</p>
<!-- l. 765 --><p class='noindent'><span class='paragraphHead'><a id='x1-220001.6.2'></a><span class='cmbx-10'>Diagramas de Hasse</span></span>
   Dado un orden parcial \(\leq \) sobre un conjunto finito \(A\) podemos realizar un diagrama de
\(\leq \), llamado <span class='cmti-10'>diagrama de Hasse, </span>siguiendo las siguientes instrucciones:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-22001x1.6.2'>Asociar en forma inyectiva, a cada \(a\in \) \(A\) un punto \(p_{a}\) del plano
     </li>
     <li class='enumerate' id='x1-22002x1.6.2'>Trazar un segmento de recta uniendo los puntos \(p_{a}\) y \(p_{b}\), cada vez que \(a\prec b\)

     </li>
     <li class='enumerate' id='x1-22003x1.6.2'>Realizar lo indicado en los puntos (1) y (2) en tal forma que
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-22004x1.6.2'>Si \(a\prec b\), entonces \(p_{a}\) esta por debajo de \(p_{b}\)
         </li>
         <li class='enumerate' id='x1-22005x1.6.2'>Si un punto \(p_{a}\) ocurre en un segmento del diagrama entonces lo hace
         en alguno de sus extremos.</li></ol>
     </li></ol>
<!-- l. 782 --><p class='noindent'>La relacion de orden \(\leq \) puede ser facilmente obtenida de su diagrama, a saber, \(a\leq b\)
sucedera si y solo si \(p_{a}=p_{b}\) o hay una sucesion de segmentos ascendentes desde \(p_{a}\) hasta
\(p_{b}\).
</p><!-- l. 788 --><p class='indent'>   Ejemplos:
</p><!-- l. 793 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.6.3   </span> <a id='x1-230001.6.3'></a>Relaciones de equivalencia</h5>
<!-- l. 795 --><p class='noindent'>Sea \(A\) un conjunto cualquiera. Por una <span class='cmti-10'>relacion de equivalencia sobre</span> \(A\) entenderemos
una relacion binaria sobre \(A\) la cual es reflexiva, transitiva y simetrica, con respecto a \(A\).
Es decir \(R\) sera una relacion de equivalencia sobre \(A\) si se cumplen:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-23001x1.6.3'>\(aRa\), cualesquiera sea \(a\in A\)
     </li>
     <li class='enumerate' id='x1-23002x1.6.3'>\(aRb\) y \(bRc\) implica \(aRc\), cualesquiera sean \(a,b,c\in A\)
     </li>
     <li class='enumerate' id='x1-23003x1.6.3'>\(aRb\) implica \(bRa\), cualesquiera sean \(a,b\in A\)</li></ol>
<!-- l. 804 --><p class='noindent'>Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-23004x1.6.3'>Sea \(R=\{(r,t)\in \mathbf{R}^{2}:r=t\}\). Entonces \(R\) es una relacion de equivalencia sobre \(\mathbf{R}\)
     </li>
     <li class='enumerate' id='x1-23005x1.6.3'>Dada una funcion \(f:A\rightarrow B\), el nucleo de \(f\), i.e. \(\ker (f)=\{(a,b)\in A^{2}:f(a)=f(b)\}\) es una relacion de equivalencia sobre
     \(A\).
     </li>
     <li class='enumerate' id='x1-23006x1.6.3'>Sea \(R=\{(1,1),(2,2),(3,3),(1,2),(2,1)\}\). Entonces \(R\) es una relacion de equivalencia sobre \(\{1,2,3\}\)
     </li>
     <li class='enumerate' id='x1-23007x1.6.3'>Sea \(R=\{(x,y)\in \omega ^{2}:x=y\}\). Entonces \(R\) es una relacion de equivalencia sobre \(\omega \)

     </li>
     <li class='enumerate' id='x1-23008x1.6.3'>Sea \(R=\{(S,T)\in \mathcal{P}(\omega ):(S-T)\cup (T-S)\) es finito\(\}\). Entonces \(R\) es una relacion de equivalencia sobre \(\mathcal{P}(\omega )\)
     </li>
     <li class='enumerate' id='x1-23009x1.6.3'>Sea \(R=\{(1,1)\}\). Entonces \(R\) es una relacion de equivalencia sobre \(\{1\}\).
     </li>
     <li class='enumerate' id='x1-23010x1.6.3'>Sea \(R=\{(x,y)\in \mathbf{Z}^{2}:x-y\) es multiplo de \(2\}\). Entonces \(R\) es una relacion de equivalencia sobre \(\mathbf{Z}\).</li></ol>
<!-- l. 821 --><p class='noindent'>Dada una relacion de equivalencia \(R\) sobre \(A\) y \(a\in A\), definimos:
</p><!-- l. 825 --><p class='indent'>   \[ a/R=\{b\in A:aRb\} \] El conjunto \(a/R\) sera llamado la <span class='cmti-10'>clase de equivalencia de</span> \(a\)<span class='cmti-10'>, con respecto a</span> \(R\).
Ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-23011x1.6.3'>Si \(R=\{(r,t)\in \mathbf{R}^{2}:r=t\}\), entonces \(r/R=\{r\}\), cualesquier sea \(r\in \mathbf{R}\)
     </li>
     <li class='enumerate' id='x1-23012x1.6.3'>Si \(R=\{(1,1),(2,2),(3,3),(1,2),(2,1)\}\), entonces \(1/R=2/R=\{1,2\}\) y \(3/R=\{3\}\)
     </li>
     <li class='enumerate' id='x1-23013x1.6.3'>Si \(R=\{(x,y)\in \mathbf{Z}^{2}:x-y\) es multiplo de \(2\}\), entonces \(0/R=\{t\in \mathbf{Z}:t\) es par\(\}\), \(1/R=\{t\in \mathbf{Z}:t\) es impar\(\}\) y en general notese que \(n/R=\{t\in \mathbf{Z}:t\) es
     par\(\}\) si \(n\) es par y \(n/R=\{t\in \mathbf{Z}:t\) es impar\(\}\) si \(n\) es impar. Es decir que hay solo dos clases de
     equivalencia con respecto a \(R\)</li></ol>
<!-- l. 840 --><p class='noindent'>Algunas propiedades basicas son:
</p>
   <div class='newtheorem'>
<!-- l. 841 --><p class='noindent'><span class='head'>
<a id='x1-23014r3'></a>
<span class='cmbx-10'>Lema 3.</span>  </span><span class='cmti-10'>Sea</span> \(R\) <span class='cmti-10'>una relacion de equivalencia sobre</span> \(A\)<span class='cmti-10'>.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-23015x3'>\(a\in a/R\)
     </li>
     <li class='enumerate' id='x1-23016x3'>\(aRb\) <span class='cmti-10'>si y solo si</span> \(a/R=b/R\)<span class='cmti-10'>. Es decir que</span> \(b\in a/R\) <span class='cmti-10'>implica</span> \(b/R=a/R\)
     </li>
     <li class='enumerate' id='x1-23017x3'>\(a/R\cap b/R=\emptyset \) <span class='cmti-10'>o</span> \(a/R=b/R\)</li></ol>
   </div>
<!-- l. 851 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 852 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>(1) es muy facil.
</p><!-- l. 854 --><p class='indent'>   (2). Supongamos \(aRb\). Veremos que \(a/R\subseteq b/R\). Supongamos \(c\in a/R\). Entonces \(aRc\). Como \(aRb\), tenemos
que \(bRa\), por lo cual hemos probado que \(bRa\) y \(aRc\), lo cual implica que \(bRc\). O sea que \(cRb\), lo
cual nos dice que \(c\in b/R\). Esto prueba que \(a/R\subseteq b/R\). Similarmente se prueba que \(b/R\subseteq a/R\), con lo cual
se tiene que \(a/R=b/R\).
</p><!-- l. 861 --><p class='indent'>   Reciprocamente, si \(a/R=b/R\), entonces \(b\in a/R\) ya que \(b\in b/R\). Pero esto nos dice que \(aRb\).
</p><!-- l. 864 --><p class='indent'>   (3). Supongamos que \(a/R\cap b/R\) no es vacio, es decir hay un \(c\in a/R\cap b/R\). Entonces es facil ver que
\(aRb\). Pero entonces por (2) tenemos que \(a/R=b/R\).                                                     □
</p>
   </div>
<!-- l. 868 --><p class='indent'>   Denotaremos con \(A/R\) al conjunto \(\{a/R:a\in A\}\). Llamaremos a \(A/R\) el <span class='cmti-10'>cociente de</span> \(A\) <span class='cmti-10'>por</span> \(R\). Ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-23018x1.6.3'>Si \(R=\{(r,t)\in \mathbf{R}^{2}:r=t\}\), entonces \(\mathbf{R}/R=\{\{r\}:r\in \mathbf{R}\}\)
     </li>
     <li class='enumerate' id='x1-23019x1.6.3'>Si \(R=\{(1,1),(2,2),(3,3),(1,2),(2,1)\}\), entonces \(\{1,2,3\}/R=\{\{1,2\},\{3\}\}\)
     </li>
     <li class='enumerate' id='x1-23020x1.6.3'>Si \(R=\{(x,y)\in \mathbf{Z}^{2}:x-y\) es multiplo de \(2\}\), ya vimos que \(\mathbf{Z}/R=\{\{t\in \mathbf{Z}:t\) es par\(\},\{t\in \mathbf{Z}:t\) es impar\(\}\}\)</li></ol>
<!-- l. 877 --><p class='noindent'>Si  \(R\) es una relacion de equivalencia sobre \(A\), definamos la funcion \(\pi _{R}:A\rightarrow A/R\) por \(\pi _{R}(a)=a/R\), para cada \(a\in A\). La
funcion \(\pi _{R}\) es llamada la <span class='cmti-10'>proyeccion canonica </span>(<span class='cmti-10'>respecto de</span> \(R\)).
</p>
   <div class='newtheorem'>
<!-- l. 881 --><p class='noindent'><span class='head'>
<a id='x1-23021r4'></a>
<span class='cmbx-10'>Lema 4.</span>  </span><span class='cmti-10'>Sea</span> \(R\) <span class='cmti-10'>una relacion de equivalencia sobre</span> \(A\)<span class='cmti-10'>. Entonces</span> \(\ker \pi _{R}=R\)<span class='cmti-10'>. Es decir que</span> \(\pi _{R}\) <span class='cmti-10'>es
</span><span class='cmti-10'>inyectiva sii</span> \(R=\{(x,y)\in A^{2}:x=y\}\)
</p>
   </div>
<!-- l. 891 --><p class='noindent'><span class='paragraphHead'><a id='x1-240001.6.3'></a><span class='cmbx-10'>Definicion de funciones con dominio</span> \(A/R\)</span>
   Supongamos \(R\) es una relacion de equivalencia sobre \(\mathbf{R}\) y supongamos definimos una
funcion \(f:\mathbf{R}/R\rightarrow \mathbf{R}\) de la siguiente manera: \[ f(r/R)=r^{2} \] A priori puede pareser que esta definicion es natural
y que no esconde ninguna posible complicacion. Pero supongamos que \(R\) es tal que
\(2R6\). Entonces tendriamos que \(2/R=6/R\) lo cual produciria la siguiente contradiccion:
</p><div class='eqnarray'>\begin{eqnarray*} 4 &amp; = &amp; 2^{2}\\ &amp; = &amp; f(2/R)\\ &amp; = &amp; f(6/R)\\ &amp; = &amp; 6^{2}\\ &amp; = &amp; 36 \end{eqnarray*}
</div>El problema aqui es que la ecuacion \(f(r/R)=r^{2}\) no esta definiendo en forma correcta o
inhambigua una funcion ya que el supuesto valor de la funcion en una clase de

equivalencia dada depende de que representante de la clase usamos para denotarla. Si
usamos el 2 la ecuacion nos dice que entonces \(f\) debe valer 4 y si usamos el 6 la
ecuacion nos dice que \(f\) debe valer 36. Claramente no estamos definiendo una
funcion.
<!-- l. 918 --><p class='indent'>   Para dar un ejemplo mas concreto de este fenomeno de ambiguedad,
supongamos \[ R=\{(x,y)\in \mathbf{Z}^{2}:x-y\text{ es multiplo de }2\} \] y definimos una funcion \(f:\mathbf{Z}/R\rightarrow \mathbf{R}\) de la siguiente manera: \[ f(n/R)=1/(n^{2}+1) \] Como ya vimos \(\mathbf{Z}/R=\{\{t\in \mathbf{Z}:t\)
es par\(\},\{t\in \mathbf{Z}:t\) es impar\(\}\}\), por lo cual facilmente se puede llegar a que la ecuacion \(f(n/R)=1/(n^{2}+1)\)
no define correctamente una funcion. Dejamos al lector explicar esto mas
detalladamente.
</p><!-- l. 932 --><p class='indent'>   Sin envargo hay muchos casos en los cuales este tipo de definiciones son
inhambiguas y desde luego muy importantes en el algebra moderna. Como un primer
ejemplo tenemos el siguiente lema el cual es una de las ideas fundamentales del
algebra moderna.
</p>
   <div class='newtheorem'>
<!-- l. 936 --><p class='noindent'><span class='head'>
<a id='x1-24001r5'></a>
<span class='cmbx-10'>Lema 5.</span>  </span><span class='cmti-10'>Si</span> \(f:A\rightarrow B\) <span class='cmti-10'>es sobre, entonces la ecuacion</span> \(\bar{f}(a/\ker f)=f(a)\) <span class='cmti-10'>define en forma inhambigua una
</span><span class='cmti-10'>funcion</span> \(\bar{f}:A/\ker f\rightarrow B\) <span class='cmti-10'>la cual es biyectiva.</span>
</p>
   </div>
<!-- l. 942 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 943 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Que la ecuacion \(\bar{f}(a/\ker f)=f(a)\) define sin ambiguedad una funcion \(\bar{f}:A/\ker f\rightarrow B\) es obvio ya que si \(a/\ker f=b/\ker f\),
entonces por definicion de \(\ker f\) debera suceder que \(a=b\). Dejamos al lector la prueba de
que \(\bar{f}\) es biyectiva                                                                                □
</p>
   </div>
<!-- l. 951 --><p class='noindent'><span class='paragraphHead'><a id='x1-250001.6.3'></a><span class='cmbx-10'>Correspondencia entre relaciones de equivalencia y particiones</span></span>
   Dado un conjunto \(A\) por una <span class='cmti-10'>particion de</span> \(A\) entenderemos un conjunto \(\mathcal{P}\) tal
que:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-25001x1.6.3'>Cada elemento de \(\mathcal{P}\) es un subconjunto no vacio de \(A\)

     </li>
     <li class='enumerate' id='x1-25002x1.6.3'>Si \(S_{1},S_{2}\in \mathcal{P}\) y \(S_{1}\neq S_{2}\), entonces \(S_{1}\cap S_{2}=\emptyset \)
     </li>
     <li class='enumerate' id='x1-25003x1.6.3'>\(A=\{a:a\in S\), para algun \(S\in \mathcal{P}\}\)</li></ol>
<!-- l. 960 --><p class='noindent'>La ultima condicion dice simplemente que la union de todos los elementos de \(\mathcal{P}\) debe ser \(A\).
Ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-25004x1.6.3'>Si \(A=\{1,2,3,4,5\}\), entonces \[ \mathcal{P}=\{\{1,5\},\{2,3\},\{4\}\} \]
     <!-- l. 968 --><p class='noindent'>es una particion de \(A\)
     </p></li>
     <li class='enumerate' id='x1-25005x1.6.3'>\(\mathcal{P}=\{\mathbf{N},\mathbf{R}-\mathbf{N}\}\) es una particion de \(\mathbf{R}\)
     </li>
     <li class='enumerate' id='x1-25006x1.6.3'>\(\mathcal{P}=\{\{0\},\{1,2\},\{3,4\},\{5,6\},\{7,8\},\{9,10\},...\}\) es una particion de \(\omega \)</li></ol>
<!-- l. 974 --><p class='noindent'>Una observacion importante es que si \(\mathcal{P}\) es una particion de \(A\), entonces para cada \(a\in A\) hay un
unico \(S\in \mathcal{P}\) tal que \(a\in S\) (por que?). O sea que podemos hablar de EL elemento de \(\mathcal{P}\) que
contiene a \(a\).
</p><!-- l. 979 --><p class='indent'>   Dada una particion \(\mathcal{P}\) de un conjunto \(A\) podemos definir una relacion binaria
asociada a \(\mathcal{P}\) de la siguiente manera: \[ R_{\mathcal{P}}=\{(a,b)\in A^{2}:a,b\in S\text{, para algun }S\in \mathcal{P}\} \]
</p>
   <div class='newtheorem'>
<!-- l. 985 --><p class='noindent'><span class='head'>
<a id='x1-25007r6'></a>
<span class='cmbx-10'>Lema 6.</span>  </span><span class='cmti-10'>Sea</span> \(A\) <span class='cmti-10'>un conjunto cualquiera. Entonces:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-25008x6'><span class='cmti-10'>Sea</span> \(\mathcal{P}\) <span class='cmti-10'>una particion de</span> \(A\)<span class='cmti-10'>. Entonces</span> \(R_{\mathcal{P}}\) <span class='cmti-10'>es una relacion de equivalencia sobre</span> \(A\)<span class='cmti-10'>.</span>
     </li>
     <li class='enumerate' id='x1-25009x6'><span class='cmti-10'>Sea</span> \(R\) <span class='cmti-10'>una relacion de equivalencia sobre</span> \(A\)<span class='cmti-10'>. Entonces</span> \(A/R\) <span class='cmti-10'>es una particion de</span> \(A\)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 995 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 996 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(1). Es facil ver que \(R_{\mathcal{P}}\) es reflexiva y simetrica. Veamos que es transitiva.
Supongamos que \(aR_{\mathcal{P}}b\) y \(bR_{\mathcal{P}}c\). O sea que hay \(S_{1},S_{2}\in \mathcal{P}\) tales que \(a,b\in S_{1}\) y \(b,c\in S_{2}\). Ya que \(S_{1}\) y \(S_{2}\) tienen un elemento
en comun, debera suceder que \(S_{1}=S_{2}\). Pero entonces tenemos que \(a,c\in S_{1}\), lo cual nos dice
que \(aR_{\mathcal{P}}c\).
</p><!-- l. 1003 --><p class='indent'>   (2). Sigue facilmente del Lema <a href='#x1-23014r3'>3<!-- tex4ht:ref: basicas a/R  --></a>.                                                      □

</p>
   </div>
<!-- l. 1007 --><p class='indent'>   El siguiente teorema da una correspondencia natural entre relaciones de
equivalencia sobre \(A\) y particiones de \(A\).
</p>
   <div class='newtheorem'>
<!-- l. 1009 --><p class='noindent'><span class='head'>
<a id='x1-25010r7'></a>
<span class='cmbx-10'>Teorema 7.</span>  </span><span class='cmti-10'>Sea</span> \(A\) <span class='cmti-10'>un conjunto cualquiera. Sean</span> </p><div class='eqnarray'>\begin{eqnarray*} Part &amp; = &amp; \{\text{particiones de }A\}\\ ReEq &amp; = &amp; \{\text{relaciones de equivalencia sobre }A\} \end{eqnarray*}
</div><span class='cmti-10'>Entonces las funciones: </span>\[ \begin{array}{rll} Part &amp; \rightarrow &amp; ReEq\\ \mathcal{P} &amp; \rightarrow &amp; R_{\mathcal{P}} \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rll} ReEq &amp; \rightarrow &amp; Part\\ R &amp; \rightarrow &amp; A/R \end{array} \] <span class='cmti-10'>son biyecciones una inversa de la otra.</span>
   </div>
<!-- l. 1028 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 1029 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que por el Lema <a href='#x1-12001r2'>2<!-- tex4ht:ref: mutuamente inversas  --></a> basta con probar:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-25011x1.6.3'>\(A/R_{\mathcal{P}}=\mathcal{P}\), cualesquiera sea la particion \(\mathcal{P}\) de \(A\)
     </li>
     <li class='enumerate' id='x1-25012x1.6.3'>\(R_{A/R}=R\), cualesquiera sea la relacion de equivalencia \(R\) sobre \(A\)</li></ol>
<!-- l. 1036 --><p class='noindent'>Prueba de (1). Primero veamos que \(A/R_{\mathcal{P}}\subseteq \mathcal{P}\). Sea \(a\in A\), veremos que \(a/R_{\mathcal{P}}=\{b:aR_{\mathcal{P}}b\}\in \mathcal{P}\). Sea \(S\) el unico elemento de \(\mathcal{P}\) que
contiene a \(a\). Es facil ver de la definicion de \(R_{\mathcal{P}}\) que \(a/R_{\mathcal{P}}=S\) por lo cual \(a/R_{\mathcal{P}}\in \mathcal{P}\). Veamos ahora que \(\mathcal{P}\subseteq A/R_{\mathcal{P}}\). Sea
\(S\in \mathcal{P}\). Sea \(a\in S\). Es facil ver de la definicion de \(R_{\mathcal{P}}\) que \(a/R_{\mathcal{P}}=S\) por lo cual \(S\in A/R_{\mathcal{P}}\).
</p><!-- l. 1044 --><p class='indent'>   Prueba de (2). Primero veamos que \(R_{A/R}\subseteq R\). Supongamos \(aR_{A/R}b\). Entonces \(a,b\in c/R\), para algun \(c\in A\). Es
claro que entonces \(aRb\). Veamos ahora que \(R\subseteq R_{A/R}\). Supongamos que \(aRb\). Entonces \(a,b\in a/R\), lo cual nos
dice que \(aR_{A/R}b\).                                                                                         □
</p>
   </div>
<!-- l. 1051 --><p class='indent'>   El teorema anterior muestra que a nivel de informacion es lo mismo tener una
relacion de equivalencia sobre \(A\) que tener una particion de \(A\). Esto es muy util ya que
muchas veces es mas facil especificar una relacion de equivalencia via su particion
asociada. Por ejemplo si hablamos de la relacion de equivalencia sobre \(\{1,2,3,4,5\}\) dada por la
particion \[ \mathcal{P}=\{\{1,5\},\{4\},\{2,3\}\} \] nos estaremos refiriendo a \(R_{\mathcal{P}}\), es decir a la relacion:
</p><!-- l. 1064 --><p class='indent'>   \[ \{(1,1),(2,2),(3,3),(4,4),(5,5),(1,5),(5,1),(2,3),(3,2)\} \]

</p><!-- l. 1067 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.7   </span> <a id='x1-260001.7'></a>Operaciones \(n\)-arias sobre un conjunto</h4>
<!-- l. 1069 --><p class='noindent'>Sea \(A\) un conjunto. Dado \(n\in \omega \), por una <span class='cmti-10'>operacion</span> \(n\)<span class='cmti-10'>-aria sobre</span> \(A\) entenderemos una funcion
cuyo dominio es \(A^{n}\) y cuya imagen esta contenida en \(A\). A las operaciones \(2\)-arias (resp.
\(3\)-arias, \(4\)-arias) tambien las llamaremos <span class='cmti-10'>operacion binarias </span>(resp. <span class='cmti-10'>ternarias,
</span><span class='cmti-10'>cuaternarias</span>). Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-26001x1.7'>Sea \(f:\mathbf{R\times R}\rightarrow \mathbf{R}\) dada por \(f(x,y)=x+y\). Entonces \(f\) es una operacion \(2\)-aria sobre \(\mathbf{R}\)
     </li>
     <li class='enumerate' id='x1-26002x1.7'>Sea \(f:\{\Diamond \}\rightarrow \omega \), dada por \(f(\Diamond )=5\). Entonces \(f\) es una operacion \(0\)-aria sobre \(\omega \).
     </li>
     <li class='enumerate' id='x1-26003x1.7'>Sea \(f:\mathbf{N\times N\times N\times N\times N}\rightarrow \mathbf{N}\), dada por \(f(x_{1},x_{2},x_{3},x_{4},x_{5})=(x_{1}.x_{2})+x_{3}\). Entonces \(f\) es una operacion \(5\)-aria sobre \(\mathbf{N}\).</li></ol>
<!-- l. 1086 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.8   </span> <a id='x1-270001.8'></a>Relaciones \(n\)-arias sobre un conjunto</h4>
<!-- l. 1088 --><p class='noindent'>Sea \(A\) un conjunto. Dado \(n\in \omega \), por una <span class='cmti-10'>relacion</span> \(n\)<span class='cmti-10'>-aria sobre</span> \(A\) entenderemos un subconjunto
de \(A^{n}\). A las relaciones \(2\)-arias (resp. \(3\)-arias, \(4\)-arias) tambien las llamaremos <span class='cmti-10'>relaciones
</span><span class='cmti-10'>binarias </span>(resp. <span class='cmti-10'>ternarias, cuaternarias</span>). Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-27001x1.8'>Sea \(R=\{(r,t)\in \mathbf{R\times R}:r\leq t\}\). Entonces \(R\) es una relacion \(2\)-aria sobre \(\mathbf{R}\)
     </li>
     <li class='enumerate' id='x1-27002x1.8'>Hay exactamente dos relaciones \(0\)-arias sobre \(A\), a saber: \(\emptyset \) y \(\{\Diamond \}\).
     </li>
     <li class='enumerate' id='x1-27003x1.8'>Sea \(R=\{(x_{1},x_{2},x_{3},x_{4},x_{5})\in \mathbf{N}^{5}:x_{5}=x_{4}\}\). Entonces \(R\) es una relacion \(5\)-aria sobre \(\mathbf{N}\). Notese que tambien \(R\) es una
     relacion \(5\)-aria sobre \(\mathbf{R}\)
     </li>
     <li class='enumerate' id='x1-27004x1.8'>\(\emptyset \) es una relacion \(n\)-aria sobre \(A\), cualesquiera sea \(n\in \omega \) y \(A\).</li></ol>
<!-- l. 1107 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.9   </span> <a id='x1-280001.9'></a>Funciones \(\Sigma \)-mixtas</h4>

<!-- l. 1109 --><p class='noindent'>Sea \(\Sigma \) un alfabeto finito. Dados \(n,m\in \omega \), usaremos \(\omega ^{n}\times \Sigma ^{\ast m}\) para abreviar la expresion \[ \overset{n\text{ veces}}{\overbrace{\omega \times ...\times \omega }}\times \overset{m\text{ veces}}{\overbrace{\Sigma ^{\ast }\times ...\times \Sigma ^{\ast }}} \] Por
ejemplo, \(\omega ^{3}\times \Sigma ^{\ast 4}\) sera una forma abreviada de escribir \(\omega \times \omega \times \omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }\times \Sigma ^{\ast }\times \Sigma ^{\ast }\). Debe quedar claro que estamos
haciendo cierto abuso notacional ya que en principio si no hacemos esta
convencion notacional, \(\omega ^{3}\times \Sigma ^{\ast 4}\) denota un conjunto de pares y \(\omega \times \omega \times \omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }\times \Sigma ^{\ast }\times \Sigma ^{\ast }\) es un conjunto de
\(7\)-uplas.
</p><!-- l. 1121 --><p class='indent'>   Notese que cuando \(n=m=0\), tenemos que \(\omega ^{n}\times \Sigma ^{\ast m}\) denota el conjunto \(\{\Diamond \}\) y si \(m=0\), entonces \(\omega ^{n}\times \Sigma ^{\ast m}\) denota el
conjunto \(\omega ^{n}\).
</p><!-- l. 1125 --><p class='indent'>   Con esta convencion notacional, un elemento generico de \(\omega ^{n}\times \Sigma ^{\ast m}\) es una \((n+m)\)-upla de la forma
\((x_{1},...,x_{n},\alpha _{1},...,\alpha _{m})\). Para abreviar, escribiremos \((\vec{x},\vec{\alpha })\) en lugar de \((x_{1},...,x_{n},\alpha _{1},...,\alpha _{m})\).
</p>
<!-- l. 1133 --><p class='noindent'><span class='likeparagraphHead'><a id='x1-290001.9'></a>Definicion de funcion \(\Sigma \)-mixta</span>
   Sea \(\Sigma \) un alfabeto finito. Dada una funcion \(f\), diremos que \(f\) es \(\Sigma \)-<span class='cmti-10'>mixta </span>si cumple las
siguientes propiedades
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-29001x1.9'>Existen \(n,m\geq 0\), tales que \(D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\)
     </li>
     <li class='enumerate' id='x1-29002x1.9'>Ya sea \(I_{f}\subseteq \omega \) o \(I_{f}\subseteq \Sigma ^{\ast }\)</li></ol>
<!-- l. 1143 --><p class='indent'>   Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-29003x1.9'>Sea \(\Sigma =\{\square ,\%,\blacktriangle \}\). La funcion \[ \begin{array}{rll} f:\omega \times \{\square ,\%,\blacktriangle \}^{\ast } &amp; \rightarrow &amp; \omega \\ (x,\alpha ) &amp; \rightarrow &amp; x+\left \vert \alpha \right \vert \end{array} \] es \(\Sigma \)-mixta ya que se cumple (M1) con \(n=m=1\) y (M2). Notese que
     \(f\) no es \(\{\square ,\%\}\)-mixta ya que no cumple (M1) respecto del alfabeto \(\{\square ,\%\}\). Sin envargo
     note que \(f\) es \(\{\square ,\%,\blacktriangle ,@\}\)-mixta
     </li>
     <li class='enumerate' id='x1-29004x1.9'>La funcion \[ \begin{array}{rll} \omega ^{4} &amp; \rightarrow &amp; \omega \\ (x,y,z,w) &amp; \rightarrow &amp; x+y \end{array} \] es \(\Sigma \)-mixta cualesquiera sea el alfabeto \(\Sigma \)
     </li>
     <li class='enumerate' id='x1-29005x1.9'>Sea \(\Sigma =\{\square ,@\}\). La funcion \[ \begin{array}{rll} \{\square \square \square ,@@\} &amp; \rightarrow &amp; \omega \\ \alpha &amp; \rightarrow &amp; \left \vert \alpha \right \vert \end{array} \]
     <!-- l. 1171 --><p class='noindent'>es \(\Sigma \)-mixta ya que se cumple (M1) (con \(n=0\) y \(m=1\)) y (M2)
     </p></li>
     <li class='enumerate' id='x1-29006x1.9'>Supongamos \(\Sigma =\emptyset \). Tenemos entonces que \(\Sigma ^{\ast }=\{\varepsilon \}\). Por ejemplo \[ \begin{array}{rll} D &amp; \rightarrow &amp; \omega \\ (x,\varepsilon ,\varepsilon ,\varepsilon ) &amp; \rightarrow &amp; x^{2} \end{array} \] donde \(D=\{(x,\varepsilon ,\varepsilon ,\varepsilon ):x\) es impar\(\}\), es
     \(\Sigma \)-mixta (con \(n=1\) y \(m=3\) en (M1)). Tambien notese que \[ \begin{array}{rll} \{(\varepsilon ,\varepsilon )\} &amp; \rightarrow &amp; \{\varepsilon \}\\ (\varepsilon ,\varepsilon ) &amp; \rightarrow &amp; \varepsilon \end{array} \] es \(\Sigma \)-mixta.</li></ol>
<!-- l. 1192 --><p class='indent'>   Dejamos al lector la facil prueba del siguiente resultado basico.
</p>
   <div class='newtheorem'>
<!-- l. 1193 --><p class='noindent'><span class='head'>
<a id='x1-29007r8'></a>

<span class='cmbx-10'>Lema 8.</span>  </span><span class='cmti-10'>Supongamos</span> \(\Sigma \subseteq \Gamma \) <span class='cmti-10'>son alfabetos finitos. Entonces si</span> \(f\) <span class='cmti-10'>es una funcion</span> \(\Sigma \)<span class='cmti-10'>-mixta,</span>
\(f\) <span class='cmti-10'>es</span> \(\Gamma \)<span class='cmti-10'>-mixta</span>
</p>
   </div>
<!-- l. 1200 --><p class='indent'>   Una funcion \(\Sigma \)-mixta \(f\) es \(\Sigma \)-<span class='cmti-10'>total </span>cuando haya \(n,m\in \omega \) tales que \(D_{f}=\omega ^{n}\times \Sigma ^{\ast m}\). El lema anterior nos dice
que si \(\Sigma \subseteq \Gamma \), entonces toda funcion \(\Sigma \)-mixta es \(\Gamma \)-mixta. Sin envargo una funcion puede ser
\(\Sigma \)-total y no ser \(\Gamma \)-total, cuando \(\Sigma \subseteq \Gamma \). Por ejemplo tomemos \(\Sigma =\{\square ,\%,\blacktriangle \}\) y \(\Gamma =\{\square ,\%,\blacktriangle ,!\}\), y consideremos la
funcion
</p><!-- l. 1213 --><p class='indent'>   \[ \begin{array}{rll} f:\omega \times \Sigma ^{\ast } &amp; \rightarrow &amp; \omega \\ (x,\alpha ) &amp; \rightarrow &amp; x+\left \vert \alpha \right \vert \end{array} \] Es claro que \(f\) es \(\Sigma \)-mixta y \(\Sigma \)-total. Tambien es \(\Gamma \)-mixta ya que \(D_{f}\subseteq \omega \times \Gamma ^{\ast }\) y \(I_{f}\subseteq \omega \), por lo cual cumple
(M1) y (M2). Sin envargo \(f\) no es \(\Gamma \)-total ya que \(D_{f}\) no es igual a \(\omega ^{n}\times \Gamma ^{\ast m}\), cualesquiera sean \(n\) y
\(m\).
</p><!-- l. 1220 --><p class='indent'>   Como hemos visto recien, una funcion \(f\) puede ser \(\Sigma \)-mixta y \(\Gamma \)-mixta para dos
alfabetos distintos \(\Sigma \) y \(\Gamma \) e incluso es facil construir un ejemplo en el cual \(\Sigma \) y \(\Gamma \) sean
incomparables como conjuntos, es decir que ninguno incluya al otro. Dejamos al
lector convencerse de que si \(f\) es una funcion que es \(\Sigma \)-mixta para algun alfabeto \(\Sigma \),
entonces hay un alfabeto \(\Sigma _{0}\) el cual es el menor de todos los alfabetos respecto de los
cuales \(f\) es mixta, es decir \(\Sigma _{0}\) cumple que \(f\) es \(\Sigma _{0}\)-mixta y si \(\Gamma \) es tal que \(f\) es \(\Gamma \)-mixta, entonces
\(\Sigma _{0}\subseteq \Gamma \).
</p><!-- l. 1231 --><p class='indent'>   A continuacion daremos algunas funciones \(\Sigma \)-mixtas basicas las cuales seran
frecuentemente usadas.
</p><!-- l. 1234 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.9.1   </span> <a id='x1-300001.9.1'></a>Funciones \(Suc\) y \(Pred\)</h5>
<!-- l. 1236 --><p class='noindent'>La <span class='cmti-10'>funcion sucesor </span>es definida por \[ \begin{array}{rll} Suc:\omega &amp; \rightarrow &amp; \omega \\ n &amp; \rightarrow &amp; n+1 \end{array} \] La <span class='cmti-10'>funcion predecesor </span>es definida por
\[ \begin{array}{rll} Pred:\mathbf{N} &amp; \rightarrow &amp; \omega \\ n &amp; \rightarrow &amp; n-1 \end{array} \]
</p><!-- l. 1252 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.9.2   </span> <a id='x1-310001.9.2'></a>Las funciones \(d_{a}\)</h5>
<!-- l. 1254 --><p class='noindent'>Sea \(\Sigma \) un alfabeto no vacio. Para cada \(a\in \Sigma \), definamos \[ \begin{array}{rll} d_{a}:\Sigma ^{\ast } &amp; \rightarrow &amp; \Sigma ^{\ast }\\ \alpha &amp; \rightarrow &amp; \alpha a \end{array} \] La funcion \(d_{a}\) es llamada la funcion
<span class='cmti-10'>derecha sub</span> \(a\), respecto del alfabeto \(\Sigma \).
</p><!-- l. 1264 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.9.3   </span> <a id='x1-320001.9.3'></a>Las funciones \(p_{i}^{n,m}\)</h5>
<!-- l. 1266 --><p class='noindent'>Sea \(\Sigma \) un alfabeto. Para \(n,m,i\in \omega \) tales que \(1\leq i\leq n\), definamos \[ \begin{array}{rll} p_{i}^{n,m}:\omega ^{n}\times \Sigma ^{\ast m} &amp; \rightarrow &amp; \omega \\ (\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; x_{i} \end{array} \] Para \(n,m,i\in \omega \) tales que \(n+1\leq i\leq n+m\), definamos \[ \begin{array}{rll} p_{i}^{n,m}:\omega ^{n}\times \Sigma ^{\ast m} &amp; \rightarrow &amp; \Sigma ^{\ast }\\ (\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; \alpha _{i-n} \end{array} \] Las
funciones \(p_{i}^{n,m}\) son llamadas <span class='cmti-10'>proyecciones</span>. La funcion \(p_{i}^{n,m}\) es llamada la <span class='cmti-10'>proyeccion</span> \(n,m,i\), respecto
del alfabeto \(\Sigma \). Notese que esta definicion requiere que \(n+m\geq 1\) ya que \(i\) debe cumplir
\(1\leq i\leq n+m\).

</p><!-- l. 1286 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.9.4   </span> <a id='x1-330001.9.4'></a>Las funciones \(C_{k}^{n,m}\) y \(C_{\alpha }^{n,m}\)</h5>
<!-- l. 1288 --><p class='noindent'>Sea \(\Sigma \) un alfabeto. Para \(n,m,k\in \omega \), y \(\alpha \in \Sigma ^{\ast }\), definamos \[ \begin{array}{rll} C_{k}^{n,m}:\omega ^{n}\times \Sigma ^{\ast m} &amp; \rightarrow &amp; \omega \\ (\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; k \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rll} C_{\alpha }^{n,m}:\omega ^{n}\times \Sigma ^{\ast m} &amp; \rightarrow &amp; \Sigma ^{\ast }\\ (\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; \alpha \end{array} \] Notese que \(C_{k}^{0,0}:\{\Diamond \}\rightarrow \{k\}\) y que \(C_{\alpha }^{0,0}:\{\Diamond \}\rightarrow \{\alpha \}\).
</p><!-- l. 1301 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.9.5   </span> <a id='x1-340001.9.5'></a>La funcion \(pr\)</h5>
<!-- l. 1303 --><p class='noindent'>Definamos \[ \begin{array}{rll} pr:\mathbf{N} &amp; \rightarrow &amp; \omega \\ n &amp; \rightarrow &amp; n\text{-esimo numero primo} \end{array} \] Notese que \(pr(1)=2\), \(pr(2)=3\), \(pr(3)=5\), etc.
</p><!-- l. 1312 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.9.6   </span> <a id='x1-350001.9.6'></a>El tipo de una funcion mixta</h5>
<!-- l. 1314 --><p class='noindent'>Dada una funcion \(\Sigma \)-mixta \(f\), si \(n,m\in \omega \) son tales que \(D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) y ademas \(I_{f}\subseteq \omega \), entonces diremos que \(f\) <span class='cmti-10'>es
</span><span class='cmti-10'>una funcion de tipo</span> \((n,m,\#)\). Similarmente si \(n,m\in \omega \) son tales que \(D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) y ademas \(I_{f}\subseteq \Sigma ^{\ast }\), entonces
diremos que \(f\) <span class='cmti-10'>es una funcion de tipo</span> \((n,m,\ast )\). Notese que si \(f\neq \emptyset \), entonces hay unicos \(n,m\in \omega \) y
\(s\in \{\#,\ast \}\) tales que \(f\) es una funcion de tipo \((n,m,s)\). Sin envargo \(\emptyset \) es una funcion de tipo \((n,m,s)\)
cualesquiera sean \(n,m\in \omega \) y \(s\in \{\#,\ast \}\). De esta forma, cuando \(f\neq \emptyset \) hablaremos de ”el tipo de \(f\)”
para refererirnos a esta unica terna \((n,m,s)\). Notese que \(Suc\) es de tipo \((1,0,\#)\) y \(d_{a}\) es de tipo
\((0,1,\ast )\).
</p><!-- l. 1327 --><p class='indent'>   Tambien notese que la relacion ”\(f\) es una funcion de tipo \((n,m,s)\)” no depende del alfabeto
\(\Sigma \) (que significa esto?).
</p><!-- l. 1330 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.9.7   </span> <a id='x1-360001.9.7'></a>Funciones con imagen contenida en \(\omega ^{n}\times \Sigma ^{\ast m}\)</h5>
<!-- l. 1332 --><p class='noindent'>Supongamos que \(k,l,n,m\in \omega \) y que \(F:D_{F}\subseteq \omega ^{k}\times \Sigma ^{\ast l}\rightarrow \omega ^{n}\times \Sigma ^{\ast m}\). Supongamos ademas que \(n+m\geq 1\). Entonces denotaremos con \(F_{(i)}\) a la
funcion \(p_{i}^{n,m}\circ F\). Notar que </p><div class='eqnarray'>\begin{eqnarray*} F_{(i)} &amp; : &amp; D_{F}\subseteq \omega ^{k}\times \Sigma ^{\ast l}\rightarrow \omega \text{, para cada }i=1,...,n\\ F_{(i)} &amp; : &amp; D_{F}\subseteq \omega ^{k}\times \Sigma ^{\ast l}\rightarrow \Sigma ^{\ast }\text{, para cada }i=n+1,...,n+m \end{eqnarray*}
</div>Por lo cual cada una de las funciones \(F_{(i)}\) son \(\Sigma \)-mixtas. Ademas notese que \[ F=[F_{(1)},...,F_{(n+m)}] \]
<!-- l. 1349 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.9.8   </span> <a id='x1-370001.9.8'></a>Predicados \(\Sigma \)-mixtos</h5>
<!-- l. 1351 --><p class='noindent'>Un <span class='cmti-10'>predicado</span> \(\Sigma \)-<span class='cmti-10'>mixto </span>es una funcion \(f\) la cual es \(\Sigma \)-mixta y ademas cumple que \(I_{f}\subseteq \{0,1\}\). Por
ejemplo \[ \begin{array}{rll} \omega \times \omega &amp; \rightarrow &amp; \omega \\ (x,y) &amp; \rightarrow &amp; \left \{ \begin{array}{l} 1\text{ si }x=y\\ 0\text{ si }x\neq y \end{array}\right . \end{array}\ \ \ \ \ \ \ \ \ \ \ \begin{array}{rll} \{1,2,3,4,5\}\times \Sigma ^{\ast } &amp; \rightarrow &amp; \omega \\ (x,\alpha ) &amp; \rightarrow &amp; \left \{ \begin{array}{l} 1\text{ si }x=\left \vert \alpha \right \vert \\ 0\text{ si }x\neq \left \vert \alpha \right \vert \end{array}\right . \end{array} \]

</p>
<!-- l. 1371 --><p class='noindent'><span class='paragraphHead'><a id='x1-380001.9.8'></a><span class='cmbx-10'>Operaciones logicas entre predicados</span></span>
   Dados predicados \(P:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \{0,1\}\) y \(Q:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \{0,1\}\), con el mismo dominio, definamos nuevos predicados \((P\vee Q)\), \((P\wedge Q)\) y \(\lnot P\) de
la siguiente manera \[ \begin{array}{rll} (P\vee Q):S &amp; \rightarrow &amp; \omega \\ (\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; \left \{ \begin{array}{lll} 1 &amp; &amp; \text{si }P(\vec{x},\vec{\alpha })=1\text{ o }Q(\vec{x},\vec{\alpha })=1\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \end{array} \] \[ \begin{array}{rll} (P\wedge Q):S &amp; \rightarrow &amp; \omega \\ (\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; \left \{ \begin{array}{lll} 1 &amp; &amp; \text{si }P(\vec{x},\vec{\alpha })=1\text{ y }Q(\vec{x},\vec{\alpha })=1\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \end{array} \] \[ \begin{array}{rll} \lnot P:S &amp; \rightarrow &amp; \omega \\ (\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; \left \{ \begin{array}{lll} 1 &amp; &amp; \text{si }P(\vec{x},\vec{\alpha })=0\\ 0 &amp; &amp; \text{si }P(\vec{x},\vec{\alpha })=1 \end{array}\right . \end{array} \]
</p><!-- l. 1406 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.9.9   </span> <a id='x1-390001.9.9'></a>Familias \(\Sigma \)-indexadas de funciones</h5>
<!-- l. 1408 --><p class='noindent'>Dado un alfabeto \(\Sigma \), una <span class='cmti-10'>familia</span> \(\Sigma \)-<span class='cmti-10'>indexada de funciones </span>sera una funcion \(\mathcal{G}\) tal que \(D_{\mathcal{G}}=\Sigma \) y
para cada \(a\in D_{\mathcal{G}}\) se tiene que \(\mathcal{G}(a)\) es una funcion. Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-39001x1.9.9'>Sea \(\mathcal{G}\) dada por \[ \begin{array}{rcl} \mathcal{G}:\{\square ,\%,\blacktriangle \} &amp; \rightarrow &amp; \{Suc,Pred\}\\ \square &amp; \rightarrow &amp; Suc\\ \% &amp; \rightarrow &amp; Suc\\ \blacktriangle &amp; \rightarrow &amp; Pred \end{array} \] Claramente \(\mathcal{G}\) es una familia \(\{\square ,\%,\blacktriangle \}\)-indexada de funciones. Notar
     que \[ \mathcal{G}=\{(\square ,Suc),(\%,Suc),(\blacktriangle ,Pred)\} \] Se tiene tambien por ejemplo que \(\mathcal{G}(\%)=Suc\) por lo cual tambien es cierto que
     \(\mathcal{G}(\%)(22)=23\), etc.
     </li>
     <li class='enumerate' id='x1-39002x1.9.9'>Si  \(\Sigma \)  es  un  alfabeto  no  vacio,  la  funcion  \[ \begin{array}{rcl} \mathcal{G}:\Sigma &amp; \rightarrow &amp; \{f:f\text{ es una funcion de }\Sigma ^{\ast }\text{ en }\Sigma ^{\ast }\}\\ a &amp; \rightarrow &amp; d_{a} \end{array} \]  es  una  familia  \(\Sigma \)-indexada  de
     funciones. Notar que \[ \mathcal{G}=\{(a,d_{a}):a\in \Sigma \} \]
     </li>
     <li class='enumerate' id='x1-39003x1.9.9'>\(\emptyset \) es una flia \(\emptyset \)-indexada de funciones</li></ol>
<!-- l. 1442 --><p class='noindent'>Si  \(\mathcal{G}\) es una familia \(\Sigma \)-indexada de funciones, entonces para \(a\in \Sigma \), escribiremos \(\mathcal{G}_{a}\) en lugar de
\(\mathcal{G}(a)\).
</p><!-- l. 1450 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.10   </span> <a id='x1-400001.10'></a>Conjuntos \(\Sigma \)-mixtos</h4>
<!-- l. 1452 --><p class='noindent'>Un conjunto \(S\) es llamado \(\Sigma \)<span class='cmti-10'>-mixto </span>si hay \(n,m\in \omega \) tales que \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\). Notese que \(S\) es \(\emptyset \)-mixto sii existe un
\(n\geq 0\), tal que \(S\subseteq \omega ^{n}\). Por ejemplo, \[ \{(x,\alpha )\in \omega \times \{\blacktriangle ,!\}^{\ast }:\left \vert \alpha \right \vert =x\} \] \[ \{(0,\blacktriangle \blacktriangle \blacktriangle ,\varepsilon ),(1,\%\blacktriangle \%,\blacktriangle \blacktriangle )\} \] son conjuntos \(\{\blacktriangle ,\%,!\}\)-mixtos. Tambien notese que \(\emptyset \) y \(\{\Diamond \}\) son conjuntos
\(\Sigma \)-mixtos, cualesquiera sea el alfabeto \(\Sigma \).
</p><!-- l. 1466 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.10.1   </span> <a id='x1-410001.10.1'></a>El tipo de un conjunto mixto</h5>
<!-- l. 1468 --><p class='noindent'>Dado un conjunto \(\Sigma \)-mixto \(S\), si \(n,m\in \omega \) son tales que \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\), entonces diremos que \(S\) <span class='cmti-10'>es un conjunto de
</span><span class='cmti-10'>tipo</span> \((n,m)\). Notese que si \(S\neq \emptyset \), entonces hay unicos \(n,m\in \omega \) tales que \(S\) es un conjunto de tipo \((n,m)\). Sin
envargo \(\emptyset \) es un conjunto de tipo \((n,m)\) cualesquiera sean \(n,m\in \omega \). De esta forma, cuando \(S\neq \emptyset \)
hablaremos de ”el tipo de \(S\)” para refererirnos a este unico par \((n,m)\). Notese que \(\omega \) es de tipo
\((1,0)\) y \(\Sigma ^{\ast }\) es de tipo \((0,1)\).
</p><!-- l. 1478 --><p class='indent'>   Tambien notese que la relacion ”\(S\) es un conjunto de tipo \((n,m)\)” no depende del alfabeto
\(\Sigma \) (que significa esto?).

</p><!-- l. 1489 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.10.2   </span> <a id='x1-420001.10.2'></a>Conjuntos rectangulares</h5>
<!-- l. 1491 --><p class='noindent'>Un conjunto \(\Sigma \)-mixto \(S\) es llamado <span class='cmti-10'>rectangular </span>si es de la forma \[ S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}, \] con cada \(S_{i}\subseteq \omega \) y cada \(L_{i}\subseteq \Sigma ^{\ast }\).
Notar que todo subconjunto de \(\omega \) es rectangular (es el caso \(n=1\) y \(m=0\)). Tambien \(\{\Diamond \}\) es
rectangular (es el caso \(n=m=0\)). Otros ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-42001x1.10.2'>\(\mathbf{N}\times \{1,2\}\times \{@@,\varepsilon \}\) es rectangular (aqui \(n=2\) y \(m=1\))
     </li>
     <li class='enumerate' id='x1-42002x1.10.2'>\(\{!!!,!!\}\times \{@@,\varepsilon \}\) es rectangular (aqui \(n=0\) y \(m=2\))</li></ol>
<!-- l. 1506 --><p class='noindent'>Tambien notese que \(\emptyset =\emptyset \times \emptyset \) por lo cual \(\emptyset \) es un conjunto rectangular.
</p><!-- l. 1509 --><p class='indent'>   El concepto de conjunto rectangular es muy importante en nuestro enfoque.
Aunque en general no habra restricciones acerca del dominio de las funciones y
predicados, nuestra filosofia sera tratar en lo posible que los dominios de las funciones
que utilicemos para hacer nuestro analisis de recursividad de los distintos
paradigmas, sean rectangulares. Aunque en principio puede pareser que todos los
conjuntos son rectangulares, el siguiente lema mostrara cuan ingenua es esta
vision.
</p>
   <div class='newtheorem'>
<!-- l. 1516 --><p class='noindent'><span class='head'>
<a id='x1-42003r9'></a>
<span class='cmbx-10'>Lema 9.</span>  </span><span class='cmti-10'>Sea</span> \(S\subseteq \omega \times \Sigma ^{\ast }\)<span class='cmti-10'>. Entonces</span> \(S\) <span class='cmti-10'>es rectangular si y solo si se cumple la siguiente
</span><span class='cmti-10'>propiedad:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-42004x9'><span class='cmti-10'>Si</span> \((x,\alpha ),(y,\beta )\in S\)<span class='cmti-10'>, entonces</span> \((x,\beta )\in S\)</li></ol>
   </div>
<!-- l. 1524 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 1525 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ejercicio.                                                                                □
</p>
   </div>
<!-- l. 1529 --><p class='indent'>   Supongamos \(\Sigma =\{\#,\blacktriangle ,\%\}\). Notese que podemos usar el lema anterior para probar por ejemplo
que los siguientes conjuntos no son rectangulares

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-42005x1.10.2'>\(\{(0,\#\#),(1,\%\%\%)\}\)
     </li>
     <li class='enumerate' id='x1-42006x1.10.2'>\(\{(x,\alpha ):\left \vert \alpha \right \vert =x\}\)</li></ol>
<!-- l. 1536 --><p class='noindent'>Dejamos como ejercicio para el lector enunciar un lema analogo al anterior pero que
caracterice cuando \(S\subseteq \omega ^{2}\times \Sigma ^{\ast 3}\) es rectangular.
</p><!-- l. 1543 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.11   </span> <a id='x1-430001.11'></a>Notacion lambda</h4>
<!-- l. 1545 --><p class='noindent'>Usaremos la notacion lambda de Church en la forma que se explica a continuacion.
Esta notacion siempre depende de un alfabeto finito previamente fijado. En general
en nuestro lenguaje matematico utilizamos diversas expresiones las cuales involucran
variables que una vez fijadas en sus valores hacen que la expresion tambien represente
un determinado valor
</p><!-- l. 1552 --><p class='indent'>   En el contexto de la notacion lambda solo se podran utilizar expresiones con
caracteristicas muy especiales por lo cual a continuacion iremos describiendo que
condiciones tienen que cumplir las expresiones para que puedan ser usadas en la
notacion lambda
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-43001x1.11'>Solo utilizaremos expresiones que involucran variables numericas, las cuales se
     valuaran en numeros de \(\omega \), y variables alfabeticas, las cuales se valuaran en
     palabras del alfabeto previamente fijado. Las variables numericas seran
     seleccionadas de la lista <div class='eqnarray'>\begin{eqnarray*} &amp; &amp; x,y,z,w,n,m,k,...\\ &amp; &amp; x_{1},x_{2},...\\ &amp; &amp; y_{1},y_{2},...\\ &amp; &amp; etc \end{eqnarray*}
     </div>Las variables alfabeticas seran seleccionadas de la lista <div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \alpha ,\beta ,\gamma ,\eta ,...\\ &amp; &amp; \alpha _{1},\alpha _{2},...\\ &amp; &amp; \beta _{1},\beta _{2},...\\ &amp; &amp; etc \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-43002x1.11'>Por ejemplo la expresion: \[ x+y+1 \] tiene dos variables numericas \(x\) e \(y\) (y ninguna
     alfabetica). Si le asignamos a \(x\) el valor 2 y a \(y\) el valor 45, entonces la expresion \(x+y+1\)
     produce o representa el valor \(48=2+45+1\).
     </li>
     <li class='enumerate' id='x1-43003x1.11'>Otro ejemplo, consideremos la expresion \[ \left \vert \alpha \beta \right \vert +\left \vert \alpha \right \vert ^{x} \] la cual tiene una variable
     numerica \(x\) y dos variables alfabeticas \(\alpha \) y \(\beta \). Supongamos ademas que el
     alfabeto previamente fijado es \(\{@,\%\}\). Si le asignamos a \(x\) el valor 2, a \(\alpha \) el valor \(@@\)
     y a \(\beta \) el valor \(\%\%\%\), entonces la expresion \(\left \vert \alpha \beta \right \vert +\left \vert \alpha \right \vert ^{x}\) produce o representa el valor
     \(\left \vert @@\%\%\%\right \vert +\left \vert @@\right \vert ^{2}=9\).
     </li>
     <li class='enumerate' id='x1-43004x1.11'>Para ciertas valuaciones de sus variables la expresion puede no estar definida.
     Por ejemplo la expresion \[ Pred(\left \vert \alpha \right \vert ) \] no asume valor o no esta definida cuando el valor
     asignado a \(\alpha \) es \(\varepsilon \). Otro ejemplo, consideremos la expresion \[ x/(y-\left \vert \alpha \right \vert )^{2} \] Esta expresion no esta

     definida o no asume valor para aquellas asignaciones de valores a sus variables
     en las cuales el valor asignado a \(y\) sea igual a la longitud del valor asignado a
     \(\alpha \).
     </li>
     <li class='enumerate' id='x1-43005x1.11'>En los ejemplos anteriores las expresiones producen valores numericos pero
     tambien trabajaremos con expresiones que producen valores alfabeticos. Por
     ejemplo la expresion \[ \beta ^{y} \] tiene una variable numerica, \(y\), una variable alfabetica, \(\beta \), y
     una vez valuadas estas variables produce un valor alfabetico, a saber el
     resultado de elevar el valor asignado a la variable \(\beta \), a el valor asignado a
     \(y\).
     </li>
     <li class='enumerate' id='x1-43006x1.11'>Una expresion \(E\) para poder ser utilizada en la notacion lambda relativa a un
     alfabeto \(\Sigma \) debera cumplir alguna de las dos siguientes propiedades
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-43008x1'>los valores que asuma \(E\) cuando hayan sido asignados valores de \(\omega \) a sus
         variables numericas y valores de \(\Sigma ^{\ast }\) a sus variables alfabeticas deberan
         ser siempre elementos de \(\omega \)
         </li>
         <li class='enumerate' id='x1-43010x2'>los valores que asuma \(E\) cuando hayan sido asignados valores de \(\omega \) a sus
         variables numericas y valores de \(\Sigma ^{\ast }\) a sus variables alfabeticas deberan
         ser siempre elementos de \(\Sigma ^{\ast }\).</li></ol>
     </li>
     <li class='enumerate' id='x1-43011x1.11'>Por ejemplo la expresion \[ x/2 \] no cumple la propiedad dada en (6) ya que para
     ciertos valores de \(\omega \) asignados a la variable \(x\), la expresion da valores que se salen
     de \(\omega \) por lo cual no puede cumpir ni a. ni b.
     </li>
     <li class='enumerate' id='x1-43012x1.11'>Otro ejemplo, si el alfabeto fijado es \(\Sigma =\{@,\%\}\), entonces la expresion \[ @^{x}\$^{y} \] no cumple la
     propiedad dada en (6) ya que por ejemplo cuando le asignamos a \(x\) el valor 2 y a \(y\)
     el valor 6, la expresion nos da la palabra \(@@\$\$\$\$\$\$\) la cual no pertenece a \(\Sigma ^{\ast }\) por lo cual no
     puede cumpir ni a. ni b.
     </li>
     <li class='enumerate' id='x1-43013x1.11'>No necesariamente las expresiones que usaremos en la notacion lambda deben
     ser hechas como combinacion de operaciones matematicas conocidas. Muchas
     veces usaremos expresiones que involucran incluso lenguaje coloquial castellano.
     Por ejemplo la expresion \[ \mathrm{el\ menor\ numero\ primo\ que\ es\ mayor\ que\ }x \] Es claro que esta expresion para cada valor de \(\omega \)
     asignado a la variable \(x\) produce o representa un valor concreto de \(\omega \). Otro
     ejemplo: \[ \mathrm{el\ tercer\ simbolo\ de\ }\alpha \] notese que esta expresion, una ves fijado un alfabeto \(\Sigma \), estara definida
     o producira un valor solo cuando le asignamos a \(\alpha \) una palabra de \(\Sigma ^{\ast }\) de longitud
     mayor o igual a \(3\).
     </li>
     <li class='enumerate' id='x1-43014x1.11'><span class='cmbx-10'>Expresiones Booleanas. </span>A las expresiones Booleanas tales como
     \[ x=y+1\text{ y }\left \vert \alpha \right \vert \leq 22 \]</li></ol>

<!-- l. 1663 --><p class='noindent'>las pensaremos que asumen valores del conjunto \(\{0,1\}\subseteq \omega \). Por ejemplo la expresion anterior
asume o produce el valor \(1\) cuando le asignamos a \(x\) el valor 11, a \(y\) el valor 10 y a \(\alpha \) la
palabra \(\varepsilon \). Las expresiones Booleanas pensadas de esta forma podran ser
utilizadas en la notacion lambda si es que tambien cumplen con las anteriores
condiciones.
</p><!-- l. 1673 --><p class='noindent'>
</p>
   <h5 class='likesubsubsectionHead'><a id='x1-440001.11'></a>Definicion de \(\lambda x_{1}...x_{n}\alpha _{1}...\alpha _{m}\left [E\right ]\)</h5>
<!-- l. 1675 --><p class='noindent'>Supongamos ya hemos fijado un alfabeto finito \(\Sigma \) y supongamos \(E\) es una expresion la
cual tiene las caracteristicas descriptas anteriormente. Sea \(x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\) una lista de variables
todas distintas tal que las variables numericas que ocurren en \(E\) estan todas contenidas
en la lista \(x_{1},...,x_{n}\) y las variables alfabeticas que ocurren en \(E\) estan en la lista \(\alpha _{1},...,\alpha _{m}\) (puede
suceder que haya variables de la lista \(x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\) las cuales no ocurran en \(E\)). Entonces \[ \lambda x_{1}...x_{n}\alpha _{1}...\alpha _{m}\left [E\right ] \] denotara
la funcion definida por:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-44001x1.11'>El dominio de \(\lambda x_{1}...x_{n}\alpha _{1}...\alpha _{m}\left [E\right ]\) es el conjunto de las \((n+m)\)-uplas \((k_{1},...,k_{n},\beta _{1},...,\beta _{m})\in \omega ^{n}\times \Sigma ^{\ast m}\) tales que \(E\) esta definida cuando
     le asignamos a cada \(x_{i}\) el valor \(k_{i}\) y a cada \(\alpha _{i}\) el valor \(\beta _{i}\).
     </li>
     <li class='enumerate' id='x1-44002x1.11'>\(\lambda x_{1}...x_{n}\alpha _{1}...\alpha _{m}\left [E\right ](k_{1},...,k_{n},\beta _{1},...,\beta _{m})=\) valor que asume o representa \(E\) cuando le asignamos a cada \(x_{i}\) el valor \(k_{i}\) y a
     cada \(\alpha _{i}\) el valor \(\beta _{i}\).</li></ol>
<!-- l. 1699 --><p class='indent'>   Notese que por tener \(E\) la propiedad (6) de mas arriba, la funcion \(\lambda x_{1}...x_{n}\alpha _{1}...\alpha _{m}\left [E\right ]\) es \(\Sigma \)-mixta de tipo
\((n,m,s)\) para algun \(s\in \{\#,\ast \}\). Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-44003x1.11'>Supongamos fijamos el alfabeto \(\Sigma =\{@,?,\)¡\(\}\). Entonces \(\lambda x\alpha \left [\alpha ^{2x}\right ]\) es la funcion \[ \begin{array}{rll} \omega \times \{@,?,\text{¡}\}^{\ast } &amp; \rightarrow &amp; \{@,?,\text{¡}\}^{\ast }\\ (x,\alpha ) &amp; \rightarrow &amp; \alpha ^{2x} \end{array} \] Aqui el lector
     puede notar la dependencia de la notacion lambda respecto del alfabeto
     fijado. Si en lugar de fijar \(\Sigma =\{@,?,\)¡\(\}\) hubieramos fijado \(\Sigma =\{\%\}\), entonces \(\lambda x\alpha \left [\alpha ^{2x}\right ]\) denotaria otra
     funcion, a saber \[ \begin{array}{rll} \omega \times \{\%\}^{\ast } &amp; \rightarrow &amp; \{\%\}^{\ast }\\ (x,\alpha ) &amp; \rightarrow &amp; \alpha ^{2x} \end{array} \]
     </li>
     <li class='enumerate' id='x1-44004x1.11'>Supongamos fijamos el alfabeto \(\Sigma =\{@,?,\)¡\(\}\). Entonces \(\lambda xyz\alpha \left [\alpha ^{2x}\right ]\) es la funcion \[ \begin{array}{rll} \omega ^{3}\times \{@,?,\text{¡}\}^{\ast } &amp; \rightarrow &amp; \{@,?,\text{¡}\}^{\ast }\\ (x,y,z,\alpha ) &amp; \rightarrow &amp; \alpha ^{2x} \end{array} \]
     </li>
     <li class='enumerate' id='x1-44005x1.11'>Supongamos fijamos el alfabeto \(\Sigma =\{\%,!\}\). Entonces \(\lambda \alpha \beta \left [\alpha \beta \right ]\) es la funcion \[ \begin{array}{rll} \{\%,!\}^{\ast }\times \{\%,!\}^{\ast } &amp; \rightarrow &amp; \{\%,!\}^{\ast }\\ (\alpha ,\beta ) &amp; \rightarrow &amp; \alpha \beta \end{array} \]
     <!-- l. 1738 --><p class='noindent'>Tambien  tenemos  que  \(\lambda \beta \alpha \left [\alpha \beta \right ]\)  es  la  funcion  \[ \begin{array}{rll} \{\%,!\}^{\ast }\times \{\%,!\}^{\ast } &amp; \rightarrow &amp; \{\%,!\}^{\ast }\\ (\beta ,\alpha ) &amp; \rightarrow &amp; \alpha \beta \end{array} \]  Notese  que  estas  funciones  son
     distintas. Por ejemplo \(\lambda \alpha \beta \left [\alpha \beta \right ](\%,!)=\%!\) y \(\lambda \beta \alpha \left [\alpha \beta \right ](\%,!)=!\%\)
     </p></li>
     <li class='enumerate' id='x1-44006x1.11'>Independientemente de quien sea \(\Sigma \) el alfabeto previamente fijado, tenemos
     que \(\lambda xy[x+y]\) es la funcion \[ \begin{array}{rll} \omega ^{2} &amp; \rightarrow &amp; \omega \\ (x,y) &amp; \rightarrow &amp; x+y \end{array} \] Tambien \(\lambda xyzw[x+w]\) es la funcion \[ \begin{array}{rll} \omega ^{4} &amp; \rightarrow &amp; \omega \\ (x,y,z,w) &amp; \rightarrow &amp; x+w \end{array} \]

     </li>
     <li class='enumerate' id='x1-44007x1.11'>Supongamos fijamos el alfabeto \(\Sigma =\{@,?,\)¡\(\}\). Entonces por la clausula (L1) tenemos
     que el dominio de la funcion \(\lambda xy\alpha \beta \left [Pred(\left \vert \alpha \right \vert )+Pred(y)\right ]\) es \[ D=\left \{ (x,y,\alpha ,\beta )\in \omega ^{2}\times \Sigma ^{\ast 2}:\left \vert \alpha \right \vert \geq 1\text{ y }y\geq 1\right \} \] Es decir que \(\lambda xy\alpha \beta \left [Pred(\left \vert \alpha \right \vert )+Pred(y)\right ]\) es la funcion \[ \begin{array}{rll} D &amp; \rightarrow &amp; \omega \\ (x,y,\alpha ,\beta ) &amp; \rightarrow &amp; Pred(\left \vert \alpha \right \vert )+Pred(y) \end{array} \]
     </li>
     <li class='enumerate' id='x1-44008x1.11'>Atentos a (10) de mas arriba, la funcion \(\lambda xy\left [x=y\right ]\) es el predicado \[ \begin{array}{rll} \omega \times \omega &amp; \rightarrow &amp; \omega \\ (x,y) &amp; \rightarrow &amp; \left \{ \begin{array}{l} 1\text{ si }x=y\\ 0\text{ si }x\neq y \end{array}\right . \end{array} \] y \(\lambda x\alpha \left [Pred(x)=\left \vert \alpha \right \vert \right ]\) es el predicado
     \[ \begin{array}{rll} \mathbf{N}\times \Sigma ^{\ast } &amp; \rightarrow &amp; \omega \\ (x,\alpha ) &amp; \rightarrow &amp; \left \{ \begin{array}{l} 1\text{ si }Pred(x)=\left \vert \alpha \right \vert \\ 0\text{ si }Pred(x)\neq \left \vert \alpha \right \vert \end{array}\right . \end{array} \] Tambien \(\lambda \alpha \beta \left [\alpha =\beta \right ]\) es el predicado \[ \begin{array}{rll} \Sigma ^{\ast }\times \Sigma ^{\ast } &amp; \rightarrow &amp; \omega \\ (\alpha ,\beta ) &amp; \rightarrow &amp; \left \{ \begin{array}{l} 1\text{ si }\alpha =\beta \\ 0\text{ si }\alpha \neq \beta \end{array}\right . \end{array} \]
     </li>
     <li class='enumerate' id='x1-44009x1.11'>Notar que para \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) se tiene que \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}=\lambda x_{1}...x_{n}\alpha _{1}...\alpha _{m}\left [(\vec{x},\vec{\alpha })\in S\right ]\)
     </li>
     <li class='enumerate' id='x1-44010x1.11'>Como  dijimos,  la  notacion  lambda  depende  del  alfabeto  previamnete
     fijado, aunque para el caso en que la lista de variables que sigue a la letra
     \(\lambda \) no tenga variables alfabeticas, la funcion representada no depende del
     alfabeto</li></ol>
<!-- l. 1818 --><p class='indent'>   @@finpagina@@
</p><!-- l. 1822 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.12   </span> <a id='x1-450001.12'></a>Ordenes naturales sobre \(\Sigma ^{\ast }\)</h4>
<!-- l. 1824 --><p class='noindent'>Llamaremos <span class='cmti-10'>numerales </span>a los siguientes simbolos \[ 0\ 1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9 \] Usaremos \(Num\) para denotar el conjunto
de numerales. Notese que \(Num\cap \omega =\emptyset \). Es decir, no debemos confundir los simbolos que
usualmente denotan los primeros diez numeros enteros con los numeros que ellos
denotan. De hecho en china o japon los primeros diez numeros enteros se
denotan con otros simbolos. Similarmente las palabras pertenecientes a \(Num^{\ast }\)
denotan (notacion decimal) a los numeros de \(\omega \) pero debemos tener en cuenta
que \(Num^{\ast }\cap \omega =\emptyset \). Cuando tratamos con palabras de \(Num^{\ast }\), debemos ser cuidadosos ya que
muchas veces en nuestro discurso matematico (es decir las guias, el apunte, lo
que escriben los profesores en el pizarron, etc) representamos dos objetos
diferentes de la misma forma. Por ejemplo \(45\) puede estar denotando al numero
entero cuarenta y cinco o tambien \(45\) puede estar denotando la palabra de
longitud \(2\) cuyo primer simbolo es el numeral \(4\) y cuyo segundo simbolo es el
numeral \(5\), es decir ella misma. Por dar otro ejemplo, el simbolo \(1\) en nuestro
discurso algunas veces se denotara a si mismo y otras veces denotara al numero
uno.
</p><!-- l. 1846 --><p class='indent'>   Es bien conocido que, en notacion decimal, las siguientes palabras del alfabeto \(Num\),
denotan, de menor a mayor, a los numeros de \(\omega \) \[ 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,... \] Por supuesto esta lista de
palabras es infinita pero asumimos que el lector sabe como obtener la palabra
siguiente a cada miembro de la lista (i.e. sumar 1 en notacion decimal), lo cual
determina por completo la lista conociendo que la misma comienza con la palabra
\(0\).
</p><!-- l. 1857 --><p class='indent'>   Cabe destacar que debido a la presencia del numeral \(0\) en la lista, la \(n\)-esima palabra
representa o denota al numero \(n-1\) o, dicho de otra forma, el numero \(n\in \omega \) es representado

por la \((n+1)\)-esima palabra de la lista.
</p><!-- l. 1862 --><p class='indent'>   Un detalle de la representacion decimal de numeros de \(\omega \) mediante palabras de \(Num^{\ast }\) es
que la misma no nos da una biyeccion entre \(Num^{\ast }\) y \(\omega \) ya que por ejemplo las palabras \(00016\) y \(16\)
representan el mismo numero. Dicho de otra forma en la lista anterior no figuran
todas las palabras de \(Num^{\ast }\), a saber estan omitidas todas las palabras que comienzan con
el simbolo \(0\) y tienen longitud mayor que uno. A continuacion daremos una
representacion de los numeros de \(\omega \) mediante palabras, la cual no tendra este
problema. El alfabeto que usaremos tendra todos los numerales menos el \(0\) y ademas
tendra un simbolo para denotar al numero diez, a saber el simbolo \(d\). Es decir \[ \widetilde{Num}=\{1,2,3,4,5,6,7,8,9,d\} \]
Representaremos a los numeros de \(\omega \) con la siguiente lista infinita de palabras de
\(\widetilde{Num}\)
</p><!-- l. 1879 --><p class='indent'>   \(\bigskip \)
</p><!-- l. 1881 --><p class='indent'>   \(\varepsilon ,1,2,3,4,5,6,7,8,9,d,\)
</p><!-- l. 1883 --><p class='indent'>   \(11,12,...,1d,21,22,...,2d,...,91,92,...,9d,d1,d2,...,dd,\)
</p><!-- l. 1885 --><p class='indent'>   \(111,112,...,11d,121,122,...,12d,...\)
</p><!-- l. 1889 --><p class='noindent'>El lector ya se habra dado cuenta de que el siguiente a una palabra \(\alpha \) de la lista
anterior se obtiene aplicando las siguientes clausulas
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-45001x1.12'>si \(\alpha =d^{n}\), con \(n\geq 0\) entonces el siguiente de \(\alpha \) es \(1^{n+1}\)
     </li>
     <li class='enumerate' id='x1-45002x1.12'>si \(\alpha \) no es de la forma \(d^{n}\), con \(n\geq 0\), entonces el siguiente de \(\alpha \) se obtiene de la siguiente
     manera:
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-45004x1'>buscar de derecha a izquierda el primer simbolo no igual a \(d\)
         </li>
         <li class='enumerate' id='x1-45006x2'>reemplazar dicho simbolo por su siguiente en la lista \(1,2,3,4,5,6,7,8,9,d\)
         </li>
         <li class='enumerate' id='x1-45008x3'>reemplazar por el simbolo \(1\) a todos los simbolos iguales a \(d\) que ocurrian
         a la derecha del simbolo reemplazado</li></ol>
     </li></ol>
<!-- l. 1904 --><p class='noindent'>Notese que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-45009x1.12'>El numero \(0\) es representado en la lista anterior con la palabra \(\varepsilon \)
     </li>
     <li class='enumerate' id='x1-45010x1.12'>El numero \(1\) es representado en la lista anterior con la palabra \(1\)
     <!-- l. 1911 --><p class='noindent'>\(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \vdots \)
     </p></li>
     <li class='enumerate' id='x1-45011x1.12'>El numero \(9\) es representado en la lista anterior con la palabra \(9\)

     </li>
     <li class='enumerate' id='x1-45012x1.12'>El numero \(10\) es representado en la lista anterior con la palabra \(d\)
     </li>
     <li class='enumerate' id='x1-45013x1.12'>El numero \(11\) es representado en la lista anterior con la palabra \(11\)
     <!-- l. 1919 --><p class='noindent'>\(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \vdots \)
     </p></li>
     <li class='enumerate' id='x1-45014x1.12'>El numero \(19\) es representado en la lista anterior con la palabra \(19\)
     </li>
     <li class='enumerate' id='x1-45015x1.12'>El numero \(20\) es representado en la lista anterior con la palabra \(1d\)
     </li>
     <li class='enumerate' id='x1-45016x1.12'>El numero \(21\) es representado en la lista anterior con la palabra \(21\)
     </li>
     <li class='enumerate' id='x1-45017x1.12'>El numero \(22\) es representado en la lista anterior con la palabra \(22\)
     <!-- l. 1929 --><p class='noindent'>\(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \vdots \)</p></li></ol>
<!-- l. 1931 --><p class='noindent'>Como puede notarse en estos primeros veinte y pico numeros solo dos (el \(0\) y el \(20\)) se
representan en forma distinta a la reprentacion decimal clasica. Es natural que \(\varepsilon \)
denote al numero \(0\) y ademas notese que la palabra \(1d\) (que en la lista representa el \(20\))
puede leerse como ”diecidiez” (es decir la palabra que sigue a ”diecinueve”) que
justamente es \(20\). Por supuesto con esta manera de pensar la palabra \(2d\) deberiamos leerla
como ”ventidiez” y si nos fijamos en la lista ella representa al numero treinta lo
cual nuevamente es muy natural. Otro ejemplo: a \(6d\) deberiamos leerla como
”sesentidiez” y es natural ya que en la lista representa al setenta. Tambien, la
palabra \(9d\) puede leerse noventidiez ya que representa en la lista al numero
\(100\).
</p><!-- l. 1944 --><p class='indent'>   La lista anterior va representando los numeros de \(\omega \) en forma muy natural pero
aunque nuestra intuicion nos diga que no, en principio podria pasar que una misma
palabra del alfabeto \(\widetilde{Num}\) ocurra dos veces en la lista y esto nos diria que una misma
palabra estaria representando a dos numeros distintos. Tambien, en principio podria
suceder que haya una palabra del alfabeto \(\widetilde{Num}\) la cual nunca figure en la lista. Mas
abajo probaremos que estas dos posibilidades no suceden, es decir muestran
que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-45018x1.12'>Toda palabra de \(\widetilde{Num}^{\ast }\) aparece en la lista
     </li>
     <li class='enumerate' id='x1-45019x1.12'>Ninguna palabra de \(\widetilde{Num}^{\ast }\) aparece mas de una ves</li></ol>
<!-- l. 1956 --><p class='noindent'>Notese que la propiedad (S) nos dice que la funcion \[ \begin{array}[t]{rll} \ast :\omega &amp; \rightarrow &amp; \widetilde{Num}^{\ast }\\ n &amp; \rightarrow &amp; (n+1)\text{-esimo elemento de la lista} \end{array} \] es sobreyectiva y la propiedad
(I) nos garantiza que dicha funcion es inyectiva, por lo cual entre las dos
nos garantizan que dicha representacion establece una biyeccion entre \(\omega \) y
\(\widetilde{Num}^{\ast }\).

</p><!-- l. 1967 --><p class='indent'>   Por supuesto, la pregunta que inmediatamente surge es como calcular la inversa
de \(\ast \). Llamemos \(\#\) a la inversa de \(\ast \). Notese que dada una palabra \(\alpha \in \widetilde{Num}^{\ast }\), el numero \(\#(\alpha )\) es
justamente el numero representado por la palabra \(\alpha \), o dicho de otra forma \(\#(\alpha )\) es la
posicion que ocupa \(\alpha \) en la lista, contando desde el \(0\) (es decir \(\alpha \) es la \((\#(\alpha )+1)\)-esima palabra de la
lista). Por ejemplo: </p><div class='gather-star'><img alt=' ' src='apunte0x.png' /></div>Aqui hay que tener cuidado como leemos las igualdades anteriores. Por ejemplo en
la igualdad \[ \#(1)=1 \] la primera ocurrencia del simbolo \(1\) se refiere al numeral uno, es decir
denota una palabra y la segunda ocurrencia se esta refiriendo al numero uno, es decir
denota un numero.
<!-- l. 1995 --><p class='indent'>   Dejamos al lector el ejercicio de ganar intuicion con ejemplos hasta que se
convensa de que tal como en el caso de la notacion decimal, el numero \(\#(\alpha )\) se expresa
como una suma de potencias de \(10\), con los coeficientes dados en funcion de los simbolos
de \(\alpha \). Mas concretamente si \(\alpha =s_{1}s_{2}...s_{k}\) con \(k\geq 1\) y \(s_{1},s_{2},...,s_{k}\in \widetilde{Num}\), entonces \[ \#(\alpha )=\#(s_{1}).10^{k-1}+\#(s_{2}).10^{k-2}+...+\#(s_{k}).10^{0} \] No daremos aqui una prueba de este
hecho ya que lo probaremos abajo para el caso general. Para ganar intuicion sobre el
mismo el lector puede ver mas abajo la prueba de las propiedades (S) e
(I), desde donde se ve con mas claridad como va aumentando la funcion \(\#\) a
medida que recorremos la lista de izquierda a derecha. Algunos ejemplos
</p><div class='eqnarray'>\begin{eqnarray*} \#(1d) &amp; = &amp; 1.10^{1}+10.10^{0}=10+10=20\\ \#(dd) &amp; = &amp; 10.10^{1}+10.10^{0}=100+10=110\\ \#(111) &amp; = &amp; 1.10^{2}+1.10^{1}+1.10^{0}=100+10+1=111\\ \#(1d3d) &amp; = &amp; 1.10^{3}+10.10^{2}+3.10^{1}+10.10^{0} \end{eqnarray*}
</div>
<!-- l. 2016 --><p class='indent'>   Ahora que sabemos que las palabras de \(\widetilde{Num}\) representan los numeros como suma de
potencias de diez, en forma analoga a la notacion decimal clasica, podemos refozar
aun mas la analogia poniendo nombres adecuados que, tal como en el caso clasico,
nos permitan leer las palabras de \(\widetilde{Num}\) describiendo su suma de potencias asociada. Por
ejemplo podriamos llamar ”decenta” al numero \(100\), por analogia a ”treinta”,
”cuarenta”,...,”noventa”. O sea una decenta es diez veces diez. De esta forma la
palabra \(d1\) se leera ”decenta y uno” y esto es natural ya que en la lista representa al
\(101\). La palabra \(dd\) se leera ”decenta y diez” y esto describe a la perfeccion el
numero que representa, i.e. el \(10.10+10=110\). La palabra que sigue en la lista a \(dd\) es \(111\) la cual
representa al \(111\), es decir aqui como en los otros casos vistos en los cuales no
hay ocurrencias del simbolo \(d\) la palabra representa al mismo numero que
representa en la notacion decimal clasica. Por dar otro ejemplo, la palabra \(59d3\)
se leera ”cinco mil novecientos decenta y tres” y representara al numero
\(6003\).
</p><!-- l. 2034 --><p class='indent'>   Para seguir debemos ponerle nombre a ”diez veces cien”, es decir, ”decientos”
(por analogia con ”novecientos = nueve veces cien”) denotara al numero \(1000=10.100\). De esta
forma la palabra \(d51\) se leera ”decientos cincuenta y uno” y esto es natural
ya que pensando un rato se puede ver que ella representa al \(1051\). Tambien,
la palabra \(ddd\) se leera ”decientos decenta y diez” y representara al numero
\(1110\).
</p><!-- l. 2045 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.12.1   </span> <a id='x1-460001.12.1'></a>Prueba de las propiedades (S) e (I)</h5>

<!-- l. 2047 --><p class='noindent'>Dado que el siguiente a un elemento \(\alpha \) de la lista es de la misma longitud que \(\alpha \) o tiene
longitud igual a \(\left \vert \alpha \right \vert +1\), podemos representar la lista anterior de la siguiente manera: \[ B_{0};B_{1};B_{2};B_{3};B_{4};... \] donde
cada \(B_{n}\) es, por definicion, la parte de la lista en la cual las palabras tienen longitud
exactamente \(n\). Por ejemplo:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-46001x1.12.1'>\(B_{0}\) es \(\varepsilon \)
     </li>
     <li class='enumerate' id='x1-46002x1.12.1'>\(B_{1}\) es \(1,2,3,4,5,6,7,8,9,d\)
     </li>
     <li class='enumerate' id='x1-46003x1.12.1'>\(B_{2}\) es \(11,12,...,1d,21,22,...,2d,...,91,92,...,9d,d1,d2,...,dd\)</li></ol>
<!-- l. 2060 --><p class='noindent'>Notese que hasta el momento nada nos asegura que no suceda que para algun \(n\) se de que \(B_{n}\)
sea una lista infinita, lo cual ademas nos diria que los bloques \(B_{n+1},B_{n+2},...\) son todos vacios. Es
decir podria pasar que la lista se estanque en una longitud \(n\) y nunca aparezca una
palabra de longitud mayor que \(n\). Esto por supuesto obligaria a que se repitan muchas
veces palabras de dicha longitud \(n\) ya que hay una cantidad finita de las mismas
(\(10^{n}\)).
</p><!-- l. 2068 --><p class='indent'>   Por supuesto nuestra intuicion nos dice que en el bloque \(B_{n}\) estan listadas sin
repeticion todas las palabras de \(\widetilde{Num}^{\ast }\) de longitud \(n\), pero debemos justificar esto con
argumentos solidos. Algunas propiedades basicas que se pueden probar facilmente
son:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-46004x1.12.1'>Si \(B_{n}=\alpha _{1},...,\alpha _{k}\), entonces \(\alpha _{1}=1^{n}\) y \(\alpha _{k}=d^{n}\)
     </li>
     <li class='enumerate' id='x1-46005x1.12.1'>Si \(d^{n}\) ocurre en \(B_{n}\) lo hace en la ultima posicion</li></ol>
<!-- l. 2077 --><p class='noindent'>estas propiedades son consecuencias inmediatas de como se calcula el elemento siguiente
a uno dado en la lista y son dejadas como ejercicio. Otra propiedad importante es la
siguiente
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-46006x1.12.1'>Si \(B_{n}=\alpha _{1},...,\alpha _{k}\), entonces \(B_{n+1}=1\alpha _{1},...,1\alpha _{k},2\alpha _{1},...,2\alpha _{k},...,d\alpha _{1},...,d\alpha _{k}\)</li></ol>
<!-- l. 2083 --><p class='noindent'>Para probar (3) es muy util el siguiente resultado obvio
</p>
   <div class='newtheorem'>
<!-- l. 2084 --><p class='noindent'><span class='head'>
<a id='x1-46007r10'></a>
<span class='cmbx-10'>Lema 10.</span>  </span><span class='cmti-10'>Sea</span> \(\sigma \in \widetilde{Num}\) <span class='cmti-10'>y supongamos</span> \(\alpha \in \widetilde{Num}^{\ast }\) <span class='cmti-10'>no es de la forma</span> \(d^{n}\)<span class='cmti-10'>. Entonces el siguiente a</span> \(\sigma \alpha \) <span class='cmti-10'>es</span> \(\sigma \beta \)
<span class='cmti-10'>donde</span> \(\beta \) <span class='cmti-10'>es el siguiente a</span> \(\alpha \)

</p>
   </div>
<!-- l. 2090 --><p class='indent'>   Dejamos como ejercicio al lector hacer la prueba de (3) usando el lema anterior y
las propiedades (1) y (2). Ahora es facil usando (3) probar inductivamente
que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-46008x1.12.1'>\(B_{n}\) es una lista sin repeticiones de todas las palabras de longitud \(n\)</li></ol>
<!-- l. 2097 --><p class='noindent'>Pero claramente de (4) se desprenden en forma obvia las propiedades (S) y
(I).
</p><!-- l. 2100 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.13   </span> <a id='x1-470001.13'></a>El caso general</h4>
<!-- l. 2102 --><p class='noindent'>Sea \(\Sigma \) un alfabeto no vacio y supongamos \(\leq \) es un orden total sobre \(\Sigma \). Supongamos que \(\Sigma =\{a_{1},...,a_{n}\}\),
con \(a_{1}&lt;a_{2}&lt;...&lt;a_{n}\). Inspirados en la lista dada anteriormente de las palabras de \(\widetilde{Num}^{\ast }\), podemos dar la
siguiente lista de palabras de \(\Sigma ^{\ast }\)
</p><!-- l. 2110 --><p class='indent'>   \({\small \varepsilon ,a}_{1}{\small ,a}_{2}{\small ,...,a}_{n}{\small ,}\)
</p><!-- l. 2112 --><p class='indent'>   \({\small a}_{1}{\small a}_{1}{\small ,a}_{1}{\small a}_{2}{\small ,...,a}_{1}{\small a}_{n}{\small ,a}_{2}{\small a}_{1}{\small ,a}_{2}{\small a}_{2}{\small ,...,a}_{2}{\small a}_{n}{\small ,...,a}_{n}{\small a}_{1}{\small ,a}_{n}{\small a}_{2}{\small ,...,a}_{n}{\small a}_{n}{\small ,}\)
</p><!-- l. 2114 --><p class='indent'>   \({\small a}_{1}{\small a}_{1}{\small a}_{1}{\small ,a}_{1}{\small a}_{1}{\small a}_{2}{\small ,...,a}_{1}{\small a}_{1}{\small a}_{n}{\small ,a}_{1}{\small a}_{2}{\small a}_{1}{\small ,a}_{1}{\small a}_{2}{\small a}_{2}{\small ,...,a}_{1}{\small a}_{2}{\small a}_{n}{\small ,...,a}_{1}{\small a}_{n}{\small a}_{1}{\small ,a}_{1}{\small a}_{n}{\small a}_{2}{\small ,a}_{1}{\small a}_{n}{\small a}_{n}{\small ,}\)
</p><!-- l. 2116 --><p class='indent'>   \({\small a}_{2}{\small a}_{1}{\small a}_{1}{\small ,a}_{2}{\small a}_{1}{\small a}_{2}{\small ,...,a}_{2}{\small a}_{1}{\small a}_{n}{\small ,a}_{2}{\small a}_{2}{\small a}_{1}{\small ,a}_{2}{\small a}_{2}{\small a}_{2}{\small ,...,a}_{2}{\small a}_{2}{\small a}_{n}{\small ,...,a}_{2}{\small a}_{n}{\small a}_{1}{\small ,a}_{2}{\small a}_{n}{\small a}_{2}{\small ,a}_{2}{\small a}_{n}{\small a}_{n}{\small ,}\)
</p><!-- l. 2118 --><p class='indent'>   \({\small \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\vdots \)
</p><!-- l. 2120 --><p class='indent'>   \({\small a}_{n}{\small a}_{1}{\small a}_{1}{\small ,a}_{n}{\small a}_{1}{\small a}_{2}{\small ,...,a}_{n}{\small a}_{1}{\small a}_{n}{\small ,a}_{n}{\small a}_{2}{\small a}_{1}{\small ,a}_{n}{\small a}_{2}{\small a}_{2}{\small ,...,a}_{n}{\small a}_{2}{\small a}_{n}{\small ,...,a}_{n}{\small a}_{n}{\small a}_{1}{\small ,a}_{n}{\small a}_{n}{\small a}_{2}{\small ,a}_{n}{\small a}_{n}{\small a}_{n}{\small ,}\)
</p><!-- l. 2122 --><p class='indent'>   \({\small a}_{1}{\small a}_{1}{\small a}_{1}{\small a}_{1}{\small ,a}_{1}{\small a}_{1}{\small a}_{1}{\small a}_{2}{\small ,...}\)
</p><!-- l. 2126 --><p class='noindent'>El objetivo es probar que la lista anterior enumera sin repeticiones todas las
palabras de \(\Sigma ^{\ast }\), i.e. produce naturalmente una biyeccion entre \(\omega \) y \(\Sigma ^{\ast }\). Pero antes
debemos definir mas formalmente la lista. Para esto definamos \(s^{\leq }:\Sigma ^{\ast }\rightarrow \Sigma ^{\ast }\) de la siguiente
manera
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-47001x1.13'>\(s^{\leq }((a_{n})^{m})=(a_{1})^{m+1}\), para cada \(m\geq 0\)
     </li>
     <li class='enumerate' id='x1-47002x1.13'>\(s^{\leq }(\alpha a_{i}(a_{n})^{m})=\alpha a_{i+1}(a_{1})^{m}\), cada vez que \(\alpha \in \Sigma ^{\ast }\), \(1\leq i&lt;n\) y \(m\geq 0\)</li></ol>
<!-- l. 2137 --><p class='noindent'>Notese que la definicion de \(s^{\leq }\) es correcta ya que una palabra de \(\Sigma ^{\ast }\) ya sea es de la forma \((a_{n})^{m}\),
con \(m\geq 0\), o es de la forma \(\alpha a_{i}(a_{n})^{m}\), con \(\alpha \in \Sigma ^{\ast }\), \(1\leq i&lt;n\) y \(m\geq 0\); y estos dos casos posibles son mutuamente
excluyentes.
</p><!-- l. 2143 --><p class='indent'>   Claramente se tiene entonces que la lista anterior puede ser escrita de la siguiente
manera \[ \varepsilon ,s^{\leq }(\varepsilon ),s^{\leq }(s^{\leq }(\varepsilon )),s^{\leq }(s^{\leq }(s^{\leq }(\varepsilon ))),s^{\leq }(s^{\leq }(s^{\leq }(s^{\leq }(\varepsilon )))),... \] Con esta definicion formal de la lista, podemos probar de la misma forma en
la que lo hicimos arriba que:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-47003x1.13'>Toda palabra de \(\Sigma ^{\ast }\) aparece en la lista

     </li>
     <li class='enumerate' id='x1-47004x1.13'>Ninguna palabra de \(\Sigma ^{\ast }\) aparese mas de una ves en la lista</li></ol>
<!-- l. 2155 --><p class='noindent'>(dejamos al lector los detalles por tratarse de un argumento completamente
similar).
</p><!-- l. 2158 --><p class='indent'>   Definamos \(\ast ^{\leq }:\omega \rightarrow \Sigma ^{\ast }\) recursivamente de la siguiente manera:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-47005x1.13'>\(\ast ^{\leq }(0)=\varepsilon \)
     </li>
     <li class='enumerate' id='x1-47006x1.13'>\(\ast ^{\leq }(i+1)=s^{\leq }(\ast ^{\leq }(i))\)</li></ol>
<!-- l. 2164 --><p class='noindent'>Es claro que entonces \(\ast ^{\leq }(i)\) nos da el \((i+1)\)-esimo elemento de la lista, o lo que es lo mismo, el
\(i\)-esimo elemento de la lista contando desde el \(0\). O sea que las propiedades (S) y (I) nos
garantizan que la funcion \(\ast ^{\leq }\) es biyectiva. A continuacion describiremos su inversa.
Primero un lema facil pero muy importante.
</p>
   <div class='newtheorem'>
<!-- l. 2170 --><p class='noindent'><span class='head'>
<a id='x1-47007r11'></a>
<span class='cmbx-10'>Lema 11.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto no vacio y supongamos</span> \(\leq \) <span class='cmti-10'>es un orden total sobre</span> \(\Sigma \)<span class='cmti-10'>.
</span><span class='cmti-10'>Supongamos que</span> \(\Sigma =\{a_{1},...,a_{n}\}\)<span class='cmti-10'>, con</span> \(a_{1}&lt;a_{2}&lt;...&lt;a_{n}\)<span class='cmti-10'>. Entonces para cada</span> \(\alpha \in \Sigma ^{\ast }-\{\varepsilon \}\) <span class='cmti-10'>hay unicos</span> \(k\in \omega \) <span class='cmti-10'>y</span> \(i_{0},i_{1},...,i_{k}\in \{1,...,n\}\) <span class='cmti-10'>tales que </span>\[ \alpha =a_{i_{k}}...a_{i_{0}} \]
</p>
   </div>
<!-- l. 2183 --><p class='indent'>   Notar que \(k\) del lema anterior es \(\left \vert \alpha \right \vert -1\) y los numeros \(i_{k},...,i_{0}\) van dando el numero de orden de
cada simbolo de \(\alpha \) yendo de izquierda a derecha. Por ejemplo si \(\Sigma =\{\%,!,@\}\) y \(\leq \) es el orden total
sobre \(\Sigma \) dado por \(\%&lt;!&lt;@\) (es decir que aqui \(a_{1}=\%\), \(a_{2}=!\) y \(a_{3}=@\)) entonces para la palabra \(!\%@\%@\) tenemos \(k=4\) y \(i_{4}=2\), \(i_{3}=1\), \(i_{2}=3\), \(i_{1}=1\) y \(i_{0}=3\).
Sin envargo si hubieramos tomado el orden dado por \(@&lt;\%&lt;!\), para la misma palabra
hubieramos tenido \(i_{4}=3\), \(i_{3}=2\), \(i_{2}=1\), \(i_{1}=2\) y \(i_{0}=1\).
</p><!-- l. 2193 --><p class='indent'>   Ahora podemos definir la funcion \(\#^{\leq }\) de la siguiente manera \[ \begin{array}[t]{rll} \#^{\leq }:\Sigma ^{\ast } &amp; \rightarrow &amp; \omega \\ \varepsilon &amp; \rightarrow &amp; 0\\ a_{i_{k}}...a_{i_{0}} &amp; \rightarrow &amp; i_{k}n^{k}+...+i_{0}n^{0} \end{array} \]
</p>
   <div class='newtheorem'>
<!-- l. 2202 --><p class='noindent'><span class='head'>
<a id='x1-47008r12'></a>
<span class='cmbx-10'>Lema 12.</span>  </span><span class='cmti-10'>La funcion</span> \(\#^{\leq }\) <span class='cmti-10'>es la inversa de</span> \(\ast ^{\leq }\)
</p>
   </div>
<!-- l. 2207 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 2208 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Primero probaremos por induccion en \(x\) que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-47009x1.13'>Para cada \(x\in \omega \), se tiene que \(\#^{\leq }(\ast ^{\leq }(x))=x\)</li></ol>
<!-- l. 2212 --><p class='noindent'>El caso \(x=0\) es trivial. Supongamos que \(\#^{\leq }(\ast ^{\leq }(x))=x\), veremos entonces que \(\#^{\leq }(\ast ^{\leq }(x+1))=x+1\). Sean \(k\geq 0\) y \(i_{k},...,i_{0}\) tales que \(\ast ^{\leq }(x)=a_{i_{k}}...a_{i_{0}}\). Ya que \(\#^{\leq }(\ast ^{\leq }(x))=x\)
tenemos que \(x=i_{k}n^{k}+...+i_{0}n^{0}\). Hay varios casos.
</p><!-- l. 2218 --><p class='noindent'>Caso \(i_{0}&lt;n\). Entonces \(\ast ^{\leq }(x+1)=s^{\leq }(\ast ^{\leq }(x))=a_{i_{k}}...a_{i_{0}+1}\) por lo cual \[ \begin{array}{ll} \#^{\leq }(\ast ^{\leq }(x+1)) &amp; =i_{k}n^{k}+i_{k-1}n^{k-1}+...+(i_{0}+1)n^{0}\\ &amp; =\left (i_{k}n^{k}+i_{k-1}n^{k-1}+...+i_{0}n^{0}\right )+1\\ &amp; =x+1 \end{array} \] Caso \(i_{k}=i_{k-1}=...=i_{0}=n\). Entonces \(\ast ^{\leq }(x+1)=s^{\leq }(\ast ^{\leq }(x))=(a_{1})^{k+2}\) por lo cual \[ \begin{array}{ll} \#^{\leq }(\ast ^{\leq }(x+1)) &amp; =1n^{k+1}+1n^{k}+...+1n^{1}+1n^{0}\\ &amp; =\left (nn^{k}+nn^{k-1}+...+nn^{0}\right )+1\\ &amp; =x+1 \end{array} \] Caso \(i_{0}=i_{1}=...=i_{h}=n\), \(\;i_{h+1}\not =n\),  para algun \(0\leq h&lt;k\).
Entonces \(\ast ^{\leq }(x+1)=s^{\leq }(\ast ^{\leq }(x))=a_{i_{k}}...a_{i_{h+2}}a_{i_{h+1}+1}(a_{1})^{h}\) por lo cual \[ \begin{array}{ll} \#^{\leq }(\ast ^{\leq }(x+1)) &amp; =i_{k}n^{k}+...+i_{h+2}n^{h+2}+(i_{h+1}+1)n^{h+1}+1n^{h}+...+1n^{1}+1n^{0}\\ &amp; =\left (i_{k}n^{k}+...+i_{h+2}n^{h+2}+i_{h+1}n^{h+1}+n^{h+1}+n^{h}+...+n^{1}\right )+1\\ &amp; =\left (i_{k}n^{k}+...+i_{h+2}n^{h+2}+i_{h+1}n^{h+1}+nn^{h}+...+nn^{0}\right )+1\\ &amp; =x+1 \end{array} \] De esta forma hemos probado (a).
</p><!-- l. 2249 --><p class='indent'>   Por definicion la inversa de \(\ast ^{\leq }\) es la funcion con dominio \(\Sigma ^{\ast }\) que a una palabra \(\alpha \) le
asocia el unico \(x\in \omega \) tal que \(\ast ^{\leq }(x)=\alpha \). Es decir debemos probar que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-47010x1.13'>\(\#^{\leq }(\alpha )=\) unico \(x\in \omega \) tal que \(\ast ^{\leq }(x)=\alpha \), para cada \(\alpha \in \Sigma ^{\ast }\)</li></ol>
<!-- l. 2256 --><p class='noindent'>Pero (b) es una concecuencia inmediata de (a).                                             □
</p>
   </div>
<!-- l. 2260 --><p class='indent'>   Cabe destacar que dada una palabra \(\alpha \), el numero \(\#^{\leq }(\alpha )\) nos dice en que posicion se
hubica \(\alpha \) en la lista, es decir \(\alpha \) es la (\(\#^{\leq }(\alpha )+1\))-esima palabra de la lista.
</p><!-- l. 2264 --><p class='indent'>   De los desarrollos hechos se desprende el interesante resultado. Dejamos al lector
la prueba como ejercicio.
</p>
   <div class='newtheorem'>
<!-- l. 2266 --><p class='noindent'><span class='head'>
<a id='x1-47011r13'></a>
<span class='cmbx-10'>Lema 13.</span>  </span><span class='cmti-10'>Sea</span> \(n\geq 1\) <span class='cmti-10'>fijo. Entonces cada</span> \(x\geq 1\) <span class='cmti-10'>se escribe en forma unica de la siguiente
</span><span class='cmti-10'>manera: </span>\[ x=i_{k}n^{k}+i_{k-1}n^{k-1}+...+i_{0}n^{0}, \] <span class='cmti-10'>con</span> \(k\geq 0\) <span class='cmti-10'>y</span> \(1\leq i_{k},i_{k-1},...,i_{0}\leq n\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 2277 --><p class='indent'>   Como hemos visto las biyecciones dadas producen una ”identificacion” entre
numeros de \(\omega \) y palabras del alfabeto \(\Sigma \). Es decir, en algun sentido identificamos
palabras y numeros ya que se corresponden biunivocamente. Supongamos que \(\alpha \) es una
palabra de \(\Sigma ^{\ast }-\{\varepsilon \}\) y queremos ”verla como un numero”. Entonces en ves de ver sus simbolos
vemos los ordenes de aparicion en \(\Sigma \) de los mismos y miramos la suma de potencias
asociada.
</p><!-- l. 2285 --><p class='indent'>   Supongamos ahora que \(x\) es un numero de \(\omega -\{0\}\) y ademas supongamos que
somos super inteligentes y que cuando vemos a \(x\) vemos la secuencia unica de
numeros \(i_{k},i_{k-1},...,i_{0}\) que nos permite expresarlo como suma de potencias segun el lema
anterior. Entonces si queremos ver a \(x\) como una palabra simplemente miramos
la secuencia \(i_{k},i_{k-1},...,i_{0}\) como palabra, reemplazando cada \(i_{j}\) por el simbolo \(i_{j}\)-esimo de
\(\Sigma \).

</p><!-- l. 2294 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.13.1   </span> <a id='x1-480001.13.1'></a>Caracter recursivo de las funciones \(s^{\protect \leq }\), \(\ast ^{\protect \leq }\) y \(\#^{\protect \leq }\)</h5>
<!-- l. 2296 --><p class='noindent'>Es un ejercicio (dejado al lector) probar que cualquiera sea \(\alpha \in \Sigma ^{\ast }\), se tiene que
</p><div class='eqnarray'>\begin{eqnarray*} s^{\leq }(\varepsilon ) &amp; = &amp; a_{1}\\ s^{\leq }(\alpha a_{i}) &amp; = &amp; \alpha a_{i+1}\text{, }i&lt;n\\ s^{\leq }(\alpha a_{n}) &amp; = &amp; s^{\leq }(\alpha )a_{1} \end{eqnarray*}
</div>Notese que esto nos permite calcular recursivamente el valor de \(s^{\leq }\) ya que las ecuaciones
anteriores nos muestran como obtener rapidamente \(s^{\leq }(\alpha a)\) en terminos de \(s^{\leq }(\alpha )\) y \(a\), donde \(a\) es
un elemento cualquiera de \(\Sigma \). Por supuesto, en algun momento deberemos
usar el dato inicial \(s^{\leq }(\varepsilon )=a_{1}\). En un lenguaje de programacion funcional, las tres
ecuaciones anteriores son directamente un programa para computar \(s^{\leq }\) o si se
quiere una definicion de dicha funcion. Dejamos al lector que intente usar
las ecuaciones anteriores para dar un programa imperativo que compute \(s^{\leq }\)
(esto esta hecho mas adelante en la primera lista de funciones \(\Sigma \)-efectivamente
computables).
<!-- l. 2315 --><p class='indent'>   Lo mismo sucede con la funcion \(\ast ^{\leq }\) la cual fue directamente definida en forma
recursiva por las ecuaciones </p><div class='eqnarray'>\begin{eqnarray*} \ast ^{\leq }(0) &amp; = &amp; \varepsilon \\ \ast ^{\leq }(i+1) &amp; = &amp; s^{\leq }(\ast ^{\leq }(i)) \end{eqnarray*}
</div>Dejamos al lector corroborar que la funcion \(\#^{\leq }\) verifica las siguientes ecuaciones,
las cuales obviamente pueden ser usadas para calcular recursivamente sus
valores
   <div class='eqnarray'>\begin{eqnarray*} \#^{\leq }(\varepsilon ) &amp; = &amp; 0\\ \#^{\leq }(\alpha a_{i}) &amp; = &amp; \#^{\leq }(\alpha ).n+i \end{eqnarray*}
</div>
<!-- l. 2333 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>1.13.2   </span> <a id='x1-490001.13.2'></a>Extension del orden total de \(\Sigma \) a \(\Sigma ^{\ast }\)</h5>
<!-- l. 2335 --><p class='noindent'>Podemos extender el orden de \(\Sigma \) a \(\Sigma ^{\ast }\) de la siguiente manera
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-49001x1.13.2'>\(\alpha \leq \beta \) sii \(\#^{\leq }(\alpha )\leq \#^{\leq }(\beta )\)</li></ol>
<!-- l. 2340 --><p class='noindent'>Es decir \(\alpha \leq \beta \) sii \(\alpha =\beta \) o \(\alpha \) ocurre antes que \(\beta \) en la lista. Dejamos como ejercicio para el lector probar
que \(\leq \) es un orden total sobre \(\Sigma ^{\ast }\).
</p><!-- l. 2346 --><p class='indent'>   Deberia ser intuitivamente claro que el orden recien definido sobre \(\Sigma ^{\ast }\) posee las
mismas propiedades matematicas que el orden usual de \(\omega \). Esto se entendera en forma
mas profunda cuando veamos el concepto de isomorfismo de posets en los capitulos
de logica. Veamos un ejemplo:
</p>
   <div class='newtheorem'>
<!-- l. 2351 --><p class='noindent'><span class='head'>
<a id='x1-49002r14'></a>
<span class='cmbx-10'>Lema 14.</span>  </span><span class='cmti-10'>Si</span> \(S\subseteq \Sigma ^{\ast }\) <span class='cmti-10'>es no vacio, entonces existe</span> \(\alpha \in S\) <span class='cmti-10'>tal que</span> \(\alpha \leq \beta \)<span class='cmti-10'>, para cada</span> \(\beta \in S\)<span class='cmti-10'>.</span>

</p>
   </div>
<!-- l. 2356 --><p class='indent'>   @@finpagina@@
</p><!-- l. 2358 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>1.14   </span> <a id='x1-500001.14'></a>Codificacion de infinituplas de numeros</h4>
<!-- l. 2360 --><p class='noindent'>Usaremos \(\omega ^{\mathbf{N}}\) para denotar el conjunto de todas las infinituplas con coordenadas en \(\omega \). Es
decir \[ \omega ^{\mathbf{N}}=\left \{ (s_{1},s_{2},...):s_{i}\in \omega \text{, para cada }i\geq 1\right \} \text{.} \] Definamos el siguiente subconjunto de \(\omega ^{\mathbf{N}}\) \[ \omega ^{\left [\mathbf{N}\right ]}=\left \{ (s_{1},s_{2},...)\in \omega ^{\mathbf{N}}:\text{ hay un }n\in \mathbf{N}\text{ tal que }s_{i}=0,\text{para }i\geq n\right \} \text{.} \] Notese que \(\omega ^{\mathbf{N}}\neq \omega ^{\left [\mathbf{N}\right ]}\), por ejemplo las
infinituplas
</p>
   <div class='eqnarray'>\begin{eqnarray*} &amp; &amp; (10,20,30,40,50,...)\\ &amp; &amp; (1,0,1,0,1,0,1,0,...) \end{eqnarray*}
</div>no pertenecen a \(\omega ^{\left [\mathbf{N}\right ]}\). Notese que \((s_{1},s_{2},...)\in \omega ^{\left [\mathbf{N}\right ]}\) si y solo si solo una cantidad finita de coordenadas de \((s_{1},s_{2},...)\)
son no nulas (i.e. \(\{i:s_{i}\neq 0\}\) es finito).
<!-- l. 2380 --><p class='indent'>   Definamos \[ \begin{array}{rll} pr:\mathbf{N} &amp; \rightarrow &amp; \omega \\ n &amp; \rightarrow &amp; n\text{-esimo numero primo} \end{array} \] Nótese que \(pr(1)=2\), \(pr(2)=3\), \(pr(3)=5\), etc.
</p><!-- l. 2389 --><p class='indent'>   Es bien conocido que todo numero natural es expresable como producto de
primos. Por ejemplo si tomamos \(x=57596\) tenemos que \(x=2.2.7.11.11.17\). Tambien es un hecho conocido que
dicha representacion en producto de primos es unica, si escribimos a los factores
primos de menor a mayor, tal como lo hicimos recien con el numero \(57596\). El Teorema
Fundamental de la Aritmetica justamente acevera esta propiedad de factorisacion
unica de todo numero natural. Trataremos de escribir este teorema de una forma un
poco mas ”cheta”.
</p><!-- l. 2398 --><p class='indent'>   Ya que \(57596=2.2.7.11.11.17\), podemos escribir \[ 57596=pr(1)^{2}.pr(4)^{1}.pr(5)^{2}.pr(7)^{1} \] Notese que ahora cada primo que interviene en la
factorizacion de \(57596\) figura con un exponente que nos dice cuantas veces ocurre en dicha
factorizacion. Hay muchos primos que no ocurren en esta factorizacion, es decir
ocurren \(0\) veces en la misma. Pero podemos escribir \[ 57596=pr(1)^{2}.pr(2)^{0}.pr(3)^{0}.pr(4)^{1}.pr(5)^{2}.pr(6)^{0}.pr(7)^{1}.pr(8)^{0}.pr(9)^{0}.pr(10)^{0}.... \] y la igualdad no se altera ya
que agregamos factores iguales a \(1\) (una cantidad infinita!). De esta manera
cada primo interviene en la factorizacion. Ademas si vemos la infinitupla
de exponentes de dicha factorizacion, es decir \[ (2,0,0,1,2,0,1,0,0,0,...) \] obtenemos un elemento de
\(\omega ^{[\mathbf{N}]}\).
</p><!-- l. 2418 --><p class='indent'>   Por supuesto esto lo podemos hacer con cualquier numero natural y siempre la
infinitupla de exponentes sera un elemento de \(\omega ^{[\mathbf{N}]}\). Ademas es facil notar que estas
representaciones ”chetas” tambien resultan unicas.
</p><!-- l. 2423 --><p class='indent'>   Para probar nuestra version del Teorema Fundamental de la Aritmetica
necesitaremos el siguiente lema el cual aceptaremos sin demostracion.
</p>
   <div class='newtheorem'>
<!-- l. 2428 --><p class='noindent'><span class='head'>
<a id='x1-50001r15'></a>
<span class='cmbx-10'>Lema 15.</span>  </span><span class='cmti-10'>Si</span> \(p,p_{1},...,p_{n}\) <span class='cmti-10'>son numeros primos y</span> \(p\) <span class='cmti-10'>divide a</span> \(p_{1}.....p_{n}\)<span class='cmti-10'>, entonces</span> \(p=p_{i}\)<span class='cmti-10'>, para algun</span> \(i\)<span class='cmti-10'>.</span>

</p>
   </div>
   <div class='newtheorem'>
<!-- l. 2435 --><p class='noindent'><span class='head'>
<a id='x1-50002r16'></a>
<span class='cmbx-10'>Teorema 16.</span>  </span><span class='cmti-10'>Para cada</span> \(x\in \mathbf{N}\)<span class='cmti-10'>, hay una unica infinitupla</span> \((s_{1},s_{2},...)\in \omega ^{\left [\mathbf{N}\right ]}\) <span class='cmti-10'>tal que </span>\[ x=\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}} \] <span class='cmti-10'>(Tiene sentido
</span><span class='cmti-10'>escribir</span> \(\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}}\)<span class='cmti-10'>, ya que en esta productoria solo una cantidad finita de factores son no
</span><span class='cmti-10'>iguales a</span> \(1\)<span class='cmti-10'>.)</span>
</p>
   </div>
<!-- l. 2446 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 2447 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Primero probaremos la existencia por induccion en \(x\). Claramente \(1=\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{0}\), con
lo cual tomando \((s_{1},s_{2},...)=(0,0,0,...)\) el caso \(x=1\) esta probado. Fijemos ahora un \(x&gt;1\) y supongamos la
existencia vale para cada \(y\) menor que \(x\). Veremos que entonces vale para \(x\). Si \(x\) es
primo, entonces \(x=pr(i_{0})\) para algun \(i_{0}\) por lo cual tenemos que \(x=\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}}\), tomando \(s_{i}=0\) si \(i\neq i_{0}\) y \(s_{i_{0}}=1\). Si \(x\) no
es primo, entonces \(x=y_{1}.y_{2}\), con \(y_{1},y_{2}&lt;x\). Por hipotesis inductiva tenemos que hay \((s_{1},s_{2},...),(t_{1},t_{2},...)\in \omega ^{\left [\mathbf{N}\right ]}\) tales que \(y_{1}=\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}}\) y
\(y_{2}=\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{t_{i}}\). Tenemos entonces que \(x=\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}+t_{i}}\) lo cual concluye la prueba de la existencia.
</p><!-- l. 2461 --><p class='indent'>   Veamos ahora la unicidad. Suponganos que las infinituplas \((s_{1},s_{2},...),(t_{1},t_{2},...)\in \omega ^{\left [\mathbf{N}\right ]}\) son tales que \[ \underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}}=\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{t_{i}} \] y
ademas \(s_{i}\neq t_{i}\) para algun \(i\). Si \(s_{i}&gt;t_{i}\) entonces dividiendo ambos miembros por \(pr(i)^{t_{i}}\) obtenemos
que \(pr(i)\) divide a un producto de primos todos distintos de el, lo cual es absurdo
por el lema anterior. Analogamente llegamos a un absurdo si suponemos que \(t_{i}&gt;s_{i}\),
lo cual nos dice que vale la unicidad.                                                      □
</p>
   </div>
<!-- l. 2474 --><p class='indent'>   Como podra notarse la existencia en el teorema anterior es facil e intuitivamente
clara de probar. En realidad la potencia del Teorema Fundamental de la Aritmética
radica en el hecho de que dicha factorizacion es unica.
</p><!-- l. 2479 --><p class='indent'>   A continuacion un poco de notacion. Dada una infinitupla \((s_{1},s_{2},...)\in \omega ^{\left [\mathbf{N}\right ]}\) usaremos \(\left \langle s_{1},s_{2},...\right \rangle \) para
denotar al numero \(\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}}\). Dado \(x\in \mathbf{N}\), usaremos \((x)\) para denotar a la unica infinitupla \((s_{1},s_{2},...)\in \omega ^{\left [\mathbf{N}\right ]}\) tal que \[ x=\left \langle s_{1},s_{2},...\right \rangle =\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}} \]
Ademas para \(i\in \mathbf{N}\), usaremos \((x)_{i}\) para denotar a \(s_{i}\) de dicha unica infinitupla. Es decir
que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-50003x1.14'>\((x)=((x)_{1},(x)_{2},...)\)

     </li>
     <li class='enumerate' id='x1-50004x1.14'>\((x)_{i}\) es el exponente de \(pr(i)\) en la (unica posible) factorizacion de \(x\) como producto
     de primos</li></ol>
<!-- l. 2496 --><p class='indent'>   Claramente entonces
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-50005x1.14'>\(\left \langle (x)_{1},(x)_{2},...\right \rangle =x\), para cada \(x\in \mathbf{N}\)
     </li>
     <li class='enumerate' id='x1-50006x1.14'>Para cada \((s_{1},s_{2},...)\in \omega ^{\left [\mathbf{N}\right ]}\), se tiene que \[ (\left \langle s_{1},s_{2},...\right \rangle )_{i}=s_{i}\text{, para }i\in \mathbf{N} \] Es decir que \[ (\left \langle s_{1},s_{2},...\right \rangle )=(s_{1},s_{2},...) \]</li></ol>
<!-- l. 2511 --><p class='indent'>   (Justifique con palabras las propiedades (3) y (4)). Tenemos entonces el siguiente
resultado fundamental
</p>
   <div class='newtheorem'>
<!-- l. 2513 --><p class='noindent'><span class='head'>
<a id='x1-50007r17'></a>
<span class='cmbx-10'>Teorema 17.</span>  </span><span class='cmti-10'>Las funciones </span>\[ \begin{array}{lll} \mathbf{N} &amp; \rightarrow &amp; \omega ^{\left [\mathbf{N}\right ]}\\ x &amp; \rightarrow &amp; (x)=((x)_{1},(x)_{2},...) \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rll} \omega ^{\left [\mathbf{N}\right ]} &amp; \rightarrow &amp; \mathbf{N}\\ (s_{1},s_{2},...) &amp; \rightarrow &amp; \left \langle s_{1},s_{2},...\right \rangle \end{array} \] <span class='cmti-10'>son biyecciones una inversa de la otra.</span>
</p>
   </div>
<!-- l. 2527 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 2528 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Llamemos \(f\) a la funcion de la izquierda y \(g\) a la de la derecha. Notese que
el Lema <a href='#x1-12001r2'>2<!-- tex4ht:ref: mutuamente inversas  --></a> nos dice que basta con probar que \(f\circ g=Id_{\omega ^{\left [\mathbf{N}\right ]}}\) y \(g\circ f=Id_{\mathbf{N}}\). Pero (3) justamente nos dice
que \(g\circ f=Id_{\mathbf{N}}\) y (4) nos dice que \(f\circ g=Id_{\omega ^{\left [\mathbf{N}\right ]}}\).                                                                      □
</p>
   </div>
<!-- l. 2536 --><p class='indent'>   Tal como se hace en la escuela primaria, el siguiente lema nos permite calcular
\((x)_{i}\).
</p>
   <div class='newtheorem'>
<!-- l. 2538 --><p class='noindent'><span class='head'>
<a id='x1-50008r18'></a>
<span class='cmbx-10'>Lema 18.</span>  </span><span class='cmti-10'>Dados</span> \(x,i\in \mathbf{N}\)<span class='cmti-10'>, se tiene que </span>\[ (x)_{i}=\max _{t}\left (pr(i)^{t}\text{ divide a }x\right ) \]

</p>
   </div>
<!-- l. 2545 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 2546 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ejercicio (aplique el Lema <a href='#x1-50001r15'>15<!-- tex4ht:ref: primos  --></a>).                                                    □
</p>
   </div>
<!-- l. 2550 --><p class='indent'>   Definamos la funcion \(Lt:\mathbf{N}\rightarrow \omega \) de la siguiente manera: \[ Lt(x)=\left \{ \begin{array}{lll} \max _{i}\;(x)_{i}\neq 0 &amp; &amp; \text{si }x\neq 1\\ 0 &amp; &amp; \text{si }x=1 \end{array}\right . \] Se tienen las siguientes propiedades
basicas
</p>
   <div class='newtheorem'>
<!-- l. 2559 --><p class='noindent'><span class='head'>
<a id='x1-50009r19'></a>
<span class='cmbx-10'>Lema 19.</span>  </span><span class='cmti-10'>Para cada</span> \(x\in \mathbf{N}\)<span class='cmti-10'>:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-50011x1'>\(Lt(x)=0\) <span class='cmti-10'>sii</span> \(x=1\)
     </li>
     <li class='enumerate' id='x1-50013x2'>\(x=\prod \nolimits _{i=1}^{Lt(x)}pr(i)^{(x)_{i}}\)</li></ol>
   </div>
<!-- l. 2570 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>2   </span> <a id='x1-510002'></a>Procedimientos efectivos</h3>
<!-- l. 2572 --><p class='noindent'>Un concepto importante en ciencias de la computacion es el de <span class='cmti-10'>procedimiento </span>o
<span class='cmti-10'>metodo </span>para realizar alguna tarea determinada. Nos interesan los procedimientos que
estan definidos en forma precisa e inambigua, es decir aquellos en los cuales en cada
paso a seguir, la tarea a realizar esta objetivamente descripta. Ademas siempre
supondremos que el interprete o ejecutante es una persona.
</p><!-- l. 2579 --><p class='indent'>   Una caracteristica de los procedimientos que surgen en la tarea cientifica es que
hay un <span class='cmti-10'>conjunto de datos de entrada</span>, es decir, el conjunto de objetos a partir de
los cuales puede comenzar a realizarse el procedimiento. Tambien en los
procedimientos que surgen en la tarea cientifica tenemos un <span class='cmti-10'>conjunto de datos de

</span><span class='cmti-10'>salida</span>, es decir el conjunto de todos los datos que el procedimiento dara como
salida en alguna de las posibles ejecuciones al variar los datos de entrada
posibles.
</p><!-- l. 2588 --><p class='indent'>   Una propiedad importante de los procedimientos es la propiedad de detencion. Si \(\mathbb{P}\)
es un procedimiento y \(d\) es un dato de entrada de \(\mathbb{P}\), entonces diremos que \(\mathbb{P}\)<span class='cmti-10'> se detiene
</span><span class='cmti-10'>partiendo de</span> \(d\) si en algun momento de la ejecucion de \(\mathbb{P}\) partiendo de \(d\), el ejecutante
concluye una tarea encomendada por \(\mathbb{P}\) y no hay una nueva tarea requerida por \(\mathbb{P}\) al
ejecutante. Puede pasar que para ciertos datos de entrada el procedimiento no se
detenga nunca, es decir puede suceder que a medida que se vayan realizando las
instrucciones o tareas, siempre el procedimiento direccione a realizar otra tarea
especifica y asi sucesivamente.
</p><!-- l. 2600 --><p class='indent'>   Cabe destacar que en la gerga computacional a veces se dice ”el procedimiento
termina” y en realidad a lo que nos referimos es a que termina de realizar la tarea
especifica para la cual fue diseñado e inmediatamente se detiene ya que no
encomienda mas tareas para hacer. Es decir, en algun sentido terminar es mas fuerte
que detenerse ya que el concepto de detencion no presupone la terminacion
de ninguna tarea especifica, simplemente se refiere a que el procedimiento
llega a un punto en el que no direcciona a ninguna tarea al ejecutante. De
todas maneras muchas veces se usara el verbo terminar como sinonimo de
detenerse.
</p><!-- l. 2610 --><p class='indent'>   Los procedimientos tambien deben ser repetibles, en el sentido de que si
realizamos un procedimiento dos veces con el mismo dato de entrada, entonces ambas
ejecuciones deben ser identicas, es decir se ralizaran las mismas tareas y en el mismo
orden.
</p><!-- l. 2615 --><p class='indent'>   Otro aspecto muy importante a considerar es que un procedimiento puede tener
pasos a seguir los cuales sean realizables solo en un sentido puramente teorico. Por
ejemplo, un procedimiento puede tener una instruccion como la que se muestra a
continuacion:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-51001x2'>si el polinomio \(ax^{5}+bx^{4}+421\) tiene una raiz racional, entonces realizar la tarea descripta
     en A, en caso contrario realizar la tarea descripta en B</li></ol>
<!-- l. 2624 --><p class='noindent'>(\(a,b\) son datos calculados previamente). Como puede notarse mas alla de este aspecto
teorico de la instruccion, su descripcion es clara y objetiva, pero en principio no es
claro que se pueda ejecutar dicha instruccion en un sentido efectivo a los fines de
seguir realizando las siguientes instrucciones. Un procedimiento sera llamado <span class='cmti-10'>efectivo</span>
cuando cada paso del mismo sea simple y facil de realizar en forma efectiva por
cualquier persona.
</p><!-- l. 2632 --><p class='indent'>   En general los procedimientos efectivos que nos interesan son en los que el
interprete o ejecutante trabaja solo con papel y lapiz. Ademas el conjunto de datos
de entrada siempre estara determinado a priori como parte de la descripcion del
procedimiento. Cabe destacar que puede ser muy dificil o imposible, en general,
conocer con precision el conjunto de datos de salida de un procedimiento (esto lo
justificaremos mas adelante).
</p><!-- l. 2640 --><p class='indent'>   Tambien supondremos que los elementos de \(\omega \) que intervienen en los datos de
entrada y de salida estaran representados por palabras de \(Num\) usando la notacion

decimal.
</p><!-- l. 2644 --><p class='indent'>   Quisas el procedimiento efectivo mas famoso de la matematica es aquel que se
enseña en los colegios para sumar dos numeros naturales expresados en notacion
decimal. Notar que el conjunto de datos de entrada de dicho procedimiento es \(\omega ^{2}\) y el
conjunto de datos de salida es el conjunto formado por todas las sumas posibles de
pares de elementos de \(\omega \), es decir \(\omega \). Por supuesto este procedimiento solo usa
lapiz, papel y pasos extremadamente simples a seguir en cada momento
de la computacion, es decir, en algun sentido, no es necesario ”entender
que es lo que se esta haciendo” para llegar al final y obtener la palabra que
representa en notacion decimal a la suma de los numeros iniciales. Dejamos al
lector repasar este procedimiento asi como el que calcula dado un numero
\(x\) no nulo de \(\omega \), al numero \(x-1\), los cuales nos haran falta mas adelante en los
ejemplos.
</p><!-- l. 2661 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.1   </span> <a id='x1-520002.1'></a>Funciones \(\Sigma \)-efectivamente computables</h4>
<!-- l. 2663 --><p class='noindent'>Una funcion \(\Sigma \)-mixta \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) sera llamada \(\Sigma \)<span class='cmti-10'>-efectivamente computable </span>si hay un procedimiento
efectivo \(\mathbb{P}\) tal que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-52001x2.1'>El conjunto de datos de entrada de \(\mathbb{P}\) es \(\omega ^{n}\times \Sigma ^{\ast m}\)
     </li>
     <li class='enumerate' id='x1-52002x2.1'>El conjunto de datos de salida esta contenido en \(\omega \).
     </li>
     <li class='enumerate' id='x1-52003x2.1'>Si \((\vec{x},\vec{\alpha })\in D_{f}\), entonces \(\mathbb{P}\) se detiene partiendo de \((\vec{x},\vec{\alpha })\), dando como dato de salida \(f(\vec{x},\vec{\alpha })\).
     </li>
     <li class='enumerate' id='x1-52004x2.1'>Si \((\vec{x},\vec{\alpha })\in (\omega ^{n}\times \Sigma ^{\ast m})-D_{f}\), entonces \(\mathbb{P}\) no se detiene partiendo desde \((\vec{x},\vec{\alpha })\)</li></ol>
<!-- l. 2675 --><p class='noindent'>Analogamente una funcion \(\Sigma \)-mixta \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \Sigma ^{\ast }\) sera llamada \(\Sigma \)<span class='cmti-10'>-efectivamente computable </span>si hay un
procedimiento efectivo \(\mathbb{P}\) tal que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-52005x2.1'>El conjunto de datos de entrada de \(\mathbb{P}\) es \(\omega ^{n}\times \Sigma ^{\ast m}\)
     </li>
     <li class='enumerate' id='x1-52006x2.1'>El conjunto de datos de salida esta contenido en \(\Sigma ^{\ast }\).
     </li>
     <li class='enumerate' id='x1-52007x2.1'>Si \((\vec{x},\vec{\alpha })\in D_{f}\), entonces \(\mathbb{P}\) se detiene partiendo de \((\vec{x},\vec{\alpha })\), dando como dato de salida \(f(\vec{x},\vec{\alpha })\).
     </li>
     <li class='enumerate' id='x1-52008x2.1'>Si \((\vec{x},\vec{\alpha })\in (\omega ^{n}\times \Sigma ^{\ast m})-D_{f}\), entonces \(\mathbb{P}\) no se detiene partiendo desde \((\vec{x},\vec{\alpha })\)</li></ol>

<!-- l. 2687 --><p class='noindent'>En ambos casos diremos que \(\mathbb{P}\) <span class='cmti-10'>computa </span>a la funcion \(f\).
</p><!-- l. 2690 --><p class='indent'>   Notese que esta definicion para el caso \(f=\emptyset \) tiene a priori cierta ambiguedad ya que
cualesquiera sean \(n,m\in \omega \) y \(O\in \{\omega ,\Sigma ^{\ast }\}\) tenemos que \(\emptyset :\emptyset \subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) ya que \(D_{\emptyset }=\emptyset \) y \(I_{\emptyset }=\emptyset \). De todas maneras, cualesquiera sean
los \(n,m\) y \(O\) elejidos, siempre hay un procedimiento efectivo que computa a \(f=\emptyset \), i.e. un
procedimiento que nunca se detiene, cualesquiera sea el dato de entrada de \(\omega ^{n}\times \Sigma ^{\ast m}\). Es decir
que la funcion \(\emptyset \) es \(\Sigma \)-efectivamente computable cualesquiera sea el alfabeto \(\Sigma \). Cabe
destacar que para el caso de una funcion \(f\neq \emptyset \), nuestra definicion es inambigua ya que hay
unicos \(n,m\in \omega \) y \(O\in \{\omega ,\Sigma ^{\ast }\}\) tales que \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\).
</p><!-- l. 2703 --><p class='indent'>   Veamos algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-52009x2.1'>La  funcion  \(\lambda xy\left [x+y\right ]\)  es  \(\Sigma \)-efectivamente  computable,  cualquiera  sea  el  alfabeto  \(\Sigma \)
     ya que el procedimiento enseñado en la escuela primaria para sumar
     numeros en notacion decimal es efectivo y computa esta funcion. Tambien
     las funciones \(\lambda xy\left [x.y\right ]\) y \(\lambda xy\left [x^{y}\right ]\) son \(\Sigma \)-efectivamente computables via los procedimientos
     clasicos enseñados en la escuela primaria.
     </li>
     <li class='enumerate' id='x1-52010x2.1'>La funcion \(C_{3}^{1,2}\) es \(\Sigma \)-efectivamente computable ya que el siguiente procedimiento \(\mathbb{P}\)
     con conjunto de datos de entrada \(\omega \times \Sigma ^{\ast 2}\) la computa:
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-52011x2.1'>Independientemente de quien sea el dato de entrada \((x_{1},\alpha _{1},\alpha _{2})\), terminar y dar
         como salida el numero \(3\)</li></ol>
     </li>
     <li class='enumerate' id='x1-52012x2.1'>La funcion \(p_{3}^{2,3}\) es \(\Sigma \)-efectivamente computable ya que el siguiente procedimiento con
     conjunto de datos de entrada \(\omega ^{2}\times \Sigma ^{\ast 3}\) la computa:
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-52013x2.1'>Dado el dato de entrada \((x_{1},x_{2},\alpha _{1},\alpha _{2},\alpha _{3})\), terminar y dar como salida la palabra \(\alpha _{1}\)</li></ol>
     </li>
     <li class='enumerate' id='x1-52014x2.1'>\(Pred\) es \(\Sigma \)-efectivamente computable. Para realizar el procedimiento efectivo que
     compute a \(Pred\) necesitaremos el procedimiento de la escuela primaria que dado un
     numero no nulo \(x\), expresado en notacion decimal, calcula el numero \(x-1\),
     en notacion decimal. Llamemos \(\mathbb{P}_{-1}\) a dicho procedimiento. El siguiente
     procedimiento (con conjunto de datos de entrada igual a \(\omega \)) computa a
     \(Pred\):
     <!-- l. 2732 --><p class='noindent'>Dado como dato de entrada un elemento \(x\in \omega \), realizar lo siguiente:
     </p><!-- l. 2734 --><p class='noindent'>Etapa 1
     </p><!-- l. 2736 --><p class='noindent'>Si \(x=0\), entonces ir a Etapa 3, en caso contrario ir a Etapa 2.
     </p><!-- l. 2739 --><p class='noindent'>Etapa 2
     </p><!-- l. 2741 --><p class='noindent'>Correr \(\mathbb{P}_{-1}\) con dato de entrada \(x\) obteniendo \(y\) como dato de salida. Dar \(y\) como dato
     de salida y terminar.
     </p><!-- l. 2744 --><p class='noindent'>Etapa 3

     </p><!-- l. 2746 --><p class='noindent'>Si \(x=0\), entonces ir a Etapa 1.
     </p><!-- l. 2748 --><p class='noindent'>Como puede notarse el procedimiento anterior es efectivo ya que debemos
     entender que en la Etapa 2, los sucesivos pasos efectuados al correr \(\mathbb{P}_{-1}\) son todos
     simples y efectivamente realizables ya que \(\mathbb{P}_{-1}\) es efectivo. Por supuesto si uno
     quisiera ser mas prolijo, deberia reemplazar la Etapa 2 por las distintas
     instrucciones de \(\mathbb{P}_{-1}\), referidas a \(x\).
     </p></li>
     <li class='enumerate' id='x1-52015x2.1'>El predicado \(\lambda xy[x&lt;y]\) es \(\Sigma \)-efectivamente computable cualquiera sea el alfabeto \(\Sigma \).
     Describiremos con palabras un procedimiento que computa a \(\lambda xy[x&lt;y]\). Su conjunto de
     datos de entrada es \(\omega ^{2}\). Dado un par \((x,y)\in \omega ^{2}\), el procedimiento primero compara las
     longitudes de las palabras que en notacion decimal representan a \(x\) y \(y\). Por
     supuesto esto lo hace borrando de a un simbolo y viendo si alguna se termina
     primero. Si resultan de distinta longitud, es facil darse cuenta como sigue.
     En caso de que las palabras resulten de igual longitud, entonces se
     hace el procedimiento clasico de ir comparando digitos de izquierda a
     derecha.
     </li>
     <li class='enumerate' id='x1-52016x2.1'>Veamos que la funcion \(\lambda \alpha [\left \vert \alpha \right \vert ]\) es \(\Sigma \)-efectivamente computable. Como en los
     lenguajes de programacion, usaremos variables y asignaciones para
     diseñar el procedimiento. Ademas llamemos \(\mathbb{P}_{+1}\) a el procedimiento de la
     escuela primaria que dado un numero no nulo \(x\), expresado en notacion
     decimal, calcula el numero \(x+1\), en notacion decimal. Sea \(\mathbb{P}\) el siguiente
     procedimiento.
     <!-- l. 2772 --><p class='noindent'>Dado como dato de entrada un elemento \(\alpha \in \Sigma ^{\ast }\), realizar lo siguiente:
     </p><!-- l. 2775 --><p class='noindent'>Etapa 1: Hacer las siguientes asignaciones </p><div class='eqnarray'>\begin{eqnarray*} A &amp; \leftarrow &amp; \alpha \\ B &amp; \leftarrow &amp; 0 \end{eqnarray*}
     </div>e ir a Etapa 2.
     <!-- l. 2782 --><p class='noindent'>Etapa 2: Si \(A\) no es \(\varepsilon \), ir a Etapa 3. En caso contrario terminar y dar como salida
     \(B\).
     </p><!-- l. 2785 --><p class='noindent'>Etapa 3: Correr \(\mathbb{P}_{+1}\) con dato de entrada igual al contenido de \(B\), obteniendo \(y\) como
     salida. Hacer la asignacion </p><div class='eqnarray'>\begin{eqnarray*} A &amp; \leftarrow &amp; \text{resultado de remover el 1er simbolo de }A\\ B &amp; \leftarrow &amp; y \end{eqnarray*}
     </div>e ir a Etapa 2.
     <!-- l. 2793 --><p class='noindent'>Dejamos como ejercicio convenserse que el uso de asignaciones puede realizarse
     usando solo lapiz y papel. Imagine como lo haria en este ejemplo y
     corrobore que dicho procedimiento es efectivo y ademas computa a
     \(\lambda \alpha [\left \vert \alpha \right \vert ]\)
     </p></li>
     <li class='enumerate' id='x1-52017x2.1'>Si \(\leq \) es el orden total sobre \(\Sigma =\{\blacktriangle ,\%\}\) dado por \(\blacktriangle &lt;\%\), entonces veremos que la funcion \(s^{\leq }\) es
     \(\Sigma \)-efectivamente computable. Por el Lema <span class='cmbx-10'>??</span> tenemos que cualquiera sea \(\alpha \in \Sigma ^{\ast }\), se
     cumple <div class='eqnarray'>\begin{eqnarray*} s^{\leq }(\varepsilon ) &amp; = &amp; \blacktriangle \\ s^{\leq }(\alpha \blacktriangle ) &amp; = &amp; \alpha \%\\ s^{\leq }(\alpha \%) &amp; = &amp; s^{\leq }(\alpha )\blacktriangle  \end{eqnarray*}
     </div>Tal como lo explica dicho lema el valor de \(s^{\leq }\) queda determinado por las tres
     ecuaciones anteriores. Usaremos esta idea para dar un procedimiento
     efectivo (con conjunto de datos de entrada igual a \(\Sigma ^{\ast }\)) que compute a

     \(s^{\leq }\).
     <!-- l. 2811 --><p class='noindent'>Etapa 1: Dado el dato de entrada \(\alpha \in \Sigma ^{\ast }\), hacer las siguientes asignaciones
     </p><div class='eqnarray'>\begin{eqnarray*} A &amp; \leftarrow &amp; \alpha \\ B &amp; \leftarrow &amp; \varepsilon \\ F &amp; \leftarrow &amp; \blacktriangle  \end{eqnarray*}
     </div>e ir a Etapa 2.
     <!-- l. 2820 --><p class='noindent'>Etapa 2: Si \(A\) comiensa con \(\blacktriangle \), entonces hacer las siguientes asignaciones
     </p><div class='eqnarray'>\begin{eqnarray*} A &amp; \leftarrow &amp; \text{resultado de remover el 1er simbolo de }A\\ F &amp; \leftarrow &amp; B\%\\ B &amp; \leftarrow &amp; B\blacktriangle  \end{eqnarray*}
     </div>e ir a la Etapa 2. En caso contrario ir a la Etapa 3.
     <!-- l. 2829 --><p class='noindent'>Etapa 3: Si \(A\) comiensa con \(\%\), entonces hacer las siguientes asignaciones
     </p><div class='eqnarray'>\begin{eqnarray*} A &amp; \leftarrow &amp; \text{resultado de remover el 1er simbolo de }A\\ F &amp; \leftarrow &amp; F\blacktriangle \\ B &amp; \leftarrow &amp; B\% \end{eqnarray*}
     </div>e ir a la Etapa 2. En caso contrario ir a la Etapa 4.
     <!-- l. 2838 --><p class='noindent'>Etapa 4: Dar como salida \(F\)
     </p></li>
     <li class='enumerate' id='x1-52018x2.1'>Usando que \(s^{\leq }\) es \(\Sigma \)-efectivamente computable podemos ver que \(\ast ^{\leq }:\omega \rightarrow \Sigma ^{\ast }\) tambien lo es ya
     que \(\ast ^{\leq }\) es definida con las ecuaciones <div class='eqnarray'>\begin{eqnarray*} \ast ^{\leq }(0) &amp; = &amp; \varepsilon \\ \ast ^{\leq }(x+1) &amp; = &amp; s^{\leq }(\ast ^{\leq }(x)) \end{eqnarray*}
     </div></li></ol>
<!-- l. 2847 --><p class='noindent'>Dejamos como ejercico para el lector diseñar procedimientos efectivos que computen las
funciones:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-52019x2.1'>\(\lambda xy[x\) divide a \(y]\)
     </li>
     <li class='enumerate' id='x1-52020x2.1'>\(\lambda x[pr(x)]\)
     </li>
     <li class='enumerate' id='x1-52021x2.1'>\(\lambda ix[(x)_{i}]\)</li></ol>
<!-- l. 2854 --><p class='noindent'>(Utilice en el diseño de los respectivos procedimientos a los procedimientos que
computan las funciones \(\lambda xy\left [x+y\right ]\), \(\lambda xy\left [x.y\right ]\) y \(\lambda xy\left [x^{y}\right ]\))
</p><!-- l. 2860 --><p class='indent'>   <span class='cmbx-10'>Nota Importante: </span>en lo que sigue muchas veces daremos procedimientos que
son efectivos en terminos de otros que ya se han dado, es decir daremos
un procedimiento que en principio no es claro que sea efectivo pero el cual
se volveria efectivo si reemplazaramos ciertas instrucciones por la manera
efectiva de simularlas. Para hacer mas dinamico el discurso no distinguiremos
entre este tipo de procedimientos (efectivisables) y los efectivos propiamente
dichos.
</p><!-- l. 2871 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>2.1.1   </span> <a id='x1-530002.1.1'></a>Constructores de funciones</h5>

<!-- l. 2873 --><p class='noindent'>Hay muchos procesos constructivos que nos sirven para definir o construir
una funcion en terminos de otras funciones dadas. Un ejemplo de esto es la
composicion de funciones, la cual dadas dos funciones \(f,g\) nos permite construir su
composicion, a saber \(f\circ g\). Otro ejemplo es el contructor de predicados que dados dos
predicados \(\Sigma \)-mixtos \(P:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \{0,1\}\) y \(Q:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \{0,1\}\), con el mismo dominio, nos define el predicado \[ \begin{array}{rll} (P\vee Q):S &amp; \rightarrow &amp; \omega \\ (\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; \left \{ \begin{array}{lll} 1 &amp; &amp; \text{si }P(\vec{x},\vec{\alpha })=1\text{ o }Q(\vec{x},\vec{\alpha })=1\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \end{array} \] Otro
constructor muy importante que utilizaremos mucho es aquel que a partir
de funciones \(f_{i}:D_{f_{i}}\rightarrow O\), \(i=1,...,k\), tales que \(D_{f_{i}}\cap D_{f_{j}}=\emptyset \) para \(i\neq j\), nos da la nueva funcion \(f_{1}\cup ...\cup f_{k}\), la cual cumple
\[ \begin{array}{rll} D_{f_{1}}\cup ...\cup D_{f_{k}} &amp; \rightarrow &amp; O\\ e &amp; \rightarrow &amp; \left \{ \begin{array}{clc} f_{1}(e) &amp; &amp; \text{si }e\in D_{f_{1}}\\ \vdots &amp; &amp; \vdots \\ f_{k}(e) &amp; &amp; \text{si }e\in D_{f_{k}} \end{array}\right . \end{array} \]
</p>
   <div class='newtheorem'>
<!-- l. 2919 --><p class='noindent'><span class='head'>
<a id='x1-53001r20'></a>
<span class='cmbx-10'>Lema 20.</span>  </span><span class='cmti-10'>Si</span> \(P:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>y</span> \(Q:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>son predicados</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computables, entonces</span> \((P\vee Q)\)<span class='cmti-10'>,</span> \((P\wedge Q)\) <span class='cmti-10'>y</span> \(\lnot P\) <span class='cmti-10'>lo
</span><span class='cmti-10'>son tambien.</span>
</p>
   </div>
<!-- l. 2927 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>2.1.2   </span> <a id='x1-540002.1.2'></a>Composicion</h5>
<!-- l. 2929 --><p class='noindent'>Dadas funciones \(\Sigma \)-mixtas \(f,f_{1},...,f_{r}\), con \(r\geq 1\), diremos que la funcion \(f\circ [f_{1},...,f_{r}]\) es <span class='cmti-10'>obtenida por composicion a
</span><span class='cmti-10'>partir de las funciones</span> \(f,f_{1},...,f_{r}\). Para probar que la composicion preserva la computabilidad
efectiva necesitaremos el siguiente lema.
</p>
   <div class='newtheorem'>
<!-- l. 2934 --><p class='noindent'><span class='head'>
<a id='x1-54001r21'></a>
<span class='cmbx-10'>Lema 21.</span>  </span><span class='cmti-10'>Supongamos que</span> \(f,f_{1},...,f_{r}\) <span class='cmti-10'>son funciones</span> \(\Sigma \)<span class='cmti-10'>-mixtas, con</span> \(r\geq 1\)<span class='cmti-10'>. Supongamos ademas que</span> \(f\circ [f_{1},...,f_{r}]\neq \emptyset \)<span class='cmti-10'>.
</span><span class='cmti-10'>Entonces hay</span> \(n,m,k,l\in \omega \) <span class='cmti-10'>y</span> \(s\in \{\#,\ast \}\) <span class='cmti-10'>tales que</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-54002x21'>\(r=n+m\)
     </li>
     <li class='enumerate' id='x1-54003x21'>\(f\) <span class='cmti-10'>es de tipo</span> \((n,m,s)\)

     </li>
     <li class='enumerate' id='x1-54004x21'>\(f_{i}\) <span class='cmti-10'>es de tipo</span> \((k,l,\#)\)<span class='cmti-10'>, para cada</span> \(i=1,...,n\)
     </li>
     <li class='enumerate' id='x1-54005x21'>\(f_{i}\) <span class='cmti-10'>es de tipo</span> \((k,l,\ast )\)<span class='cmti-10'>, para cada</span> \(i=n+1,...,n+m\)</li></ol>
<!-- l. 2944 --><p class='noindent'><span class='cmti-10'>Mas aun, en tal caso la funcion</span> \(f\circ [f_{1},...,f_{n+m}]\) <span class='cmti-10'>es de tipo</span> \((k,l,s)\) <span class='cmti-10'>y:</span> </p><div class='eqnarray'>\begin{eqnarray*} D_{f\circ [f_{1},...,f_{n+m}]} &amp; = &amp; \left \{ (\vec{x},\vec{\alpha })\in \bigcap _{i=1}^{n+m}D_{f_{i}}:(f_{1}(\vec{x},\vec{\alpha }),...,f_{n+m}(\vec{x},\vec{\alpha }))\in D_{f}\right \} \\ f\circ [f_{1},...,f_{n+m}](\vec{x},\vec{\alpha }) &amp; = &amp; f(f_{1}(\vec{x},\vec{\alpha }),...,f_{n+m}(\vec{x},\vec{\alpha })). \end{eqnarray*}
</div>
   </div>
<!-- l. 2952 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 2953 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que \(f\neq \emptyset \) y \([f_{1},...,f_{r}]\neq \emptyset \) (por que?). Ya que \(f\neq \emptyset \) tenemos que hay unicos \(n,m\in \omega \) y \(s\in \{\#,\ast \}\) tales que \(f\) es de
tipo \((n,m,s)\). Ya que \(f\circ [f_{1},...,f_{r}]\neq \emptyset \) y \(I_{[f_{1},...,f_{r}]}\subseteq I_{f_{1}}\times ...\times I_{f_{r}}\), tenemos que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-54006x2.1.2'>\(r=n+m\)
     </li>
     <li class='enumerate' id='x1-54007x2.1.2'>\(I_{f_{i}}\subseteq \omega \), para cada \(i=1,...,n\)
     </li>
     <li class='enumerate' id='x1-54008x2.1.2'>\(I_{f_{i}}\subseteq \Sigma ^{\ast }\), para cada \(i=n+1,...,n+m\)</li></ol>
<!-- l. 2963 --><p class='noindent'>Ya que \([f_{1},...,f_{r}]\neq \emptyset \) tenemos que \(D_{[f_{1},...,f_{r}]}=\bigcap _{i=1}^{r}D_{f_{i}}\neq \emptyset \), por lo cual los conjuntos \(D_{f_{1}},...,D_{f_{n+m}}\) deberan ser todos de un mismo tipo,
digamos de tipo \((k,l)\). Es decir que \(f_{i}\) es de tipo \((k,l,\#)\), para cada \(i=1,...,n\) y \(f_{i}\) es de tipo \((k,l,\ast )\), para cada
\(i=n+1,...,n+m\).
</p><!-- l. 2969 --><p class='indent'>   Las ultimas observaciones del lema son directas de las definiciones de \([f_{1},...,f_{n+m}]\) y de
composicion de funciones                                                                     □
</p>
   </div>
<!-- l. 2974 --><p class='indent'>   Ahora si podemos probar facilmente que se preserva la computabilidad efectiva
cuando componemos
</p>
   <div class='newtheorem'>
<!-- l. 2976 --><p class='noindent'><span class='head'>
<a id='x1-54009r22'></a>
<span class='cmbx-10'>Lema 22.</span>  </span><span class='cmti-10'>Si</span> \(f,f_{1},...,f_{r}\)<span class='cmti-10'>, con</span> \(r\geq 1\)<span class='cmti-10'>, son</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computables, entonces</span> \(f\circ [f_{1},...,f_{r}]\) <span class='cmti-10'>lo es.</span>

</p>
   </div>
<!-- l. 2981 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 2982 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Si \(f\circ [f_{1},...,f_{r}]=\emptyset \), entonces claramente es \(\Sigma \)-efectivamente computable. Supongamos entonces
que \(f\circ [f_{1},...,f_{r}]\neq \emptyset \). Por el lema anterior hay \(n,m,k,l\in \omega \) y \(s\in \{\#,\ast \}\) tales que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-54010x2.1.2'>\(r=n+m\)
     </li>
     <li class='enumerate' id='x1-54011x2.1.2'>\(f\) es de tipo \((n,m,s)\)
     </li>
     <li class='enumerate' id='x1-54012x2.1.2'>\(f_{i}\) es de tipo \((k,l,\#)\), para cada \(i=1,...,n\)
     </li>
     <li class='enumerate' id='x1-54013x2.1.2'>\(f_{i}\) es de tipo \((k,l,\ast )\), para cada \(i=n+1,...,n+m\)</li></ol>
<!-- l. 2992 --><p class='noindent'>Sean \(\mathbb{P},\mathbb{P}_{1},...,\mathbb{P}_{n+m}\) procedimientos efectivos los cuales computen las funciones \(f,f_{1},...,f_{n+m}\), respectivamente.
Usando estos procedimientos es facil definir un procedimiento efectivo el cual
compute a \(f\circ [f_{1},...,f_{n+m}]\).                                                                                      □
</p>
   </div>
<!-- l. 3001 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>2.1.3   </span> <a id='x1-550002.1.3'></a>Lema de division por casos para funciones \(\Sigma \)-efectivamente computables</h5>
<!-- l. 3003 --><p class='noindent'>Recordemos que si \(f_{i}:D_{f_{i}}\rightarrow O\), \(i=1,...,k\), son funciones tales que \(D_{f_{i}}\cap D_{f_{j}}=\emptyset \) para \(i\neq j\), entonces \(f_{1}\cup ...\cup f_{k}\) es la funcion
\[ \begin{array}{rll} D_{f_{1}}\cup ...\cup D_{f_{k}} &amp; \rightarrow &amp; O\\ e &amp; \rightarrow &amp; \left \{ \begin{array}{clc} f_{1}(e) &amp; &amp; \text{si }e\in D_{f_{1}}\\ \vdots &amp; &amp; \vdots \\ f_{k}(e) &amp; &amp; \text{si }e\in D_{f_{k}} \end{array}\right . \end{array} \]
</p>
   <div class='newtheorem'>
<!-- l. 3017 --><p class='noindent'><span class='head'>
<a id='x1-55001r23'></a>
<span class='cmbx-10'>Lema 23.</span>  </span><span class='cmti-10'>Sean</span> \(n,m\in \omega \) <span class='cmti-10'>y</span> \(O\in \{\omega ,\Sigma ^{\ast }\}\)<span class='cmti-10'>. Supongamos</span> \(f_{i}:D_{f_{i}}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\)<span class='cmti-10'>,</span> \(i=1,...,k\)<span class='cmti-10'>, son funciones</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computables
</span><span class='cmti-10'>tales que</span> \(D_{f_{i}}\cap D_{f_{j}}=\emptyset \) <span class='cmti-10'>para</span> \(i\neq j\)<span class='cmti-10'>. Entonces</span> \(f_{1}\cup ...\cup f_{k}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable.</span>

</p>
   </div>
<!-- l. 3025 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 3026 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Haremos el caso \(O=\Sigma ^{\ast }\) y \(k=2\). Sean \(\mathbb{P}_{1}\) y \(\mathbb{P}_{2}\) procedimientos efectivos que computen a \(f_{1}\)
y \(f_{2}\), respectivamente. Sea \(\mathbb{P}\) el procedimiento efectivo siguiente:
</p><!-- l. 3031 --><p class='indent'>   - Conjunto de datos de entrada de \(\mathbb{P}\) igual a \(\omega ^{n}\times \Sigma ^{\ast m}\)
</p><!-- l. 3033 --><p class='indent'>   - Conjunto de datos de salida de \(\mathbb{P}\) contenido en \(\Sigma ^{\ast }\)
</p><!-- l. 3035 --><p class='indent'>   - Funcionamiento:
</p><!-- l. 3037 --><p class='indent'>   Etapa 1
</p><!-- l. 3039 --><p class='noindent'>Hacer \(T=1\)
</p><!-- l. 3041 --><p class='indent'>   Etapa 2
</p><!-- l. 3043 --><p class='noindent'>Correr el procedimiento \(\mathbb{P}_{1}\) una cantidad \(T\) de pasos. En caso de que termine guardar
la salida en la variable \(X\) e ir a Etapa 5. Si no termina ir a Etapa 3.
</p><!-- l. 3047 --><p class='indent'>   Etapa 3
</p><!-- l. 3049 --><p class='noindent'>Correr el procedimiento \(\mathbb{P}_{2}\) una cantidad \(T\) de pasos. En caso de que termine guardar
la salida en la variable \(X\) e ir a Etapa 6. Si no termina ir a Etapa 4.
</p><!-- l. 3053 --><p class='indent'>   Etapa 4
</p><!-- l. 3055 --><p class='noindent'>Hacer \(T=T+1\) e ir a Etapa 2
</p><!-- l. 3057 --><p class='indent'>   Etapa 5
</p><!-- l. 3059 --><p class='noindent'>Dar como salida el contenido de \(X\) y terminar.
</p><!-- l. 3061 --><p class='indent'>   Dejamos al lector corroborar que el procedimiento \(\mathbb{P}\) computa a la funcion
\(f_{1}\cup f_{2}\).                                                                                                     □
</p>
   </div>
<!-- l. 3068 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.2   </span> <a id='x1-560002.2'></a>Conjuntos \(\Sigma \)-efectivamente computables</h4>
<!-- l. 3070 --><p class='noindent'>Un conjunto \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) sera llamado \(\Sigma \)<span class='cmti-10'>-efectivamente computable </span>cuando la funcion \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) sea
\(\Sigma \)-efectivamente computable. Notese que \(S\) es \(\Sigma \)-efectivamente computable sii hay un
procedimiento efectivo \(\mathbb{P}\), el cual computa \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\), es decir:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-56001x2.2'>El conjunto de datos de entrada de \(\mathbb{P}\) es \(\omega ^{n}\times \Sigma ^{\ast m}\), siempre termina y da como dato
     de salida un elemento de \(\{0,1\}\).
     </li>
     <li class='enumerate' id='x1-56002x2.2'>Dado \((\vec{x},\vec{\alpha })\in \omega ^{n}\times \Sigma ^{\ast m}\), \(\mathbb{P}\) da como salida al numero \(1\) si \((\vec{x},\vec{\alpha })\in S\) y al numero \(0\) si \((\vec{x},\vec{\alpha })\notin S\).</li></ol>

<!-- l. 3083 --><p class='noindent'>Si  \(\mathbb{P}\) es un procedimiento efectivo el cual computa a \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\), diremos que \(\mathbb{P}\) <span class='cmti-10'>decide la pertenecia a</span> \(S\),
con respecto al conjunto \(\omega ^{n}\times \Sigma ^{\ast m}\).
</p><!-- l. 3087 --><p class='indent'>   Notese que esta definicion para el caso \(S=\emptyset \) tiene a priori cierta ambiguedad ya que
cualesquiera sean \(n,m\in \omega \) tenemos que \(\emptyset \subseteq \omega ^{n}\times \Sigma ^{\ast m}\). De todas maneras, cualesquiera sean los \(n,m\) elejidos,
siempre hay un procedimiento efectivo que computa a \(\chi _{\emptyset }^{\omega ^{n}\times \Sigma ^{\ast m}}\), i.e. un procedimiento que
siempre da como salida \(0\), cualesquiera sea el dato de entrada de \(\omega ^{n}\times \Sigma ^{\ast m}\). Es decir que el
conjunto \(\emptyset \) es \(\Sigma \)-efectivamente computable cualesquiera sea el alfabeto \(\Sigma \). Cabe destacar
que para el caso de un conjunto \(S\neq \emptyset \), nuestra definicion es inambigua ya que hay unicos \(n,m\in \omega \)
tales que \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\).
</p><!-- l. 3101 --><p class='indent'>   Dejamos al lector la facil prueba del siguiente resultado.
</p>
   <div class='newtheorem'>
<!-- l. 3102 --><p class='noindent'><span class='head'>
<a id='x1-56003r24'></a>
<span class='cmbx-10'>Lema 24.</span>  </span><span class='cmti-10'>Sean</span>  \(S_{1},S_{2}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\)  <span class='cmti-10'>conjuntos</span>  \(\Sigma \)<span class='cmti-10'>-efectivamente  computables.  Entonces</span>  \(S_{1}\cup S_{2},S_{1}\cap S_{2}\)  <span class='cmti-10'>y</span>  \((\omega ^{n}\times \Sigma ^{\ast m})-S_{1}\)  <span class='cmti-10'>son</span>
\(\Sigma \)<span class='cmti-10'>-efectivamente computables.</span>
</p>
   </div>
<!-- l. 3111 --><p class='indent'>   El siguiente lema caracteriza cuando un conjunto rectangular es \(\Sigma \)-efectivamente
computable
</p>
   <div class='newtheorem'>
<!-- l. 3113 --><p class='noindent'><span class='head'>
<a id='x1-56004r25'></a>
<span class='cmbx-10'>Lema 25.</span>  </span><span class='cmti-10'>Supongamos</span> \(S_{1},...,S_{n}\subseteq \omega \)<span class='cmti-10'>,</span> \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) <span class='cmti-10'>son conjuntos no vacios. Entonces</span> \(S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente
</span><span class='cmti-10'>computable sii</span> \(S_{1},...,S_{n},L_{1},...,L_{m}\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computables</span>
</p>
   </div>
<!-- l. 3120 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 3121 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que si \(n=m=0\), entonces \(S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}=\{\Diamond \}\) el cual es \(\Sigma \)-efectivamente computable por lo cual
el lema se cumple. Vemos entonces el caso \(n+m\geq 1\). Para hacer mas lejible la prueba
haremos el caso \(n=m=1\). La prueba general es completamente analoga.

</p><!-- l. 3127 --><p class='indent'>   (\(\Rightarrow \)) Ya que \(S_{1}\) y \(L_{1}\) son conjuntos no vacios, hay \(x_{0}\in S_{1}\) y \(\alpha _{0}\in L_{1}\). Ya que \(S_{1}\times L_{1}\) es \(\Sigma \)-efectivamente
computable, tenemos que \(\chi _{S_{1}\times L_{1}}^{\omega \times \Sigma ^{\ast }}\) es \(\Sigma \)-efectivamente computable. Notese que: \[ x\in S_{1}\text{ sii }(x,\alpha _{0})\in S_{1}\times L_{1}\text{ sii }\chi _{S_{1}\times L_{1}}^{\omega \times \Sigma ^{\ast }}(x,\alpha _{0})=1\text{ } \] Por lo
tanto, es facil usando un procedimiento efectivo que compute a \(\chi _{S_{1}\times L_{1}}^{\omega \times \Sigma ^{\ast }}\) diseñar un
procedimiento efectivo que compute a \(\chi _{S_{1}}^{\omega }\). En forma similar se prueba que \(L_{1}\) es
\(\Sigma \)-efectivamente computable.
</p><!-- l. 3140 --><p class='indent'>   (\(\Leftarrow \)) Es facil, usando procedimientos efectivos que computen a \(\chi _{S_{1}}^{\omega }\) y \(\chi _{L_{1}}^{\Sigma ^{\ast }}\), armar un
procedimiento efectivo que compute a \(\chi _{S_{1}\times L_{1}}^{\omega \times \Sigma ^{\ast }}\).                                                  □
</p>
   </div>
<!-- l. 3148 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.3   </span> <a id='x1-570002.3'></a>Conjuntos \(\Sigma \)-efectivamente enumerables</h4>
<!-- l. 3150 --><p class='noindent'>Un conjunto \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) sera llamado \(\Sigma \)<span class='cmti-10'>-efectivamente enumerable </span>cuando sea vacio o haya una
funcion \(F:\omega \rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) tal que \(I_{F}=S\) y \(F_{(i)}\) sea \(\Sigma \)-efectivamente computable, para cada \(i\in \{1,...,n+m\}\). Notese que para el
caso \(n=m=0\), la condicion de que \(F_{(i)}\) sea \(\Sigma \)-efectivamente computable, para cada \(i\in \{1,...,n+m\}\) se cumple
vacuamente y por lo tanto la definicion anterior nos dice que un conjunto \(S\subseteq \omega ^{0}\times \Sigma ^{\ast 0}=\{\Diamond \}\) sera
\(\Sigma \)-efectivamente enumerable sii es vacio o hay una funcion \(\Sigma \)-efectivamente
computable \(F:\omega \rightarrow \{\Diamond \}\), tal que \(I_{F}=S\). Por supuesto, esto nos dice que \(\emptyset \) y \(\{\Diamond \}\) son \(\Sigma \)-efectivamente
enumerables.
</p><!-- l. 3163 --><p class='indent'>   El siguiente resultado nos permite entender mejor la idea subyacente a esta
definicion.
</p>
   <div class='newtheorem'>
<!-- l. 3165 --><p class='noindent'><span class='head'>
<a id='x1-57001r26'></a>
<span class='cmbx-10'>Lema 26.</span>  </span><span class='cmti-10'>Un conjunto no vacio</span> \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente enumerable sii hay un
</span><span class='cmti-10'>procedimiento efectivo</span> \(\mathbb{P}\) <span class='cmti-10'>tal que</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-57002x26'><span class='cmti-10'>El conjunto de datos de entrada de</span> \(\mathbb{P}\) <span class='cmti-10'>es</span> \(\omega \)
     </li>
     <li class='enumerate' id='x1-57003x26'>\(\mathbb{P}\) <span class='cmti-10'>se detiene para cada</span> \(x\in \omega \)
     </li>
     <li class='enumerate' id='x1-57004x26'><span class='cmti-10'>El conjunto de datos de salida de</span> \(\mathbb{P}\) <span class='cmti-10'>es igual a</span> \(S\)<span class='cmti-10'>. (Es decir, siempre que</span> \(\mathbb{P}\) <span class='cmti-10'>se
     </span><span class='cmti-10'>detiene, da como salida un elemento de</span> \(S\)<span class='cmti-10'>, y para cada elemento</span> \((\vec{x},\vec{\alpha })\in S\)<span class='cmti-10'>, hay un</span> \(x\in \omega \)
     <span class='cmti-10'>tal que</span> \(\mathbb{P}\) <span class='cmti-10'>da como salida a</span> \((\vec{x},\vec{\alpha })\) <span class='cmti-10'>cuando lo corremos con</span> \(x\) <span class='cmti-10'>como dato de entrada)</span></li></ol>

   </div>
<!-- l. 3180 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 3181 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>El caso \(n=m=0\) es facil y es dejado al lector. Supongamos entonces que \(n+m\geq 1\).
</p><!-- l. 3184 --><p class='indent'>   (\(\Rightarrow \)) Supongamos que \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) es \(\Sigma \)-efectivamente enumerable. Ya que \(S\) es no vacio, por
definicion hay una funcion \(F:\omega \rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) tal que \(I_{F}=S\) y cada \(F_{(i)}\) es \(\Sigma \)-efectivamente computable. Para
cada \(i\in \{1,...,n+m\}\) sea \(\mathbb{P}_{i}\) un procedimiento efectivo que compute a \(F_{(i)}\). Notar que cada \(\mathbb{P}_{i}\) tiene
a \(\omega \) como conjunto de datos de entrada y siempre termina. Sea \(\mathbb{P}\) el siguiente
procedimiento efectivo, con conjunto de datos de entrada igual a \(\omega \) y conjunto de
datos de salida contenido en \(\omega ^{n}\times \Sigma ^{\ast m}\).
</p><!-- l. 3195 --><p class='indent'>   Etapa 1: Correr \(\mathbb{P}_{1}\) con dato de entrada \(x\) y alojar el dato de salida en la variable
\(X_{1}\)
</p><!-- l. 3198 --><p class='indent'>   Etapa 2: Correr \(\mathbb{P}_{2}\) con dato de entrada \(x\) y alojar el dato de salida en la variable
\(X_{2}\)
</p><!-- l. 3201 --><p class='indent'>   \(\ \ \ \ \vdots \)
</p><!-- l. 3203 --><p class='indent'>   Etapa \(n\): Correr \(\mathbb{P}_{n}\) con dato de entrada \(x\) y alojar el dato de salida en la variable
\(X_{n}\)
</p><!-- l. 3206 --><p class='indent'>   Etapa \(n+1\): Correr \(\mathbb{P}_{n+1}\) con dato de entrada \(x\) y alojar el dato de salida en la variable
\(A_{1}\)
</p><!-- l. 3209 --><p class='indent'>   Etapa \(n+2\): Correr \(\mathbb{P}_{n+2}\) con dato de entrada \(x\) y alojar el dato de salida en la variable
\(A_{2}\)
</p><!-- l. 3212 --><p class='indent'>   \(\ \ \ \ \vdots \)
</p><!-- l. 3214 --><p class='indent'>   Etapa \(n+m\): Correr \(\mathbb{P}_{n+m}\) con dato de entrada \(x\) y alojar el dato de salida en la variable
\(A_{m}\)
</p><!-- l. 3217 --><p class='indent'>   Etapa \(n+m+1\): Detenerse y dar \((X_{1},...,X_{n},A_{1},...,A_{m})\) como dato de salida
</p><!-- l. 3220 --><p class='noindent'>Dejamos al lector la verificacion de que el procedimiento \(\mathbb{P}\) es efectivo y cumple
las propiedades (1), (2) y (3).
</p><!-- l. 3223 --><p class='indent'>   (\(\Leftarrow \)) Supongamos \(\mathbb{P}\) es un procedimiento efectivo el cual cumple las propiedades
(1), (2) y (3). Definamos \(F:\omega \rightarrow \omega ^{n}\times \Sigma ^{\ast m}\), de la siguiente manera: \[ F(x)=\text{ dato de salida de }\mathbb{P}\text{ cuando lo corremos desde }x \] Notar que para cada \(i\in \{1,...,n+m\}\) la
funcion \(F_{(i)}\) es \(\Sigma \)-efectivamente computable ya que el siguiente procedimiento efectivo
la computa:
</p><!-- l. 3233 --><p class='indent'>   Etapa 1: Correr \(\mathbb{P}\) desde \(x\) y guardar la salida en la variable \(V\)
</p><!-- l. 3236 --><p class='indent'>   Etapa 2: Dar como salida la coordenada \(i\)-esima de \(V\)                              □
</p>
   </div>
<!-- l. 3240 --><p class='indent'>   Cuando un procedimiento \(\mathbb{P}\) cumpla (1), (2) y (3) del lema anterior, diremos que \(\mathbb{P}\)
<span class='cmti-10'>enumera </span>a \(S\). O sea que \(S\) es \(\Sigma \)-efectivamente enumerable sii es vacio o hay un
procedimiento efectivo el cual enumera a \(S\).

</p><!-- l. 3245 --><p class='indent'>   Dicho de otra forma un conjunto no vacio \(S\) es \(\Sigma \)-efectivamente enumerable sii hay
un procedimiento efectivo \(\mathbb{P}\) el cual tiene conjunto de datos de entrada \(\omega \) y ademas para
los sucesivos datos de entrada \(0,1,2,3,...\), el procedimiento \(\mathbb{P}\) produce respectivamente los datos
de salida \(e_{0},e_{1},e_{2},e_{3},...\) de manera que \(S=\{e_{0},e_{1},e_{2},...\}\). Cabe destacar aqui que puede suceder que \(e_{i}=e_{j}\), para ciertos \(i,j\),
con \(i\neq j\).
</p><!-- l. 3253 --><p class='indent'>   Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-57005x2.3'>El conjunto \(S=\{x\in \omega :x\) es par\(\}\) es \(\Sigma \)-efectivamente enumerable, cualesquiera sea \(\Sigma \). El siguiente
     procedimiento enumera a \(S\):
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-57006x2.3'>Calcular \(2x\), darlo como dato de salida y terminar.</li></ol>
     </li>
     <li class='enumerate' id='x1-57007x2.3'>Un procedimiento que enumera \(\omega \times \omega \) es el siguiente:
     <!-- l. 3263 --><p class='noindent'>Etapa 1
     </p><!-- l. 3265 --><p class='noindent'>Si \(x=0\), dar como salida el par \((0,0)\) y terminar. Si \(x\neq 0\), calcular \(x_{1}=(x)_{1}\) y \(x_{2}=(x)_{2}\).
     </p><!-- l. 3268 --><p class='noindent'>Etapa 2
     </p><!-- l. 3270 --><p class='noindent'>Dar como dato de salida el par \((x_{1},x_{2})\) y terminar
     </p><!-- l. 3272 --><p class='noindent'>Como puede notarse el procedimiento es efectivo y ademas el conjunto de datos
     de salida es \(\omega \times \omega \) ya que si tomamos un par cualquiera \((a,b)\in \omega \times \omega \), el procedimiento lo dara
     como dato de salida para la entrada \(x=2^{a}3^{b}\).
     </p></li>
     <li class='enumerate' id='x1-57008x2.3'>Veamos que \(\omega ^{2}\times \Sigma ^{\ast 3}\) es \(\Sigma \)-efectivamente enumerable cualquiera sea el alfabeto no vacio \(\Sigma \).
     Sea \(\leq \) un orden total para el alfabeto \(\Sigma \). Utilisando el orden \(&lt;\) podemos diseñar el
     siguiente procedimiento para enumerar \(\omega ^{2}\times \Sigma ^{\ast 3}\):
     <!-- l. 3281 --><p class='noindent'>Etapa 1
     </p><!-- l. 3283 --><p class='noindent'>Si \(x=0\), dar como salida \((0,0,\varepsilon ,\varepsilon ,\varepsilon )\) y terminar. Si \(x\neq 0\), calcular
     </p><!-- l. 3286 --><p class='noindent'>\(x_{1}=(x)_{1}\)
     </p><!-- l. 3288 --><p class='noindent'>\(x_{2}=(x)_{2}\)
     </p><!-- l. 3290 --><p class='noindent'>\(\alpha _{1}=\ast ^{\leq }((x)_{3})\)
     </p><!-- l. 3292 --><p class='noindent'>\(\alpha _{2}=\ast ^{\leq }((x)_{4})\)
     </p><!-- l. 3294 --><p class='noindent'>\(\alpha _{3}=\ast ^{\leq }((x)_{5})\)
     </p><!-- l. 3296 --><p class='noindent'>Etapa 2
     </p><!-- l. 3298 --><p class='noindent'>Dar como dato de salida la 5-upla \((x_{1},x_{2},\alpha _{1},\alpha _{2},\alpha _{3})\).</p></li></ol>
   <div class='newtheorem'>
<!-- l. 3302 --><p class='noindent'><span class='head'>
<a id='x1-57009r27'></a>

<span class='cmbx-10'>Lema 27.</span>  </span><span class='cmti-10'>Sean</span>  \(S_{1},S_{2}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\)  <span class='cmti-10'>conjuntos</span>  \(\Sigma \)<span class='cmti-10'>-efectivamente  enumerables.  Entonces</span>  \(S_{1}\cup S_{2}\)  <span class='cmti-10'>y</span>  \(S_{1}\cap S_{2}\)  <span class='cmti-10'>son</span>
\(\Sigma \)<span class='cmti-10'>-efectivamente enumerables.</span>
</p>
   </div>
<!-- l. 3308 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 3309 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>El caso en el que alguno de los conjuntos es vacio es trivial. Supongamos que
ambos conjuntos son no vacios y sean \(\mathbb{P}_{1}\) y \(\mathbb{P}_{2}\) procedimientos que enumeran a \(S_{1}\) y \(S_{2}\). El
siguiente procedimiento enumera al conjunto \(S_{1}\cup S_{2}\):
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-57010x2.3'>Si \(x\) es par realizar \(\mathbb{P}_{1}\) partiendo de \(x/2\) y dar el elemento de \(S_{1}\) obtenido como
     salida. Si \(x\) es impar realizar \(\mathbb{P}_{2}\) partiendo de \((x-1)/2\) y dar el elemento de \(S_{2}\) obtenido
     como salida.</li></ol>
<!-- l. 3319 --><p class='noindent'>Veamos ahora que \(S_{1}\cap S_{2}\) es \(\Sigma \)-efectivamente enumerable. Si \(S_{1}\cap S_{2}=\emptyset \) entonces no hay nada que probar.
Supongamos entonces que \(S_{1}\cap S_{2}\) es no vacio. Sea \(e_{0}\) un elemento fijo de \(S_{1}\cap S_{2}\). Sea \(\mathbb{P}\) un
procedimiento efectivo el cual enumere a \(\omega \times \omega \) (ver el ejemplo de mas arriba). Un
procedimiento que enumera a \(S_{1}\cap S_{2}\) es el siguiente
</p><!-- l. 3326 --><p class='indent'>   Etapa 1
</p><!-- l. 3328 --><p class='noindent'>Realizar \(\mathbb{P}\) con dato de entrada \(x\), para obtener un par \((x_{1},x_{2})\in \omega \times \omega \).
</p><!-- l. 3331 --><p class='indent'>   Etapa 2
</p><!-- l. 3333 --><p class='noindent'>Realizar \(\mathbb{P}_{1}\) con dato de entrada \(x_{1}\) para obtener un elemento \(e_{1}\in S_{1}\)
</p><!-- l. 3336 --><p class='indent'>   Etapa 3
</p><!-- l. 3338 --><p class='noindent'>Realizar \(\mathbb{P}_{2}\) con dato de entrada \(x_{2}\) para obtener un elemento \(e_{2}\in S_{2}\)
</p><!-- l. 3341 --><p class='indent'>   Etapa 4
</p><!-- l. 3343 --><p class='noindent'>Si \(e_{1}=e_{2}\), entonces dar como dato de salida \(e_{1}.\) En caso contrario dar como dato de salida
\(e_{0}\).
</p><!-- l. 3346 --><p class='indent'>   Dejamos al lector la prueba de que este procedimiento enumera a \(S_{1}\cap S_{2}\).          □
</p>
   </div>
<!-- l. 3350 --><p class='indent'>   Dejamos al lector la prueba del siguiente resultado.
</p>
   <div class='newtheorem'>
<!-- l. 3351 --><p class='noindent'><span class='head'>
<a id='x1-57011r28'></a>
<span class='cmbx-10'>Lema 28.</span>  </span><span class='cmti-10'>Supongamos</span> \(S_{1},...,S_{n}\subseteq \omega \)<span class='cmti-10'>,</span> \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) <span class='cmti-10'>son conjuntos no vacios. Entonces</span> \(S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente
</span><span class='cmti-10'>enumerable sii</span> \(S_{1},...,S_{n},L_{1},...,L_{m}\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-efectivamente enumerables</span>

</p>
   </div>
<!-- l. 3360 --><p class='indent'>   @@finpagina@@
</p>
   <div class='newtheorem'>
<!-- l. 3361 --><p class='noindent'><span class='head'>
<a id='x1-57012r29'></a>
<span class='cmbx-10'>Lema 29.</span>  </span><span class='cmti-10'>Si</span>  \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\)  <span class='cmti-10'>es</span>  \(\Sigma \)<span class='cmti-10'>-efectivamente  computable  entonces</span>  \(S\)  <span class='cmti-10'>es</span>  \(\Sigma \)<span class='cmti-10'>-efectivamente
</span><span class='cmti-10'>enumerable.</span>
</p>
   </div>
<!-- l. 3366 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 3367 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(S\neq \emptyset \). Sea \((\vec{z},\gamma )\in S\), fijo. Sea \(\mathbb{P}\) un procedimiento efectivo que compute a
\(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\). Ya vimos en el ejemplo anterior que \(\omega ^{2}\times \Sigma ^{\ast 3}\) es \(\Sigma \)-efectivamente enumerable. En forma
similar se puede ver que \(\omega ^{n}\times \Sigma ^{\ast m}\) lo es. Sea \(\mathbb{P}_{1}\) un procedimiento efectivo que enumere a \(\omega ^{n}\times \Sigma ^{\ast m}\).
Entonces el siguiente procedimiento enumera a \(S\):
</p><!-- l. 3375 --><p class='indent'>   Etapa 1
</p><!-- l. 3377 --><p class='noindent'>Realizar \(\mathbb{P}_{1}\) con \(x\) de entrada para obtener \((\vec{x},\vec{\alpha })\in \omega ^{n}\times \Sigma ^{\ast m}\).
</p><!-- l. 3380 --><p class='indent'>   Etapa 2
</p><!-- l. 3382 --><p class='noindent'>Realizar \(\mathbb{P}\) con \((\vec{x},\vec{\alpha })\) de entrada para obtener el valor Booleano \(e\) de salida.
</p><!-- l. 3385 --><p class='indent'>   Etapa 3
</p><!-- l. 3387 --><p class='noindent'>Si \(e=1\) dar como dato de salida \((\vec{x},\vec{\alpha }).\) Si \(e=0\) dar como dato de salida \((\vec{z},\gamma )\).                          □
</p>
   </div>
<!-- l. 3392 --><p class='indent'>   Como veremos mas adelante en la materia (Proposicion <a href='#x1-135006r136'>136<!-- tex4ht:ref: A es EE y no EC  --></a>), hay conjuntos que
son \(\Sigma \)-efectivamente enumerables y no \(\Sigma \)-efectivamente computables. Sin envargo
tenemos el siguiente interesante resultado:
</p>
   <div class='newtheorem'>
<!-- l. 3395 --><p class='noindent'><span class='head'>
<a id='x1-57013r30'></a>
<span class='cmbx-10'>Teorema 30.</span>  </span><span class='cmti-10'>Sea</span> \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\)<span class='cmti-10'>. Son equivalentes</span>

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-57014x30'>\(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable</span>
     </li>
     <li class='enumerate' id='x1-57015x30'>\(S\) <span class='cmti-10'>y</span> \((\omega ^{n}\times \Sigma ^{\ast m})-S\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-efectivamente enumerables</span></li></ol>
   </div>
<!-- l. 3404 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 3405 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a)\(\Rightarrow \)(b). Por el lema anterior tenemos que \(S\) es \(\Sigma \)-efectivamente enumerable.
Notese ademas que, dado que \(S\) es \(\Sigma \)-efectivamente computable, \((\omega ^{n}\times \Sigma ^{\ast m})-S\) tambien lo es
(por que?). Es decir que aplicando nuevamente el lema anterior tenemos que \((\omega ^{n}\times \Sigma ^{\ast m})-S\)
es \(\Sigma \)-efectivamente enumerable.
</p><!-- l. 3412 --><p class='indent'>   (b)\(\Rightarrow \)(a). Si \(S=\emptyset \) o \(S=\omega ^{n}\times \Sigma ^{\ast m}\) es claro que se cumple (a). O sea que podemos suponer que ni
\(S\) ni \(\omega ^{n}\times \Sigma ^{\ast m}\) son igual al conjunto vacio. Sea \(\mathbb{P}_{1}\) un procedimiento efectivo que enumere a
\(S\) y sea \(\mathbb{P}_{2}\) un procedimiento efectivo que enumere a \((\omega ^{n}\times \Sigma ^{\ast m})-S\). Es facil ver que el siguiente
procedimiento computa el predicado \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\):
</p><!-- l. 3419 --><p class='indent'>   Etapa 1
</p><!-- l. 3421 --><p class='noindent'>Darle a la variable \(T\) el valor \(0\).
</p><!-- l. 3423 --><p class='indent'>   Etapa 2
</p><!-- l. 3425 --><p class='noindent'>Realizar \(\mathbb{P}_{1}\) con el valor de \(T\) como entrada para obtener de salida la upla \((\vec{y},\vec{\beta })\).
</p><!-- l. 3428 --><p class='indent'>   Etapa 3
</p><!-- l. 3430 --><p class='noindent'>Realizar \(\mathbb{P}_{2}\) con el valor de \(T\) como entrada para obtener de salida la upla \((\vec{z},\vec{\gamma })\).
</p><!-- l. 3433 --><p class='indent'>   Etapa 4
</p><!-- l. 3435 --><p class='noindent'>Si \((\vec{y},\vec{\beta })=(\vec{x},\vec{\alpha })\), entonces detenerse y dar como dato de salida el valor \(1\). Si \((\vec{z},\vec{\gamma })=(\vec{x},\vec{\alpha })\), entonces detenerse
y dar como dato de salida el valor \(0.\) Si no suceden ninguna de las dos posibilidades
antes mensionadas, aumentar en \(1\) el valor de la variable \(T\) y dirijirse a la Etapa
2.                                                                                                    □
</p>
   </div>
<!-- l. 3443 --><p class='indent'>   Supongamos que \(k,l,n,m\in \omega \) y que \(F:D_{F}\subseteq \omega ^{k}\times \Sigma ^{\ast l}\rightarrow \omega ^{n}\times \Sigma ^{\ast m}\). Supongamos ademas que \(n+m\geq 1\). Entonces denotaremos con \(F_{(i)}\) a
la funcion \(p_{i}^{n,m}\circ F\). Notar que </p><div class='eqnarray'>\begin{eqnarray*} F_{(i)} &amp; : &amp; D_{F}\subseteq \omega ^{k}\times \Sigma ^{\ast l}\rightarrow \omega \text{, para cada }i=1,...,n\\ F_{(i)} &amp; : &amp; D_{F}\subseteq \omega ^{k}\times \Sigma ^{\ast l}\rightarrow \Sigma ^{\ast }\text{, para cada }i=n+1,...,n+m \end{eqnarray*}
</div>Por lo cual cada una de las funciones \(F_{(i)}\) son \(\Sigma \)-mixtas. Ademas notese que \[ F=[F_{(1)},...,F_{(n+m)}] \]
   <div class='newtheorem'>
<!-- l. 3456 --><p class='noindent'><span class='head'>
<a id='x1-57016r31'></a>
<span class='cmbx-10'>Teorema 31.</span>  </span><span class='cmti-10'>Dado</span> \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\)<span class='cmti-10'>, son equivalentes</span>

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-57017x31'>\(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente enumerable</span>
     </li>
     <li class='enumerate' id='x1-57018x31'>\(S=I_{F}\)<span class='cmti-10'>, para alguna</span> \(F:D_{F}\subseteq \omega ^{k}\times \Sigma ^{\ast l}\rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>tal que cada</span> \(F_{(i)}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable.</span>
     </li>
     <li class='enumerate' id='x1-57019x31'>\(S=D_{f}\)<span class='cmti-10'>, para alguna funcion</span> \(f\) <span class='cmti-10'>la cual es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable.</span></li></ol>
   </div>
<!-- l. 3468 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 3469 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>El caso \(n=m=0\) es facil y es dejado al lector. Supongamos entonces que \(n+m\geq 1\).
</p><!-- l. 3472 --><p class='indent'>   (1)\(\Rightarrow \)(2) es trivial.
</p><!-- l. 3474 --><p class='indent'>   (2)\(\Rightarrow \)(3).  Para  \(i=1,...,n+m\),  sea  \(\mathbb{P}_{i}\)  un  procedimiento  el  cual  computa  a  \(F_{(i)}\)  y  sea  \(\mathbb{P}\)  un
procedimiento el cual enumere a \(\omega \times \omega ^{k}\times \Sigma ^{\ast l}.\) El siguiente procedimiento computa la funcion
\(f:I_{F}\rightarrow \{1\}\):
</p><!-- l. 3479 --><p class='indent'>   Etapa 1
</p><!-- l. 3481 --><p class='noindent'>Darle a la variable \(T\) el valor 0.
</p><!-- l. 3483 --><p class='indent'>   Etapa 2
</p><!-- l. 3485 --><p class='noindent'>Hacer correr \(\mathbb{P}\) con dato de entrada \(T\) y obtener \((t,z_{1},...,z_{k},\gamma _{1},...,\gamma _{l})\) como dato de salida.
</p><!-- l. 3488 --><p class='indent'>   Etapa 3
</p><!-- l. 3490 --><p class='noindent'>Para  cada  \(i=1,...,n+m\),  hacer  correr  \(\mathbb{P}_{i}\)  durante  \(t\)  pasos,  con  dato  de  entrada  \((z_{1},...,z_{k},\gamma _{1},...,\gamma _{l}).\)  Si  cada
procedimiento \(\mathbb{P}_{i}\) al cabo de los \(t\) pasos termino y dio como resultado el valor \(o_{i}\),
entonces comparar \((\vec{x},\vec{\alpha })\) con \((o_{1},...,o_{n+m})\) y en caso de que sean iguales detenerse y dar como
dato de salida el valor \(1\). En el caso en que no son iguales, aumentar en \(1\) el valor
de la variable \(T\) y dirijirse a la Etapa 2. Si algun procedimiento \(\mathbb{P}_{i}\) al cabo de los \(t\)
pasos no termino, entonces aumentar en \(1\) el valor de la variable \(T\) y dirijirse a la
Etapa 2.
</p><!-- l. 3501 --><p class='indent'>   (3)\(\Rightarrow \)(1). Supongamos \(S\neq \emptyset \). Sea \((\vec{z},\vec{\gamma })\) un elemento fijo de \(S\). Sea \(\mathbb{P}\) un procedimiento el
cual compute a \(f\). Sea \(\mathbb{P}_{1}\) un procedimiento el cual enumere a \(\omega \times \omega ^{n}\times \Sigma ^{\ast m}.\) Dejamos al lector el
diseño de un procedimiento efectivo el cual enumere \(D_{f}\).                              □
</p>
   </div>
<!-- l. 3509 --><p class='indent'>   Dejamos como ejercicio la prueba de los dos siguientes lemas.
</p>
   <div class='newtheorem'>
<!-- l. 3510 --><p class='noindent'><span class='head'>
<a id='x1-57020r32'></a>

<span class='cmbx-10'>Lema 32.</span>  </span><span class='cmti-10'>Sean</span>  \(n,m\in \omega \)  <span class='cmti-10'>y</span>  \(O\in \{\omega ,\Sigma ^{\ast }\}\)<span class='cmti-10'>.  Supongamos</span>  \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\)  <span class='cmti-10'>es</span>  \(\Sigma \)<span class='cmti-10'>-efectivamente  computable  y</span>  \(S\subseteq I_{f}\)  <span class='cmti-10'>es</span>
\(\Sigma \)<span class='cmti-10'>-efectivamente enumerable, entonces</span> \(f^{-1}(S)=\{(\vec{x},\vec{\alpha }):f(\vec{x},\vec{\alpha })\in S\}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente enumerable</span>
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 3518 --><p class='noindent'><span class='head'>
<a id='x1-57021r33'></a>
<span class='cmbx-10'>Lema 33.</span>  </span><span class='cmti-10'>Sean</span>  \(n,m\in \omega \)  <span class='cmti-10'>y</span>  \(O\in \{\omega ,\Sigma ^{\ast }\}\)<span class='cmti-10'>.  Supongamos</span>  \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\)  <span class='cmti-10'>es</span>  \(\Sigma \)<span class='cmti-10'>-efectivamente  computable  y</span>  \(S\subseteq D_{f}\)  <span class='cmti-10'>es</span>
\(\Sigma \)<span class='cmti-10'>-efectivamente enumerable, entonces</span> \(f|_{S}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable</span>
</p>
   </div>
<!-- l. 3528 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.4   </span> <a id='x1-580002.4'></a>Independencia del alfabeto</h4>
<!-- l. 3530 --><p class='noindent'>Una observacion importante es que los conceptos de funcion \(\Sigma \)-efectivamente
computable, de conjunto \(\Sigma \)-efectvamente computable y de conjunto \(\Sigma \)-efectivamente
enumerable, no dependen del alfabeto \(\Sigma \). Esto lo establecemos formalmente en los dos
siguientes lemas.
</p>
   <div class='newtheorem'>
<!-- l. 3534 --><p class='noindent'><span class='head'>
<a id='x1-58001r34'></a>
<span class='cmbx-10'>Lema 34.</span>  </span><span class='cmti-10'>Sean</span>  \(\Sigma \)  <span class='cmti-10'>y</span>  \(\Gamma \)  <span class='cmti-10'>alfabetos  cualesquiera.  Supongamos  una  funcion</span>  \(f\)  <span class='cmti-10'>es</span>
\(\Sigma \)<span class='cmti-10'>-mixta y</span> \(\Gamma \)<span class='cmti-10'>-mixta, entonces</span> \(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable sii</span> \(f\) <span class='cmti-10'>es</span> \(\Gamma \)<span class='cmti-10'>-efectivamente
</span><span class='cmti-10'>computable.</span>
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 3543 --><p class='noindent'><span class='head'>
<a id='x1-58002r35'></a>
<span class='cmbx-10'>Lema 35.</span>  </span><span class='cmti-10'>Sean</span> \(\Sigma \) <span class='cmti-10'>y</span> \(\Gamma \) <span class='cmti-10'>alfabetos cualesquiera. Supongamos un conjunto</span> \(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-mixto
</span><span class='cmti-10'>y</span>           \(\Gamma \)<span class='cmti-10'>-mixto,           entonces</span>           \(S\)           <span class='cmti-10'>es</span>           \(\Sigma \)<span class='cmti-10'>-efectivamente
</span><span class='cmti-10'>computable (resp.</span> \(\Sigma \)<span class='cmti-10'>-efectivamente enumerable) sii</span> \(S\) <span class='cmti-10'>es</span> \(\Gamma \)<span class='cmti-10'>-efectivamente computable
</span><span class='cmti-10'>(resp.</span> \(\Gamma \)<span class='cmti-10'>-efectivamente enumerable).</span>

</p>
   </div>
<!-- l. 3554 --><p class='indent'>   Dejamos al lector los detalles de las rutinarias pruebas de estos dos lemas.
</p><!-- l. 3560 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>3   </span> <a id='x1-590003'></a>Tres modelos matematicos de la computabilidad efectiva</h3>
<!-- l. 3562 --><p class='noindent'>Ya que el concepto de procedimiento efectivo es un concepto intuitivo, impresiso y a
priori no expresado en el formalismo matematico, los conceptos de
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-59001x3'>Funcion \(\Sigma \)-efectivamente computable
     </li>
     <li class='enumerate' id='x1-59002x3'>Conjunto \(\Sigma \)-efectivamente computable
     </li>
     <li class='enumerate' id='x1-59003x3'>Conjunto \(\Sigma \)-efectivamente enumerable</li></ol>
<!-- l. 3570 --><p class='noindent'>tambien son impresisos y estan fuera del formalismo matematico, debido a que los tres se
definen en terminos de la existencia de procedimientos efectivos. Por supuesto, los
tres conceptos son fundamentales en el estudio teorico de la computabilidad por lo
que es muy importante poder dar un modelo o formalizacion matematica de estos
conceptos. Pero notese que los dos ultimos se definen en funcion del primero por lo
que una formalizacion matematica precisa del concepto de funcion \(\Sigma \)-efectivamente
computable, resuelve el problema de modelizar en forma matematica estos a tres
conceptos.
</p><!-- l. 3580 --><p class='indent'>   En esta seccion daremos las tres formalizaciones matematicas mas clasicas del
concepto de funcion \(\Sigma \)-efectivamente computable. La primera y la mas apegada a la
idea intuitiva de procedimiento efectivo es la dada por Alan Turing via la
matematizacion del concepto de maquina. La segunda, es la dada por Godel en su
estudio de sistemas formales de la logica de primer orden. Por ultimo veremos la
formalizacion via un lenguaje de programacion imperativo. En honor a la influencia
que tuvo Von Neumann en el diseño de la primer computadora de caracter universal
(i.e. programable de proposito general), llamaremos a este paradigma el paradigma
imperativo de Von Neumann.
</p><!-- l. 3593 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.1   </span> <a id='x1-600003.1'></a>El paradigma de Turing</h4>

<!-- l. 3595 --><p class='noindent'>Estudiaremos el concepto de maquina de Turing, el cual fue introducido por Alam
Turing para formalizar o modelizar matematicamente la idea de procedimiento
efectivo. Una vez definidas las maquinas podremos dar modelizacion matematica
precisa del concepto de funcion \(\Sigma \)-efectivamente computable. Llamaremos a estas
funciones \(\Sigma \)-Turing computables y seran aquellas que (en algun sentido que sera bien
presisado matematicamente) pueden ser computadas por una maquina de Turing.
Por supuesto, la fidedignidad de este concepto, es decir cuan buena es la
modelizacion matematica dada por Turing, puede no ser clara al comienzo pero a
medida que vayamos avanzando en nuestro estudio y conozcamos ademas los
otros paradigmas y su relacion, quedara claro que el modelo de Turing es
acertado.
</p><!-- l. 3608 --><p class='indent'>   Vivimos en un mundo plagado de maquinas (ascensores, celulares, relojes,
taladros, etc). Una caracteristica comun a todas las maquinas es que tienen distintos
estados posibles. Un estado es el conjunto de caracteristicas que determinan un
momento concreto posible de la maquina cuando esta funcionando. Por ejemplo un
estado posible de un ascensor seria:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-60001x3.1'>esta en el tercer piso, con la primer puerta abierta y la otra cerrada, esta
     apretado el boton de ir al sexto piso, etc</li></ol>
<!-- l. 3617 --><p class='noindent'>donde ponemos etc porque dependiendo del tipo de ascensor (si es con memoria, a que
pisos puede ir, etc) habra mas datos que especificar para determinar un estado
concreto.
</p><!-- l. 3621 --><p class='indent'>   Otra caracteristica comun de las maquinas es que interactuan de distintas
formas con el usuario o mas generalmente su entorno. Dependiendo de que
accion se ejecute sobre la maquina y en que estado este, la maquina realizara
alguna tarea y ademas cambiara de estado. En general las maquinas son
deterministicas en el sentido que siempre que esten en determinado estado y se les
aplique determinada accion, realizaran la misma tarea y pasaran al mismo
estado.
</p><!-- l. 3632 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.1.1   </span> <a id='x1-610003.1.1'></a>Descripcion informal de las maquinas de Turing</h5>
<!-- l. 3634 --><p class='noindent'>Son un modelo abstracto de maquina con una cantidad finita de estados la cual
trabaja sobre una cinta de papel dividida en cuadros e interactua o recibe acciones
externas por medio de una cabeza lectora que lee de a un cuadro de la cinta a
la ves y ademas puede borrar el contenido del cuadro leido y escribir en
el un simbolo. Tambien la cabeza lectora puede moverse un cuadro hacia
la izquierda o hacia la derecha. La cinta tiene un primer cuadro hacia su
izquierda pero hacia la derecha puede extenderse todo lo necesario. En un
cuadro de la cinta podra haber un simbolo o un cuadro puede simplemente
estar en blanco. Es decir que habra un alfabeto \(\Gamma \) el cual consiste de todos

los simbolos que pueden figurar en la cinta. Esto sera parte de los datos o
caracteristicas de cada maquina, es decir, \(\Gamma \) puede cambiar dependiendo de la
maquina. La maquina, en funcion del estado en que se encuentre y de lo que
vea su cabeza lectora en el cuadro escaneado, podra moverse a lo sumo un
cuadro (izquierda, derecha o quedarse quieta), modificar lo que encuentre en
dicho cuadro (borrando y escribiendo algun nuevo simbolo) y cambiar de
estado (posiblemente al mismo que tenia). Para simplificar supondremos que
hay en \(\Gamma \) un simbolo el cual si aparece en un cuadro de la cinta, significara
que dicho cuadro esta sin escribir o en blanco. Esto nos permitira describir
mas facilmente el funcionamiento de la maquina. En gral llamaremos \(B\) a tal
simbolo. Tambien por lo general llamaremos \(Q\) al conjunto de estados de la
maquina.
</p><!-- l. 3658 --><p class='indent'>   Tambien cada maquina tendra un estado especial el cual sera llamado su estado
inicial, generalmente denotado con \(q_{0}\), el cual sera el estado en el que estara la maquina
al comenzar a trabajar sobre la cinta. Hay otras caracteristicas que tendran las
maquinas de Turing pero para dar un primer ejemplo ya nos basta. Describiremos
una maquina de Turing \(M\) que tendra \(\Gamma =\{@,a,b,B\}\) y tendra dos estados, es decir \(Q=\{q_{0},q_{1}\}\). Obviamente \(q_{0}\)
sera su estado inicial y ademas su ”comportamiento” estara dado por las siguientes
clausulas:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-61001x3.1.1'>Estando en estado \(q_{0}\) si ve ya sea \(b\) o \(B\) o \(@\), entonces se queda en estado \(q_{0}\) y se
     mueve a la derecha
     </li>
     <li class='enumerate' id='x1-61002x3.1.1'>Estando en estado \(q_{0}\) si ve \(a\) entonces reescribe \(@\), se mueve a la izquierda y
     cambia al estado \(q_{1}\)
     </li>
     <li class='enumerate' id='x1-61003x3.1.1'>Estando en estado \(q_{1}\) si ve \(a\) o \(b\) o \(B\) o \(@\) entonces lo deja como esta, se mueve a
     la izquierda y queda en estado \(q_{1}\)</li></ol>
<!-- l. 3675 --><p class='noindent'>Supongamos ahora que tomamos una palabra \(\alpha \in \Gamma ^{\ast }\) y la distribuimos en la cinta dejando el
primer cuadro en blanco y luego poniendo los simbolos de \(\alpha \) en los siguientes cuadros.
Supongamos ademas que ponemos la maquina en estado \(q_{0}\) y con su cabeza lectora
escaneando el primer cuadro de la cinta. Esto lo podemos representar graficamente de
la siguiente manera \[ \begin{array}{cccccccc} B &amp; \alpha _{1} &amp; ... &amp; \alpha _{n} &amp; B &amp; B &amp; B &amp; ...\\ \uparrow \\ q_{0} \end{array} \] donde \(\alpha _{1},...,\alpha _{n}\) son los sucesivos simbolos de \(\alpha \). Supongamos
ademas que \(a\) ocurre an \(\alpha \). Dejamos al lector ir aplicando las clausulas de \(M\) para
convencerse que luego de un rato de funcionar \(M\), la situacion sera \[ \begin{array}{cccccccc} B &amp; \beta _{1} &amp; ... &amp; \beta _{n} &amp; B &amp; B &amp; B &amp; ...\\ \uparrow \\ q_{1} \end{array} \] donde \(\beta _{1}...\beta _{n}\)
es el resultado de reemplazar en \(\alpha \) la primer ocurrencia de \(a\) por \(@\). Dejmos
como ejercicio para el lector averiguar que sucede cuando \(a\) no ocurre en
\(\alpha \)
</p><!-- l. 3705 --><p class='indent'>   Una cosa que puede pasar es que para un determinado estado \(p\) y un \(\sigma \in \Gamma \), la maquina
no tenga contemplada ninguna accion posible. Por ejemplo sea \(M\) la maquina de Turing
dada por \(Q=\{q_{0}\}\), \(\Gamma =\{@,\$,B\}\) y por la siguiente clausula:

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-61004x3.1.1'>Estando en estado \(q_{0}\) si ve ya sea \(@\) o \(B\), entonces se queda en estado \(q_{0}\) y se
     mueve a la derecha</li></ol>
<!-- l. 3713 --><p class='noindent'>Es facil ver que si partimos de una situacion \[ \begin{array}{cccccccc} B &amp; \alpha _{1} &amp; ... &amp; \alpha _{n} &amp; B &amp; B &amp; B &amp; ...\\ \uparrow \\ q_{0} \end{array} \] donde \(\alpha _{1},...,\alpha _{n}\in \Gamma \), entonces si ningun \(\alpha _{i}\) es igual a \(\$\), la
maquina se movera indefinidamente hacia la derecha y en caso contrario
se movera \(i\) pasos a la derecha y se detendra, donde \(i\) es el menor \(l\) tal que
\(\alpha _{i}=\$\).
</p><!-- l. 3726 --><p class='indent'>   Otro caso posible de detencion de una maquina de Turing es cuando esta
escaneando el primer cuadro de la cinta y su unica accion posible implica moverse un
cuadro a la izquierda. Tambien en estos casos diremos que la maquina se detiene ya
que la cinta no es extensible hacia la izquierda.
</p><!-- l. 3732 --><p class='indent'>   Otra caracteristica de las maquinas de Turing es que poseen un <span class='cmti-10'>alfabeto de
</span><span class='cmti-10'>entrada </span>el cual esta contenido en el alfabeto \(\Gamma \) y en el cual estan los simbolos que se
usaran para formar la configuracion inicial de la cinta (exepto \(B\)). En general lo
denotaremos con \(\Sigma \) al alfabeto de entrada y los simbolos de \(\Gamma -\Sigma \) son considerados
auxiliares. Tambien habra un conjunto \(F\) contenido en el conjunto \(Q\) de los estados de la
maquina, cuyos elementos seran llamados <span class='cmti-10'>estados finales</span>.
</p><!-- l. 3741 --><p class='indent'>   Diremos que una palabra \(w=w_{1}...w_{n}\in \Sigma ^{\ast }\) es <span class='cmti-10'>aceptada por</span> \(M\) (<span class='cmti-10'>por alcance de estado final</span>) si
partiendo de \[ \begin{array}{cccccccc} B &amp; w_{1} &amp; ... &amp; w_{n} &amp; B &amp; B &amp; B &amp; ...\\ \uparrow \\ q_{0} \end{array} \] en algun momento de la computacion \(M\) esta en un estado de \(F\).
Llamaremos \(L(M)\) al conjunto formado por todas las palabras que son aceptadas por
alcance de estado final
</p><!-- l. 3754 --><p class='indent'>   Diremos que una palabra \(w=w_{1}...w_{n}\in \Sigma ^{\ast }\) es <span class='cmti-10'>aceptada por</span> \(M\) (<span class='cmti-10'>por detencion</span>) si partiendo de \[ \begin{array}{cccccccc} B &amp; w_{1} &amp; ... &amp; w_{n} &amp; B &amp; B &amp; B &amp; ...\\ \uparrow \\ q_{0} \end{array} \] en
algun momento \(M\) se detiene. Llamaremos \(H(M)\) al conjunto formado por todas las palabras
que son aceptadas por detencion
</p><!-- l. 3769 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.1.2   </span> <a id='x1-620003.1.2'></a>Definicion matematica de maquina de Turing</h5>
<!-- l. 3771 --><p class='noindent'>Si bien las maquinas usadas por Turing para simular procedimientos efectivos son
deterministicas, estudiaremos aqui tambien a las maquinas de Turing no
deterministicas y sus lenguajes aceptados, dada su importancia en un tema central a
las ciencias de la computacion como la complejidad.
</p><!-- l. 3776 --><p class='indent'>   Una <span class='cmti-10'>maquina de Turing </span>es una 7-upla \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,F\right )\) donde
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-62001x3.1.2'>\(Q\) es un conjunto finito cuyos elementos son llamados <span class='cmti-10'>estados</span>
     </li>
     <li class='enumerate' id='x1-62002x3.1.2'>\(\Gamma \) es un alfabeto que contiene a \(\Sigma \)
     </li>
     <li class='enumerate' id='x1-62003x3.1.2'>\(\Sigma \) es un alfabeto llamado el <span class='cmti-10'>alfabeto de entrada</span>
     </li>
     <li class='enumerate' id='x1-62004x3.1.2'>\(B\in \Gamma -\Sigma \) es un simbolo de \(\Gamma \) llamado el <span class='cmti-10'>blank symbol</span>

     </li>
     <li class='enumerate' id='x1-62005x3.1.2'>\(\delta :Q\times \Gamma \rightarrow \mathcal{P}(Q\times \Gamma \times \{L,R,K\})\)
     </li>
     <li class='enumerate' id='x1-62006x3.1.2'>\(q_{0}\) es un estado llamado el <span class='cmti-10'>estado inicial </span>de \(M\)
     </li>
     <li class='enumerate' id='x1-62007x3.1.2'>\(F\subseteq Q\) es un conjunto de estados llamados <span class='cmti-10'>finales</span></li></ol>
<!-- l. 3788 --><p class='noindent'>Si bien en nuestra definicion de maquina de Turing no hay ninguna restriccion
acerca de la naturaleza de los elementos de \(Q\), para continuar nuestro analisis
asumiremos siempre que \(Q\) es un alfabeto disjunto con \(\Gamma \). Esto nos permitira
dar definiciones matematicas precisas que formalizaran el funcionamiento
de las maquinas de Turing en el contexto de las funciones mixtas. Deberia
quedar claro que el hecho que solo analicemos maquinas en las cuales \(Q\) es un
alfabeto disjunto con \(\Gamma \), no afectara la profundidad y generalidad de nuestros
resultados.
</p>
<!-- l. 3801 --><p class='noindent'><span class='paragraphHead'><a id='x1-630003.1.2'></a><span class='cmbx-10'>Maquinas de Turing deterministicas</span></span>
   Una maquina de Turing \(M\) sera llamada <span class='cmti-10'>deterministica </span>cuando se de que \(\left \vert \delta (p,\sigma )\right \vert \leq 1\),
cualesquiera sean \(p\in Q\) y \(\sigma \in \Gamma \).
</p>
<!-- l. 3807 --><p class='noindent'><span class='paragraphHead'><a id='x1-640003.1.2'></a><span class='cmbx-10'>Descripciones instantaneas</span></span>
   Una <span class='cmti-10'>descripcion instantanea </span>sera una palabra de la forma \(\alpha q\beta \), donde \(\alpha ,\beta \in \Gamma ^{\ast }\), \(\left [\beta \right ]_{\left \vert \beta \right \vert }\neq B\) y \(q\in Q\). La
descripcion instantanea \(\alpha _{1}...\alpha _{n}q\beta _{1}...\beta _{m}\), con \(\alpha _{1},...,\alpha _{n}\), \(\beta _{1},...,\beta _{m}\in \Gamma \), \(n,m\geq 0\) representara la siguiente situacion \[ \begin{array}{cccccccccccc} \alpha _{1} &amp; \alpha _{2} &amp; ... &amp; \alpha _{n} &amp; \beta _{1} &amp; \beta _{2} &amp; ... &amp; \beta _{m} &amp; B &amp; B &amp; B &amp; ...\\ &amp; &amp; &amp; &amp; \uparrow \\ &amp; &amp; &amp; &amp; q \end{array} \] Usaremos \(Des\) para
denotar el conjunto de las descripciones instantaneas. Definamos la funcion \(St:Des\rightarrow Q\), de la
siguiente manera \[ St(d)=\text{unico simbolo de }Q\text{ que ocurre en }d \]
</p>
<!-- l. 3828 --><p class='noindent'><span class='paragraphHead'><a id='x1-650003.1.2'></a><span class='cmbx-10'>La relacion</span> \(\vdash \)</span>
   Dado \(\alpha \in (Q\cup \Gamma )^{\ast }\), definamos \(\left \lfloor \alpha \right \rfloor \) de la siguiente manera </p><div class='eqnarray'>\begin{eqnarray*} \left \lfloor \varepsilon \right \rfloor &amp; = &amp; \varepsilon \\ \left \lfloor \alpha \sigma \right \rfloor &amp; = &amp; \alpha \sigma \text{, si }\sigma \neq B\\ \left \lfloor \alpha B\right \rfloor &amp; = &amp; \left \lfloor \alpha \right \rfloor  \end{eqnarray*}
</div>Es decir \(\left \lfloor \alpha \right \rfloor \) es el resultado de remover de \(\alpha \) el tramo final mas grande de la forma \(B^{n}\). Dada
cualquier palabra \(\alpha \) definimos \[ ^{\curvearrowright }\alpha =\left \{ \begin{array}{lll} \left [\alpha \right ]_{2}...\left [\alpha \right ]_{\left \vert \alpha \right \vert } &amp; \text{si} &amp; \left \vert \alpha \right \vert \geq 2\\ \varepsilon &amp; \text{si} &amp; \left \vert \alpha \right \vert \leq 1 \end{array}\right .\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \alpha ^{\curvearrowleft }=\left \{ \begin{array}{lll} \left [\alpha \right ]_{1}...\left [\alpha \right ]_{\left \vert \alpha \right \vert -1} &amp; \text{si} &amp; \left \vert \alpha \right \vert \geq 2\\ \varepsilon &amp; \text{si} &amp; \left \vert \alpha \right \vert \leq 1 \end{array}\right . \] Dadas \(d_{1},d_{2}\in Des\), escribiremos \(d_{1}\vdash d_{2}\) cuando existan \(\sigma \in \Gamma \), \(\alpha ,\beta \in \Gamma ^{\ast }\) y \(p,q\in Q\) tales que se
cumple alguno de los siguientes casos
<!-- l. 3853 --><p class='indent'>   Caso 1. </p><div class='eqnarray'>\begin{eqnarray*} d_{1} &amp; = &amp; \alpha p\beta \\ (q,\sigma ,R) &amp; \in &amp; \delta \left (p,\left [\beta B\right ]_{1}\right )\\ d_{2} &amp; = &amp; \alpha \sigma q^{\curvearrowright }\beta  \end{eqnarray*}
</div>
<!-- l. 3860 --><p class='indent'>   Caso 2. </p><div class='eqnarray'>\begin{eqnarray*} d_{1} &amp; = &amp; \alpha p\beta \\ (q,\sigma ,L) &amp; \in &amp; \delta \left (p,\left [\beta B\right ]_{1}\right )\text{ y }\alpha \neq \varepsilon \\ d_{2} &amp; = &amp; \left \lfloor \alpha ^{\curvearrowleft }q\left [\alpha \right ]_{\left \vert \alpha \right \vert }\sigma ^{\curvearrowright }\beta \right \rfloor  \end{eqnarray*}
</div>

<!-- l. 3867 --><p class='indent'>   Caso 3. </p><div class='eqnarray'>\begin{eqnarray*} d_{1} &amp; = &amp; \alpha p\beta \\ (q,\sigma ,K) &amp; \in &amp; \delta (p,\left [\beta B\right ]_{1})\\ d_{2} &amp; = &amp; \left \lfloor \alpha q\sigma ^{\curvearrowright }\beta \right \rfloor  \end{eqnarray*}
</div>Escribiremos \(d\nvdash d^{\prime }\) para expresar que no se da \(d\vdash d^{\prime }\). Para \(d,d^{\prime }\in Des\) y \(n\geq 0\), escribiremos \(d\overset{n}{\vdash }d^{\prime }\) si existen \(d_{1},...,d_{n+1}\in Des\) tales que
<div class='eqnarray'>\begin{eqnarray*} d &amp; = &amp; d_{1}\\ d^{\prime } &amp; = &amp; d_{n+1}\\ d_{i} &amp; \vdash &amp; d_{i+1}\text{, para }i=1,...,n. \end{eqnarray*}
</div>Notese que \(d\overset{0}{\vdash }d^{\prime }\) sii \(d=d^{\prime }\). Finalmente definamos \[ d\overset{\ast }{\vdash }d^{\prime }\text{ sii }(\exists n\in \omega )\;d\overset{n}{\vdash }d^{\prime }\text{.} \]
<!-- l. 3888 --><p class='noindent'><span class='paragraphHead'><a id='x1-660003.1.2'></a><span class='cmbx-10'>Detencion</span></span>
   Dada \(d\in Des\), diremos que \(M\) <span class='cmti-10'>se detiene partiendo de</span> \(d\) si existe \(d^{\prime }\in Des\) tal que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-66001x3.1.2'>\(d\overset{\ast }{\vdash }d^{\prime }\)
     </li>
     <li class='enumerate' id='x1-66002x3.1.2'>\(d^{\prime }\nvdash d^{\prime \prime }\), para cada \(d^{\prime \prime }\in Des\)</li></ol>
<!-- l. 3896 --><p class='noindent'>Deberia quedar claro que es posible que \(\alpha p\beta \nvdash d\), para cada descripcion instantanea \(d\), y que \(\delta (p,[\beta B]_{1})\) sea
no vacio.
</p>
<!-- l. 3900 --><p class='noindent'><span class='paragraphHead'><a id='x1-670003.1.2'></a><span class='cmbx-10'>El lenguaje</span> \(L(M)\)</span>
   Diremos que una palabra \(w\in \Sigma ^{\ast }\) es <span class='cmti-10'>aceptada por</span> \(M\) (<span class='cmti-10'>por alcance de estado final</span>) cuando \[ \left \lfloor q_{0}Bw\right \rfloor \overset{\ast }{\vdash }d\text{, con }d\text{ tal que }St(d)\in F. \]
El <span class='cmti-10'>lenguage aceptado por</span> \(M\) (<span class='cmti-10'>por alcance de estado final</span>) se define de la siguiente
manera \[ L(M)=\{w\in \Sigma ^{\ast }:w\text{ es aceptada por }M\text{ por alcance de estado final}\}\text{.} \]
</p>
<!-- l. 3914 --><p class='noindent'><span class='paragraphHead'><a id='x1-680003.1.2'></a><span class='cmbx-10'>El lenguaje</span> \(H(M)\)</span>
   Diremos que una palabra \(w\in \Sigma ^{\ast }\) es <span class='cmti-10'>aceptada por</span> \(M\) (<span class='cmti-10'>por detencion</span>) cuando \(M\) se detiene
partiendo de \(\left \lfloor q_{0}Bw\right \rfloor \). El <span class='cmti-10'>lenguage aceptado por</span> \(M\) (<span class='cmti-10'>por detencion</span>) se define de la siguiente
manera \[ H(M)=\{w\in \Sigma ^{\ast }:w\text{ es aceptada por }M\text{ por detencion}\} \]
</p><!-- l. 3924 --><p class='indent'>   Aceptaremos sin demostracion el siguiente resultado.
</p>
   <div class='newtheorem'>
<!-- l. 3925 --><p class='noindent'><span class='head'>
<a id='x1-68001r36'></a>
<span class='cmbx-10'>Lema 36.</span>  </span><span class='cmti-10'>Sea</span> \(L\subseteq \Sigma ^{\ast }\)<span class='cmti-10'>. Entonces son equivalentes</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-68002x36'><span class='cmti-10'>Existe una maquina de Turing</span> \(M=(Q,\Sigma ,\Gamma ,\delta ,q_{0},B,F)\) <span class='cmti-10'>tal que</span> \(L=L(M)\)
     </li>
     <li class='enumerate' id='x1-68003x36'><span class='cmti-10'>Existe una maquina de Turing</span> \(M=(Q,\Sigma ,\Gamma ,\delta ,q_{0},B,F)\) <span class='cmti-10'>tal que</span> \(L=H(M)\)</li></ol>

   </div>
<!-- l. 3935 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 3936 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(1)\(\Rightarrow \)(2). Dada una maquina \(M=(Q,\Sigma ,\Gamma ,\delta ,q_{0},B,F)\), costruiremos una maquina \(M_{1}=(Q_{1},\Sigma ,\Gamma _{1},\delta _{1},\tilde{q}_{0},B,\emptyset )\) tal que \(L(M)=H(M_{1})\). Tomaremos \(\Gamma _{1}=\Gamma \cup \{X\}\),
con \(X\) un simbolo nuevo no perteneciente a \(\Gamma \). Para cada \(a\in \Sigma \), sea \(q_{a}\) un estado nuevo, no
perteneciente a \(Q.\) Sean \(\tilde{q}_{0},q_{r},q_{d},q_{B}\) estados nuevos no pertenecientes a \(Q.\) Tomemos entonces \[ Q_{1}=Q\cup \{\tilde{q}_{0},q_{r},q_{d},q_{B}\}\cup \{q_{a}:a\in \Sigma \} \]
Finalmente definamos \(\delta _{1}\) de la siguiente manera: </p><div class='eqnarray'>\begin{eqnarray*} \delta _{1}(\tilde{q}_{0},B) &amp; = &amp; \{(q_{B},X,R)\}\\ \delta _{1}(q_{B},a) &amp; = &amp; \{(q_{a},B,R)\}\text{, para }a\in \Sigma \\ \delta _{1}(q_{B},B) &amp; = &amp; \{(q_{0},B,K)\}\\ \delta _{1}(q_{a},b) &amp; = &amp; \{(q_{b},a,R)\}\text{, para }a,b\in \Sigma \\ \delta _{1}(q_{a},B) &amp; = &amp; \{(q_{r},a,L)\}\text{, para }a\in \Sigma \\ \delta _{1}(q_{r},a) &amp; = &amp; \{(q_{r},a,L)\}\text{, para }a\in \Sigma \\ \delta _{1}(q_{r},B) &amp; = &amp; \{(q_{0},B,K)\}\\ \delta _{1}(q,X) &amp; = &amp; \{(q,X,K)\}\text{, para }q\in Q\\ \delta _{1}(q,\sigma ) &amp; = &amp; \delta (q,\sigma )\cup \{(q_{d},\sigma ,K)\}\text{, para }q\in F\text{ y }\sigma \in \Gamma \\ \delta _{1}(q,\sigma ) &amp; = &amp; \delta (q,\sigma )\text{, para }q\in Q-F\text{ y }\sigma \in \Gamma \\ \delta _{1}(q_{d},\sigma ) &amp; = &amp; \emptyset \text{, para }\sigma \in \Gamma  \end{eqnarray*}
</div>(\(\delta _{1}\) se define igual a vacio para los casos no contemplados arriba).
<!-- l. 3963 --><p class='indent'>   (2)\(\Rightarrow \)(1). Dada \(M=(Q,\Sigma ,\Gamma ,\delta ,q_{0},B,F)\), dejamos al lector la construccion de una maquina \(M_{1}=(Q_{1},\Sigma ,\Gamma _{1},\delta _{1},\tilde{q}_{0},B,\emptyset )\) tal que
\(H(M)=L(M_{1})\).                                                                                                     □
</p>
   </div>
<!-- l. 3970 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.1.3   </span> <a id='x1-690003.1.3'></a>Funciones \(\Sigma \)-Turing computables</h5>
<!-- l. 3972 --><p class='noindent'>Para poder computar funciones mixtas con una maquina de Turing necesitaremos un
simbolo para representar numeros sobre la cinta. Llamaremos a este simbolo <span class='cmti-10'>unit </span>y lo
denotaremos con \(\shortmid \). Mas formalmente una <span class='cmti-10'>maquina de Turing con unit </span>es una 8-upla \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,\shortmid ,F\right )\)
tal que \(\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,F\right )\) es una maquina de Turing y \(\shortmid \) es un simbolo distingido perteneciente a
\(\Gamma -(\{B\}\cup \Sigma )\).
</p><!-- l. 3980 --><p class='indent'>   Diremos que una funcion \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \Sigma ^{\ast }\) es \(\Sigma \)-<span class='cmti-10'>Turing computable </span>si existe una maquina de Turing
deterministica con unit, \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,\shortmid ,F\right )\) tal que:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-69001x3.1.3'>Si \((\vec{x},\vec{\alpha })\in D_{f}\), entonces hay un \(p\in Q\) tal que \[ \left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right \rfloor \overset{\ast }{\vdash }\left \lfloor pBf(\vec{x},\vec{\alpha })\right \rfloor \] y \(\left \lfloor pBf(\vec{x},\vec{\alpha })\right \rfloor \nvdash d\), para cada \(d\in Des\)
     </li>
     <li class='enumerate' id='x1-69002x3.1.3'>Si \((\vec{x},\vec{\alpha })\in \omega ^{n}\times \Sigma ^{\ast m}-D_{f}\), entonces \(M\) no se detiene partiendo de \[ \left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right \rfloor . \]</li></ol>
<!-- l. 3998 --><p class='noindent'>En forma similar, una funcion \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast }{}^{m}\rightarrow \omega \), es llamada \(\Sigma \)-<span class='cmti-10'>Turing computable </span>si existe una maquina de
Turing deterministica con unit, \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,\shortmid ,F\right )\), tal que:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-69003x3.1.3'>Si \((\vec{x},\vec{\alpha })\in D_{f}\), entonces hay un \(p\in Q\) tal que \[ \left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right \rfloor \overset{\ast }{\vdash }\left \lfloor pB\shortmid ^{f(\vec{x},\vec{\alpha })}\right \rfloor \] y \(\left \lfloor pB\shortmid ^{f(\vec{x},\vec{\alpha })}\right \rfloor \nvdash d\), para cada \(d\in Des\)
     </li>
     <li class='enumerate' id='x1-69004x3.1.3'>Si \((\vec{x},\vec{\alpha })\in \omega ^{n}\times \Sigma ^{\ast m}-D_{f}\), entonces \(M\) no se detiene partiendo de \[ \left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right \rfloor \]</li></ol>

<!-- l. 4016 --><p class='noindent'>Cuando \(M\) y \(f\) cumplan los items (1) y (2) de la definicion anterior, diremos que la funcion \(f\)
es <span class='cmti-10'>computada </span>por \(M\).
</p><!-- l. 4019 --><p class='indent'>   Por supuesto esta definicion no tendria sentido como modelo matematico del
concepto de funcion \(\Sigma \)-efectivamente computable si no sucediera que toda funcion
\(\Sigma \)-Turing computable fuera \(\Sigma \)-efectivamente computable. Este hecho es intuitivamente
claro y lo expresamos en forma de proposicion.
</p>
   <div class='newtheorem'>
<!-- l. 4024 --><p class='noindent'><span class='head'>
<a id='x1-69005r37'></a>
<span class='cmbx-10'>Proposition 37.</span>  </span><span class='cmti-10'>Sean</span>  \(n,m\in \omega \)  <span class='cmti-10'>y</span>  \(O\in \{\omega ,\Sigma ^{\ast }\}\)<span class='cmti-10'>.  Si</span>  \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast }{}^{m}\rightarrow O\)  <span class='cmti-10'>es  computada  por  una  maquina  de  Turing
</span><span class='cmti-10'>deterministica con unit</span> \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,\shortmid ,F\right )\)<span class='cmti-10'>, entonces</span> \(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable.</span>
</p>
   </div>
<!-- l. 4030 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4031 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Haremos el caso \(O=\Sigma ^{\ast }\). Sea \(\mathbb{P}\) el siguiente procedimiento efectivo.
</p><!-- l. 4034 --><p class='indent'>   - Conjunto de datos de entrada de \(\mathbb{P}\) igual a \(\omega ^{n}\times \Sigma ^{\ast }{}^{m}\)
</p><!-- l. 4036 --><p class='indent'>   - Conjunto de datos de salida de \(\mathbb{P}\) contenido en \(O\)
</p><!-- l. 4038 --><p class='indent'>   - Funcionamiento: Hacer funcionar paso a paso la maquina \(M\) partiendo de
la descripcion instantanea \(\left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right \rfloor \). Si en alguna instancia \(M\) termina, dar como salida
el resultado de remover de la descripcion instantanea final los dos primeros
simbolos.
</p><!-- l. 4043 --><p class='indent'>   Notese que este procedimiento termina solo en aquelos elementos \((\vec{x},\vec{\sigma })\in \omega ^{n}\times \Sigma ^{\ast }{}^{m}\) tales que la
maquina \(M\) termina partiendo desde \[ \left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right \rfloor \] por lo cual termina solo en los elementos de \(D_{f}\)
ya que \(M\) computa a \(f\). Ademas es claro que en caso de terminacion el procedimiento
da como salida \(f(\vec{x},\vec{\sigma })\).                                                                                 □
</p>
   </div>
<!-- l. 4054 --><p class='indent'>   Sin envargo el modelo Turingniano podria a priori no ser del todo correcto ya que
podria pasar que haya una funcion que sea computada por un procedimiento efectivo
pero que no exista una maquina de Turing que la compute. En otras palabras el
modelo Turingniano podria ser incompleto. La completitud de este modelo puede no
ser clara al comienzo pero a medida que vayamos avanzando en nuestro estudio y
conozcamos ademas los otros paradigmas y su relacion, quedara claro que el modelo
de Turing es acertado.

</p><!-- l. 4063 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.1.4   </span> <a id='x1-700003.1.4'></a>Conjuntos \(\Sigma \)-Turing enumerables</h5>
<!-- l. 4065 --><p class='noindent'>Ya que la nocion de funcion \(\Sigma \)-Turing computable es el modelo matematico de Turing
del concepto de funcion \(\Sigma \)-efectivamente computable, nos podriamos preguntar
entonces cual es el modelo matematico de Turing del concepto de conjunto
\(\Sigma \)-efectivamente enumerable. Si prestamos atencion a la definicion de conjunto
\(\Sigma \)-efectivamente enumerable, notaremos que depende de la existencia de ciertas
funciones \(\Sigma \)-efectivamente computables por lo cual la siguiente definicion cae de
maduro:
</p><!-- l. 4074 --><p class='indent'>   Diremos que un conjunto \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) sera llamado \(\Sigma \)<span class='cmti-10'>-Turing enumerable </span>cuando sea
vacio o haya una funcion \(F:\omega \rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) tal que \(I_{F}=S\) y \(F_{(i)}\) sea \(\Sigma \)-Turing computable, para cada
\(i\in \{1,...,n+m\}\).
</p><!-- l. 4080 --><p class='indent'>   Deberia quedar claro que si el concepto de funcion \(\Sigma \)-Turing computable
modeliza correctamente al concepto de funcion \(\Sigma \)-efectivamente computable,
entonces el concepto de conjunto \(\Sigma \)-Turing enumerable recien definido modeliza
correctamente al concepto de conjunto \(\Sigma \)-efectivamente enumerable. Notese que segun
la definicion que acabamos de escribir, un conjunto no vacio \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) es \(\Sigma \)-Turing
enumerable si y solo si hay maquinas de Turing deterministicas con unit
</p><div class='eqnarray'>\begin{eqnarray*} M_{1} &amp; = &amp; \left (Q_{1},\Sigma ,\Gamma _{1},\delta _{1},q_{01},B,\shortmid ,F_{1}\right )\\ M_{2} &amp; = &amp; \left (Q_{2},\Sigma ,\Gamma _{2},\delta _{2},q_{02},B,\shortmid ,F_{2}\right )\\ &amp; &amp; \vdots \\ M_{n+m} &amp; = &amp; \left (Q_{n+m},\Sigma ,\Gamma _{n+m},\delta _{n+m},q_{0n+m},B,\shortmid ,F_{n+m}\right ) \end{eqnarray*}
</div>tales que
     <ol class='enumerate1'>
     <li class='enumerate' id='x1-70001x3.1.4'>cada \(M_{i}\), con \(i=1,...,n\), computa una funcion \(F_{i}:\omega \rightarrow \omega \)
     </li>
     <li class='enumerate' id='x1-70002x3.1.4'>cada \(M_{i}\), con \(i=n+1,...,n+m\), computa una funcion \(F_{i}:\omega \rightarrow \Sigma ^{\ast }\)
     </li>
     <li class='enumerate' id='x1-70003x3.1.4'>\(S=\mathrm{Im}[F_{1},...,F_{n+m}]\)</li></ol>
<!-- l. 4100 --><p class='noindent'>Como puede notarse las maquinas \(M_{1},...,M_{n+m}\) puestas en paralelo a funcionar desde la descripciones
instantaneas </p><div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left \lfloor q_{01}B\shortmid ^{x}\right \rfloor \\ &amp; &amp; \left \lfloor q_{02}B\shortmid ^{x}\right \rfloor \\ &amp; &amp; \ \ \ \ \ \ \ \ \ \vdots \\ &amp; &amp; \left \lfloor q_{0n+m}B\shortmid ^{x}\right \rfloor  \end{eqnarray*}
</div>producen en forma natural un procedimiento efectivo (con dato de entrada \(x\in \omega \)) que
enumera a \(S\)  Por supuesto podemos decir que en tal caso las maquinas \(M_{1},...,M_{n+m}\) enumeran a \(S\).
La siguiente proposicion muestra que tambien las cosas se pueden hacer con una sola
maquina de Turing.
   <div class='newtheorem'>
<!-- l. 4116 --><p class='noindent'><span class='head'>
<a id='x1-70004r38'></a>
<span class='cmbx-10'>Proposition 38.</span>  </span><span class='cmti-10'>Sea</span> \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>un conjunto no vacio. Entonces</span> \(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-Turing enumerable si y
</span><span class='cmti-10'>solo si hay una maquina de Turing deterministica con unit</span> \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,\shortmid ,F\right )\)<span class='cmti-10'>, tal que:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-70005x38'><span class='cmti-10'>Para cada</span> \(x\in \omega \)<span class='cmti-10'>, tenemos que</span> \(M\) <span class='cmti-10'>se detiene partiendo de</span> \(\left \lfloor q_{0}B\shortmid ^{x}\right \rfloor \) <span class='cmti-10'>y llega a una descripcion
     </span><span class='cmti-10'>instantanea de la forma</span> \(\left \lfloor qB\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right \rfloor \)<span class='cmti-10'>, con</span> \((\vec{x},\vec{\alpha })\in S\)<span class='cmti-10'>.</span>

     </li>
     <li class='enumerate' id='x1-70006x38'><span class='cmti-10'>Para  cada</span>  \((\vec{x},\vec{\alpha })\in S\)  <span class='cmti-10'>hay  un</span>  \(x\in \omega \)  <span class='cmti-10'>tal  que</span>  \(M\)  <span class='cmti-10'>se  detiene  partiendo  de</span>  \(\left \lfloor q_{0}B\shortmid ^{x}\right \rfloor \)  <span class='cmti-10'>y  llega  a  una
     </span><span class='cmti-10'>descripcion instantanea de la forma</span> \(\left \lfloor qB\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right \rfloor \)</li></ol>
   </div>
<!-- l. 4132 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4133 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Queda  como  ejercicio  ver  como  construir  la  maquina  \(M\)  utilizando  las
maquinas  \(M_{1},...,M_{n+m}\)  y  reciprocamente  ver  como  a  partir  de  una  maquina  \(M\)  con  las
propiedades (1) y (2) se pueden construir las maquinas \(M_{1},...,M_{n+m}\).                            □
</p>
   </div>
<!-- l. 4141 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.1.5   </span> <a id='x1-710003.1.5'></a>Conjuntos \(\Sigma \)-Turing computables</h5>
<!-- l. 4143 --><p class='noindent'>La version Turingniana del concepto de conjunto \(\Sigma \)-efectivamente computable es facil
de dar: un conjunto \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) sera llamado \(\Sigma \)<span class='cmti-10'>-Turing computable </span>cuando la funcion \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) sea \(\Sigma \)-Turing
computable. O sea que \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) es \(\Sigma \)-Turing computable sii hay una maquina de Turing
deterministica con unit \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,\shortmid ,F\right )\) la cual computa a \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\), es decir:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-71001x3.1.5'>Si \((\vec{x},\vec{\alpha })\in S\), entonces hay un \(p\in Q\) tal que \[ \left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right \rfloor \overset{\ast }{\vdash }\left \lfloor pB\shortmid \right \rfloor \] y \(\left \lfloor pB\shortmid \right \rfloor \nvdash d\), para cada \(d\in Des\)
     </li>
     <li class='enumerate' id='x1-71002x3.1.5'>Si \((\vec{x},\vec{\alpha })\in (\omega ^{n}\times \Sigma ^{\ast m})-S\), entonces hay un \(p\in Q\) tal que \[ \left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right \rfloor \overset{\ast }{\vdash }\left \lfloor pB\right \rfloor \] y \(\left \lfloor pB\right \rfloor \nvdash d\), para cada \(d\in Des\)</li></ol>
<!-- l. 4166 --><p class='noindent'>Si  \(M\) es una maquina de Turing la cual computa a \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\), diremos que \(M\) <span class='cmti-10'>decide la pertenecia a</span> \(S\),
con respecto al conjunto \(\omega ^{n}\times \Sigma ^{\ast m}\).
</p><!-- l. 4176 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.2   </span> <a id='x1-720003.2'></a>El paradigma de Godel: Funciones \(\Sigma \)-recursivas</h4>
<!-- l. 4178 --><p class='noindent'>En esta seccion desarrollaremos el modelo matematico del concepto de funcion
\(\Sigma \)-efectivamente computable, dado por Godel. Dichas funciones seran llamadas
\(\Sigma \)-recursivas y la idea es partir de una familia de funciones muy simples y obviamente
\(\Sigma \)-efectivamente computables y luego obtener nuevas funciones \(\Sigma \)-efectivamente

computables usando constructores que preservan la computabilidad efectiva. Las
funciones \(\Sigma \)-recursivas seran las que se obtienen con este proceso constructivo. Nos
referiremos a este paradigma como el paradigma Godeliano o recursivo. A veces
tambien lo llamaremos el paradigma funcional.
</p><!-- l. 4189 --><p class='indent'>   La familia de funciones simples y obviamente \(\Sigma \)-efectivamente computables de la
que partiremos es la siguiente \[ \left \{ Suc,Pred,C_{0}^{0,0},C_{\varepsilon }^{0,0}\right \} \cup \left \{ d_{a}:a\in \Sigma \right \} \cup \left \{ p_{j}^{n,m}:1\leq j\leq n+m\right \} \] Los constructores que usaremos son:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-72001x3.2'>Composicion
     </li>
     <li class='enumerate' id='x1-72002x3.2'>Recursion primitiva
     </li>
     <li class='enumerate' id='x1-72003x3.2'>Minimizacion de predicados totales</li></ol>
<!-- l. 4202 --><p class='indent'>   Estos constructores nos permiten dadas ciertas funciones construir o definir una
nueva funcion y tienen la propiedad de preservar la computabilidad efectiva en el
sentido que si las funciones iniciales son \(\Sigma \)-efectivamente computables, entonces la
funcion obtenida tambien lo es. Ya definiremos bien estos constructores pero
notese que las funciones \[ Suc\circ Pred\ \ \ \ \ \ \ \ \ \ Pred\circ p_{1}^{1,2}\ \ \ \ \ \ \ Pred\circ Pred \] se obtienen con el constructor de composicion a
partir de funciones del conjunto inicial antes mencionado por lo cual seran
\(\Sigma \)-recursivas.
</p><!-- l. 4218 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.2.1   </span> <a id='x1-730003.2.1'></a>Funciones \(\Sigma \)-recursivas primitivas</h5>
<!-- l. 4220 --><p class='noindent'>Comensaremos estudiando ciertas funciones \(\Sigma \)-recursivas, llamadas \(\Sigma \)-recursivas
primitivas, las cuales son precisamente las que se obtienen a partir de las iniciales y
usando solo los constructores de composicion y recursion primitiva. Su roll es clave en
el desarrollo de la teoria.
</p>
<!-- l. 4226 --><p class='noindent'><span class='paragraphHead'><a id='x1-740003.2.1'></a><span class='cmbx-10'>Composicion</span></span>
   Dadas funciones \(\Sigma \)-mixtas \(f,f_{1},...,f_{r}\), con \(r\geq 1\), diremos que la funcion \(f\circ [f_{1},...,f_{r}]\) es <span class='cmti-10'>obtenida por
</span><span class='cmti-10'>composicion a partir de las funciones</span> \(f,f_{1},...,f_{r}\). Para probar que la composicion preserva la
computabilidad efectiva necesitaremos el siguiente lema.
</p>
   <div class='newtheorem'>
<!-- l. 4233 --><p class='noindent'><span class='head'>
<a id='x1-74001r39'></a>
<span class='cmbx-10'>Lema 39.</span>  </span><span class='cmti-10'>Supongamos que</span> \(f,f_{1},...,f_{r}\) <span class='cmti-10'>son funciones</span> \(\Sigma \)<span class='cmti-10'>-mixtas, con</span> \(r\geq 1\)<span class='cmti-10'>. Supongamos ademas que</span> \(f\circ [f_{1},...,f_{r}]\neq \emptyset \)<span class='cmti-10'>.
</span><span class='cmti-10'>Entonces hay</span> \(n,m,k,l\in \omega \) <span class='cmti-10'>y</span> \(s\in \{\#,\ast \}\) <span class='cmti-10'>tales que</span>

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-74002x39'>\(r=n+m\)
     </li>
     <li class='enumerate' id='x1-74003x39'>\(f\) <span class='cmti-10'>es de tipo</span> \((n,m,s)\)
     </li>
     <li class='enumerate' id='x1-74004x39'>\(f_{i}\) <span class='cmti-10'>es de tipo</span> \((k,l,\#)\)<span class='cmti-10'>, para cada</span> \(i=1,...,n\)
     </li>
     <li class='enumerate' id='x1-74005x39'>\(f_{i}\) <span class='cmti-10'>es de tipo</span> \((k,l,\ast )\)<span class='cmti-10'>, para cada</span> \(i=n+1,...,n+m\)</li></ol>
<!-- l. 4243 --><p class='noindent'><span class='cmti-10'>Mas aun, en tal caso la funcion</span> \(f\circ [f_{1},...,f_{n+m}]\) <span class='cmti-10'>es de tipo</span> \((k,l,s)\) <span class='cmti-10'>y:</span> </p><div class='eqnarray'>\begin{eqnarray*} D_{f\circ [f_{1},...,f_{n+m}]} &amp; = &amp; \left \{ (\vec{x},\vec{\alpha })\in \bigcap _{i=1}^{n+m}D_{f_{i}}:(f_{1}(\vec{x},\vec{\alpha }),...,f_{n+m}(\vec{x},\vec{\alpha }))\in D_{f}\right \} \\ f\circ [f_{1},...,f_{n+m}](\vec{x},\vec{\alpha }) &amp; = &amp; f(f_{1}(\vec{x},\vec{\alpha }),...,f_{n+m}(\vec{x},\vec{\alpha })). \end{eqnarray*}
</div>
   </div>
<!-- l. 4251 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4252 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que \(f\neq \emptyset \) y \([f_{1},...,f_{r}]\neq \emptyset \) (por que?). Ya que \(f\neq \emptyset \) tenemos que hay unicos \(n,m\in \omega \) y \(s\in \{\#,\ast \}\) tales que \(f\) es de
tipo \((n,m,s)\). Ya que \(f\circ [f_{1},...,f_{r}]\neq \emptyset \) y \(I_{[f_{1},...,f_{r}]}\subseteq I_{f_{1}}\times ...\times I_{f_{r}}\), tenemos que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-74006x3.2.1'>\(r=n+m\)
     </li>
     <li class='enumerate' id='x1-74007x3.2.1'>\(I_{f_{i}}\subseteq \omega \), para cada \(i=1,...,n\)
     </li>
     <li class='enumerate' id='x1-74008x3.2.1'>\(I_{f_{i}}\subseteq \Sigma ^{\ast }\), para cada \(i=n+1,...,n+m\)</li></ol>
<!-- l. 4262 --><p class='noindent'>Ya que \([f_{1},...,f_{r}]\neq \emptyset \) tenemos que \(D_{[f_{1},...,f_{r}]}=\bigcap _{i=1}^{r}D_{f_{i}}\neq \emptyset \), por lo cual los conjuntos \(D_{f_{1}},...,D_{f_{n+m}}\) deberan ser todos de un mismo tipo,
digamos de tipo \((k,l)\). Es decir que \(f_{i}\) es de tipo \((k,l,\#)\), para cada \(i=1,...,n\) y \(f_{i}\) es de tipo \((k,l,\ast )\), para cada
\(i=n+1,...,n+m\).
</p><!-- l. 4268 --><p class='indent'>   Las ultimas observaciones del lema son directas de las definiciones de \([f_{1},...,f_{n+m}]\) y de
composicion de funciones                                                                     □
</p>
   </div>
<!-- l. 4273 --><p class='indent'>   Ahora si podemos probar facilmente que el contructor composicion preserva la
computabilidad efectiva
</p>
   <div class='newtheorem'>
<!-- l. 4275 --><p class='noindent'><span class='head'>
<a id='x1-74009r40'></a>

<span class='cmbx-10'>Lema 40.</span>  </span><span class='cmti-10'>Si</span> \(f,f_{1},...,f_{r}\)<span class='cmti-10'>, con</span> \(r\geq 1\)<span class='cmti-10'>, son</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computables, entonces</span> \(f\circ [f_{1},...,f_{r}]\) <span class='cmti-10'>lo es.</span>
</p>
   </div>
<!-- l. 4280 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4281 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Si \(f\circ [f_{1},...,f_{r}]=\emptyset \), entonces claramente es \(\Sigma \)-efectivamente computable. Supongamos entonces
que \(f\circ [f_{1},...,f_{r}]\neq \emptyset \). Por el lema anterior hay \(n,m,k,l\in \omega \) y \(s\in \{\#,\ast \}\) tales que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-74010x3.2.1'>\(r=n+m\)
     </li>
     <li class='enumerate' id='x1-74011x3.2.1'>\(f\) es de tipo \((n,m,s)\)
     </li>
     <li class='enumerate' id='x1-74012x3.2.1'>\(f_{i}\) es de tipo \((k,l,\#)\), para cada \(i=1,...,n\)
     </li>
     <li class='enumerate' id='x1-74013x3.2.1'>\(f_{i}\) es de tipo \((k,l,\ast )\), para cada \(i=n+1,...,n+m\)</li></ol>
<!-- l. 4291 --><p class='noindent'>Sean \(\mathbb{P},\mathbb{P}_{1},...,\mathbb{P}_{n+m}\) procedimientos efectivos los cuales computen las funciones \(f,f_{1},...,f_{n+m}\), respectivamente.
Usando estos procedimientos es facil definir un procedimiento efectivo el cual
compute a \(f\circ [f_{1},...,f_{n+m}]\).                                                                                      □
</p>
   </div>
<!-- l. 4299 --><p class='noindent'><span class='paragraphHead'><a id='x1-750003.2.1'></a><span class='cmbx-10'>Recursion primitiva</span></span>
   La recursion primitiva es un tipo muy particular de recursion. Consideremos por
ejemplo las siguientes ecuaciones:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-75001x3.2.1'>\(R(0)=1\)
     </li>
     <li class='enumerate' id='x1-75002x3.2.1'>\(R(t+1)=1+R(t)+R(t)^{2}\)</li></ol>
<!-- l. 4307 --><p class='noindent'>Notese que hay una unica funcion \(R:\omega \rightarrow \omega \) la cual cumple (1) y (2). Esto es ya que el valor de \(R\)
en \(t\) esta determinado por sucesivas aplicaciones de las ecuaciones (1) y (2). Por
ejemplo la ecuacion (1) nos dice que \(R(0)=1\) pero entonces la ecuacion (2) nos dice que \(R(1)=1+1+1^{2}=3\) por
lo cual nuevamente la ecuacion (2) nos dice que \(R(2)=1+3+3^{2}=13\) y asi podemos notar facilmente que \(R\)
esta determinada por dichas ecuaciones.

</p><!-- l. 4315 --><p class='indent'>   Se suele decir que las ecuaciones (1) y (2) definen recursivamente a la funcion \(R\)
pero hay que tener cuidado porque esto es una manera de hablar ya que la funcion \(R\)
podria en nuestro discurso ya haber sido definida de otra manera. Mas propio es
pensar que dichas ecuaciones determinan a \(R\) en el sentido que \(R\) es la unica que las
cumple. Por ejemplo las ecuaciones:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-75003x3.2.1'>\(R(0)=50\)
     </li>
     <li class='enumerate' id='x1-75004x3.2.1'>\(R(t+1)=R(t)\)</li></ol>
<!-- l. 4325 --><p class='noindent'>definen recursivamente a la funcion \(C_{50}^{1,0}\) pero esta claro que la definicion de \(C_{50}^{1,0}\) en esta materia
no fue dada de esta forma.
</p><!-- l. 4329 --><p class='indent'>   Hay casos de recursiones en las cuales el valor de \(R(t+1)\) no solo depende de \(R(t)\) sino que
tambien depende de \(t\). Por ejemplo
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-75005x3.2.1'>\(R(0)=1\)
     </li>
     <li class='enumerate' id='x1-75006x3.2.1'>\(R(t+1)=t.R(t)+1\)</li></ol>
<!-- l. 4335 --><p class='noindent'>De todas maneras deberia quedar claro que las ecuaciones (i) y (ii) determinan una unica
funcion \(R:\omega \rightarrow \omega \) que las satisface.
</p><!-- l. 4339 --><p class='indent'>   Tambien podemos generalizar pensando que la funcion \(R\) depende no solo de un
parametro \(t\) sino que su dominio es \(\omega ^{4}\), es decir depende de \(t\) y \(x_{1},x_{2},x_{3}\). Por ejemplo
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-75007x3.2.1'>\(R(0,x_{1},x_{2},x_{3})=x_{1}+2x_{3}\)
     </li>
     <li class='enumerate' id='x1-75008x3.2.1'>\(R(t+1,x_{1},x_{2},x_{3})=t+x_{1}+x_{2}+x_{3}+R(t,x_{1},x_{2},x_{3})\)</li></ol>
<!-- l. 4348 --><p class='indent'>   Dejamos al lector convencerse de que (p) y (q) son cumplidas por una
unica funcion \(R:\omega ^{4}\rightarrow \omega \). Tambien podriamos tener variables alfabeticas. Por ejemplo
consideremos
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-75009x3.2.1'>\(R(0,x_{1},x_{2},\alpha _{1},\alpha _{2})=x_{1}+\left \vert \alpha _{1}\right \vert ^{x_{2}}\)
     </li>
     <li class='enumerate' id='x1-75010x3.2.1'>\(R(t+1,x_{1},x_{2},\alpha _{1},\alpha _{2})=t+x_{1}+x_{2}+\left \vert \alpha _{1}\right \vert +\left \vert \alpha _{2}\right \vert +R(t,x_{1},x_{2},\alpha _{1},\alpha _{2})\)</li></ol>
<!-- l. 4357 --><p class='indent'>   Es claro aqui que las ecuaciones (r) y (s) determinan una unica funcion \(R:\omega ^{3}\times \Sigma ^{\ast 2}\rightarrow \omega \) que las
cumple. Esto se puede explicar de la siguiente manera:

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-75011x3.2.1'>La ecuacion (r) determina los valores de \(R\) sobre el conjunto \(\{0\}\times \omega \times \omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }\). Pero una
     ves determinados estos valores, la ecuacion (s) tomada con \(t=0\), determina los
     valores de \(R\) sobre el conjunto \(\{1\}\times \omega \times \omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }\). Pero una ves determinados estos valores, la
     ecuacion (s) tomada con \(t=1\), determina los valores de \(R\) sobre el conjunto \(\{2\}\times \omega \times \omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }\), etc</li></ol>
<!-- l. 4370 --><p class='indent'>   El caso anterior podria generalizarse de la siguiente manera: Si tenemos dadas dos
funciones </p><div class='eqnarray'>\begin{eqnarray*} f &amp; : &amp; \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \\ g &amp; : &amp; \omega ^{n+2}\times \Sigma ^{\ast m}\rightarrow \omega  \end{eqnarray*}
</div>entonces las ecuaciones:
     <ol class='enumerate1'>
     <li class='enumerate' id='x1-75012x3.2.1'>\(R(0,\vec{x},\vec{\alpha })=f(\vec{x},\vec{\alpha })\)
     </li>
     <li class='enumerate' id='x1-75013x3.2.1'>\(R(t+1,\vec{x},\vec{\alpha })=g(R(t,\vec{x},\vec{\alpha }),t,\vec{x},\vec{\alpha })\)</li></ol>
<!-- l. 4381 --><p class='noindent'>determinan una unica funcion \(R:\omega ^{n+1}\times \Sigma ^{\ast m}\rightarrow \omega \) que las cumple. Notese que para el caso </p><div class='eqnarray'>\begin{eqnarray*} n &amp; = &amp; m=2\\ f &amp; = &amp; \lambda x_{1}x_{2}\alpha _{1}\alpha _{2}[x_{1}+\left \vert \alpha _{1}\right \vert ^{x_{2}}]\\ g &amp; = &amp; \lambda xtx_{1}x_{2}\alpha _{1}\alpha _{2}[t+x_{1}+x_{2}+\left \vert \alpha _{1}\right \vert +\left \vert \alpha _{2}\right \vert +x] \end{eqnarray*}
</div>las ecuaciones (a) y (b) se transforman en las ecuaciones (r) y (s).
<!-- l. 4390 --><p class='indent'>   El primer caso de recursion primitiva que definiremos a continuacion engloba los
ejemplos vistos recien dentro de un marco general.
</p>
<!-- l. 4396 --><p class='indent'>   <span class='subparagraphHead'> <a id='x1-760003.2.1'></a><span class='cmbx-10'>Recursion primitiva sobre variable numerica con valores numericos</span></span>
   Supongamos tenemos dadas funciones </p><div class='eqnarray'>\begin{eqnarray*} f &amp; : &amp; S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \\ g &amp; : &amp; \omega \times \omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega  \end{eqnarray*}
</div>con \(S_{1},...,S_{n}\subseteq \omega \) y \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) conjuntos no vacios. Usando el razonamiento inductivo usado en los ejemplos
anteriores, se puede probar que hay una unica funcion
<!-- l. 4409 --><p class='indent'>   \[ R:\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \] la cual cumple las ecuaciones
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-76001x3.2.1'>\(R(0,\vec{x},\vec{\alpha })=f(\vec{x},\vec{\alpha })\)
     </li>
     <li class='enumerate' id='x1-76002x3.2.1'>\(R(t+1,\vec{x},\vec{\alpha })=g(R(t,\vec{x},\vec{\alpha }),t,\vec{x},\vec{\alpha })\)</li></ol>
<!-- l. 4415 --><p class='noindent'>LLamaremos \(R(f,g)\) a esta unica funcion que cumple las ecuaciones anteriores. Resumiendo,
diremos que las ecuaciones
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-76003x3.2.1'>\(R(f,g)(0,\vec{x},\vec{\alpha })=f(\vec{x},\vec{\alpha })\)
     </li>
     <li class='enumerate' id='x1-76004x3.2.1'>\(R(f,g)(t+1,\vec{x},\vec{\alpha })=g(R(f,g)(t,\vec{x},\vec{\alpha }),t,\vec{x},\vec{\alpha })\)</li></ol>
<!-- l. 4421 --><p class='noindent'>definen recursivamente a la funcion \(R(f,g)\). Tambien diremos que \(R(f,g)\) es obtenida por <span class='cmti-10'>recursion
</span><span class='cmti-10'>primitiva </span>a partir de \(f\) y \(g\).

</p><!-- l. 4427 --><p class='indent'>   NOTA IMPOTANTE: No confundirse y pensar que \(R(f,g)\) es el resultado de
aplicar una funcion \(R\) al par \((f,g)\), de hecho hasta el momento no hemos definido
ninguna funcion \(R\) cuyo dominio sea cierto conjunto de pares ordenados de
funciones!
</p><!-- l. 4434 --><p class='indent'>   Notese que cuando \(m=n=0\), se tiene que \(D_{f}=\{\Diamond \}\) y (1) y (2) se transforman en
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-76005x3.2.1'>\(R(f,g)(0)=f(\Diamond )\)
     </li>
     <li class='enumerate' id='x1-76006x3.2.1'>\(R(f,g)(t+1)=g(R(f,g)(t),t)\)</li></ol>
<!-- l. 4442 --><p class='indent'>   Veamos algunos ejemplos
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-76007x3.2.1'>Tomemos \(f=p_{1}^{1,0}\) y \(g=Suc\circ p_{1}^{3,0}\). De la definicion de \(R(f,g)\), obtenemos que su dominio es \(\omega ^{2}\) y
     <div class='eqnarray'>\begin{eqnarray*} R(f,g)(0,x_{1}) &amp; = &amp; p_{1}^{1,0}(x_{1})=x_{1}\\ R(f,g)(t+1,x_{1}) &amp; = &amp; \left (Suc\circ p_{1}^{3,0}\right )(R(f,g)(t,x_{1}),t,x_{1})=R(f,g)(t,x_{1})+1 \end{eqnarray*}
     </div>Es facil notar que la unica funcion que cumple estas dos ecuaciones es \(\lambda tx_{1}\left [t+x_{1}\right ]\), lo cual
     implica que \(\lambda tx_{1}\left [t+x_{1}\right ]=R\left (p_{1}^{1,0},Suc\circ p_{1}^{3,0}\right )\)
     </li>
     <li class='enumerate' id='x1-76008x3.2.1'>Sean \(f=C_{0}^{0,0}\) y \(g=p_{1}^{2,0}\). De la definicion de \(R(f,g)\), obtenemos que su dominio es \(\omega \) y <div class='eqnarray'>\begin{eqnarray*} R(f,g)(0) &amp; = &amp; C_{0}^{0,0}(\Diamond )=0\\ R(f,g)(t+1) &amp; = &amp; p_{1}^{2,0}(R(f,g)(t),t)=R(f,g)(t) \end{eqnarray*}
     </div>Es facil notar que la unica funcion que cumple estas dos ecuaciones es \(C_{0}^{1,0}\) lo cual
     implica que \(C_{0}^{1,0}=R\left (C_{0}^{0,0},p_{1}^{2,0}\right )\)</li></ol>
<!-- l. 4463 --><p class='indent'>   Como era de esperar, este caso del constructor de recursion primitiva preserva la
computabilidad efectiva
</p>
   <div class='newtheorem'>
<!-- l. 4465 --><p class='noindent'><span class='head'>
<a id='x1-76009r41'></a>
<span class='cmbx-10'>Lema 41.</span>  </span><span class='cmti-10'>Si</span> \(f\) <span class='cmti-10'>y</span> \(g\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computables, entonces</span> \(R(f,g)\) <span class='cmti-10'>lo es.</span>
</p>
   </div>
<!-- l. 4470 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4471 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es dejada al lector                                                                    □

</p>
   </div>
<!-- l. 4475 --><p class='indent'>   <span class='cmbx-10'>Nota importante: </span>En los ejemplos anteriores y en todos los casos que
manejaremos en esta primera etapa, en las aplicaciones del constructor de recursion
primitiva (en sus cuatro formas) las funciones iniciales seran \(\Sigma \)-totales (es decir \(S_{1}=...=S_{n}=\omega \) y \(L_{1}=...=L_{m}=\Sigma ^{\ast }\)).
Mas adelante veremos aplicaciones con funciones no \(\Sigma \)-totales.
</p>
<!-- l. 4485 --><p class='indent'>   <span class='subparagraphHead'> <a id='x1-770003.2.1'></a><span class='cmbx-10'>Recursion primitiva sobre variable numerica con valores alfabeticos</span></span>
   Ahora haremos el caso en el que la funcion definida recursivamente tiene imagen
contenida en \(\Sigma ^{\ast }\). Es claro que entonces \(f\) y \(g\) tambien deberan tener imagen contenida en \(\Sigma ^{\ast }\).
El unico detalle a tener en cuenta en la definicion de este caso es que si solo
hicieramos estos cambios y pusieramos las mismas ecuaciones la funcion \(g\)
no resultaria \(\Sigma \)-mixta en general. Para que la \(g\) de la recursion siga siendo
\(\Sigma \)-mixta deberemos modificar levemente su dominio en relacion al caso ya
hecho
</p><!-- l. 4496 --><p class='indent'>   Supongamos \(\Sigma \) es un alfabeto finito. Sean </p><div class='eqnarray'>\begin{eqnarray*} f &amp; : &amp; S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \Sigma ^{\ast }\\ g &amp; : &amp; \omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\times \Sigma ^{\ast }\rightarrow \Sigma ^{\ast } \end{eqnarray*}
</div>con \(S_{1},...,S_{n}\subseteq \omega \) y \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) conjuntos no vacios. Definamos \[ R(f,g):\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \Sigma ^{\ast } \] de la siguiente manera
     <ol class='enumerate1'>
     <li class='enumerate' id='x1-77001x3.2.1'>\(R(f,g)(0,\vec{x},\vec{\alpha })=f(\vec{x},\vec{\alpha })\)
     </li>
     <li class='enumerate' id='x1-77002x3.2.1'>\(R(f,g)(t+1,\vec{x},\vec{\alpha })=g(t,\vec{x},\vec{\alpha },R(f,g)(t,\vec{x},\vec{\alpha }))\)</li></ol>
<!-- l. 4511 --><p class='noindent'>Diremos que \(R(f,g)\) es obtenida por <span class='cmti-10'>recursion primitiva </span>a partir de \(f\) y \(g\). Notese que cuando \(m=n=0\), se
tiene que \(D_{f}=\{\Diamond \}\) y (1) y (2) se transforman en
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-77003x3.2.1'>\(R(f,g)(0)=f(\Diamond )\)
     </li>
     <li class='enumerate' id='x1-77004x3.2.1'>\(R(f,g)(t+1)=g(t,R(f,g)(t))\)</li></ol>
<!-- l. 4520 --><p class='indent'>   Veamos algunos ejemplos
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-77005x3.2.1'>Tomemos \(f=C_{\varepsilon }^{0,1}\) y \(g=\lambda \alpha \beta \left [\alpha \beta \right ]\circ \left [p_{3}^{1,2},p_{2}^{1,2}\right ]\). De la definicion de \(R(f,g)\), obtenemos que <div class='eqnarray'>\begin{eqnarray*} R(f,g)(0,\alpha _{1}) &amp; = &amp; C_{\varepsilon }^{0,1}(\alpha _{1})=\varepsilon \\ R(f,g)(t+1,\alpha _{1}) &amp; = &amp; \lambda \alpha \beta \left [\alpha \beta \right ]\circ \left [p_{3}^{1,2},p_{2}^{1,2}\right ](t,\alpha _{1},R(f,g)(t,\alpha _{1}))=R(f,g)(t,\alpha _{1})\alpha _{1} \end{eqnarray*}
     </div>Es facil notar que la unica funcion que cumple estas dos ecuaciones es \(\lambda t\alpha _{1}\left [\alpha _{1}{}^{t}\right ]\), lo cual
     implica que \(\lambda t\alpha _{1}\left [\alpha _{1}{}^{t}\right ]=R\left (C_{\varepsilon }^{0,1},\lambda \alpha \beta \left [\alpha \beta \right ]\circ \left [p_{3}^{1,2},p_{2}^{1,2}\right ]\right )\)
     </li>
     <li class='enumerate' id='x1-77006x3.2.1'>Sean \(f=C_{\varepsilon }^{0,0}\) y \(g=p_{2}^{2,0}\). De la definicion de \(R(f,g)\), obtenemos que <div class='eqnarray'>\begin{eqnarray*} R(f,g)(0) &amp; = &amp; C_{\varepsilon }^{0,0}(\Diamond )=\varepsilon \\ R(f,g)(t+1) &amp; = &amp; p_{2}^{2,0}(t,R(f,g)(t))=R(f,g)(t) \end{eqnarray*}
     </div>Es facil notar que la unica funcion que cumple estas dos ecuaciones es \(C_{\varepsilon }^{1,0}\) lo cual
     implica que \(C_{\varepsilon }^{1,0}=R\left (C_{\varepsilon }^{0,0},p_{2}^{2,0}\right )\)</li></ol>

<!-- l. 4542 --><p class='indent'>   La prueba del siguiente lema es completamente analoga a la del lema anterior que
fue dejada como ejercicio.
</p>
   <div class='newtheorem'>
<!-- l. 4544 --><p class='noindent'><span class='head'>
<a id='x1-77007r42'></a>
<span class='cmbx-10'>Lema 42.</span>  </span><span class='cmti-10'>Si</span> \(f\) <span class='cmti-10'>y</span> \(g\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computables, entonces</span> \(R(f,g)\) <span class='cmti-10'>lo es.</span>
</p>
   </div>
<!-- l. 4552 --><p class='indent'>   <span class='subparagraphHead'> <a id='x1-780003.2.1'></a><span class='cmbx-10'>Recursion primitiva sobre variable alfabetica con valores numericos</span></span>
   Ya vimos dos casos de recursion donde el parametro que comanda la
recursion es numerico. Daremos a continuacion un ejemplo de recursion en el
cual el parametro principal es alfabetico. Sea \(\Sigma =\{\%,@,?\}\) y consideremos las siguientes
ecuaciones:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-78001x3.2.1'>\(R(\varepsilon )=15\)
     </li>
     <li class='enumerate' id='x1-78002x3.2.1'>\(R(\alpha \%)=R(\alpha )+1\)
     </li>
     <li class='enumerate' id='x1-78003x3.2.1'>\(R(\alpha @)=R(\alpha ).5\)
     </li>
     <li class='enumerate' id='x1-78004x3.2.1'>\(R(\alpha ?)=R(\alpha )^{20}\)</li></ol>
<!-- l. 4566 --><p class='indent'>   Notese que las ecuaciones anteriores determinan una funcion \(R:\Sigma ^{\ast }\rightarrow \omega \). Esto es ya que \(R\) en \(\varepsilon \)
debe valer \(15\) y sabiendo esto las ecuaciones (2), (3) y (4) (con \(\alpha =\varepsilon \)) nos dicen que
</p><div class='eqnarray'>\begin{eqnarray*} R(\%) &amp; = &amp; 16\\ R(@) &amp; = &amp; 75\\ R(?) &amp; = &amp; 15^{20} \end{eqnarray*}
</div>por lo cual podemos aplicarlas nuevamente a dichas ecuaciones (con \(\alpha \in \{\%,@,?\}\)) para calcular \(R\)
en todas las palabras de longitud \(2\); y asi sucesivamente.
<!-- l. 4579 --><p class='indent'>   Daremos otro ejemplo un poco mas complicado para seguir aproximandonos al
caso general. Nuevamente supongamos que \(\Sigma =\{\%,@,?\}\) y supongamos tenemos una funcion \[ f:\omega \times \Sigma ^{\ast }\rightarrow \omega \] y
tres funciones </p><div class='eqnarray'>\begin{eqnarray*} \mathcal{G}_{\%} &amp; : &amp; \omega \times \omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }\rightarrow \omega \\ \mathcal{G}_{@} &amp; : &amp; \omega \times \omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }\rightarrow \omega \\ \mathcal{G}_{?} &amp; : &amp; \omega \times \omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }\rightarrow \omega  \end{eqnarray*}
</div>Entonces hay una unica funcion \(R::\omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }\rightarrow \omega \) la cual cumple las siguientes ecuaciones
     <ol class='enumerate1'>
     <li class='enumerate' id='x1-78005x3.2.1'>\(R(x_{1},\alpha _{1},\varepsilon )=f(x_{1},\alpha _{1})\)
     </li>
     <li class='enumerate' id='x1-78006x3.2.1'>\(R(x_{1},\alpha _{1},\alpha \%)=\mathcal{G}_{\%}(R(x_{1},\alpha _{1},\alpha ),x_{1},\alpha _{1},\alpha )\)

     </li>
     <li class='enumerate' id='x1-78007x3.2.1'>\(R(x_{1},\alpha _{1},\alpha @)=\mathcal{G}_{@}(R(x_{1},\alpha _{1},\alpha ),x_{1},\alpha _{1},\alpha )\)
     </li>
     <li class='enumerate' id='x1-78008x3.2.1'>\(R(x_{1},\alpha _{1},\alpha ?)=\mathcal{G}_{?}(R(x_{1},\alpha _{1},\alpha ),x_{1},\alpha _{1},\alpha )\)</li></ol>
<!-- l. 4599 --><p class='noindent'>(Justifique que las ecuaciones anteriores determinan a la funcion \(R\).)
</p><!-- l. 4602 --><p class='indent'>   El ejemplo anterior nos muestra que para hacer recursion sobre parametro
alfabetico nos hace falta ”una funcion \(g\) por cada simbolo de \(\Sigma \)”. Esto motiva la
siguiente definicion. Dado un alfabeto \(\Sigma \), una <span class='cmti-10'>familia</span> \(\Sigma \)-<span class='cmti-10'>indexada de funciones </span>sera
una funcion \(\mathcal{G}\) tal que \(D_{\mathcal{G}}=\Sigma \) y para cada \(a\in D_{\mathcal{G}}\) se tiene que \(\mathcal{G}(a)\) es una funcion. Algunos
ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-78009x3.2.1'>Sea \(\mathcal{G}\) dada por \[ \begin{array}{rcl} \mathcal{G}:\{\square ,\%,\blacktriangle \} &amp; \rightarrow &amp; \{Suc,Pred\}\\ \square &amp; \rightarrow &amp; Suc\\ \% &amp; \rightarrow &amp; Suc\\ \blacktriangle &amp; \rightarrow &amp; Pred \end{array} \] Claramente \(\mathcal{G}\) es una familia \(\{\square ,\%,\blacktriangle \}\)-indexada de funciones. Notar
     que \[ \mathcal{G}=\{(\square ,Suc),(\%,Suc),(\blacktriangle ,Pred)\} \] Se tiene tambien por ejemplo que \(\mathcal{G}(\%)=Suc\) por lo cual tambien es cierto que
     \(\mathcal{G}(\%)(22)=23\), etc.
     </li>
     <li class='enumerate' id='x1-78010x3.2.1'>Si  \(\Sigma \)  es  un  alfabeto  no  vacio,  la  funcion  \[ \begin{array}{rcl} \mathcal{G}:\Sigma &amp; \rightarrow &amp; \{f:f\text{ es una funcion de }\Sigma ^{\ast }\text{ en }\Sigma ^{\ast }\}\\ a &amp; \rightarrow &amp; d_{a} \end{array} \]  es  una  familia  \(\Sigma \)-indexada  de
     funciones. Notar que \[ \mathcal{G}=\{(a,d_{a}):a\in \Sigma \} \]
     </li>
     <li class='enumerate' id='x1-78011x3.2.1'>\(\emptyset \) es una flia \(\emptyset \)-indexada de funciones</li></ol>
<!-- l. 4641 --><p class='indent'>   Si \(\mathcal{G}\) es una familia \(\Sigma \)-indexada de funciones, entonces para \(a\in \Sigma \), escribiremos \(\mathcal{G}_{a}\) en lugar
de \(\mathcal{G}(a)\). Ahora sí, nuestro caso de recursion primitiva. Sea \[ f:S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \] con \(S_{1},...,S_{n}\subseteq \omega \) y \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) conjuntos no vacios
y sea \(\mathcal{G}\) una familia \(\Sigma \)-indexada de funciones tal que \[ \mathcal{G}_{a}:\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\times \Sigma ^{\ast }\rightarrow \omega \] para cada \(a\in \Sigma .\) Definamos \[ R(f,\mathcal{G}):S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\times \Sigma ^{\ast }\rightarrow \omega \] de la
siguiente manera
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-78012x3.2.1'>\(R(f,\mathcal{G})(\vec{x},\vec{\alpha },\varepsilon )=f(\vec{x},\vec{\alpha })\)
     </li>
     <li class='enumerate' id='x1-78013x3.2.1'>\(R(f,\mathcal{G})(\vec{x},\vec{\alpha },\alpha a)=\mathcal{G}_{a}(R(f,\mathcal{G})(\vec{x},\vec{\alpha },\alpha ),\vec{x},\vec{\alpha },\alpha )\)</li></ol>
<!-- l. 4663 --><p class='noindent'>Diremos que \(R(f,\mathcal{G})\) es obtenida por <span class='cmti-10'>recursion primitiva </span>a partir de \(f\) y \(\mathcal{G}\). Notese que cuando \(m=n=0\), se
tiene que \(D_{f}=\{\Diamond \}\) y (1) y (2) se transforman en
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-78014x3.2.1'>\(R(f,\mathcal{G})(\varepsilon )=f(\Diamond )\)
     </li>
     <li class='enumerate' id='x1-78015x3.2.1'>\(R(f,\mathcal{G})(\alpha a)=\mathcal{G}_{a}(R(f,\mathcal{G})(\alpha ),\alpha )\)</li></ol>
   <div class='newtheorem'>
<!-- l. 4672 --><p class='noindent'><span class='head'>
<a id='x1-78016r43'></a>

<span class='cmbx-10'>Lema 43.</span>  </span><span class='cmti-10'>Si</span> \(f\) <span class='cmti-10'>y cada</span> \(\mathcal{G}_{a}\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computables, entonces</span> \(R(f,\mathcal{G})\) <span class='cmti-10'>lo es.</span>
</p>
   </div>
<!-- l. 4677 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4678 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es dejada al lector                                                                    □
</p>
   </div>
<!-- l. 4683 --><p class='indent'>   <span class='subparagraphHead'> <a id='x1-790003.2.1'></a><span class='cmbx-10'>Recursion primitiva sobre variable alfabetica con valores alfabeticos</span></span>
   Supongamos \(\Sigma \) es un alfabeto finito. Sea \[ f:S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \Sigma ^{\ast } \] con \(S_{1},...,S_{n}\subseteq \omega \) y \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) conjuntos no vacios y sea \(\mathcal{G}\) una
familia \(\Sigma \)-indexada de funciones tal que \[ \mathcal{G}_{a}:S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\times \Sigma ^{\ast }\times \Sigma ^{\ast }\rightarrow \Sigma ^{\ast } \] para cada \(a\in \Sigma \). Definamos \[ R(f,\mathcal{G}):S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\times \Sigma ^{\ast }\rightarrow \Sigma ^{\ast } \] de la siguiente
manera
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-79001x3.2.1'>\(R(f,\mathcal{G})(\vec{x},\vec{\alpha },\varepsilon )=f(\vec{x},\vec{\alpha })\)
     </li>
     <li class='enumerate' id='x1-79002x3.2.1'>\(R(f,\mathcal{G})(\vec{x},\vec{\alpha },\alpha a)=\mathcal{G}_{a}(\vec{x},\vec{\alpha },\alpha ,R(f,\mathcal{G})(\vec{x},\vec{\alpha },\alpha )).\)</li></ol>
<!-- l. 4704 --><p class='noindent'>Diremos que \(R(f,\mathcal{G})\) es obtenida por <span class='cmti-10'>recursion primitiva </span>a partir de \(f\) y \(\mathcal{G}\). Notese que cuando \(m=n=0\), se
tiene que \(D_{f}=\{\Diamond \}\) y (1) y (2) se transforman en
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-79003x3.2.1'>\(R(f,\mathcal{G})(\varepsilon )=f(\Diamond )\)
     </li>
     <li class='enumerate' id='x1-79004x3.2.1'>\(R(f,\mathcal{G})(\alpha a)=\mathcal{G}_{a}(\alpha ,R(f,\mathcal{G})(\alpha ))\)</li></ol>
<!-- l. 4713 --><p class='indent'>   La prueba del siguiente lema es completamente analoga a la del lema anterior que
fue dejada como ejercicio.
</p>
   <div class='newtheorem'>
<!-- l. 4715 --><p class='noindent'><span class='head'>
<a id='x1-79005r44'></a>
<span class='cmbx-10'>Lema 44.</span>  </span><span class='cmti-10'>Si</span> \(f\) <span class='cmti-10'>y cada</span> \(\mathcal{G}_{a}\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computables, entonces</span> \(R(f,\mathcal{G})\) <span class='cmti-10'>lo es.</span>

</p>
   </div>
<!-- l. 4725 --><p class='noindent'><span class='paragraphHead'><a id='x1-800003.2.1'></a><span class='cmbx-10'>Definicion de funcion</span> \(\Sigma \)<span class='cmbx-10'>-recursiva primitiva</span></span>
   Intuitivamente hablando ya sabemos que una funcion es \(\Sigma \)-recursiva primitiva si se
puede obtener de las iniciales usando los constructores de composicion y recursion
primitiva. Daremos ahora una definicion matematica de este concepto. Definamos los
conjuntos \(\mathrm{PR}_{0}^{\Sigma }\subseteq \mathrm{PR}_{1}^{\Sigma }\subseteq \mathrm{PR}_{2}^{\Sigma }\subseteq ...\subseteq \mathrm{PR}^{\Sigma }\) de la siguiente manera \[ \begin{array}{lll} \mathrm{PR}_{0}^{\Sigma } &amp; = &amp; \left \{ Suc,Pred,C_{0}^{0,0},C_{\varepsilon }^{0,0}\right \} \cup \left \{ d_{a}:a\in \Sigma \right \} \cup \left \{ p_{j}^{n,m}:1\leq j\leq n+m\right \} \\ \mathrm{PR}_{k+1}^{\Sigma } &amp; = &amp; \mathrm{PR}_{k}^{\Sigma }\cup \left \{ f\circ [f_{1},...,f_{r}]:f,f_{1},...,f_{r}\in \mathrm{PR}_{k}^{\Sigma }\text{, }r\geq 1\right \} \cup \\ &amp; &amp; \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\left \{ R(f,\mathcal{G}):f\text{ y cada }\mathcal{G}_{a}\text{ pertenecen a }\mathrm{PR}_{k}^{\Sigma }\right \} \cup \\ &amp; &amp; \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\left \{ R(f,g):f,g\in \mathrm{PR}_{k}^{\Sigma }\right \} \medskip \\ \mathrm{PR}^{\Sigma } &amp; = &amp; \bigcup _{k\geq 0}\mathrm{PR}_{k}^{\Sigma } \end{array} \] Una funcion es llamada \(\Sigma \)-<span class='cmti-10'>recursiva primitiva </span>(\(\Sigma \)<span class='cmti-10'>-p.r.</span>)
si pertenece a \(\mathrm{PR}^{\Sigma }\).
</p>
   <div class='newtheorem'>
<!-- l. 4746 --><p class='noindent'><span class='head'>
<a id='x1-80001r45'></a>
<span class='cmbx-10'>Proposition 45.</span>  </span><span class='cmti-10'>Si</span> \(f\in \mathrm{PR}^{\Sigma }\)<span class='cmti-10'>, entonces</span> \(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable.</span>
</p>
   </div>
<!-- l. 4751 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4752 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Dejamos al lector la prueba por induccion en \(k\) de que si \(f\in \mathrm{PR}_{k}^{\Sigma }\), entonces \(f\)
es \(\Sigma \)-efectivamente computable, la cual sale en forma directa usando los lemas
anteriores  que  garantizan  que  los  constructores  de  composicion  y  recursion
primitiva preservan la computabilidad efectiva                                         □
</p>
   </div>
<!-- l. 4761 --><p class='noindent'><span class='paragraphHead'><a id='x1-810003.2.1'></a><span class='cmbx-10'>Algunas funciones</span> \(\Sigma \)<span class='cmbx-10'>-recursivas primitivas</span></span>
   En los siguientes cuatro lemas se prueba bien formalmente que varias funciones
bien conocidas son \(\Sigma \)-primitivas recursivas.
</p>
   <div class='newtheorem'>
<!-- l. 4765 --><p class='noindent'><span class='head'>
<a id='x1-81001r46'></a>

<span class='cmbx-10'>Lema 46.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto finito.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-81002x46'>\(\emptyset \in \mathrm{PR}^{\Sigma }\)<span class='cmti-10'>.</span>
     </li>
     <li class='enumerate' id='x1-81003x46'>\(\lambda xy\left [x+y\right ]\in \mathrm{PR}^{\Sigma }\)<span class='cmti-10'>.</span>
     </li>
     <li class='enumerate' id='x1-81004x46'>\(\lambda xy\left [x.y\right ]\in \mathrm{PR}^{\Sigma }\)<span class='cmti-10'>.</span>
     </li>
     <li class='enumerate' id='x1-81005x46'>\(\lambda x\left [x!\right ]\in \mathrm{PR}^{\Sigma }\)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 4775 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4776 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(1) Notese que \(\emptyset =Pred\circ C_{0}^{0,0}\in \mathrm{PR}_{1}^{\Sigma }\)
</p><!-- l. 4778 --><p class='indent'>   (2) Notar que </p><div class='eqnarray'>\begin{eqnarray*} \lambda xy\left [x+y\right ](0,x_{1}) &amp; = &amp; x_{1}=p_{1}^{1,0}(x_{1})\\ \lambda xy\left [x+y\right ](t+1,x_{1}) &amp; = &amp; \lambda xy\left [x+y\right ](t,x_{1})+1\\ &amp; = &amp; \left (Suc\circ p_{1}^{3,0}\right )\left (\lambda xy\left [x+y\right ](t,x_{1}),t,x_{1}\right ) \end{eqnarray*}
</div>lo cual implica que \(\lambda xy\left [x+y\right ]=R\left (p_{1}^{1,0},Suc\circ p_{1}^{3,0}\right )\in \mathrm{PR}_{2}^{\Sigma }.\)
<!-- l. 4786 --><p class='indent'>   (3) Primero note que </p><div class='eqnarray'>\begin{eqnarray*} C_{0}^{1,0}(0) &amp; = &amp; C_{0}^{0,0}(\Diamond )\\ C_{0}^{1,0}(t+1) &amp; = &amp; C_{0}^{1,0}(t) \end{eqnarray*}
</div>lo cual implica que \(C_{0}^{1,0}=R\left (C_{0}^{0,0},p_{1}^{2,0}\right )\in \mathrm{PR}_{1}^{\Sigma }.\) Tambien note que \[ \lambda tx\left [t.x\right ]=R\left (C_{0}^{1,0},\lambda xy\left [x+y\right ]\circ \left [p_{1}^{3,0},p_{3}^{3,0}\right ]\right ), \] lo cual por (2) implica que \(\lambda tx\left [t.x\right ]\in \mathrm{PR}_{4}^{\Sigma }\).
<!-- l. 4798 --><p class='indent'>   (4) Note que </p><div class='eqnarray'>\begin{eqnarray*} \lambda x\left [x!\right ](0) &amp; = &amp; 1=C_{1}^{0,0}(\Diamond )\\ \lambda x\left [x!\right ](t+1) &amp; = &amp; \lambda x\left [x!\right ](t).(t+1), \end{eqnarray*}
</div>lo cual implica que \[ \lambda x\left [x!\right ]=R\left (C_{1}^{0,0},\lambda xy\left [x.y\right ]\circ \left [p_{1}^{2,0},Suc\circ p_{2}^{2,0}\right ]\right ). \] Ya que \(C_{1}^{0,0}=\) \(Suc\circ C_{0}^{0,0}\), tenemos que \(C_{1}^{0,0}\in \mathrm{PR}_{1}^{\Sigma }\). Por (3), tenemos que \[ \lambda xy\left [x.y\right ]\circ \left [p_{1}^{2,0},Suc\circ p_{2}^{2,0}\right ]\in \mathrm{PR}_{5}^{\Sigma }, \] obteniendo que
\(\lambda x\left [x!\right ]\in \mathrm{PR}_{6}^{\Sigma }\).                                                                                                     □
   </div>
<!-- l. 4816 --><p class='indent'>   Ahora consideraremos dos funciones las cuales son obtenidas naturalmente por
recursion primitiva sobre variable alfabetica.
</p>
   <div class='newtheorem'>
<!-- l. 4818 --><p class='noindent'><span class='head'>
<a id='x1-81006r47'></a>
<span class='cmbx-10'>Lema 47.</span>  </span><span class='cmti-10'>Supongamos</span> \(\Sigma \) <span class='cmti-10'>es un alfabeto finito.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-81007x47'>\(\lambda \alpha \beta \left [\alpha \beta \right ]\in \mathrm{PR}^{\Sigma }\)
     </li>
     <li class='enumerate' id='x1-81008x47'>\(\lambda \alpha \left [\left \vert \alpha \right \vert \right ]\in \mathrm{PR}^{\Sigma }\)</li></ol>

   </div>
<!-- l. 4826 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4827 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Ya que </p><div class='eqnarray'>\begin{eqnarray*} \lambda \alpha \beta \left [\alpha \beta \right ](\alpha _{1},\varepsilon ) &amp; = &amp; \alpha _{1}=p_{1}^{0,1}(\alpha _{1})\\ \lambda \alpha \beta \left [\alpha \beta \right ](\alpha _{1},\alpha a) &amp; = &amp; d_{a}(\lambda \alpha \beta \left [\alpha \beta \right ](\alpha _{1},\alpha )),a\in \Sigma  \end{eqnarray*}
</div>tenemos que \(\lambda \alpha \beta \left [\alpha \beta \right ]=R\left (p_{1}^{0,1},\mathcal{G}\right )\), donde \(\mathcal{G}_{a}=d_{a}\circ p_{3}^{0,3}\), para cada \(a\in \Sigma \).
<!-- l. 4835 --><p class='indent'>   (b) Ya que </p><div class='eqnarray'>\begin{eqnarray*} \lambda \alpha \left [\left \vert \alpha \right \vert \right ](\varepsilon ) &amp; = &amp; 0=C_{0}^{0,0}(\Diamond )\\ \lambda \alpha \left [\left \vert \alpha \right \vert \right ](\alpha a) &amp; = &amp; \lambda \alpha \left [\left \vert \alpha \right \vert \right ](\alpha )+1 \end{eqnarray*}
</div>tenemos que \(\lambda \alpha \left [\left \vert \alpha \right \vert \right ]=R\left (C_{0}^{0,0},\mathcal{G}\right )\), donde \(\mathcal{G}_{a}=\) \(Suc\circ p_{1}^{1,1}\), para cada \(a\in \Sigma .\).                                                        □
   </div>
   <div class='newtheorem'>
<!-- l. 4845 --><p class='noindent'><span class='head'>
<a id='x1-81009r48'></a>
<span class='cmbx-10'>Lema 48.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto finito. Entonces</span> \(C_{k}^{n,m},C_{\alpha }^{n,m}\in \mathrm{PR}^{\Sigma }\)<span class='cmti-10'>, para cada</span> \(n,m,k\geq 0\) <span class='cmti-10'>y</span> \(\alpha \in \Sigma ^{\ast }\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 4850 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4851 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Note que \(C_{k+1}^{0,0}=\) \(Suc\circ C_{k}^{0,0}\), lo cual implica \(C_{k}^{0,0}\in \mathrm{PR}_{k}^{\Sigma }\), para \(k\geq 0\). Tambien note que \(C_{\alpha a}^{0,0}=d_{a}\circ C_{\alpha }^{0,0}\), lo cual dice que \(C_{\alpha }^{0,0}\in \mathrm{PR}^{\Sigma }\),
para \(\alpha \in \Sigma ^{\ast }\). Para ver que \(C_{k}^{0,1}\in \mathrm{PR}^{\Sigma }\) notar que </p><div class='eqnarray'>\begin{eqnarray*} C_{k}^{0,1}(\varepsilon ) &amp; = &amp; k=C_{k}^{0,0}(\Diamond )\\ C_{k}^{0,1}(\alpha a) &amp; = &amp; C_{k}^{0,1}(\alpha )=p_{1}^{1,1}\left (C_{k}^{0,1}(\alpha ),\alpha \right ) \end{eqnarray*}
</div>lo cual implica que \(C_{k}^{0,1}=R\left (C_{k}^{0,0},\mathcal{G}\right )\), con \(\mathcal{G}_{a}=p_{1}^{1,1}\), \(a\in \Sigma \). En forma similar podemos ver que \(C_{k}^{1,0},C_{\alpha }^{1,0},C_{\alpha }^{0,1}\in \mathrm{PR}^{\Sigma }\). Supongamos ahora
que \(m&gt;0\). Entonces <div class='eqnarray'>\begin{eqnarray*} C_{k}^{n,m} &amp; = &amp; C_{k}^{0,1}\circ p_{n+1}^{n,m}\\ C_{\alpha }^{n,m} &amp; = &amp; C_{\alpha }^{0,1}\circ p_{n+1}^{n,m} \end{eqnarray*}
</div>de lo cual obtenemos que \(C_{k}^{n,m},C_{\alpha }^{n,m}\in \mathrm{PR}^{\Sigma }\). El caso \(n&gt;0\) es similar.                                         □
   </div>
   <div class='newtheorem'>
<!-- l. 4873 --><p class='noindent'><span class='head'>
<a id='x1-81010r49'></a>
<span class='cmbx-10'>Lema 49.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto finito.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-81011x49'>\(\lambda xy\left [x^{y}\right ]\in \mathrm{PR}^{\Sigma }\)<span class='cmti-10'>.</span>

     </li>
     <li class='enumerate' id='x1-81012x49'>\(\lambda t\alpha \left [\alpha ^{t}\right ]\in \mathrm{PR}^{\Sigma }\)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 4881 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4882 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Note que \[ \lambda tx\left [x^{t}\right ]=R\left (C_{1}^{1,0},\lambda xy\left [x.y\right ]\circ \left [p_{1}^{3,0},p_{3}^{3,0}\right ]\right )\in \mathrm{PR}^{\Sigma }. \] O sea que \(\lambda xy\left [x^{y}\right ]=\lambda tx\left [x^{t}\right ]\circ \left [p_{2}^{2,0},p_{1}^{2,0}\right ]\in \mathrm{PR}^{\Sigma }\).
</p><!-- l. 4888 --><p class='indent'>   (b) Note que \[ \lambda t\alpha \left [\alpha ^{t}\right ]=R\left (C_{\varepsilon }^{0,1},\lambda \alpha \beta \left [\alpha \beta \right ]\circ \left [p_{3}^{1,2},p_{2}^{1,2}\right ]\right )\in \mathrm{PR}^{\Sigma }. \]                                                                                □
</p>
   </div>
<!-- l. 4895 --><p class='indent'>   Ahora probaremos que si \(\Sigma \) es no vacio, entonces las biyeciones naturales entre \(\Sigma ^{\ast }\) y \(\omega \),
dadas en el Lema <span class='cmbx-10'>??</span>, son \(\Sigma \)-p.r..
</p>
   <div class='newtheorem'>
<!-- l. 4898 --><p class='noindent'><span class='head'>
<a id='x1-81013r50'></a>
<span class='cmbx-10'>Lema 50.</span>  </span><span class='cmti-10'>Si</span> \(\leq \) <span class='cmti-10'>es un orden total sobre un alfabeto no vacio</span> \(\Sigma \)<span class='cmti-10'>, entonces</span> \(s^{\leq }\)<span class='cmti-10'>,</span> \(\#^{\leq }\) <span class='cmti-10'>y</span> \(\ast ^{\leq }\)
<span class='cmti-10'>pertenecen a</span> \(\mathrm{PR}^{\Sigma }\)
</p>
   </div>
<!-- l. 4904 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4905 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(\Sigma =\{a_{1},...,a_{k}\}\) y \(\leq \) es dado por \(a_{1}&lt;...&lt;a_{k}\). Ya que </p><div class='eqnarray'>\begin{eqnarray*} s^{\leq }(\varepsilon ) &amp; = &amp; a_{1}\\ s^{\leq }(\alpha a_{i}) &amp; = &amp; \alpha a_{i+1}\text{, para }i&lt;k\\ s^{\leq }(\alpha a_{k}) &amp; = &amp; s^{\leq }(\alpha )a_{1} \end{eqnarray*}
</div>tenemos que \(s^{\leq }=R\left (C_{a_{1}}^{0,0},\mathcal{G}\right )\), donde \(\mathcal{G}_{a_{i}}=d_{a_{i+1}}\circ p_{1}^{0,2}\), para \(i=1,...,k-1\) y \(\mathcal{G}_{a_{k}}=d_{a_{1}}\circ p_{2}^{0,2}.\) O sea que \(s^{\leq }\in \mathrm{PR}^{\Sigma }.\) Ya que <div class='eqnarray'>\begin{eqnarray*} \ast ^{\leq }(0) &amp; = &amp; \varepsilon \\ \ast ^{\leq }(t+1) &amp; = &amp; s^{\leq }(\ast ^{\leq }(t)) \end{eqnarray*}
</div>podemos ver que \(\ast ^{\leq }\in \mathrm{PR}^{\Sigma }\). Ya que <div class='eqnarray'>\begin{eqnarray*} \#^{\leq }(\varepsilon ) &amp; = &amp; 0\\ \#^{\leq }(\alpha a_{i}) &amp; = &amp; \#^{\leq }(\alpha ).k+i\text{, para }i=1,...,k, \end{eqnarray*}
</div>tenemos que \(\#^{\leq }=R\left (C_{0}^{0,0},\mathcal{G}\right )\), donde \[ \mathcal{G}_{a_{i}}=\lambda xy\left [x+y\right ]\circ \left [\lambda xy\left [x.y\right ]\circ \left [p_{1}^{1,1},C_{k}^{1,1}\right ],C_{i}^{1,1}\right ]\text{, para }i=1,...,k\text{.} \] O sea que \(\#^{\leq }\in \mathrm{PR}^{\Sigma }\).                                                          □
   </div>
<!-- l. 4933 --><p class='indent'>   Dados \(x,y\in \omega \), definamos \[ x\dot{-}y=\max (x-y,0). \]
</p><!-- l. 4938 --><p class='indent'>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-81014x3.2.1'>\(\lambda xy\left [x\dot{-}y\right ]\in \mathrm{PR}^{\Sigma }.\)

         <ol class='enumerate2'>
         <li class='enumerate' id='x1-81015x3.2.1'>\(\lambda xy\left [\max (x,y)\right ]\in \mathrm{PR}^{\Sigma }.\)
         </li>
         <li class='enumerate' id='x1-81016x3.2.1'>\(\lambda xy\left [x=y\right ]\in \mathrm{PR}^{\Sigma }.\)
         </li>
         <li class='enumerate' id='x1-81017x3.2.1'>\(\lambda xy\left [x\leq y\right ]\in \mathrm{PR}^{\Sigma }.\)
         </li>
         <li class='enumerate' id='x1-81018x3.2.1'>\(\lambda \alpha \beta \left [\alpha =\beta \right ]\in \mathrm{PR}^{\Sigma }\)</li></ol>
     </li></ol>
<!-- l. 4947 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 4948 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Primero notar que \(\lambda x\left [x\dot{-}1\right ]=R\left (C_{0}^{0,0},p_{2}^{2,0}\right )\in \mathrm{PR}^{\Sigma }.\) Tambien note que \[ \lambda tx\left [x\dot{-}t\right ]=R\left (p_{1}^{1,0},\lambda x\left [x\dot{-}1\right ]\circ p_{1}^{3,0}\right )\in \mathrm{PR}^{\Sigma }. \] O sea que \(\lambda xy\left [x\dot{-}y\right ]=\lambda tx\left [x\dot{-}t\right ]\circ \left [p_{2}^{2,0},p_{1}^{2,0}\right ]\in \mathrm{PR}^{\Sigma }.\)
</p><!-- l. 4955 --><p class='indent'>   (b) Note que \(\lambda xy\left [\max (x,y)\right ]=\lambda xy\left [x+(y\dot{-}x)\right ].\)
</p><!-- l. 4957 --><p class='indent'>   (c) Note que \(\lambda xy\left [x=y\right ]=\lambda xy\left [1\dot{-}((x\dot{-}y)+(y\dot{-}x))\right ].\)
</p><!-- l. 4959 --><p class='indent'>   (d) Note que \(\lambda xy\left [x\leq y\right ]=\lambda xy\left [1\dot{-}(x\dot{-}y)\right ].\)
</p><!-- l. 4961 --><p class='indent'>   (e) Sea \(\leq \) un orden total sobre \(\Sigma .\) Ya que \[ \alpha =\beta \text{ sii }\#^{\leq }(\alpha )=\#^{\leq }(\beta ) \] tenemos que \[ \lambda \alpha \beta \left [\alpha =\beta \right ]=\lambda xy\left [x=y\right ]\circ \left [\#^{\leq }\circ p_{1}^{0,2},\#^{\leq }\circ p_{2}^{0,2}\right ] \] lo cual nos dice que \(\lambda \alpha \beta \left [\alpha =\beta \right ]\) es
\(\Sigma \)-p.r.                                                                                                □
</p>
   </div>
<!-- l. 4975 --><p class='noindent'><span class='paragraphHead'><a id='x1-820003.2.1'></a><span class='cmbx-10'>Operaciones logicas entre predicados</span></span>
   Dados predicados \(P:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) y \(Q:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \), con el mismo dominio, definamos nuevos predicados \((P\vee Q)\), \((P\wedge Q)\) y \(\lnot P\) de
la siguiente manera
</p>
   <div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \begin{array}{rll} (P\vee Q):S &amp; \rightarrow &amp; \omega \\ (\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; \left \{ \begin{array}{lll} 1 &amp; &amp; \text{si }P(\vec{x},\vec{\alpha })=1\text{ o }Q(\vec{x},\vec{\alpha })=1\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \end{array}\\ &amp; &amp; \begin{array}{rll} (P\wedge Q):S &amp; \rightarrow &amp; \omega \\ (\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; \left \{ \begin{array}{lll} 1 &amp; &amp; \text{si }P(\vec{x},\vec{\alpha })=1\text{ y }Q(\vec{x},\vec{\alpha })=1\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \end{array}\\ &amp; &amp; \begin{array}{rll} \lnot P:S &amp; \rightarrow &amp; \omega \\ (\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; \left \{ \begin{array}{lll} 1 &amp; &amp; \text{si }P(\vec{x},\vec{\alpha })=0\\ 0 &amp; &amp; \text{si }P(\vec{x},\vec{\alpha })=1 \end{array}\right . \end{array} \end{eqnarray*}
</div>
   <div class='newtheorem'>
<!-- l. 5006 --><p class='noindent'><span class='head'>
<a id='x1-82001r51'></a>
<span class='cmbx-10'>Lema 51.</span>  </span><span class='cmti-10'>Si</span> \(P:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>y</span> \(Q:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>son predicados</span> \(\Sigma \)<span class='cmti-10'>-p.r., entonces</span> \((P\vee Q)\)<span class='cmti-10'>,</span> \((P\wedge Q)\) <span class='cmti-10'>y</span> \(\lnot P\) <span class='cmti-10'>lo son tambien.</span>
</p>
   </div>
<!-- l. 5013 --><p class='indent'>
</p>
   <div class='proof'>

<!-- l. 5014 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Note que </p><div class='eqnarray'>\begin{eqnarray*} \lnot P &amp; = &amp; \lambda xy\left [x\dot{-}y\right ]\circ \left [C_{1}^{n,m},P\right ]\\ (P\wedge Q) &amp; = &amp; \lambda xy\left [x.y\right ]\circ [P,Q]\\ (P\vee Q) &amp; = &amp; \lnot (\lnot P\wedge \lnot Q). \end{eqnarray*}
</div>                                                                 □
   </div>
<!-- l. 5025 --><p class='noindent'><span class='paragraphHead'><a id='x1-830003.2.1'></a><span class='cmbx-10'>Conjuntos</span> \(\Sigma \)<span class='cmbx-10'>-recursivos primitivos</span></span>
   Un conjunto \(\Sigma \)-mixto \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) es llamado \(\Sigma \)<span class='cmti-10'>-recursivo primitivo </span>si su funcion caracteristica \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\)
es \(\Sigma \)-p.r.. (Notese que \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) es el predicado \(\lambda \vec{x}\vec{\alpha }\left [(\vec{x},\vec{\alpha })\in S\right ]\).)
</p>
   <div class='newtheorem'>
<!-- l. 5032 --><p class='noindent'><span class='head'>
<a id='x1-83001r52'></a>
<span class='cmbx-10'>Lema 52.</span>  </span><span class='cmti-10'>Si</span> \(S_{1},S_{2}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-p.r., entonces</span> \(S_{1}\cup S_{2}\)<span class='cmti-10'>,</span> \(S_{1}\cap S_{2}\) <span class='cmti-10'>y</span> \(S_{1}-S_{2}\) <span class='cmti-10'>lo son.</span>
</p>
   </div>
<!-- l. 5038 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5039 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Note que </p><div class='eqnarray'>\begin{eqnarray*} \chi _{S_{1}\cup S_{2}}^{\omega ^{n}\times \Sigma ^{\ast m}} &amp; = &amp; (\chi _{S_{1}}^{\omega ^{n}\times \Sigma ^{\ast m}}\vee \chi _{S_{2}}^{\omega ^{n}\times \Sigma ^{\ast m}})\\ \chi _{S_{1}\cap S_{2}}^{\omega ^{n}\times \Sigma ^{\ast m}} &amp; = &amp; (\chi _{S_{1}}^{\omega ^{n}\times \Sigma ^{\ast m}}\wedge \chi _{S_{2}}^{\omega ^{n}\times \Sigma ^{\ast m}})\\ \chi _{S_{1}-S_{2}}^{\omega ^{n}\times \Sigma ^{\ast m}} &amp; = &amp; \lambda xy\left [x\dot{-}y\right ]\circ \left [\chi _{S_{1}}^{\omega ^{n}\times \Sigma ^{\ast m}},\chi _{S_{2}}^{\omega ^{n}\times \Sigma ^{\ast m}}\right ] \end{eqnarray*}
</div>                                                                 □
   </div>
   <div class='newtheorem'>
<!-- l. 5046 --><p class='noindent'><span class='head'>
<a id='x1-83002r53'></a>
<span class='cmbx-10'>Corollary 53.</span>  </span><span class='cmti-10'>Si</span> \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>es finito, entonces</span> \(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span>
</p>
   </div>
<!-- l. 5051 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5052 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Si \(S=\emptyset \), entonces es claro que \(S\) es \(\Sigma \)-p.r.. Probaremos ahora el lema para el caso en
que \(S\) tiene un solo elemento. Supongamos entonces \[ S=\{(z_{1},...,z_{n},\gamma _{1},...,\gamma _{m})\}. \] Note que \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) es el siguiente
predicado \[ \left (\chi _{\{z_{1}\}}^{\omega }\circ p_{1}^{n,m}\wedge ...\wedge \chi _{\{z_{n}\}}^{\omega }\circ p_{n}^{n,m}\wedge \chi _{\{\gamma _{1}\}}^{\Sigma ^{\ast }}\circ p_{n+1}^{n,m}\wedge ...\wedge \chi _{\{\gamma _{m}\}}^{\Sigma ^{\ast }}\circ p_{n+m}^{n,m}\right ). \] Ya que los predicados </p><div class='eqnarray'>\begin{eqnarray*} \chi _{\{z_{i}\}}^{\omega } &amp; = &amp; \lambda xy\left [x=y\right ]\circ \left [p_{1}^{1,0},C_{z_{i}}^{1,0}\right ]\\ \chi _{\{\gamma _{i}\}}^{\Sigma ^{\ast }} &amp; = &amp; \lambda \alpha \beta \left [\alpha =\beta \right ]\circ \left [p_{1}^{0,1},C_{\gamma _{i}}^{0,1}\right ] \end{eqnarray*}
</div>son \(\Sigma \)-p.r., el Lema <a href='#x1-82001r51'>51<!-- tex4ht:ref: boolean op  --></a> (aplicado \((n+m)-1\) veces), implica que \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) es \(\Sigma \)-p.r.. Cuando \(S\) tiene mas de un
elemento, ya que entonces es la union de una cantidad finita de conjuntos de un
solo elemento, se puede aplicar el Lema <a href='#x1-83001r52'>52<!-- tex4ht:ref: union  --></a> (\(\left \vert S\right \vert -1\) veces) para obtener que \(S\) es
\(\Sigma \)-p.r..                                                                                                □
   </div>
<!-- l. 5077 --><p class='indent'>   El siguiente lema caracteriza cuando un conjunto rectangular es \(\Sigma \)-p.r..
</p>
   <div class='newtheorem'>
<!-- l. 5078 --><p class='noindent'><span class='head'>
<a id='x1-83003r54'></a>
<span class='cmbx-10'>Lema 54.</span>  </span><span class='cmti-10'>Supongamos</span> \(S_{1},...,S_{n}\subseteq \omega \)<span class='cmti-10'>,</span> \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) <span class='cmti-10'>son conjuntos no vacios. Entonces</span> \(S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r. sii</span> \(S_{1},...,S_{n},L_{1},...,L_{m}\) <span class='cmti-10'>son</span>
\(\Sigma \)<span class='cmti-10'>-p.r.</span>
</p>
   </div>
<!-- l. 5085 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5086 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(\(\Rightarrow \)) Veremos por ejemplo que \(L_{1}\) es \(\Sigma \)-p.r.. Sea \((z_{1},...,z_{n},\zeta _{1},...,\zeta _{m})\) un elemento fijo de \(S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}.\) Note que
\[ \alpha \in L_{1}\text{ sii }(z_{1},...,z_{n},\alpha ,\zeta _{2},...,\zeta _{m})\in S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}, \] lo cual implica que \[ \chi _{L_{1}}^{\Sigma ^{\ast }}=\chi _{S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}}^{\omega ^{n}\times \Sigma ^{\ast m}}\circ \left [C_{z_{1}}^{0,1},...,C_{z_{n}}^{0,1},p_{1}^{0,1},C_{\zeta _{2}}^{0,1},...,C_{\zeta _{m}}^{0,1}\right ] \] (\(\Leftarrow \)) Note que \(\chi _{S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}}^{\omega ^{n}\times \Sigma ^{\ast m}}\) es el predicado \[ \left (\chi _{S_{1}}^{\omega }\circ p_{1}^{n,m}\wedge ...\wedge \chi _{S_{n}}^{\omega }\circ p_{n}^{n,m}\wedge \chi _{L_{1}}^{\Sigma ^{\ast }}\circ p_{n+1}^{n,m}\wedge ...\wedge \chi _{L_{m}}^{\Sigma ^{\ast }}\circ p_{n+m}^{n,m}\right ). \]                                     □
</p>
   </div>
<!-- l. 5105 --><p class='indent'>   Dada una funcion \(f\) y un conjunto \(S\subseteq D_{f}\), usaremos \(f|_{S}\) para denotar la <span class='cmti-10'>restriccion </span>de \(f\) al
conjunto \(S\), i.e. \(f|_{S}=f\cap (S\times I_{f})\). Notese que \(f|_{S}\) es la funcion dada por \[ D_{f|_{S}}=S\text{ \ \ \ y \ \ }f|_{S}(e)=f(e)\text{, para cada }e\in S \]
</p>
   <div class='newtheorem'>
<!-- l. 5113 --><p class='noindent'><span class='head'>
<a id='x1-83004r55'></a>
<span class='cmbx-10'>Lema 55.</span>  </span><span class='cmti-10'>Sean</span> \(n,m\in \omega \) <span class='cmti-10'>y</span> \(O\in \{\omega ,\Sigma ^{\ast }\}\)<span class='cmti-10'>. Supongamos</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r.. Si</span> \(S\subseteq D_{f}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r., entonces</span> \(f|_{S}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span>

</p>
   </div>
<!-- l. 5120 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5121 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(O=\Sigma ^{\ast }\). Entonces \[ f|_{S}=\lambda x\alpha \left [\alpha ^{x}\right ]\circ \left [Suc\circ Pred\circ \chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}},f\right ] \] lo cual nos dice que \(f|_{S}\) es \(\Sigma \)-p.r.. El caso \(O=\omega \) es similar
usando \(\lambda xy\left [x^{y}\right ]\) en lugar de \(\lambda x\alpha \left [\alpha ^{x}\right ]\).                                                                          □
</p>
   </div>
<!-- l. 5130 --><p class='indent'>   Usando el lema anterior en combinacion con el Lema <a href='#x1-82001r51'>51<!-- tex4ht:ref: boolean op  --></a> podemos ver que muchos
predicados usuales son \(\Sigma \)-p.r.. Por ejemplo sea \[ P=\lambda x\alpha \beta \gamma \left [x=\left \vert \gamma \right \vert \wedge \alpha =\gamma ^{Pred(\left \vert \beta \right \vert )}\right ]. \] Notese que \[ D_{P}=\omega \times \Sigma ^{\ast }\times (\Sigma ^{\ast }-\{\varepsilon \})\times \Sigma ^{\ast } \] es \(\Sigma \)-p.r. ya que \[ \chi _{D_{P}}^{\omega \times \Sigma ^{\ast 3}}=\lnot \lambda \alpha \beta \left [\alpha =\beta \right ]\circ \left [p_{3}^{1,3},C_{\varepsilon }^{1,3}\right ] \] Tambien
note que los predicados </p><div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \lambda x\alpha \beta \gamma \left [x=\left \vert \gamma \right \vert \right ]\\ &amp; &amp; \lambda x\alpha \beta \gamma \left [\alpha =\gamma ^{Pred(\left \vert \beta \right \vert )}\right ] \end{eqnarray*}
</div>son \(\Sigma \)-p.r. ya que pueden obtenerse componiendo funciones \(\Sigma \)-p.r.. O sea que \(P\) es \(\Sigma \)-p.r. ya
que \[ P=\left (\lambda x\alpha \beta \gamma \left [x=\left \vert \gamma \right \vert \right ]|_{D_{P}}\wedge \lambda x\alpha \beta \gamma \left [\alpha =\gamma ^{Pred(\left \vert \beta \right \vert )}\right ]\right ). \]
<!-- l. 5155 --><p class='indent'>   @@finpagina@@
</p>
   <div class='newtheorem'>
<!-- l. 5156 --><p class='noindent'><span class='head'>
<a id='x1-83005r56'></a>
<span class='cmbx-10'>Lema 56.</span>  </span><span class='cmti-10'>Sean</span> \(n,m\in \omega \) <span class='cmti-10'>y</span> \(O\in \{\omega ,\Sigma ^{\ast }\}\)<span class='cmti-10'>. Si</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r., entonces existe una funcion</span> \(\Sigma \)<span class='cmti-10'>-p.r.</span> \(\bar{f}:\omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\)<span class='cmti-10'>, tal que</span> \(f=\bar{f}|_{D_{f}}\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 5163 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5164 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es facil ver por induccion en \(k\) que el enunciado se cumple para cada \(f\in \mathrm{PR}_{k}^{\Sigma }\)   □
</p>
   </div>
<!-- l. 5169 --><p class='indent'>   Ahora podemos probar el siguiente importante resultado
</p>
   <div class='newtheorem'>
<!-- l. 5170 --><p class='noindent'><span class='head'>
<a id='x1-83006r57'></a>

<span class='cmbx-10'>Proposition 57.</span>  </span><span class='cmti-10'>Un conjunto</span> \(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r. sii</span> \(S\) <span class='cmti-10'>es el dominio de alguna funcion</span>
\(\Sigma \)<span class='cmti-10'>-p.r.</span>\(.\)
</p>
   </div>
<!-- l. 5175 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5176 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos que \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\).
</p><!-- l. 5178 --><p class='indent'>   (\(\Rightarrow \)) Note que \(S=D_{Pred\circ \chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}}\).
</p><!-- l. 5180 --><p class='indent'>   (\(\Leftarrow \)) Probaremos por induccion en \(k\) que \(D_{F}\) es \(\Sigma \)-p.r., para cada \(F\in \mathrm{PR}_{k}^{\Sigma }.\) El caso \(k=0\) es facil\(.\)
Supongamos el resultado vale para un \(k\) fijo y supongamos \(F\in \mathrm{PR}_{k+1}^{\Sigma }.\) Veremos entonces que
\(D_{F}\) es \(\Sigma \)-p.r.. Hay varios casos. Consideremos primero el caso en que \(F=R(f,g)\), donde
</p><div class='eqnarray'>\begin{eqnarray*} f &amp; : &amp; S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \Sigma ^{\ast }\\ g &amp; : &amp; \omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\times \Sigma ^{\ast }\rightarrow \Sigma ^{\ast }, \end{eqnarray*}
</div>con \(S_{1},...,S_{n}\subseteq \omega \) y \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) conjuntos no vacios y \(f,g\in \mathrm{PR}_{k}^{\Sigma }\). Notese que por definicion de \(R(f,g)\), tenemos que \[ D_{F}=\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}. \] Por
hipotesis inductiva tenemos que \(D_{f}=S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\) es \(\Sigma \)-p.r., lo cual por el Lema <a href='#x1-83003r54'>54<!-- tex4ht:ref: rectangulos pr  --></a> nos dice
que los conjuntos \(S_{1},...,S_{n}\), \(L_{1},...,L_{m}\) son \(\Sigma \)-p.r.. Ya que \(\omega \) es \(\Sigma \)-p.r., el Lema <a href='#x1-83003r54'>54<!-- tex4ht:ref: rectangulos pr  --></a> nos dice que \(D_{F}\) es
\(\Sigma \)-p.r..
<!-- l. 5201 --><p class='indent'>   Los otros casos de recursion primitiva son dejados al lector.
</p><!-- l. 5203 --><p class='indent'>   Supongamos ahora que \(F=g\circ [g_{1},...,g_{r}]\) con \(g,g_{1},...,g_{r}\in \mathrm{PR}_{k}^{\Sigma }\). Si \(F=\emptyset \), entonces es claro que \(D_{F}=\emptyset \) es \(\Sigma \)-p.r.. Supongamos
entonces que \(F\) no es la funcion \(\emptyset \). Tenemos entonces que \(r\) es de la forma \(n+m\) y
</p><div class='eqnarray'>\begin{eqnarray*} g &amp; : &amp; D_{g}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\\ g_{i} &amp; : &amp; D_{g_{i}}\subseteq \omega ^{k}\times \Sigma ^{\ast l}\rightarrow \omega \text{, }i=1,...,n\\ g_{i} &amp; : &amp; D_{g_{i}}\subseteq \omega ^{k}\times \Sigma ^{\ast l}\rightarrow \Sigma ^{\ast },i=n+1,...,n+m \end{eqnarray*}
</div>con \(O\in \{\omega ,\Sigma ^{\ast }\}\) y \(k,l\in \omega \). Por Lema <a href='#x1-83005r56'>56<!-- tex4ht:ref: extension  --></a>, hay funciones \(\Sigma \)-p.r. \(\bar{g}_{1},...,\bar{g}_{n+m}\) las cuales son \(\Sigma \)-totales y cumplen \[ g_{i}=\bar{g}_{i}|_{D_{g_{i}}}\text{, para }i=1,...,n+m. \] Por
hipotesis inductiva los conjuntos \(D_{g}\), \(D_{g_{i}}\), \(i=1,...,n+m\), son \(\Sigma \)-p.r. y por lo tanto \[ S=\bigcap _{i=1}^{n+m}D_{g_{i}} \] lo es. Notese que \[ \chi _{D_{F}}^{\omega ^{k}\times \Sigma ^{\ast l}}=(\chi _{D_{g}}^{\omega ^{n}\times \Sigma ^{\ast m}}\circ \left [\bar{g}_{1},...,\bar{g}_{n+m}\right ]\wedge \chi _{S}^{\omega ^{k}\times \Sigma ^{\ast l}}) \] lo
cual nos dice que \(D_{F}\) es \(\Sigma \)-p.r..                                                                    □
   </div>
<!-- l. 5232 --><p class='noindent'><span class='paragraphHead'><a id='x1-840003.2.1'></a><span class='cmbx-10'>Lema de division por casos para funciones</span> \(\Sigma \)<span class='cmbx-10'>-p.r.</span></span>
   Una observacion interesante es que si \(f_{i}:D_{f_{i}}\rightarrow O\), \(i=1,...,k\), son funciones tales que \(D_{f_{i}}\cap D_{f_{j}}=\emptyset \) para \(i\neq j\), entonces \(f_{1}\cup ...\cup f_{k}\)
es la funcion \[ \begin{array}{rll} D_{f_{1}}\cup ...\cup D_{f_{k}} &amp; \rightarrow &amp; O\\ e &amp; \rightarrow &amp; \left \{ \begin{array}{clc} f_{1}(e) &amp; &amp; \text{si }e\in D_{f_{1}}\\ \vdots &amp; &amp; \vdots \\ f_{k}(e) &amp; &amp; \text{si }e\in D_{f_{k}} \end{array}\right . \end{array} \]
</p>
   <div class='newtheorem'>
<!-- l. 5248 --><p class='noindent'><span class='head'>
<a id='x1-84001r58'></a>
<span class='cmbx-10'>Lema 58.</span>  </span><span class='cmti-10'>Sean</span> \(n,m\in \omega \) <span class='cmti-10'>y</span> \(O\in \{\omega ,\Sigma ^{\ast }\}\)<span class='cmti-10'>. Supongamos</span> \(f_{i}:D_{f_{i}}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\)<span class='cmti-10'>,</span> \(i=1,...,k\)<span class='cmti-10'>, son funciones</span> \(\Sigma \)<span class='cmti-10'>-p.r. tales que</span> \(D_{f_{i}}\cap D_{f_{j}}=\emptyset \) <span class='cmti-10'>para</span> \(i\neq j.\) <span class='cmti-10'>Entonces</span>
\(f_{1}\cup ...\cup f_{k}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span>

</p>
   </div>
<!-- l. 5255 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5256 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(O=\Sigma ^{\ast }\) y \(k=2.\) Sean \[ \bar{f}_{i}:\omega ^{n}\times \Sigma ^{\ast m}\rightarrow \Sigma ^{\ast },i=1,2, \] funciones \(\Sigma \)-p.r. tales que \(\bar{f}_{i}|_{D_{f_{i}}}=f_{i}\), \(i=1,2\) (Lema <a href='#x1-83005r56'>56<!-- tex4ht:ref: extension  --></a>)\(.\) Por Lema
<a href='#x1-83006r57'>57<!-- tex4ht:ref: caract-dominios  --></a> los conjuntos \(D_{f_{1}}\) y \(D_{f_{2}}\) son \(\Sigma \)-p.r. y por lo tanto lo es \(D_{f_{1}}\cup D_{f_{2}}\). Ya que \[ f_{1}\cup f_{2}=\left (\lambda \alpha \beta \left [\alpha \beta \right ]\circ \left [\lambda x\alpha \left [\alpha ^{x}\right ]\circ \left [\chi _{D_{f_{1}}}^{\omega ^{n}\times \Sigma ^{\ast m}},\bar{f}_{1}\right ],\lambda x\alpha \left [\alpha ^{x}\right ]\circ \left [\chi _{D_{f_{2}}}^{\omega ^{n}\times \Sigma ^{\ast m}},\bar{f}_{2}\right ]\right ]\right )|_{D_{f_{1}}\cup D_{f_{2}}} \] tenemos que \(f_{1}\cup f_{2}\) es \(\Sigma \)-p.r..
</p><!-- l. 5269 --><p class='indent'>   El caso \(k&gt;2\) puede probarse por induccion ya que \[ f_{1}\cup ...\cup f_{k}=(f_{1}\cup ...\cup f_{k-1})\cup f_{k}. \]                                     □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 5274 --><p class='noindent'><span class='head'>
<a id='x1-84002r59'></a>
<span class='cmbx-10'>Corollary 59.</span>  </span><span class='cmti-10'>Supongamos</span> \(f\) <span class='cmti-10'>es una funcion</span> \(\Sigma \)<span class='cmti-10'>-mixta cuyo dominio es finito.
</span><span class='cmti-10'>Entonces</span> \(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span>
</p>
   </div>
<!-- l. 5279 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5280 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\), con \(D_{f}=\{e_{1},...,e_{k}\}\). Por el Corolario <a href='#x1-83002r53'>53<!-- tex4ht:ref: finito  --></a>, cada \(\{e_{i}\}\) es \(\Sigma \)-p.r. por lo cual el Lema
<a href='#x1-83004r55'>55<!-- tex4ht:ref: restriccion  --></a> nos dice que \(C_{f(e_{i})}^{n,m}|_{\{e_{i}\}}\) es \(\Sigma \)-p.r.. O sea que \[ f=C_{f(e_{1})}^{n,m}|_{\{e_{1}\}}\cup ...\cup C_{f(e_{k})}^{n,m}|_{\{e_{k}\}} \] es \(\Sigma \)-p.r..                                            □
</p>
   </div>
<!-- l. 5292 --><p class='indent'>   Recordemos que dados \(i\in \omega \) y \(\alpha \in \Sigma ^{\ast }\), definimos \[ \left [\alpha \right ]_{i}=\left \{ \begin{array}{lll} i\text{-esimo elemento de }\alpha &amp; &amp; \text{si }1\leq i\leq \left \vert \alpha \right \vert \\ \varepsilon &amp; &amp; \text{caso contrario} \end{array}\right . \]
</p>
   <div class='newtheorem'>
<!-- l. 5300 --><p class='noindent'><span class='head'>
<a id='x1-84003r60'></a>
<span class='cmbx-10'>Lema 60.</span>  </span>\(\lambda i\alpha \left [[\alpha ]_{i}\right ]\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span>

</p>
   </div>
<!-- l. 5304 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5305 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Note que </p><div class='eqnarray'>\begin{eqnarray*} [\varepsilon ]_{i} &amp; = &amp; \varepsilon \\{} [\alpha a]_{i} &amp; = &amp; \left \{ \begin{array}{lll} [\alpha ]_{i} &amp; &amp; \text{si }i\neq \left \vert \alpha \right \vert +1\\ a &amp; &amp; \text{si }i=\left \vert \alpha \right \vert +1 \end{array}\right . \end{eqnarray*}
</div>lo cual dice que \(\lambda i\alpha \left [[\alpha ]_{i}\right ]=R\left (C_{\varepsilon }^{1,0},\mathcal{G}\right )\), donde \(\mathcal{G}_{a}:\omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }\rightarrow \Sigma ^{\ast }\) es dada por \[ \mathcal{G}_{a}(i,\alpha ,\zeta )=\left \{ \begin{array}{lll} \zeta &amp; &amp; \text{si }i\neq \left \vert \alpha \right \vert +1\\ a &amp; &amp; \text{si }i=\left \vert \alpha \right \vert +1 \end{array}\right . \] O sea que solo resta probar que cada \(\mathcal{G}_{a}\) es \(\Sigma \)-p.r..
Primero note que los conjuntos <div class='eqnarray'>\begin{eqnarray*} S_{1} &amp; = &amp; \left \{ (i,\alpha ,\zeta )\in \omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }:i\neq \left \vert \alpha \right \vert +1\right \} \\ S_{2} &amp; = &amp; \left \{ (i,\alpha ,\zeta )\in \omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }:i=\left \vert \alpha \right \vert +1\right \} \end{eqnarray*}
</div>son \(\Sigma \)-p.r. ya que <div class='eqnarray'>\begin{eqnarray*} \chi _{S_{1}}^{\omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }} &amp; = &amp; \lambda xy\left [x\neq y\right ]\circ \left [p_{1}^{1,2},Suc\circ \lambda \alpha \left [\left \vert \alpha \right \vert \right ]\circ p_{2}^{1,2}\right ]\\ \chi _{S_{2}}^{\omega \times \Sigma ^{\ast }\times \Sigma ^{\ast }} &amp; = &amp; \lambda xy\left [x=y\right ]\circ \left [p_{1}^{1,2},Suc\circ \lambda \alpha \left [\left \vert \alpha \right \vert \right ]\circ p_{2}^{1,2}\right ] \end{eqnarray*}
</div>Ya que \[ \mathcal{G}_{a}=p_{3}^{1,2}|_{S_{1}}\cup C_{a}^{1,2}|_{S_{2}} \] el Lema <a href='#x1-84001r58'>58<!-- tex4ht:ref: dpc  --></a> nos dice que \(\mathcal{G}_{a}\) es \(\Sigma \)-p.r., para cada \(a\in \Sigma \).                                □
   </div>
<!-- l. 5343 --><p class='noindent'><span class='paragraphHead'><a id='x1-850003.2.1'></a><span class='cmbx-10'>Sumatoria, productoria y concatenatoria de funciones</span> \(\Sigma \)<span class='cmbx-10'>-p.r.</span></span>
   Sea \(\Sigma \) un alfabeto finito. Sea \(f:\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \), con \(S_{1},...,S_{n}\subseteq \omega \) y \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) no vacios. Para \(x,y\in \omega \) y \((\vec{x},\vec{\alpha })\in S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\), definamos </p><div class='eqnarray'>\begin{eqnarray*} \sum \limits _{t=x}^{t=y}f(t,\vec{x},\vec{\alpha }) &amp; = &amp; \left \{ \begin{array}{lll} 0 &amp; &amp; \text{si }x&gt;y\\ f(x,\vec{x},\vec{\alpha })+f(x+1,\vec{x},\vec{\alpha })+...+f(y,\vec{x},\vec{\alpha }) &amp; &amp; \text{si }x\leq y \end{array}\right .\\ \prod \limits _{t=x}^{t=y}f(t,\vec{x},\vec{\alpha }) &amp; = &amp; \left \{ \begin{array}{lll} 1 &amp; &amp; \text{si }x&gt;y\\ f(x,\vec{x},\vec{\alpha }).f(x+1,\vec{x},\vec{\alpha })....f(y,\vec{x},\vec{\alpha }) &amp; &amp; \text{si }x\leq y \end{array}\right . \end{eqnarray*}
</div>En forma similar, cuando \(I_{f}\subseteq \Sigma ^{\ast }\), definamos \[ \overset{t=y}{\underset{t=x}{\subset }}f(t,\vec{x},\vec{\alpha })=\left \{ \begin{array}{lll} \varepsilon &amp; &amp; \text{si }x&gt;y\\ f(x,\vec{x},\vec{\alpha })f(x+1,\vec{x},\vec{\alpha })....f(y,\vec{x},\vec{\alpha }) &amp; &amp; \text{si }x\leq y \end{array}\right . \] Note que, en virtud de la definicion anterior, el
dominio de las funciones
<!-- l. 5370 --><p class='indent'>   \[ \lambda xy\vec{x}\vec{\alpha }\left [\sum _{t=x}^{t=y}f(t,\vec{x},\vec{\alpha })\right ]\ \ \ \ \ \ \ \ \ \ \ \ \lambda xy\vec{x}\vec{\alpha }\left [\prod _{t=x}^{t=y}f(t,\vec{x},\vec{\alpha })\right ]\ \ \ \ \ \ \ \ \ \ \ \ \lambda xy\vec{x}\vec{\alpha }\left [\subset _{t=x}^{t=y}f(t,\vec{x},\vec{\alpha })\right ] \] es \(\omega \times \omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\).
</p>
   <div class='newtheorem'>
<!-- l. 5372 --><p class='noindent'><span class='head'>
<a id='x1-85001r61'></a>
<span class='cmbx-10'>Lema 61.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto finito.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-85002x61'><span class='cmti-10'>Si</span> \(f:\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r., con</span> \(S_{1},...,S_{n}\subseteq \omega \) <span class='cmti-10'>y</span> \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) <span class='cmti-10'>no vacios, entonces las funciones</span> \(\lambda xy\vec{x}\vec{\alpha }\left [\sum _{t=x}^{t=y}f(t,\vec{x},\vec{\alpha })\right ]\) <span class='cmti-10'>y</span> \(\lambda xy\vec{x}\vec{\alpha }\left [\prod _{t=x}^{t=y}f(t,\vec{x},\vec{\alpha })\right ]\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-p.r.</span>
     </li>
     <li class='enumerate' id='x1-85003x61'><span class='cmti-10'>Si</span> \(f:\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \Sigma ^{\ast }\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r., con</span> \(S_{1},...,S_{n}\subseteq \omega \) <span class='cmti-10'>y</span> \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) <span class='cmti-10'>no vacios, entonces la funcion</span> \(\lambda xy\vec{x}\vec{\alpha }\left [\subset _{t=x}^{t=y}f(t,\vec{x},\vec{\alpha })\right ]\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r.</span></li></ol>
   </div>
<!-- l. 5387 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5388 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>(a) Sea \(G=\lambda tx\vec{x}\vec{\alpha }\left [\sum _{i=x}^{i=t}f(i,\vec{x},\vec{\alpha })\right ]\). Ya que \[ \lambda xy\vec{x}\vec{\alpha }\left [\sum _{i=x}^{i=y}f(i,\vec{x},\vec{\alpha })\right ]=G\circ \left [p_{2}^{n+2,m},p_{1}^{n+2,m},p_{3}^{n+2,m},...,p_{n+m+2}^{n+2,m}\right ] \] solo tenemos que probar que \(G\) es \(\Sigma \)-p.r.. Primero note que
</p><div class='eqnarray'>\begin{eqnarray*} G(0,x,\vec{x},\vec{\alpha }) &amp; = &amp; \left \{ \begin{array}{lll} 0 &amp; &amp; \text{si }x&gt;0\\ f(0,\vec{x},\vec{\alpha }) &amp; &amp; \text{si }x=0 \end{array}\right .\\ G(t+1,x,\vec{x},\vec{\alpha }) &amp; = &amp; \left \{ \begin{array}{lll} 0 &amp; &amp; \text{si }x&gt;t+1\\ G(t,x,\vec{x},\vec{\alpha })+f(t+1,\vec{x},\vec{\alpha }) &amp; &amp; \text{si }x\leq t+1 \end{array}\right . \end{eqnarray*}
</div>O sea que si definimos \[ \begin{array}{rll} h:\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m} &amp; \rightarrow &amp; \omega \\ (x,\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; \left \{ \begin{array}{lll} 0 &amp; &amp; \text{si }x&gt;0\\ f(0,\vec{x},\vec{\alpha }) &amp; &amp; \text{si }x=0 \end{array}\right . \end{array} \] \[ \begin{array}{rll} g:\omega ^{3}\times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m} &amp; \rightarrow &amp; \omega \\ (A,t,x,\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; \left \{ \begin{array}{lll} 0 &amp; &amp; \text{si }x&gt;t+1\\ A+f(t+1,\vec{x},\vec{\alpha }) &amp; &amp; \text{si }x\leq t+1 \end{array}\right . \end{array} \] tenemos que \(G=R(h,g)\). Es decir que solo nos falta probar que \(h\) y \(g\) son
\(\Sigma \)-p.r.. Sean <div class='eqnarray'>\begin{eqnarray*} D_{1} &amp; = &amp; \left \{ (x,\vec{x},\vec{\alpha })\in \omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}:x&gt;0\right \} \\ D_{2} &amp; = &amp; \left \{ (x,\vec{x},\vec{\alpha })\in \omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}:x=0\right \} \\ H_{1} &amp; = &amp; \left \{ (z,t,x,\vec{x},\vec{\alpha })\in \omega ^{3}\times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}:x&gt;t+1\right \} \\ H_{2} &amp; = &amp; \left \{ (z,t,x,\vec{x},\vec{\alpha })\in \omega ^{3}\times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}:x\leq t+1\right \} . \end{eqnarray*}
</div>Notese que <div class='eqnarray'>\begin{eqnarray*} h &amp; = &amp; C_{0}^{n+1,m}|_{D_{1}}\cup \lambda x\vec{x}\vec{\alpha }\left [f(0,\vec{x},\vec{\alpha })\right ]|_{D_{2}}\\ g &amp; = &amp; C_{0}^{n+3,m}|_{H_{1}}\cup \lambda Atx\vec{x}\vec{\alpha }\left [A+f(t+1,\vec{x},\vec{\alpha })\right ])|_{H_{2}} \end{eqnarray*}
</div>Ya que \(f\) es \(\Sigma \)-p.r. y <div class='eqnarray'>\begin{eqnarray*} \lambda x\vec{x}\vec{\alpha }\left [f(0,\vec{x},\vec{\alpha })\right ] &amp; = &amp; f\circ \left [C_{0}^{n+1,m},p_{2}^{n+1,m},p_{3}^{n+1,m},...,p_{n+1+m}^{n+1,m}\right ]\\ \lambda Atx\vec{x}\vec{\alpha }\left [A+f(t+1,\vec{x},\vec{\alpha })\right ]) &amp; = &amp; \lambda xy[x+y]\circ \left [p_{1}^{n+3,m},f\circ \left [Suc\circ p_{2}^{n+3,m},p_{4}^{n+3,m},...,p_{n+3+m}^{n+3,m}\right ]\right ] \end{eqnarray*}
</div>tenemos que \(\lambda x\vec{x}\vec{\alpha }\left [f(0,\vec{x},\vec{\alpha })\right ]\) y \(\lambda Atx\vec{x}\vec{\alpha }\left [A+f(t+1,\vec{x},\vec{\alpha })\right ])\) son \(\Sigma \)-p.r..O sea que para probar que \(h\) y \(g\) son \(\Sigma \)-p.r.solo nos falta ver que
los conjuntos \(D_{1},D_{2},H_{1},H_{2}\) son \(\Sigma \)-p.r.. y aplicar luego el Lema <a href='#x1-83004r55'>55<!-- tex4ht:ref: restriccion  --></a>. Veamos que por ejemplo \(H_{1}\) lo es. Es
decir debemos ver que \(\chi _{H_{1}}^{\omega ^{3+n}\times \Sigma ^{\ast m}}\) es \(\Sigma \)-p.r.. Ya que \(f\) es \(\Sigma \)-p.r. tenemos que \(D_{f}=\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\) es \(\Sigma \)-p.r., lo cual por el
Lema <a href='#x1-83003r54'>54<!-- tex4ht:ref: rectangulos pr  --></a> nos dice que los conjuntos \(S_{1},...,S_{n}\), \(L_{1},...,L_{m}\) son \(\Sigma \)-p.r.. Ya que \(\omega \) es \(\Sigma \)-p.r., el Lema <a href='#x1-83003r54'>54<!-- tex4ht:ref: rectangulos pr  --></a> nos dice
que \(R=\omega ^{3}\times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\) es \(\Sigma \)-p.r.. Notese que \(\chi _{H_{1}}^{\omega ^{3+n}\times \Sigma ^{\ast m}}=(\chi _{R}^{\omega ^{3+n}\times \Sigma ^{\ast m}}\wedge \lambda ztx\vec{x}\vec{\alpha }\left [x&gt;t+1\right ])\) por lo cual \(\chi _{H_{1}}^{\omega ^{3+n}\times \Sigma ^{\ast m}}\) es \(\Sigma \)-p.r. ya que es la conjuncion de dos
predicados \(\Sigma \)-p.r.                                                                                  □
   </div>
<!-- l. 5458 --><p class='indent'>   Veamos un ejemplo de como se puede aplicar el lema anterior. Sea \(F=\lambda yx_{1}\left [\sum _{t=0}^{t=y}(x_{1})^{t}\right ]\). Es claro que \(D_{F}=\omega ^{2}\).
Para ver que \(F\) es \(\Sigma \)-p.r. aplicaremos el lema anterior por lo cual es importante
encontrar la \(f\) adecuada a la cual se le aplicara el lema. Tomemos \(f=\lambda tx_{1}[(x_{1})^{t}]\). Claramente \(f\) es
\(\Sigma \)-p.r. por lo cual el lema anterior nos dice que \[ G=\lambda xyx_{1}\left [\sum _{t=x}^{t=y}f(t,x_{1})\right ]=\lambda xyx_{1}\left [\sum _{t=x}^{t=y}(x_{1})^{t}\right ] \] es \(\Sigma \)-p.r.. Claramente \(G\) no es
la funcion \(F\) pero es en algun sentido ”mas amplia” que \(F\) ya que tiene una
variable mas y se tiene que \(F(y,x_{1})=G(0,y,x_{1})\), para cada \(y,x_{1}\in \omega \). Es facil ver que \[ F=G\circ \left [C_{0}^{2,0},p_{1}^{2,0},p_{2}^{2,0}\right ] \] por lo cual \(F\) es
\(\Sigma \)-p.r..
</p>
<!-- l. 5479 --><p class='noindent'><span class='paragraphHead'><a id='x1-860003.2.1'></a><span class='cmbx-10'>Cuantificacion acotada de predicados</span> \(\Sigma \)<span class='cmbx-10'>-p.r. con dominio rectangular</span></span>
   Ses \(P:S\times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \) un predicado, con \(S,S_{1},...,S_{n}\subseteq \omega \) y \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) no vacios. Supongamos \(\bar{S}\subseteq S\). Entonces la expresion
Booleana \[ (\forall t\in \bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha }) \] depende de las variables \(x,\vec{x},\vec{\alpha }\) y valdra \(1\) en una \((1+n+m)\)-upla \((x,\vec{x},\vec{\alpha })\) cuando \(P(t,\vec{x},\vec{\alpha })\) sea igual a \(1\) para
cada \(t\in \{u\in \bar{S}:u\leq x\}\); y \(0\) en caso contrario. Tenemos entonces que el dominio del predicado \[ \lambda x\vec{x}\vec{\alpha }\left [(\forall t\in \bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha })\right ] \] es \(\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\). En
forma analoga se define la forma de interpretar la expresion Booleana \[ (\exists t\in \bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha }) \] Cabe destacar
que \[ \lambda x\vec{x}\vec{\alpha }\left [(\exists t\in \bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha })\right ]=\lnot \lambda x\vec{x}\vec{\alpha }\left [(\forall t\in \bar{S})_{t\leq x}\;\lnot P(t,\vec{x},\vec{\alpha })\right ] \]
</p><!-- l. 5505 --><p class='indent'>   Tambien podemos cuantificar sobre variable alfabetica. Sea \(P:S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\times L\rightarrow \omega \) un predicado, con \(S_{1},...,S_{n}\subseteq \omega \) y \(L,L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\)
no vacios. Supongamos \(\bar{L}\subseteq L\). Entonces la expresion Booleana \[ (\forall \alpha \in \bar{L})_{\left \vert \alpha \right \vert \leq x}\;P(\vec{x},\vec{\alpha },\alpha ) \] depende de las variables \(x,\vec{x},\vec{\alpha }\) y
valdra \(1\) en una \((1+n+m)\)-upla \((x,\vec{x},\vec{\alpha })\) cuando \(P(\vec{x},\vec{\alpha },\alpha )\) sea igual a \(1\) para cada \(\alpha \in \{u\in \bar{L}:\left \vert \alpha \right \vert \leq x\}\); y \(0\) en caso contrario.
Tenemos entonces que el dominio del predicado \[ \lambda x\vec{x}\vec{\alpha }\left [(\forall \alpha \in \bar{L})_{\left \vert \alpha \right \vert \leq x}\;P(\vec{x},\vec{\alpha },\alpha )\right ] \] es \(\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\). En forma analoga se
define la forma de interpretar la expresion Booleana \[ (\exists \alpha \in \bar{L})_{\left \vert \alpha \right \vert \leq x}\;P(\vec{x},\vec{\alpha },\alpha ) \] Cabe destacar que
\[ \lambda x\vec{x}\vec{\alpha }\left [(\exists \alpha \in \bar{L})_{\left \vert \alpha \right \vert \leq x}P(\vec{x},\vec{\alpha },\alpha )\right ]=\lnot \lambda x\vec{x}\vec{\alpha }\left [(\forall \alpha \in \bar{L})_{\left \vert \alpha \right \vert \leq x}\lnot P(\vec{x},\vec{\alpha },\alpha )\right ] \]
</p>
   <div class='newtheorem'>
<!-- l. 5531 --><p class='noindent'><span class='head'>
<a id='x1-86001r62'></a>
<span class='cmbx-10'>Lema 62.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto finito.</span>

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-86002x62'><span class='cmti-10'>Sea</span> \(P:S\times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \) <span class='cmti-10'>un predicado</span> \(\Sigma \)<span class='cmti-10'>-p.r., con</span> \(S,S_{1},...,S_{n}\subseteq \omega \) <span class='cmti-10'>y</span> \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) <span class='cmti-10'>no vacios. Supongamos</span> \(\bar{S}\subseteq S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r.. Entonces</span>
     \(\lambda x\vec{x}\vec{\alpha }\left [(\forall t\in \bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha })\right ]\) <span class='cmti-10'>y</span> \(\lambda x\vec{x}\vec{\alpha }\left [(\exists t\in \bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha })\right ]\) <span class='cmti-10'>son predicados</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span>
     </li>
     <li class='enumerate' id='x1-86003x62'><span class='cmti-10'>Sea</span> \(P:S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\times L\rightarrow \omega \) <span class='cmti-10'>un predicado</span> \(\Sigma \)<span class='cmti-10'>-p.r., con</span> \(S_{1},...,S_{n}\subseteq \omega \) <span class='cmti-10'>y</span> \(L,L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) <span class='cmti-10'>no vacios. Supongamos</span> \(\bar{L}\subseteq L\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r.. Entonces</span>
     \(\lambda x\vec{x}\vec{\alpha }\left [(\forall \alpha \in \bar{L})_{\left \vert \alpha \right \vert \leq x}\;P(\vec{x},\vec{\alpha },\alpha )\right ]\) <span class='cmti-10'>y</span> \(\lambda x\vec{x}\vec{\alpha }\left [(\exists \alpha \in \bar{L})_{\left \vert \alpha \right \vert \leq x}\;P(\vec{x},\vec{\alpha },\alpha )\right ]\) <span class='cmti-10'>son predicados</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span></li></ol>
   </div>
<!-- l. 5549 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5550 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Sea \[ \bar{P}=P|_{\bar{S}\times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}}\cup C_{1}^{1+n,m}|_{(\omega -\bar{S})\times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}} \] Notese que \(\bar{P}\) tiene dominio \(\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\) y es \(\Sigma \)-p.r.. Ya que </p><div class='eqnarray'>\begin{eqnarray*} \lambda x\vec{x}\vec{\alpha }\left [(\forall t\in \bar{S})_{t\leq x}P(t,\vec{x},\vec{\alpha })\right ] &amp; = &amp; \lambda x\vec{x}\vec{\alpha }\left [\prod \limits _{t=0}^{t=x}\bar{P}(t,\vec{x},\vec{\alpha })\right ]\\ &amp; = &amp; \lambda xy\vec{x}\vec{\alpha }\left [\prod \limits _{t=x}^{t=y}\bar{P}(t,\vec{x},\vec{\alpha })\right ]\circ \left [C_{0}^{1+n,m},p_{1}^{1+n,m},...,p_{1+n+m}^{1+n,m}\right ] \end{eqnarray*}
</div>el Lema <a href='#x1-85001r61'>61<!-- tex4ht:ref: iteracion  --></a> implica que \(\lambda x\vec{x}\vec{\alpha }\left [(\forall t\in \bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha })\right ]\) es \(\Sigma \)-p.r..
<!-- l. 5563 --><p class='indent'>   Ya que \[ \lambda x\vec{x}\vec{\alpha }\left [(\exists t\in \bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha })\right ]=\lnot \lambda x\vec{x}\vec{\alpha }\left [(\forall t\in \bar{S})_{t\leq x}\;\lnot P(t,\vec{x},\vec{\alpha })\right ] \] tenemos que \(\lambda x\vec{x}\vec{\alpha }\left [(\exists t\in \bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha })\right ]\) es \(\Sigma \)-p.r.
</p><!-- l. 5570 --><p class='indent'>   (b) Haremos solo el caso del cuantificador \(\forall \). Primero supongamos que \(\Sigma =\emptyset \). Ya que \(L,L_{1},...,L_{m}\)
son no vacios, debera suceder que \(L=L_{1}=...=L_{m}=\{\varepsilon \}\). Ya que \(\bar{L}\subseteq L\), tenemos que \(\bar{L}=\emptyset \) o \(\bar{L}=\{\varepsilon \}\). Si \(\bar{L}=\emptyset \), entonces
</p><div class='eqnarray'>\begin{eqnarray*} \lambda x\vec{x}\vec{\alpha }\left [(\forall \alpha \in \bar{L})_{\left \vert \alpha \right \vert \leq x}\;P(\vec{x},\vec{\alpha },\alpha )\right ] &amp; = &amp; \lambda x\vec{x}\vec{\alpha }\left [1\right ]\\ &amp; = &amp; C_{1}^{1+n,m} \end{eqnarray*}
</div>por lo cual es \(\Sigma \)-p.r.
<!-- l. 5581 --><p class='indent'>   Si \(\bar{L}=\{\varepsilon \}\), entonces </p><div class='eqnarray'>\begin{eqnarray*} \lambda x\vec{x}\vec{\alpha }\left [(\forall \alpha \in \bar{L})_{\left \vert \alpha \right \vert \leq x}\;P(\vec{x},\vec{\alpha },\alpha )\right ] &amp; = &amp; \lambda x\vec{x}\vec{\alpha }\left [(P(\vec{x},\vec{\alpha },\varepsilon )\right ]\\ &amp; = &amp; P\circ \left [p_{2}^{1+n,m},...,p_{1+n+m}^{1+n,m},C_{\varepsilon }^{1+n,m},\right ] \end{eqnarray*}
</div>por lo cual es \(\Sigma \)-p.r.
<!-- l. 5588 --><p class='indent'>   Ahora supongamos \(\Sigma \) es no vacio. Sea \(\leq \) un orden total sobre \(\Sigma .\) Sea \(k\) el cardinal de \(\Sigma \).
Primero notese que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-86004x3.2.1'>\(\left \vert \alpha \right \vert \leq x\) sii \(\#^{\leq }(\alpha )\leq \sum _{\iota =1}^{i=x}k^{i}\), cualesquiera sean \(x\in \omega \) y \(\alpha \in \Sigma ^{\ast }\)</li></ol>
<!-- l. 5595 --><p class='noindent'>(queda como ejercicio probar (*). Sean </p><div class='eqnarray'>\begin{eqnarray*} \#^{\leq }(L) &amp; = &amp; \{\#^{\leq }(\alpha ):\alpha \in L\}\\ \#^{\leq }(\bar{L}) &amp; = &amp; \{\#^{\leq }(\alpha ):\alpha \in \bar{L}\} \end{eqnarray*}
</div>Notese que <div class='eqnarray'>\begin{eqnarray*} \chi _{\#^{\leq }(L)}^{\omega } &amp; = &amp; \chi _{L}^{\Sigma ^{\ast }}\circ \ast ^{\leq }\\ \chi _{\#^{\leq }(\bar{L})}^{\omega } &amp; = &amp; \chi _{\bar{L}}^{\Sigma ^{\ast }}\circ \ast ^{\leq } \end{eqnarray*}
</div>por lo cual \(\#^{\leq }(L)\) y \(\#^{\leq }(\bar{L})\) son \(\Sigma \)-p.r.. Sea \(H=\lambda t\vec{x}\vec{\alpha }\left [P(\vec{x},\vec{\alpha },\ast ^{\leq }(t))\right ].\) Notese que \[ D_{H}=\#^{\leq }(L)\times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m} \] y \(H\) es \(\Sigma \)-p.r.. O sea que por (a) tenemos que \[ \lambda x\vec{x}\vec{\alpha }\left [(\forall t\in \#^{\leq }(\bar{L}))_{t\leq x}H(t,\vec{x},\vec{\alpha })\right ]=\lambda x\vec{x}\vec{\alpha }\left [(\forall t\in \#^{\leq }(\bar{L}))_{t\leq x}P(\vec{x},\vec{\alpha },\ast ^{\leq }(t))\right ] \]
es \(\Sigma \)-p.r.. Llamemos \(Q\) al predicado \(\lambda x\vec{x}\vec{\alpha }\left [(\forall t\in \#^{\leq }(\bar{L}))_{t\leq x}P(\vec{x},\vec{\alpha },\ast ^{\leq }(t))\right ]\). Tenemos que <div class='eqnarray'>\begin{eqnarray*} \lambda x\vec{x}\vec{\alpha }\left [(\forall \alpha \in \bar{L})_{\left \vert \alpha \right \vert \leq x}P(\vec{x},\vec{\alpha },\alpha )\right ] &amp; = &amp; \lambda x\vec{x}\vec{\alpha }\left [(\forall t\in \#^{\leq }(\bar{L}))_{t\leq \sum _{\iota =1}^{i=x}k^{i}}P(\vec{x},\vec{\alpha },\ast ^{\leq }(t))\right ]\text{ (por (*))}\\ &amp; = &amp; Q\circ \left [\lambda x\vec{x}\vec{\alpha }\left [\sum \limits _{\iota =1}^{i=x}k^{i}\right ],p_{1}^{1+n,m},...,p_{1+n+m}^{1+n,m}\right ] \end{eqnarray*}
</div>Pero \(\lambda x\vec{x}\vec{\alpha }\left [\sum \limits _{\iota =1}^{i=x}k^{i}\right ]\) es \(\Sigma \)-p.r. (ejercicio), lo cual nos dice que \(\lambda x\vec{x}\vec{\alpha }\left [(\forall \alpha \in \bar{L})_{\left \vert \alpha \right \vert \leq x}\;P(\vec{x},\vec{\alpha },\alpha )\right ]\) lo es                                    □
   </div>
<!-- l. 5627 --><p class='indent'>   OBSERVACION: La cuantificacion no acotada no preserva la propiedad de ser
\(\Sigma \)-p.r.. Como veremos mas adelante si elejimos bien al predicado \(\Sigma \)-p.r. \(P\), obtenemos que
el predicado \(\lambda \vec{x}\vec{\alpha }\left [(\exists t\in \bar{S})\;P(t,\vec{x},\vec{\alpha })\right ]\) no solo no es \(\Sigma \)-p.r. sino que tampoco es \(\Sigma \)-efectivamente computable
(Teorema <a href='#x1-135004r134'>134<!-- tex4ht:ref: autohalt es no EC  --></a>).
</p><!-- l. 5635 --><p class='indent'>   Algunos ejemplos en los cuales cuantificacion acotada se aplica naturalmente son
dados a continuacion.
</p>
   <div class='newtheorem'>

<!-- l. 5637 --><p class='noindent'><span class='head'>
<a id='x1-86005r63'></a>
<span class='cmbx-10'>Lema 63.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto finito.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-86006x63'><span class='cmti-10'>El predicado</span> \(\lambda xy\left [x\text{ divide }y\right ]\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span>
     </li>
     <li class='enumerate' id='x1-86007x63'><span class='cmti-10'>El predicado</span> \(\lambda x\left [x\text{ es primo}\right ]\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span>
     </li>
     <li class='enumerate' id='x1-86008x63'><span class='cmti-10'>El predicado</span> \(\lambda \alpha \beta \left [\alpha \text{\ }\mathrm{inicial}\ \beta \right ]\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span></li></ol>
   </div>
<!-- l. 5647 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5648 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Sea \(P=\lambda tx_{1}x_{2}\left [x_{2}=t.x_{1}\right ]\). Es claro que \(P\) es \(\Sigma \)-p.r.. El lema anterior nos dice que \(\lambda xx_{1}x_{2}\left [(\exists t\in \omega )_{t\leq x}\;P(t,x_{1},x_{2})\right ]\) es \(\Sigma \)-p.r..
Notese que \(x_{1}\) divide \(x_{2}\) si y solo si hay un \(t\leq x_{2}\) tal que \(x_{2}=t.x_{1}\). Esto nos dice que \[ \lambda x_{1}x_{2}\left [x_{1}\text{ divide }x_{2}\right ]=\lambda x_{1}x_{2}\left [(\exists t\in \omega )_{t\leq x_{2}}\;P(t,x_{1},x_{2})\right ] \] Pero \[ \lambda x_{1}x_{2}\left [(\exists t\in \omega )_{t\leq x_{2}}\;P(t,x_{1},x_{2})\right ]=\lambda xx_{1}x_{2}\left [(\exists t\in \omega )_{t\leq x}\;P(t,x_{1},x_{2})\right ]\circ \left [p_{2}^{2,0},p_{1}^{2,0},p_{2}^{2,0}\right ] \] por lo
cual \(\lambda x_{1}x_{2}\left [x_{1}\text{ divide }x_{2}\right ]\) es \(\Sigma \)-p.r.
</p><!-- l. 5662 --><p class='indent'>   (b) Ya que \[ x\text{ es primo sii }x&gt;1\wedge \left ((\forall t\in \omega )_{t\leq x}\;t=1\vee t=x\vee \lnot (t\text{ divide }x)\right ) \] podemos usar un argumento similar al de la prueba de (a).
</p><!-- l. 5668 --><p class='indent'>   (c) es dejado al lector.                                                                    □
</p>
   </div>
<!-- l. 5672 --><p class='indent'>   La idea fundamental subyacente en las aplicaciones anteriores es que en muchos
casos de predicados obtenidos por cuantificacion a partir de otros predicados, la
variable cuantificada tiene una cota natural en terminos de las otras variables y
entonces componiendo adecuadamente se lo puede presentar como un caso de
cuantificacion acotada
</p><!-- l. 5680 --><p class='indent'>   @@finpagina@@
</p><!-- l. 5682 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.2.2   </span> <a id='x1-870003.2.2'></a>Minimizacion y funciones \(\Sigma \)-recursivas</h5>
<!-- l. 5684 --><p class='noindent'>Tal como fue explicado anteriormente, para obtener la clase de las funciones
\(\Sigma \)-recursivas debemos agregar un nuevo constructor a los ya definidos de composicion
y recursion primitiva, a saber el constructor de <span class='cmti-10'>minimizacion</span>. Tiene dos
casos.

</p>
<!-- l. 5689 --><p class='noindent'><span class='paragraphHead'><a id='x1-880003.2.2'></a><span class='cmbx-10'>Minimizacion de variable numerica</span></span>
   Sea \(\Sigma \) un alfabeto finito y sea \(P:D_{P}\subseteq \omega \times \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) un predicado. Dado \((\vec{x},\vec{\alpha })\in \omega ^{n}\times \Sigma ^{\ast m}\), cuando exista al menos un \(t\in \omega \) tal
que \(P(t,\vec{x},\vec{\alpha })=1\), usaremos \(\min _{t}P(t,\vec{x},\vec{\alpha })\) para denotar al menor de tales \(t^{\prime }s\). Notese que la expresion \(\min _{t}P(t,\vec{x},\vec{\alpha })\) esta
definida solo para aquellas \((n+m)\)-uplas \((\vec{x},\vec{\alpha })\) para las cuales hay al menos un \(t\) tal que se da \(P(t,\vec{x},\vec{\alpha })=1\).
Dicho de otra forma, \(\min _{t}P(t,\vec{x},\vec{\alpha })\) no estara definida cuando para cada \(t\in \omega \) se de que \((t,\vec{x},\vec{\alpha })\) no pertenece a \(D_{P}\)
o \(P(t,\vec{x},\vec{\alpha })=0\). Otro detalle importante a tener en cuenta es que la expresion \(\min _{t}P(t,\vec{x},\vec{\alpha })\) no depende de la
variable \(t\). Por ejemplo, las expresiones \(\min _{t}P(t,\vec{x},\vec{\alpha })\) y \(\min _{i}P(i,\vec{x},\vec{\alpha })\) son equivalentes en el sentido que estan
definidas en las mismas \((n+m)\)-uplas y cuando estan definidas asumen el mismo
valor.
</p><!-- l. 5707 --><p class='indent'>   Definamos \[ M(P)=\lambda \vec{x}\vec{\alpha }\left [\min \nolimits _{t}P(t,\vec{x},\vec{\alpha })\right ] \] Notese que </p><div class='eqnarray'>\begin{eqnarray*} D_{M(P)} &amp; = &amp; \left \{ (\vec{x},\vec{\alpha })\in \omega ^{n}\times \Sigma ^{\ast m}:(\exists t\in \omega )\ P(t,\vec{x},\vec{\alpha })\right \} \\ M(P)(\vec{x},\vec{\alpha }) &amp; = &amp; \min \nolimits _{t}P(t,\vec{x},\vec{\alpha })\text{, para cada }(\vec{x},\vec{\alpha })\in D_{M(P)} \end{eqnarray*}
</div>Diremos que \(M(P)\) se obtiene por <p><span class='cmti-10'>minimizacion de variable numerica </span></p>a partir de
\(P\).
<!-- l. 5721 --><p class='indent'>   Veamos un ejemplo. Recordemos que dados \(x_{1},x_{2}\in \omega \), con \(x_{1}\) no nulo, el <span class='cmti-10'>cociente de dividir</span>
\(x_{1}\)<span class='cmti-10'> por</span> \(x_{2}\) se define como el maximo elemento del conjunto \(\{t\in \omega :t.x_{2}\leq x_{1}\}\). Sea \[ \begin{array}[t]{rll} Q:\omega \times \mathbf{N} &amp; \rightarrow &amp; \omega \\ (x_{1},x_{2}) &amp; \rightarrow &amp; \text{cociente de dividir }x_{1}\text{ por }x_{2} \end{array} \] Sea \(P=\lambda tx_{1}x_{2}\left [x_{1}&lt;t.x_{2}\right ]\). Notar que
</p><div class='eqnarray'>\begin{eqnarray*} D_{M(P)} &amp; = &amp; \{(x_{1},x_{2})\in \omega ^{2}:(\exists t\in \omega )\;P(t,x_{1},x_{2})=1\}\\ &amp; = &amp; \{(x_{1},x_{2}):(\exists t\in \omega )\;x_{1}&lt;t.x_{2}\}\\ &amp; = &amp; \omega \times \mathbf{N} \end{eqnarray*}
</div>Ademas si \((x_{1},x_{2})\in \omega \times \mathbf{N}\), es facil de probar que \[ \min \nolimits _{t}\ x_{1}&lt;t.x_{2}=Q(x_{1},x_{2})+1 \] por lo que \(M(P)=Suc\circ Q\). Si quisieramos encontrar un
predicado \(P^{\prime }\) tal que \(M(P^{\prime })=Q\), entonces podemos tomar \(P^{\prime }=\lambda tx_{1}x_{2}\left [x_{1}&lt;(t+1).x_{2}\right ]\) y con un poco de concentracion
nos daremos cuenta que \(M(P^{\prime })=Q\). De todas maneras hay una forma mas facil de
hacerlo y es tomando \(P^{\prime }\) de tal forma que para cada \((x_{1},x_{2})\in D_{Q}\) se de que \[ Q(x_{1},x_{2})=\mathrm{\ unico\ }t\in \omega \mathrm{\ tal\ que\ }P^{\prime }(t,x_{1},x_{2}) \] Por ejemplo se
puede tomar \(P^{\prime }=\lambda tx_{1}x_{2}\left [x_{1}\geq t.x_{2}\text{ y }x_{1}&lt;(t+1).x_{2}\right ]\) que dicho sea de paso es justo la definicion de cociente dada en
la escuela primaria. Dejamos al lector corroborar que \(M(P^{\prime })=Q\), para este ultimo
\(P^{\prime }\).
<!-- l. 5755 --><p class='indent'>   Tal como lo vimos recien muchas veces que querramos encontrar un predicado \(P\) tal
que \(M(P)\) sea igual a una funcion dada \(F\), sera mas facil encontrar un \(P\) el cual cumpla \[ F(\vec{x},\vec{\alpha })=\mathrm{\ unico\ }t\in \omega \mathrm{\ tal\ que\ }P(t,\vec{x},\vec{\alpha }) \] es
decir un predicado \(P\) que caracterice al valor que toma \(F\).
</p>
   <div class='newtheorem'>
<!-- l. 5765 --><p class='noindent'><span class='head'>
<a id='x1-88001r64'></a>
<span class='cmbx-10'>Lema 64.</span>  </span><span class='cmti-10'>Si</span> \(P:D_{P}\subseteq \omega \times \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>es un predicado</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable y</span> \(D_{P}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente
</span><span class='cmti-10'>computable, entonces la funcion</span> \(M(P)\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable.</span>
</p>
   </div>
<!-- l. 5772 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5773 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ejercicio                                                                                 □

</p>
   </div>
<!-- l. 5777 --><p class='indent'>   Lamentablemente si quitamos la hipotesis en el lema anterior de que \(D_{P}\) sea
\(\Sigma \)-efectivamente computable, el lema resulta falso. Mas adelante veremos un
contraejemplo basado en la tesis de Church (Proposicion <a href='#x1-135007r137'>137<!-- tex4ht:ref: P recursivo no implica M(P) recursiva  --></a>). Por el momento el
lector puede ejercitar su comprencion del tema convenciendose de que aun teniendo
un procedimiento efectivo que compute a un predicado \(P:D_{P}\subseteq \omega \times \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \), no es claro como construir
un procedimiento efectivo que compute a \(M(P)\).
</p>
<!-- l. 5790 --><p class='noindent'><span class='paragraphHead'><a id='x1-890003.2.2'></a><span class='cmbx-10'>Definicion de funcion</span> \(\Sigma \)<span class='cmbx-10'>-recursiva</span></span>
   Con este nuevo constructor de funciones estamos en condiciones de definir la clase
de las funciones \(\Sigma \)-recursivas. Definamos los conjuntos \(\mathrm{R}_{0}^{\Sigma }\subseteq \mathrm{R}_{1}^{\Sigma }\subseteq \mathrm{R}_{2}^{\Sigma }\subseteq ...\subseteq \mathrm{R}^{\Sigma }\) de la siguiente manera \[ \begin{array}{lll} \mathrm{R}_{0}^{\Sigma } &amp; = &amp; \mathrm{PR}_{0}^{\Sigma }\\ \mathrm{R}_{k+1}^{\Sigma } &amp; = &amp; \mathrm{R}_{k}^{\Sigma }\cup \left \{ f\circ [f_{1},...,f_{n}]:f,f_{1},...,f_{r}\in \mathrm{R}_{k}^{\Sigma }\text{, }r\geq 1\right \} \cup \\ &amp; &amp; \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\left \{ R(f,\mathcal{G}):f\text{ y cada }\mathcal{G}_{a}\text{ pertenecen a }\mathrm{R}_{k}^{\Sigma }\right \} \cup \\ &amp; &amp; \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\left \{ R(f,g):f,g\in \mathrm{R}_{k}^{\Sigma }\right \} \cup \\ &amp; &amp; \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\left \{ M(P):P\text{ es }\Sigma \text{-total y }P\in \mathrm{R}_{k}^{\Sigma }\right \} \\ \mathrm{R}^{\Sigma } &amp; = &amp; \bigcup _{k\geq 0}\mathrm{R}_{k}^{\Sigma } \end{array} \] Una
funcion \(f\) es llamada \(\Sigma \)-<span class='cmti-10'>recursiva </span>si pertenece a \(\mathrm{R}^{\Sigma }\). Cabe destacar que aunque \(M(P)\) fue definido
para predicados no necesariamente \(\Sigma \)-totales, en la definicion de los conjuntos \(\mathrm{R}_{k}^{\Sigma }\), nos
restringimos al caso en que \(P\) es \(\Sigma \)-total.
</p><!-- l. 5812 --><p class='indent'>   Notese que \(\mathrm{PR}_{k}^{\Sigma }\subseteq \mathrm{R}_{k}^{\Sigma }\), para cada \(k\in \omega \), por lo cual \(\mathrm{PR}^{\Sigma }\subseteq \mathrm{R}^{\Sigma }\).
</p>
   <div class='newtheorem'>
<!-- l. 5814 --><p class='noindent'><span class='head'>
<a id='x1-89001r65'></a>
<span class='cmbx-10'>Proposition 65.</span>  </span><span class='cmti-10'>Si</span> \(f\in \mathrm{R}^{\Sigma }\)<span class='cmti-10'>, entonces</span> \(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable.</span>
</p>
   </div>
<!-- l. 5819 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5820 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Dejamos al lector la prueba por induccion en \(k\) de que si \(f\in \mathrm{R}_{k}^{\Sigma }\), entonces \(f\) es
\(\Sigma \)-efectivamente computable.                                                                  □
</p>
   </div>
<!-- l. 5825 --><p class='indent'>   Daremos sin prueba el siguiente conceptualmente importante resultado.
</p>
   <div class='newtheorem'>
<!-- l. 5826 --><p class='noindent'><span class='head'>
<a id='x1-89002r66'></a>

<span class='cmbx-10'>Proposition 66.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto finito. Entonces no toda funcion</span> \(\Sigma \)<span class='cmti-10'>-recursiva
</span><span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r.</span>
</p>
   </div>
<!-- l. 5833 --><p class='indent'>   Este resultado no es facil de probar. Mas adelante (Proposicion <a href='#x1-120003r106'>106<!-- tex4ht:ref: T y FI no son PR  --></a>) veremos
ejemplos naturales de funciones \(\Sigma \)-recursivas que no son \(\Sigma \)-p.r.. Otro ejemplo natural es
la famosa funcion de Ackermann.
</p>
<!-- l. 5840 --><p class='noindent'><span class='paragraphHead'><a id='x1-900003.2.2'></a><span class='cmbx-10'>Lema de minimizacion acotada de variable numerica de predicados</span>
\(\Sigma \)<span class='cmbx-10'>-p.r.</span></span>
   Aunque no siempre que \(P\in \mathrm{R}^{\Sigma }\), tendremos que \(M(P)\in \mathrm{R}^{\Sigma }\) (Proposicion <a href='#x1-135007r137'>137<!-- tex4ht:ref: P recursivo no implica M(P) recursiva  --></a>), el siguiente lema nos
garantiza que este es el caso cuando \(P\in \mathrm{PR}^{\Sigma }\) y ademas da condiciones para que \(M(P)\) sea
\(\Sigma \)-p.r..
</p>
   <div class='newtheorem'>
<!-- l. 5846 --><p class='noindent'><span class='head'>
<a id='x1-90001r67'></a>
<span class='cmbx-10'>Lema 67.</span>  </span><span class='cmti-10'>Sean</span> \(n,m\geq 0\)<span class='cmti-10'>. Sea</span> \(P:D_{P}\subseteq \omega \times \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>un predicado</span> \(\Sigma \)<span class='cmti-10'>-p.r.. Entonces</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-90002x67'>\(M(P)\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva.</span>
     </li>
     <li class='enumerate' id='x1-90003x67'><span class='cmti-10'>Si hay una funcion</span> \(\Sigma \)<span class='cmti-10'>-p.r.</span> \(f:\omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>tal que </span>\[ M(P)(\vec{x},\vec{\alpha })=\min \nolimits _{t}P(t,\vec{x},\vec{\alpha })\leq f(\vec{x},\vec{\alpha })\text{, para cada }(\vec{x},\vec{\alpha })\in D_{M(P)}\text{,} \] <span class='cmti-10'>entonces</span> \(M(P)\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span></li></ol>
   </div>
<!-- l. 5860 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5861 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Sea \(\bar{P}=P\cup C_{0}^{n+1,m}|_{(\omega ^{n+1}\times \Sigma ^{\ast m})-D_{P}}\). Note que \(\bar{P}\) es \(\Sigma \)-p.r. (por que?). Veremos a continuacion que \(M(P)=M(\bar{P})\).
Notese que \[ \{t\in \omega :P(t,\vec{x},\vec{\alpha })=1\}=\{t\in \omega :\bar{P}(t,\vec{x},\vec{\alpha })=1\} \] Esto claramente dice que \(D_{M(P)}=D_{M(\bar{P})}\) y que \(M(P)(\vec{x},\vec{\alpha })=M(\bar{P})(\vec{x},\vec{\alpha })\), para cada \((\vec{x},\vec{\alpha })\in D_{M(P)}\)., por lo cual \(M(P)=M(\bar{P})\).
</p><!-- l. 5870 --><p class='indent'>   Veremos entonces que \(M(\bar{P})\) es \(\Sigma \)-recursiva. Sea \(k\) tal que \(\bar{P}\in \mathrm{PR}_{k}^{\Sigma }\). Ya que \(\bar{P}\) es \(\Sigma \)-total y \(\bar{P}\in \mathrm{PR}_{k}^{\Sigma }\subseteq \mathrm{R}_{k}^{\Sigma }\),
tenemos que \(M(\bar{P})\in \mathrm{R}_{k+1}^{\Sigma }\) y por lo tanto \(M(\bar{P})\in \mathrm{R}^{\Sigma }\).
</p><!-- l. 5876 --><p class='indent'>   (b) Ya que \(M(P)=M(\bar{P})\), basta con probar que \(M(\bar{P})\) es \(\Sigma \)-p.r. Primero veremos que \(D_{M(\bar{P})}\) es un
conjunto \(\Sigma \)-p.r.. Notese que \[ \chi _{D_{M(\bar{P})}}^{\omega ^{n}\times \Sigma ^{\ast m}}=\lambda \vec{x}\vec{\alpha }\left [(\exists t\in \omega )_{t\leq f(\vec{x},\vec{\alpha })}\;\bar{P}(t,\vec{x},\vec{\alpha })\right ] \] lo cual nos dice que \[ \chi _{D_{M(\bar{P})}}^{\omega ^{n}\times \Sigma ^{\ast m}}=\lambda x\vec{x}\vec{\alpha }\left [(\exists t\in \omega )_{t\leq x}\;\bar{P}(t,\vec{x},\vec{\alpha })\right ]\circ \left [f,p_{1}^{n,m},...,p_{n+m}^{n,m}\right ] \] Pero el Lema <a href='#x1-86001r62'>62<!-- tex4ht:ref: cuantificacion  --></a> nos dice que \(\lambda x\vec{x}\vec{\alpha }\left [(\exists t\in \omega )_{t\leq x}\;\bar{P}(t,\vec{x},\vec{\alpha })\right ]\)
es \(\Sigma \)-p.r. por lo cual tenemos que \(\chi _{D_{M(\bar{P})}}^{\omega ^{n}\times \Sigma ^{\ast m}}\) lo es.

</p><!-- l. 5890 --><p class='indent'>   Sea \[ P_{1}=\lambda t\vec{x}\vec{\alpha }\left [\bar{P}(t,\vec{x},\vec{\alpha })\wedge (\forall j\in \omega )_{j\leq t}\;j=t\vee \lnot \bar{P}(j,\vec{x},\vec{\alpha })\right ] \] Note que \(P_{1}\) es \(\Sigma \)-total. Dejamos al lector usando lemas anteriores probar
que \(P_{1}\) es \(\Sigma \)-p.r. Ademas notese que para \((\vec{x},\vec{\alpha })\in \omega ^{n}\times \Sigma ^{\ast m}\) se tiene que \[ P_{1}(t,\vec{x},\vec{\alpha })=1\text{ si y solo si }(\vec{x},\vec{\alpha })\in D_{M(\bar{P})}\text{ y }t=M(\bar{P})(\vec{x},\vec{\alpha }) \] Esto nos dice que \[ M(\bar{P})=\left (\lambda \vec{x}\vec{\alpha }\left [\prod _{t=0}^{f(\vec{x},\vec{\alpha })}t^{P_{1}(t,\vec{x},\vec{\alpha })}\right ]\right )|_{D_{M(\bar{P})}} \] por lo
cual para probar que \(M(\bar{P})\) es \(\Sigma \)-p.r. solo nos resta probar que \[ F=\lambda \vec{x}\vec{\alpha }\left [\prod _{t=0}^{f(\vec{x},\vec{\alpha })}t^{P_{1}(t,\vec{x},\vec{\alpha })}\right ] \] lo es. Pero \[ F=\lambda xy\vec{x}\vec{\alpha }\left [\prod _{t=x}^{y}t^{P_{1}(t,\vec{x},\vec{\alpha })}\right ]\circ \left [C_{0}^{n,m},f,p_{1}^{n,m},...,p_{n+m}^{n,m}\right ] \] y por lo
tanto el Lema <a href='#x1-85001r61'>61<!-- tex4ht:ref: iteracion  --></a> nos dice que \(F\) es \(\Sigma \)-p.r..                                                   □
</p>
   </div>
<!-- l. 5918 --><p class='indent'>   OBSERVACION: No siempre que \(P\) sea \(\Sigma \)-p.r. tendremos que \(M(P)\) lo sera. Notese que si \(M(P)\)
fuera \(\Sigma \)-p.r., cada ves que \(P\) lo sea, entonces tendriamos que \(\mathrm{PR}^{\Sigma }=\mathrm{R}^{\Sigma }\) (justifique) lo cual
contradiria la Proposicion <a href='#x1-89002r66'>66<!-- tex4ht:ref: recursivo no implica PR  --></a>. Mas adelante (Corolario <a href='#x1-120004r107'>107<!-- tex4ht:ref: minimizacion de PR que no es PR  --></a>) veremos un ejemplo de
un predicado \(P\) el cual es \(\Sigma \)-p.r. pero \(M(P)\) no es \(\Sigma \)-p.r.
</p><!-- l. 5928 --><p class='indent'>   El lema de minimizacion recien probado es muy util como veremos en los
siguientes dos lemas.
</p>
   <div class='newtheorem'>
<!-- l. 5930 --><p class='noindent'><span class='head'>
<a id='x1-90004r68'></a>
<span class='cmbx-10'>Lema 68.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto finito. Las siguientes funciones son</span> \(\Sigma \)<span class='cmti-10'>-p.r.:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-90005x68'>\(\begin{array}[t]{rll} Q:\omega \times \mathbf{N} &amp; \rightarrow &amp; \omega \\ (x,y) &amp; \rightarrow &amp; \text{cociente de la division de }x\text{ por }y \end{array}\)
     </li>
     <li class='enumerate' id='x1-90006x68'>\(\begin{array}[t]{rll} R:\omega \times \mathbf{N} &amp; \rightarrow &amp; \omega \\ (x,y) &amp; \rightarrow &amp; \text{resto de la division de }x\text{ por }y \end{array}\)
     </li>
     <li class='enumerate' id='x1-90007x68'>\(\begin{array}[t]{rll} pr:\mathbf{N} &amp; \rightarrow &amp; \omega \\ n &amp; \rightarrow &amp; n\text{-esimo numero primo} \end{array}\)</li></ol>
   </div>
<!-- l. 5949 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 5950 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Ya vimos anteriormente que \(Q=M(P^{\prime })\), donde \(P^{\prime }=\lambda tx_{1}x_{2}\left [x_{1}\geq t.x_{2}\text{ y }x_{1}&lt;(t+1).x_{2}\right ]\). Ya que \(P^{\prime }\) es \(\Sigma \)-p.r. y \[ Q(x_{1},x_{2})\leq p_{1}^{2,0}(x_{1},x_{2}),\text{ para cada }(x_{1},x_{2})\in \omega \times \mathbf{N} \] (b) del Lema
<a href='#x1-90001r67'>67<!-- tex4ht:ref: minimizacion  --></a> implica que \(Q\in \mathrm{PR}^{\Sigma }\).
</p><!-- l. 5957 --><p class='indent'>   (b) Notese que \[ R=\lambda xy\left [x\dot{-}Q(x,y).y\right ] \] y por lo tanto \(R\in \mathrm{PR}^{\Sigma }\).
</p><!-- l. 5963 --><p class='indent'>   (c) Para ver que \(pr\) es \(\Sigma \)-p.r., veremos que la extension \(h:\omega \rightarrow \omega \), dada por \(h(0)=0\) y \(h(n)=pr(n)\), \(n\geq 1\), es \(\Sigma \)-p.r.. Luego
\(pr=h|_{\mathbf{N}}\) resultara \(\Sigma \)-p.r. por ser la restriccion de una funcion \(\Sigma \)-p.r. a un conjunto \(\Sigma \)-p.r.. Primero
note que </p><div class='eqnarray'>\begin{eqnarray*} h(0) &amp; = &amp; 0\\ h(t+1) &amp; = &amp; \min \nolimits _{i}\left (i\text{ es primo}\wedge i&gt;h(t)\right ) \end{eqnarray*}
</div>O sea que \(h=R\left (C_{0}^{0,0},g\right )\), donde \[ \begin{array}[t]{rll} g:\omega \times \omega &amp; \rightarrow &amp; \omega \\ (A,t) &amp; \rightarrow &amp; \min \nolimits _{i}\left (i\text{ es primo}\wedge i&gt;A\right ) \end{array} \] Es decir que solo nos resta ver que \(g\) es \(\Sigma \)-p.r.. Pero notese que \(g=M(P)\),
donde \(P=\lambda iAt\left [i\text{ es primo}\wedge i&gt;A\right ]\). Claramente \(P\) es \(\Sigma \)-p.r. por lo cual para poder aplicar (b) del lema anterior

debemos encontrar una funcion \(f:\omega \times \omega \rightarrow \omega \) tal que \[ M(P)(A,t)\leq f(A,t)\text{, para cada }(A,t)\in \omega ^{2} \] Es decir \(f\) debera cumplir \[ \min \nolimits _{i}\left (i\text{ es primo}\wedge i&gt;A\right )\leq f(A,t)\text{, para cada }(A,t)\in \omega ^{2} \] Definamos \(f=\lambda At[A!+1]\).
Debemos probar entonces que \[ \min \nolimits _{i}\left (i\text{ es primo}\wedge i&gt;A\right )\leq A!+1\text{, para cada }A\in \omega \] Sea \(p\) un primo tal que \(p\) divide a \(A!+1\). Es facil ver que
entonces \(p&gt;A\) ya que de lo contrario \(p\) dividiria a \(A!\) lo cual nos diria que \(p\) divide a \(1=A!+1-A!\), lo cual es
absurdo. Pero esto claramente nos dice que \[ \min \nolimits _{i}\left (i\text{ es primo}\wedge i&gt;A\right )\leq p\leq A!+1 \] O sea que (b) del Lema <a href='#x1-90001r67'>67<!-- tex4ht:ref: minimizacion  --></a> implica que \(g=M(P)\)
es \(\Sigma \)-p.r.                                                                                             □
   </div>
   <div class='newtheorem'>
<!-- l. 6007 --><p class='noindent'><span class='head'>
<a id='x1-90008r69'></a>
<span class='cmbx-10'>Lema 69.</span>  </span><span class='cmti-10'>Las funciones</span> \(\lambda xi\left [(x)_{i}\right ]\) <span class='cmti-10'>y</span> \(\lambda x\left [Lt(x)\right ]\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-p.r.</span>
</p>
   </div>
<!-- l. 6012 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 6013 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Note que \(D_{\lambda xi\left [(x)_{i}\right ]}=\mathbf{N}\times \mathbf{N}\). Sea \[ P=\lambda txi\left [\lnot (pr(i)^{t+1}\ \text{divide }x)\right ] \] Note que \(P\) es \(\Sigma \)-p.r. y que \(D_{P}=\omega \times \omega \times \mathbf{N}\). Dejamos al lector la prueba de
que \(\lambda xi\left [(x)_{i}\right ]=M(P)\). Ya que \((x)_{i}\leq x\), para todo \((x,i)\in \mathbf{N}\times \mathbf{N}\), (b) del Lema <a href='#x1-90001r67'>67<!-- tex4ht:ref: minimizacion  --></a> implica que \(\lambda xi\left [(x)_{i}\right ]\) es \(\Sigma \)-p.r..
</p><!-- l. 6024 --><p class='indent'>   Veamos que \(\lambda x\left [Lt(x)\right ]\) es \(\Sigma \)-p.r.. Sea \[ Q=\lambda tx\left [(\forall i\in \mathbf{N})_{i\leq x}\;(i\leq t\vee (x)_{i}=0)\right ] \] Notese que \(D_{Q}=\omega \times \mathbf{N}\) y que ademas por el Lema <a href='#x1-86001r62'>62<!-- tex4ht:ref: cuantificacion  --></a> tenemos
que \(Q\) es \(\Sigma \)-p.r. (dejamos al lector explicar como se aplica tal lema en este caso).
Ademas notese que \(\lambda x\left [Lt(x)\right ]=M(Q)\) y que \[ Lt(x)\leq x,\text{para todo }x\in \mathbf{N} \] lo cual por (b) del Lema <a href='#x1-90001r67'>67<!-- tex4ht:ref: minimizacion  --></a> nos dice que \(\lambda x\left [Lt(x)\right ]\) es \(\Sigma \)-p.r..   □
</p>
   </div>
<!-- l. 6040 --><p class='indent'>   Para \(x_{1},...,x_{n}\in \omega \), con \(n\geq 1\), escribiremos \(\left \langle x_{1},...,x_{n}\right \rangle \) en lugar de \(\left \langle x_{1},...,x_{n},0,...\right \rangle \).
</p>
   <div class='newtheorem'>
<!-- l. 6042 --><p class='noindent'><span class='head'>
<a id='x1-90009r70'></a>
<span class='cmbx-10'>Lema 70.</span>  </span><span class='cmti-10'>Sea</span> \(n\geq 1\)<span class='cmti-10'>. La funcion</span> \(\lambda x_{1}...x_{n}\left [\left \langle x_{1},...,x_{n}\right \rangle \right ]\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r.</span>
</p>
   </div>
<!-- l. 6047 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 6048 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Sea \(f_{n}=\lambda x_{1}...x_{n}\left [\left \langle x_{1},...,x_{n}\right \rangle \right ]\). Claramente \(f_{1}\) es \(\Sigma \)-p.r.. Ademas note que para cada \(n\geq 1\), tenemos \[ f_{n+1}=\lambda x_{1}...x_{n+1}\left [\left (f_{n}(x_{1},...,x_{n})pr(n+1)^{x_{n+1}}\right )\right ]\text{.} \] O sea
que podemos aplicar un argumento inductivo.                                          □
</p>
   </div>
<!-- l. 6059 --><p class='noindent'><span class='paragraphHead'><a id='x1-910003.2.2'></a><span class='cmbx-10'>Minimizacion de variable alfabetica</span></span>
   Supongamos que \(\Sigma \neq \emptyset \). Sea \(\leq \) un orden total sobre \(\Sigma \). Recordemos que \(\leq \) puede ser
naturalmente extendido a un orden total sobre \(\Sigma ^{\ast }\). Sea \(P:D_{P}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\times \Sigma ^{\ast }\rightarrow \omega \) un predicado. Cuando \((\vec{x},\vec{\alpha })\in \omega ^{n}\times \Sigma ^{\ast m}\)
es tal que existe al menos un \(\alpha \in \Sigma ^{\ast }\) tal que \(P(\vec{x},\vec{\alpha },\alpha )=1\), usaremos \(\min _{\alpha }^{\leq }P(\vec{x},\vec{\alpha },\alpha )\) para denotar al menor \(\alpha \in \Sigma ^{\ast }\)
tal que \(P(\vec{x},\vec{\alpha },\alpha )=1\). Notese que la expresion \(\min _{\alpha }^{\leq }P(\vec{x},\vec{\alpha },\alpha )\) esta definida solo para aquellas \((n+m)\)-uplas \((\vec{x},\vec{\alpha })\)
para las cuales hay al menos un \(\alpha \) tal que se da \(P(\vec{x},\vec{\alpha },\alpha )=1\). Dicho de otra forma, \(\min _{\alpha }^{\leq }P(\vec{x},\vec{\alpha },\alpha )\) no
estara definida cuando para cada \(\alpha \in \Sigma ^{\ast }\) se de que \((\vec{x},\vec{\alpha },\alpha )\) no pertenece a \(D_{P}\) o \(P(\vec{x},\vec{\alpha },\alpha )=0\). Otro detalle
importante a tener en cuenta es que la expresion \(\min _{\alpha }^{\leq }P(\vec{x},\vec{\alpha },\alpha )\) no depende de la variable \(\alpha \).
Por ejemplo, las expresiones \(\min _{\alpha }^{\leq }P(\vec{x},\vec{\alpha },\alpha )\) y \(\min _{\beta }^{\leq }P(\vec{x},\vec{\alpha },\beta )\) son equivalentes en el sentido que estan
definidas en las mismas \((n+m)\)-uplas y cuando estan definidas asumen el mismo
valor.
</p><!-- l. 6080 --><p class='indent'>   Definamos \[ \begin{array}{c} M^{\leq }(P)=\lambda \vec{x}\vec{\alpha }\left [\min _{\alpha }^{\leq }P(\vec{x},\vec{\alpha },\alpha )\right ]\end{array} \] Notese que </p><div class='eqnarray'>\begin{eqnarray*} D_{M^{\leq }(P)} &amp; = &amp; \left \{ (\vec{x},\vec{\alpha })\in \omega ^{n}\times \Sigma ^{\ast m}:(\exists \alpha \in \Sigma ^{\ast })\ P(\vec{x},\vec{\alpha },\alpha )\right \} \\ M^{\leq }(P)(\vec{x},\vec{\alpha }) &amp; = &amp; \min \nolimits _{\alpha }^{\leq }P(\vec{x},\vec{\alpha },\alpha )\text{, para cada }(\vec{x},\vec{\alpha })\in D_{M^{\leq }(P)} \end{eqnarray*}
</div>Diremos que \(M^{\leq }(P)\) es obtenida por <p><span class='cmti-10'>minimizacion de variable alfabetica </span></p>a partir de
\(P\).
<!-- l. 6093 --><p class='indent'>   Vemos un ejemplo. Sea \(\Sigma =\{@,a,b,c,d,e\}\) y sea \(\leq \) un orden total sobre \(\Sigma \). Sea \(Dir=\{\alpha _{1}\in \Sigma ^{\ast }:\left \vert \alpha _{1}\right \vert _{@}=1\}\) y definamos \(U:Dir\rightarrow \Sigma ^{\ast }\) de la
siguiente manera \[ U(\alpha _{1})=\text{unico }\alpha \text{ tal que }\alpha @\text{ es tramo inicial de }\alpha _{1} \] Sea \[ P=\lambda \alpha _{1}\alpha [\alpha _{1}\in Dir\text{ y }\alpha @\text{ es tramo inicial de }\alpha _{1}] \] Tenemos que </p><div class='eqnarray'>\begin{eqnarray*} D_{M^{\leq }(P)} &amp; = &amp; \left \{ \alpha _{1}\in \Sigma ^{\ast }:(\exists \alpha \in \Sigma ^{\ast })\ P(\alpha _{1},\alpha )\right \} \\ &amp; = &amp; \left \{ \alpha _{1}\in \Sigma ^{\ast }:\alpha _{1}\in Dir\text{ y }(\exists \alpha \in \Sigma ^{\ast })\ \alpha @\text{ es tramo inicial de }\alpha _{1}\right \} \\ &amp; = &amp; Dir \end{eqnarray*}
</div>y ademas es claro que \(M^{\leq }(P)(\alpha _{1})=U(\alpha _{1})\), para cada \(\alpha _{1}\in Dir\), por lo cual \(M^{\leq }(P)=U\). Intente explicar por que se utiizaron
los nombres \(Dir\) y \(U\).
<!-- l. 6117 --><p class='indent'>   <span class='subparagraphHead'> <a id='x1-920003.2.2'></a><span class='cmbx-10'>Lema de minimizacion acotada de variable alfabetica de predicados</span>
\(\Sigma \)<span class='cmbx-10'>-p.r.</span></span>
</p>
   <div class='newtheorem'>
<!-- l. 6118 --><p class='noindent'><span class='head'>
<a id='x1-92001r71'></a>
<span class='cmbx-10'>Lema 71.</span>  </span><span class='cmti-10'>Supongamos que</span> \(\Sigma \neq \emptyset \)<span class='cmti-10'>. Sea</span> \(\leq \) <span class='cmti-10'>un orden total sobre</span> \(\Sigma \)<span class='cmti-10'>, sean</span> \(n,m\geq 0\) <span class='cmti-10'>y sea</span> \(P:D_{P}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\times \Sigma ^{\ast }\rightarrow \omega \) <span class='cmti-10'>un predicado</span>
\(\Sigma \)<span class='cmti-10'>-p.r.. Entonces</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-92002x71'>\(M^{\leq }(P)\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva.</span>
     </li>
     <li class='enumerate' id='x1-92003x71'><span class='cmti-10'>Si existe una funcion</span> \(\Sigma \)<span class='cmti-10'>-p.r.</span> \(f:\omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>tal que </span>\[ \left \vert M^{\leq }(P)(\vec{x},\vec{\alpha })\right \vert =\left \vert \min \nolimits _{\alpha }^{\leq }P(\vec{x},\vec{\alpha },\alpha )\right \vert \leq f(\vec{x},\vec{\alpha })\text{, para cada }(\vec{x},\vec{\alpha })\in D_{M^{\leq }(P)}\text{,} \] <span class='cmti-10'>entonces</span> \(M^{\leq }(P)\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span></li></ol>

   </div>
   <div class='proof'>
<!-- l. 6134 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea \(Q=P\circ \left [p_{2}^{1+n,m},...,p_{1+n+m}^{1+n,m},\ast ^{\leq }\circ p_{1}^{1+n,m}\right ]\). Note que \[ M^{\leq }(P)=\ast ^{\leq }\circ M(Q) \] lo cual por (a) del Lema <a href='#x1-90001r67'>67<!-- tex4ht:ref: minimizacion  --></a> implica que \(M^{\leq }(P)\) es \(\Sigma \)-recursiva.
</p><!-- l. 6142 --><p class='indent'>   Sea \(k\) el cardinal de \(\Sigma \). Ya que \[ \left \vert \ast ^{\leq }(M(Q)(\vec{x},\vec{\alpha }))\right \vert =\left \vert M^{\leq }(P)(\vec{x},\vec{\alpha })\right \vert \leq f(\vec{x},\vec{\alpha })\text{,} \] para todo \((\vec{x},\vec{\alpha })\in D_{M^{\leq }(P)}=D_{M(Q)}\), tenemos que \[ M(Q)(\vec{x},\vec{\alpha })\leq \sum _{\iota =1}^{i=f(\vec{x},\vec{\alpha })}k^{i}\text{, para cada }(\vec{x},\vec{\alpha })\in D_{M(Q)}\text{.} \] O sea que por (b) del
Lema <a href='#x1-90001r67'>67<!-- tex4ht:ref: minimizacion  --></a>, \(M(Q)\) es \(\Sigma \)-p.r. y por lo tanto \(M^{\leq }(P)\) lo es.                                                   □
</p>
   </div>
<!-- l. 6156 --><p class='indent'>   En el ejemplo de recien vimos que \(U=M(P)\), con \(P=\lambda \alpha _{1}\alpha [\alpha @\) es tramo inicial de \(\alpha _{1}]\) por lo cual, dado que
\(P\) es \(\Sigma \)-p.r. y ademas \[ \left \vert U(\alpha _{1})\right \vert \leq \left \vert \alpha _{1}\right \vert \text{, para cada }\alpha _{1}\in Dir \] el lema anterior nos dice que \(U\) es \(\Sigma \)-p.r.
</p><!-- l. 6167 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.2.3   </span> <a id='x1-930003.2.3'></a>Conjuntos \(\Sigma \)-recursivamente enumerables</h5>
<!-- l. 6169 --><p class='noindent'>Ya que la nocion de funcion \(\Sigma \)-recursiva es el modelo matematico Godeliano del
concepto de funcion \(\Sigma \)-efectivamente computable, nos podriamos preguntar
entonces cual es el modelo matematico Godeliano del concepto de conjunto
\(\Sigma \)-efectivamente enumerable. Si prestamos atencion a la definicion de conjunto
\(\Sigma \)-efectivamente enumerable, notaremos que depende de la existencia de ciertas
funciones \(\Sigma \)-efectivamente computables por lo cual la siguiente definicion cae de
maduro:
</p><!-- l. 6177 --><p class='indent'>   Diremos que un conjunto \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) sera llamado \(\Sigma \)<span class='cmti-10'>-recursivamente enumerable </span>cuando sea
vacio o haya una funcion \(F:\omega \rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) tal que \(I_{F}=S\) y \(F_{(i)}\) sea \(\Sigma \)-recursiva, para cada \(i\in \{1,...,n+m\}\).
</p><!-- l. 6183 --><p class='indent'>   Deberia entonces quedar claro que si el concepto de funcion \(\Sigma \)-recursiva modeliza
correctamente al concepto de funcion \(\Sigma \)-efectivamente computable, entonces el
concepto de conjunto \(\Sigma \)-recursivamente enumerable recien definido modeliza
correctamente al concepto de conjunto \(\Sigma \)-efectivamente enumerable.
</p><!-- l. 6192 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.2.4   </span> <a id='x1-940003.2.4'></a>Conjuntos \(\Sigma \)-recursivos</h5>
<!-- l. 6194 --><p class='noindent'>La version Godeliana del concepto de conjunto \(\Sigma \)-efectivamente computable es
facil de dar: un conjunto \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) sera llamado \(\Sigma \)<span class='cmti-10'>-recursivo </span>cuando la funcion \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) sea
\(\Sigma \)-recursiva.

</p><!-- l. 6202 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.2.5   </span> <a id='x1-950003.2.5'></a>Algunos resultados basicos</h5>
<!-- l. 6204 --><p class='noindent'>Muchos resultados ya probados para el caso primitivo recursivo pueden ser probados
usando basicamente las mismas pruebas e ideas para el caso recursivo. Por ejemplo
las pruebas de los siguientes cuatro lemas son identicas a las del caso primitivo
recursivo
</p>
   <div class='newtheorem'>
<!-- l. 6211 --><p class='noindent'><span class='head'>
<a id='x1-95001r72'></a>
<span class='cmbx-10'>Lema 72.</span>  </span><span class='cmti-10'>Si</span> \(P:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>y</span> \(Q:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>son predicados</span> \(\Sigma \)<span class='cmti-10'>-r., entonces</span> \((P\vee Q)\)<span class='cmti-10'>,</span> \((P\wedge Q)\) <span class='cmti-10'>y</span> \(\lnot P\) <span class='cmti-10'>lo son tambien.</span>
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 6220 --><p class='noindent'><span class='head'>
<a id='x1-95002r73'></a>
<span class='cmbx-10'>Lema 73.</span>  </span><span class='cmti-10'>Si</span> \(S_{1},S_{2}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-r., entonces</span> \(S_{1}\cup S_{2}\)<span class='cmti-10'>,</span> \(S_{1}\cap S_{2}\) <span class='cmti-10'>y</span> \(S_{1}-S_{2}\) <span class='cmti-10'>lo son.</span>
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 6228 --><p class='noindent'><span class='head'>
<a id='x1-95003r74'></a>
<span class='cmbx-10'>Lema 74.</span>  </span><span class='cmti-10'>Supongamos</span> \(S_{1},...,S_{n}\subseteq \omega \)<span class='cmti-10'>,</span> \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\) <span class='cmti-10'>son conjuntos no vacios. Entonces</span> \(S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r. sii</span> \(S_{1},...,S_{n},L_{1},...,L_{m}\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-r.</span>
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 6237 --><p class='noindent'><span class='head'>
<a id='x1-95004r75'></a>
<span class='cmbx-10'>Lema 75.</span>  </span><span class='cmti-10'>Si</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r. y</span> \(S\subseteq D_{f}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r., entonces</span> \(f|_{S}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r</span>

</p>
   </div>
<!-- l. 6245 --><p class='indent'>   Tambien se puede probar una version del lema de division por casos para
funciones \(\Sigma \)-recursivas con dominio \(\Sigma \)-recursivo, la cual generaliza el caso \(\Sigma \)-p.r.. La
prueba es la misma que la del caso primitivo recursivo aunque al lema previo de
existencia de extensiones lo probaremos en forma mas directa que para el caso
primitivo recursivo. A saber:
</p>
   <div class='newtheorem'>
<!-- l. 6251 --><p class='noindent'><span class='head'>
<a id='x1-95005r76'></a>
<span class='cmbx-10'>Lema 76.</span>  </span><span class='cmti-10'>Si</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r. y</span> \(D_{f}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r., entonces existe una funcion</span> \(\Sigma \)<span class='cmti-10'>-r.</span> \(\bar{f}:\omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\)<span class='cmti-10'>, tal que</span> \(f=\bar{f}|_{D_{f}}\)
</p>
   </div>
<!-- l. 6258 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 6259 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Si \(f=\emptyset \), es facil de probar y dejado al lector. Supongamos entonces \(f\) es
no vacia. Sin perdida de generalidad podemos suponer que \((0,...,0,\varepsilon ,...,\varepsilon )\in D_{f}\). Sea \[ \begin{array}[t]{rll} F:\omega ^{n}\times \Sigma ^{\ast m} &amp; \rightarrow &amp; \omega ^{n}\times \Sigma ^{\ast m}\\ (\vec{x},\vec{\alpha }) &amp; \rightarrow &amp; \left \{ \begin{array}{lll} (\vec{x},\vec{\alpha }) &amp; &amp; \text{si }(\vec{x},\vec{\alpha })\in D_{f}\\ (0,...,0,\varepsilon ,...,\varepsilon ) &amp; &amp; \text{caso contrario} \end{array}\right . \end{array} \] Ya que
</p><div class='eqnarray'>\begin{eqnarray*} F_{(i)} &amp; = &amp; \lambda \vec{x}\vec{\alpha }\left [x_{i}.\chi _{D_{f}}^{\omega ^{n}\times \Sigma ^{\ast m}}(\vec{x},\vec{\alpha })\right ]\text{, para }i=1,...,n\\ F_{(i)} &amp; = &amp; \lambda \vec{x}\vec{\alpha }\left [\alpha _{i}^{\chi _{D_{f}}^{\omega ^{n}\times \Sigma ^{\ast m}}(\vec{x},\vec{\alpha })}\right ]\text{, para }i=n+1,...,n+m \end{eqnarray*}
</div>tenemos que cada \(F_{(i)}\) es \(\Sigma \)-recursiva. Es claro que \(\bar{f}=f\circ F\) cumple que \(f=\bar{f}|_{D_{f}}\) por lo cual solo falta ver
que \(\bar{f}\) es \(\Sigma \)-recursiva. Pero esto es obvio ya que \(F=\left [F_{(1)},...,F_{(n+m)}\right ]\)                                           □
   </div>
   <div class='newtheorem'>
<!-- l. 6282 --><p class='noindent'><span class='head'>
<a id='x1-95006r77'></a>
<span class='cmbx-10'>Lema 77.</span>  </span><span class='cmti-10'>Supongamos</span>  \(f_{i}:D_{f_{i}}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\)<span class='cmti-10'>,</span>  \(i=1,...,k\)<span class='cmti-10'>,  son  funciones</span>  \(\Sigma \)<span class='cmti-10'>-recursivas  tales  que  cada</span>  \(D_{f_{i}}\)  <span class='cmti-10'>es</span>
\(\Sigma \)<span class='cmti-10'>-recursivo y</span> \(D_{f_{i}}\cap D_{f_{j}}=\emptyset \) <span class='cmti-10'>para</span> \(i\neq j\)<span class='cmti-10'>. Entonces la funcion</span> \(f_{1}\cup ...\cup f_{k}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva.</span>
</p>
   </div>
<!-- l. 6289 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 6290 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Completamente analoga a la del caso primitivo recursivo.                 □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 6294 --><p class='noindent'><span class='head'>
<a id='x1-95007r78'></a>
<span class='cmbx-10'>Lema 78.</span>  </span><span class='cmti-10'>Si</span> \(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursivo, entonces</span> \(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r.e.</span>
</p>
   </div>
<!-- l. 6298 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 6299 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(\emptyset \neq S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\). Sea \((z_{1},...,z_{n},\gamma _{1},...,\gamma _{m})\in S\) fijo. Sea \(\leq \) un orden total sobre \(\Sigma \). Sea \(G:\omega \rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) dada por \[ G(x)=\left ((x+1)_{1},...,(x+1)_{n},\ast ^{\leq }((x+1)_{n+1}),...,\ast ^{\leq }((x+1)_{n+m})\right ) \] Es
claro que cada \(G_{(i)}\) es \(\Sigma \)-recursiva y que \(\mathrm{Im}G=\omega ^{n}\times \Sigma ^{\ast m}\).
</p><!-- l. 6308 --><p class='indent'>   Para \(i=1,...,n\), definamos \(F_{i}:\omega \rightarrow \omega \) de la siguiente manera \[ F_{i}(x)=\left \{ \begin{array}{ccl} G_{(i)}(x) &amp; &amp; \text{si }G(x)\in S\\ z_{i} &amp; &amp; \text{caso contrario} \end{array}\right . \] Para \(i=n+1,...,n+m\), definamos \(F_{i}:\omega \rightarrow \Sigma ^{\ast }\) de la siguiente
manera \[ F_{i}(x)=\left \{ \begin{array}{ccl} G_{(i)}(x) &amp; &amp; \text{si }G(x)\in S\\ \gamma _{i} &amp; &amp; \text{caso contrario} \end{array}\right . \] Usando que \(S\) es \(\Sigma \)-recursivo podemos aplicar el lema anterior y ver que
cada \(F_{i}\) es \(\Sigma \)-recursiva. Sea \(F=[F_{1},...,F_{n+m}]\). Notese que \(F_{(i)}=F_{i}\) para cada \(i=1,...,n+m\). Esto nos dice que \(S\) es \(\Sigma \)-r.e. ya
que \(\mathrm{Im}F=S\).                                                                                               □
</p>
   </div>
<!-- l. 6331 --><p class='indent'>   Mas adelante (Lema <a href='#x1-135005r135'>135<!-- tex4ht:ref: A es RE y no R  --></a>) daremos un ejemplo natural de un conjunto que es \(\Sigma \)-r.e.
pero el cual no es \(\Sigma \)-recursivo.
</p><!-- l. 6334 --><p class='indent'>   Deberia quedar claro que si el modelo de Godel es correcto, entonces todos los
resultados probados dentro del paradigma filosofico de la computabilidad efectiva son
ciertos una ves reenunciados de acuerdo al paradigma Godeliano. Tal como vimos
arriba muchos de estos resultados se prueban en forma facil en su version recursiva.
Sin envargo muchos otros requieren mas trabajo y es necesario utilizar algun
paradigma mas constructivo (como el imperativo o el de Turing) para poder
probarlos en su version recursiva. Por ejemplo consideremos el teorema siguiente
dado en el contexto del paradigma filosofico:
</p>
   <div class='newtheorem'>
<!-- l. 6343 --><p class='noindent'><span class='head'>
<a id='x1-95008r79'></a>

<span class='cmbx-10'>Teorema 79.</span>  </span><span class='cmti-10'>Sea</span> \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\)<span class='cmti-10'>. Son equivalentes</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-95009x79'>\(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable</span>
     </li>
     <li class='enumerate' id='x1-95010x79'>\(S\) <span class='cmti-10'>y</span> \((\omega ^{n}\times \Sigma ^{\ast m})-S\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-efectivamente enumerables</span></li></ol>
   </div>
<!-- l. 6354 --><p class='noindent'>Se tiene que la version recursiva de (a)\(\Rightarrow \)(b) es probada sin problemas en el lema
anterior pero para probar la version recursiva de (b)\(\Rightarrow \)(a), nos sera necesario utilizar el
paradigma imperativo (Teorema <a href='#x1-134006r124'>124<!-- tex4ht:ref: carac recursivos  --></a>). Lo mismo sucede con el lema de division por
casos en su forma mas general (Lema <a href='#x1-55001r23'>23<!-- tex4ht:ref: dpc para efectivamente computables  --></a>) y con el teorema de caracterizacion de
conjuntos \(\Sigma \)-efectivamente enumerables (Teorema <a href='#x1-57016r31'>31<!-- tex4ht:ref: equivalencias de efectivamente enumerable  --></a>), ambos cuando son enunciados
en su version recursiva no son faciles de probar con las herramientas desarrolladas
hasta ahora y nos sera necesario usar el paradigma imperativo para representar a
los objetos recursivos involucrados. Estas pruebas estan en la Seccion <a href='#x1-1320003.6'>3.6<!-- tex4ht:ref: survey recursivo  --></a>
donde se compilan todos los resultados basicos (expresados en paradigma
recursivo) y se obtienen algunos resultados los cuales en esta instancia todavia
no se pueden probar ya que para obtenerlos es necesario hacer uso de la
formalizacion matematica de ambos paradigmas el funcional y el imperativo
(por ejemplo la existencia de un conjunto que es \(\Sigma \)-r.e. pero el cual no es
\(\Sigma \)-recursivo).
</p><!-- l. 6374 --><p class='indent'>   @@finpagina@@
</p><!-- l. 6376 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.2.6   </span> <a id='x1-960003.2.6'></a>Recursion primitiva sobre valores anteriores</h5>
<!-- l. 6378 --><p class='noindent'>Dada una funcion \(h:\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \), con \(S_{1},...,S_{n}\subseteq \omega \) y \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\), no vacios, definamos \(h^{\downarrow }:\omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \) de la siguiente manera
</p><div class='eqnarray'>\begin{eqnarray*} h^{\downarrow }(x,\vec{x},\vec{\alpha }) &amp; = &amp; \left \langle h(0,\vec{x},\vec{\alpha }),h(1,\vec{x},\vec{\alpha }),...,h(x,\vec{x},\vec{\alpha })\right \rangle \\ &amp; = &amp; \Pi _{i=0}^{x}pr(i+1)^{h(i,\vec{x},\vec{\alpha })} \end{eqnarray*}
</div>
   <div class='newtheorem'>
<!-- l. 6387 --><p class='noindent'><span class='head'>
<a id='x1-96001r80'></a>
<span class='cmbx-10'>Lema 80.</span>  </span><span class='cmti-10'>Supongamos</span> </p><div class='eqnarray'>\begin{eqnarray*} f &amp; : &amp; S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \\ g &amp; : &amp; \omega \times \omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \\ h &amp; : &amp; \omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega  \end{eqnarray*}
</div><span class='cmti-10'>son funciones tales que </span><div class='eqnarray'>\begin{eqnarray*} h(0,\vec{x},\vec{\alpha }) &amp; = &amp; f(\vec{x},\vec{\alpha })\\ h(x+1,\vec{x},\vec{\alpha }) &amp; = &amp; g(h^{\downarrow }(x,\vec{x},\vec{\alpha }),x,\vec{x},\vec{\alpha })\text{,} \end{eqnarray*}
</div><span class='cmti-10'>para cada</span> \(x\in \omega \) <span class='cmti-10'>y</span> \((\vec{x},\vec{\alpha })\in S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\)<span class='cmti-10'>. Entonces</span> \(h\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r. (resp.</span> \(\Sigma \)<span class='cmti-10'>-p.r.) si</span> \(f\) <span class='cmti-10'>y</span> \(g\) <span class='cmti-10'>lo son.</span>
   </div>
<!-- l. 6404 --><p class='indent'>

</p>
   <div class='proof'>
<!-- l. 6405 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(f,g\) son \(\Sigma \)-p.r.. Primero veremos que \(h^{\downarrow }\) es \(\Sigma \)-r. (resp. \(\Sigma \)-p.r.). Notese que
para cada \((\vec{x},\vec{\alpha })\in S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\) tenemos que </p><div class='eqnarray'>\begin{eqnarray*} h^{\downarrow }(0,\vec{x},\vec{\alpha }) &amp; = &amp; \left \langle h(0,\vec{x},\vec{\alpha })\right \rangle \\ &amp; = &amp; \left \langle f(\vec{x},\vec{\alpha })\right \rangle \\ &amp; = &amp; 2^{f(\vec{x},\vec{\alpha })}\\ h^{\downarrow }(x+1,\vec{x},\vec{\alpha }) &amp; = &amp; h^{\downarrow }(x,\vec{x},\vec{\alpha })pr(x+2)^{h(x+1,\vec{x},\vec{\alpha })}\\ &amp; = &amp; h^{\downarrow }(x,\vec{x},\vec{\alpha })pr(x+2)^{g(h^{\downarrow }(x,\vec{x},\vec{\alpha }),x,\vec{x},\vec{\alpha })} \end{eqnarray*}
</div>lo cual nos dice que \(h^{\downarrow }=R(f_{1},g_{1})\) donde <div class='eqnarray'>\begin{eqnarray*} f_{1} &amp; = &amp; \lambda \vec{x}\vec{\alpha }\left [2^{f(\vec{x},\vec{\alpha })}\right ]\\ g_{1} &amp; = &amp; \lambda Ax\vec{x}\vec{\alpha }\left [Apr(x+2)^{g(A,x,\vec{x},\vec{\alpha })}\right ] \end{eqnarray*}
</div>O sea que \(h^{\downarrow }\) es \(\Sigma \)-r. (resp. \(\Sigma \)-p.r.) ya que \(f_{1}\) y \(g_{1}\) lo son. Finalmente notese que \[ h=\lambda ix[(x)_{i}]\circ \left [Suc\circ p_{1}^{1+n,m},h^{\downarrow }\right ] \] lo cual nos
dice que \(h\) es \(\Sigma \)-r. (resp. \(\Sigma \)-p.r.).                                                                  □
   </div>
<!-- l. 6430 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.2.7   </span> <a id='x1-970003.2.7'></a>Independencia del alfabeto</h5>
<!-- l. 6432 --><p class='noindent'>Probaremos que los conceptos de \(\Sigma \)-recursividad y \(\Sigma \)-recursividad primitiva son en
realidad independientes del alfabeto \(\Sigma \), es decir que si \(f\) es una funcion la cual es
\(\Sigma \)-mixta y \(\Gamma \)-mixta, entonces \(f\) es \(\Sigma \)-recursiva (resp. \(\Sigma \)-p.r.) sii \(f\) es \(\Gamma \)-recursiva (resp.
\(\Gamma \)-p.r.).
</p><!-- l. 6438 --><p class='indent'>   Ya definimos para el caso de un alfabeto \(\Sigma \neq \emptyset \) y \(\leq \) un orden total sobre \(\Sigma \), las
funciones \(\#^{\leq }\) y \(\ast ^{\leq }\). Sea \(\Sigma =\emptyset \). Notese que el conjunto \(\emptyset \) es un orden total sobre \(\Sigma \) (de hecho
es el unico orden total sobre \(\Sigma \)). Definamos \[ \begin{array}{rll} \#^{\emptyset }:\{0\} &amp; \rightarrow &amp; \{\varepsilon \}\\ 0 &amp; \rightarrow &amp; \varepsilon \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rll} \ast ^{\emptyset }:\{\varepsilon \} &amp; \rightarrow &amp; \{0\}\\ \varepsilon &amp; \rightarrow &amp; 0 \end{array} \] Ya que \(\Sigma ^{\ast }=\{\varepsilon \}\), las funciones \(\#^{\emptyset }\) y \(\ast ^{\emptyset }\) son
biyecciones mutuamente inversas entre \(\{0\}\) y \(\Sigma ^{\ast }\). Ademas notese que estas funciones son
\(\Sigma \)-p.r..
</p>
   <div class='newtheorem'>
<!-- l. 6455 --><p class='noindent'><span class='head'>
<a id='x1-97001r81'></a>
<span class='cmbx-10'>Lema 81.</span>  </span><span class='cmti-10'>Supongamos</span> \(\Sigma \subseteq \Gamma \)<span class='cmti-10'>.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-97002x81'><span class='cmti-10'>Si</span> \(\leq \) <span class='cmti-10'>es un orden total sobre</span> \(\Sigma \)<span class='cmti-10'>, entonces las funciones</span> \(\Sigma \)<span class='cmti-10'>-mixtas</span> \(\ast ^{\leq }\) <span class='cmti-10'>y</span> \(\#^{\leq }\) <span class='cmti-10'>son</span> \(\Gamma \)<span class='cmti-10'>-p.r..</span>
     </li>
     <li class='enumerate' id='x1-97003x81'><span class='cmti-10'>Si</span> \(\leq ^{\prime }\) <span class='cmti-10'>es un orden total sobre</span> \(\Gamma \)<span class='cmti-10'>, entonces las funciones</span> \(\Sigma \)<span class='cmti-10'>-mixtas</span> \(\#^{\leq ^{\prime }}|_{\Sigma ^{\ast }}\) <span class='cmti-10'>y</span> \(\ast ^{\leq ^{\prime }}|_{\#^{\leq ^{\prime }}(\Sigma ^{\ast })}\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-p.r..</span></li></ol>
   </div>
<!-- l. 6467 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 6468 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>(a) Si \(\Sigma =\emptyset \), entonces es facil ver que \(\ast ^{\leq }\) y \(\#^{\leq }\) son \(\Gamma \)-p.r., y es dejado como ejercicio.
Supongamos \(\Sigma =\{a_{1},...,a_{k}\}\) con \(k\geq 1\) y \(\leq \) es dado por \(a_{1}&lt;...&lt;a_{k}\). Sea \(s_{e}^{\leq }:\Gamma ^{\ast }\rightarrow \Gamma ^{\ast }\) dada por </p><div class='eqnarray'>\begin{eqnarray*} s_{e}^{\leq }(\varepsilon ) &amp; = &amp; a_{1}\\ s_{e}^{\leq }(\alpha a_{i}) &amp; = &amp; \alpha a_{i+1}\text{, si }i&lt;k\\ s_{e}^{\leq }(\alpha a_{k}) &amp; = &amp; s_{e}^{\leq }(\alpha )a_{1}\\ s_{e}^{\leq }(\alpha a) &amp; = &amp; \varepsilon \text{, si }a\in \Gamma -\Sigma . \end{eqnarray*}
</div>Note que \(s_{e}^{\leq }\) es \(\Gamma \)-p.r. y que \(s_{e}^{\leq }|_{\Sigma ^{\ast }}=s^{\leq }\). Ya que <div class='eqnarray'>\begin{eqnarray*} \ast ^{\leq }(0) &amp; = &amp; \varepsilon \\ \ast ^{\leq }(x+1) &amp; = &amp; s^{\leq }(\ast ^{\leq }(x)) \end{eqnarray*}
</div>para cada \(x\in \omega \), tenemos que <div class='eqnarray'>\begin{eqnarray*} \ast ^{\leq }(0) &amp; = &amp; \varepsilon \\ \ast ^{\leq }(x+1) &amp; = &amp; s_{e}^{\leq }(\ast ^{\leq }(x)) \end{eqnarray*}
</div>Pero esto nos dice que \(\ast ^{\leq }=R(C_{\varepsilon }^{0,0},g)\) donde \[ \begin{array}{lll} g:\omega \times \Gamma ^{\ast } &amp; \rightarrow &amp; \Gamma ^{\ast }\\ \;\;\;\;\;(x,\alpha ) &amp; \rightarrow &amp; s_{e}^{\leq }(\alpha ) \end{array} \] Pero es claro que \(g\) es \(\Gamma \)-p.r. por lo cual \(\ast ^{\leq }\) es
\(\Gamma \)-p.r..
<!-- l. 6500 --><p class='indent'>   Para ver que \(\#^{\leq }:\Sigma ^{\ast }\rightarrow \omega \) es \(\Gamma \)-p.r., sea \(\#_{e}^{\leq }:\Gamma ^{\ast }\rightarrow \omega \) dada por </p><div class='eqnarray'>\begin{eqnarray*} \#_{e}^{\leq }(\varepsilon ) &amp; = &amp; 0\\ \#_{e}^{\leq }(\alpha a_{i}) &amp; = &amp; \#_{e}^{\leq }(\alpha ).k+i\\ \#_{e}^{\leq }(\alpha a) &amp; = &amp; 0\text{, si }a\in \Gamma -\Sigma . \end{eqnarray*}
</div>Ya que \(\#_{e}^{\leq }\) es \(\Gamma \)-p.r., eso es \(\#^{\leq }=\#_{e}^{\leq }|_{\Sigma ^{\ast }}\).
<!-- l. 6509 --><p class='indent'>   (b) El caso \(\Sigma =\emptyset \) es facil y queda como ejercicio. Supongamos entonces \(\Sigma \) es no vacio.
Sea \(n\) el cardinal de \(\Gamma .\) Ya que </p><div class='eqnarray'>\begin{eqnarray*} \#^{\leq ^{\prime }}|_{\Sigma ^{\ast }}(\varepsilon ) &amp; = &amp; 0\\ \#^{\leq ^{\prime }}|_{\Sigma ^{\ast }}(\alpha a) &amp; = &amp; \#^{\leq ^{\prime }}|_{\Sigma ^{\ast }}(\alpha ).n+\#^{\leq ^{\prime }}(a)\text{, para cada }a\in \Sigma  \end{eqnarray*}
</div>la funcion \(\#^{\leq ^{\prime }}|_{\Sigma ^{\ast }}\) es \(\Sigma \)-p.r.. O sea que el predicado \(P=\lambda x\alpha \left [\#^{\leq ^{\prime }}|_{\Sigma ^{\ast }}(\alpha )=x\right ]\) es \(\Sigma \)-p.r.. Sea \(\leq \) un orden total sobre \(\Sigma \). Note
que \(\ast ^{\leq ^{\prime }}|_{\#^{\leq ^{\prime }}(\Sigma ^{\ast })}=M^{\leq }(P)\), lo cual ya que \[ \left \vert \ast ^{\leq ^{\prime }}|_{\#^{\leq ^{\prime }}(\Sigma ^{\ast })}(x)\right \vert \leq x \] nos dice que \(\ast ^{\leq ^{\prime }}|_{\#^{\leq ^{\prime }}(\Sigma ^{\ast })}\) es \(\Sigma \)-p.r. (Lema <a href='#x1-92001r71'>71<!-- tex4ht:ref: minimizacion1  --></a>).                                □
   </div>
   <div class='newtheorem'>
<!-- l. 6529 --><p class='noindent'><span class='head'>
<a id='x1-97004r82'></a>
<span class='cmbx-10'>Lema 82.</span>  </span>\(\mathrm{PR}^{\emptyset }\subseteq \mathrm{PR}^{\Sigma }\) <span class='cmti-10'>y</span> \(\mathrm{R}^{\emptyset }\subseteq \mathrm{R}^{\Sigma }\)
</p>
   </div>
<!-- l. 6533 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 6534 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Veamos que \(\mathrm{R}^{\emptyset }\subseteq \mathrm{R}^{\Sigma }\). Probaremos por induccion en \(k\) que \(\mathrm{R}_{k}^{\emptyset }\subseteq \mathrm{R}^{\Sigma }\). El caso \(k=0\) es trivial.
Supongamos entonces que vale la hipotesis inductiva \(\mathrm{R}_{k}^{\emptyset }\subseteq \mathrm{R}^{\Sigma }\) y veamos que \(\mathrm{R}_{k+1}^{\emptyset }\subseteq \mathrm{R}^{\Sigma }\). Sea \(F\in \mathrm{R}_{k+1}^{\emptyset }-\mathrm{R}_{k}^{\emptyset }\)
veremos que \(F\in \mathrm{R}^{\Sigma }\). Hay varios casos:
</p><!-- l. 6542 --><p class='indent'>   Caso \(F=R(f,\mathcal{G})\), con </p><div class='eqnarray'>\begin{eqnarray*} f &amp; : &amp; S_{1}\times ...\times S_{n}\times \emptyset ^{\ast m}\rightarrow \emptyset ^{\ast }\\ \mathcal{G}_{a} &amp; : &amp; S_{1}\times ...\times S_{n}\times \emptyset ^{\ast m}\times \emptyset ^{\ast }\times \emptyset ^{\ast }\rightarrow \emptyset ^{\ast }\text{, para cada }a\in \emptyset  \end{eqnarray*}
</div>funciones en \(\mathrm{R}_{k}^{\emptyset }\) y cada \(S_{i}\) no vacio. Por hipotesis inductiva tenemos que \(f\in \mathrm{R}^{\Sigma }\). Notese que \(\mathcal{G}=\emptyset \), lo
cual nos dice que por definicion \[ \begin{array}{rll} R(f,\mathcal{G}):S_{1}\times ...\times S_{n}\times \emptyset ^{\ast m}\times \emptyset ^{\ast } &amp; \rightarrow &amp; \emptyset ^{\ast }\\ (\vec{x},\varepsilon ,...,\varepsilon ,\varepsilon ) &amp; \rightarrow &amp; f(\vec{x},\varepsilon ,...,\varepsilon ) \end{array} \] Es claro que \(\omega ^{n}\times \Sigma ^{\ast m}\times \emptyset ^{\ast }\) es un conjunto \(\Sigma \)-p.r. por lo cual las
funciones \(p_{i}^{n,m+1}|_{\omega ^{n}\times \Sigma ^{\ast m}\times \emptyset ^{\ast }}\) son \(\Sigma \)-p.r. (aqui las \(p_{i}^{n,m+1}\) son respecto de \(\Sigma \)). Ya que \[ R(f,\mathcal{G})=f\circ \left [p_{1}^{n,m+1}|_{\omega ^{n}\times \Sigma ^{\ast m}\times \emptyset ^{\ast }},...,p_{n+m}^{n,m+1}|_{\omega ^{n}\times \Sigma ^{\ast m}\times \emptyset ^{\ast }}\right ] \] tenemos que \(F\) es
\(\Sigma \)-recursiva
<!-- l. 6565 --><p class='indent'>   Caso \(F=R(f,g)\), con </p><div class='eqnarray'>\begin{eqnarray*} f &amp; : &amp; S_{1}\times ...\times S_{n}\times \emptyset ^{\ast m}\rightarrow \emptyset ^{\ast }\\ g &amp; : &amp; \omega \times S_{1}\times ...\times S_{n}\times \emptyset ^{\ast m}\times \emptyset ^{\ast }\rightarrow \emptyset ^{\ast } \end{eqnarray*}
</div>funciones en \(\mathrm{R}_{k}^{\emptyset }\) y cada \(S_{i}\) no vacio. Por hipotesis inductiva tenemos que \(f,g\in \mathrm{R}^{\Sigma }\). Notese
que respecto de \(\Sigma \), la funcion \(R(f,g)\) no esta definida ya que por la forma de \(f\), el
dominio de \(g\) deberia ser \(\omega \times S_{1}\times ...\times S_{n}\times \emptyset ^{\ast m}\times \Sigma ^{\ast }\). Sea \[ \tilde{g}=g\circ \left [p_{1}^{1+n,m+1},...,p_{1+n+m}^{1+n,m+1},C_{\varepsilon }^{1+n,m+1}\right ] \] (aqui las \(p_{i}^{1+n,m+1}\) y \(C_{\varepsilon }^{1+n,m+1}\) son respecto de \(\Sigma \)). Notese que \(D_{\tilde{g}}=\omega \times S_{1}\times ...\times S_{n}\times \emptyset ^{\ast m}\times \Sigma ^{\ast }\) y \(\tilde{g}\) es
\(\Sigma \)-recursiva. Ademas es facil ver que \(F=Rf,\tilde{g})\) (respecto del alfabeto \(\Sigma \)) por lo cual \(F\) es
\(\Sigma \)-recursiva

<!-- l. 6583 --><p class='indent'>   Caso \(F=M(P)\), con \(P:\omega \times \omega ^{n}\times \emptyset ^{\ast m}\rightarrow \omega \), un predicado en \(\mathrm{R}_{k}^{\emptyset }\). Por hipotesis inductiva tenemos que \(P\in \mathrm{R}^{\Sigma }\). Sea \[ \bar{P}=P\circ \left [p_{1}^{1+n,m},...,p_{1+n}^{1+n,m},C_{\varepsilon }^{1+n,m},...,C_{\varepsilon }^{1+n,m}\right ] \] Notese
que \(\bar{P}\) es \(\Sigma \)-total y \(\Sigma \)-recursivo y ademas extiende a \(P\). Sea \[ \tilde{P}=\lambda xy[x.y]\circ \left [\bar{P},\chi _{\omega \times \omega ^{n}\times \emptyset ^{\ast m}}^{\omega \times \omega ^{n}\times \Sigma ^{\ast m}}\right ] \] Tambien \(\tilde{P}\) es \(\Sigma \)-total y \(\Sigma \)-recursivo y
extiende a \(P\) pero ademas fuera del dominio de \(P\) vale \(0\). Esto nos dice que \(M(\tilde{P})=M(P)\) por lo cual \(F\) es
\(\Sigma \)-recursiva ya que \(M(\tilde{P})\) lo es
</p><!-- l. 6599 --><p class='indent'>   Los otros casos de recursion primitiva son parecidos a los hechos y el caso de la
composicion es trivial.
</p><!-- l. 6602 --><p class='indent'>   La prueba de que \(\mathrm{PR}^{\emptyset }\subseteq \mathrm{PR}^{\Sigma }\) es muy similar. Se dejan los detalles como ejercicio para el
lector                                                                                               □
</p>
   </div>
<!-- l. 6607 --><p class='indent'>   Sea \(\Sigma \) un alfabeto finito (puede ser vacio) y sea \(\leq \) un orden total sobre \(\Sigma \). Para \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \),
definamos \[ f^{\#^{\leq }}=f\circ \left [p_{1}^{n+m,0},...,p_{n}^{n+m,0},\ast ^{\leq }\circ p_{n+1}^{n+m,0},...,\ast ^{\leq }\circ p_{n+m}^{n+m,0}\right ] \] Similarmente, para \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \Sigma ^{\ast }\), definamos \[ f^{\#^{\leq }}=\#^{\leq }\circ f\circ \left [p_{1}^{n+m,0},...,p_{n}^{n+m,0},\ast ^{\leq }\circ p_{n+1}^{n+m,0},...,\ast ^{\leq }\circ p_{n+m}^{n+m,0}\right ] \]
</p>
   <div class='newtheorem'>
<!-- l. 6619 --><p class='noindent'><span class='head'>
<a id='x1-97005r83'></a>
<span class='cmbx-10'>Lema 83.</span>  </span><span class='cmti-10'>Sea</span> \(\Gamma \) <span class='cmti-10'>un alfabeto finito y sea</span> \(\leq \) <span class='cmti-10'>un orden total sobre</span> \(\Gamma \)<span class='cmti-10'>. Dada</span> \(h\) <span class='cmti-10'>una funcion</span>
\(\Gamma \)<span class='cmti-10'>-mixta, son equivalentes</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-97006x83'>\(h\) <span class='cmti-10'>es</span> \(\Gamma \)<span class='cmti-10'>-recursiva (resp.</span> \(\Gamma \)<span class='cmti-10'>-p.r.)</span>
     </li>
     <li class='enumerate' id='x1-97007x83'>\(h^{\#^{\leq }}\) <span class='cmti-10'>es</span> \(\emptyset \)<span class='cmti-10'>-recursiva (resp.</span> \(\emptyset \)<span class='cmti-10'>-p.r.)</span></li></ol>
   </div>
<!-- l. 6628 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 6629 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(2)\(\Rightarrow \)(1). Supongamos \(h:D_{h}\subseteq \omega ^{n}\times \Gamma ^{\ast m}\rightarrow \Gamma ^{\ast }\) es tal que \(h^{\#^{\leq }}\) es \(\emptyset \)-recursiva (resp. \(\emptyset \)-p.r.). Dejamos al
lector chequear que \[ h=\ast ^{\leq }\circ h^{\#^{\leq }}\circ \left [p_{1}^{n,m},...,p_{n}^{n,m},\#^{\leq }\circ p_{n+1}^{n,m},...,\#^{\leq }\circ p_{n+m}^{n,m}\right ] \] (aqui las \(p_{i}^{n,m}\) son respecto de \(\Gamma \)). Por el lema anterior tenemos
que \(h^{\#^{\leq }}\) es \(\Gamma \)-recursiva (resp. \(\Gamma \)-p.r.). Ya que (aun cuando \(\Gamma =\emptyset \)) tenemos que las funciones
\(\ast ^{\leq }\) y \(\#^{\leq }\) son \(\Gamma \)-p.r., tenemos que \(h\) es \(\Gamma \)-recursiva (resp. \(\Gamma \)-p.r.) ya que es composicion de
funciones \(\Gamma \)-recursivas (resp. \(\Gamma \)-p.r.).
</p><!-- l. 6642 --><p class='indent'>   (1)\(\Rightarrow \)(2). El caso \(\Gamma =\emptyset \) es trivial ya que \(h^{\#^{\leq }}\) se define como composicion de funciones
\(\emptyset \)-recursivas (resp. \(\emptyset \)-p.r.). Supongamos entonces que \(\Gamma =\{a_{1},...,a_{r}\}\), con \(a_{1}&lt;a_{2}&lt;...&lt;a_{r}\) y \(r&gt;0\). Probaremos por
induccion en \(k\) que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-97008x3.2.7'>Si \(h\in \mathrm{R}_{k}^{\Gamma }\) (resp. \(h\in \mathrm{PR}_{k}^{\Gamma }\)), entonces \(h^{\#^{\leq }}\) es \(\emptyset \)-recursiva (resp. \(\emptyset \)-p.r.).</li></ol>

<!-- l. 6651 --><p class='noindent'>El caso \(k=0\) es facil y dejado al lector. Supongamos (*) vale para un \(k\) fijo. Veremos que vale
para \(k+1\). Sea \(h\in \mathrm{R}_{k+1}^{\Gamma }\) (resp. \(h\in \mathrm{PR}_{k+1}^{\Gamma }\)). Hay varios casos
</p><!-- l. 6655 --><p class='indent'>   Caso 1. Supongamos \(h=f\circ [f_{1},...,f_{n}]\), con \(f,f_{1},...,f_{n}\in \mathrm{R}_{k}^{\Gamma }\) (resp. \(f,f_{1},...,f_{n}\in \mathrm{PR}_{k}^{\Gamma }\)). Por hipotesis inductiva tenemos
que \(f^{\#^{\leq }},f_{1}^{\#^{\leq }},...,f_{n}^{\#^{\leq }}\) son \(\emptyset \)-recursivas (resp. \(\emptyset \)-p.r.). Ya que \(h^{\#^{\leq }}=f^{\#^{\leq }}\circ \left [f_{1}^{\#^{\leq }},...,f_{n}^{\#^{\leq }}\right ]\), tenemos que \(h^{\#^{\leq }}\) es \(\emptyset \)-recursiva (resp.
\(\emptyset \)-p.r.).
</p><!-- l. 6661 --><p class='indent'>   Caso 2. Supongamos \(h=M(P)\), con \(P:\omega \times \omega ^{n}\times \Gamma ^{\ast m}\rightarrow \omega \), un predicado en \(\mathrm{R}_{k}^{\Gamma }\). Ya que \(h^{\#^{\leq }}=M(P^{\#^{\leq }})\), tenemos que \(h^{\#^{\leq }}\) es
\(\emptyset \)-recursiva.
</p><!-- l. 6665 --><p class='indent'>   Caso 3. Supongamos \(h=R(f,\mathcal{G})\), con </p><div class='eqnarray'>\begin{eqnarray*} f &amp; : &amp; S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \Gamma ^{\ast }\\ \mathcal{G}_{a} &amp; : &amp; S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\times \Gamma ^{\ast }\times \Gamma ^{\ast }\rightarrow \Gamma ^{\ast }\text{, }a\in \Gamma  \end{eqnarray*}
</div>funciones en \(\mathrm{R}_{k}^{\Gamma }\) (resp. \(\mathrm{PR}_{k}^{\Gamma }\)) y \(S_{1},...,S_{n}\subseteq \omega \) y \(L_{1},...,L_{m}\subseteq \Sigma ^{\ast }\), no vacios. Notese que <div class='eqnarray'>\begin{eqnarray*} f^{\#^{\leq }} &amp; : &amp; S_{1}\times ...\times S_{n}\times \#^{\leq }(L_{1})\times ...\times \#^{\leq }(L_{m})\rightarrow \omega \\ \mathcal{G}_{a}^{\#^{\leq }} &amp; : &amp; S_{1}\times ...\times S_{n}\times \#^{\leq }(L_{1})\times ...\times \#^{\leq }(L_{m})\times \omega \times \omega \rightarrow \omega \text{, }a\in \Gamma \\ h^{\#^{\leq }} &amp; : &amp; S_{1}\times ...\times S_{n}\times \#^{\leq }(L_{1})\times ...\times \#^{\leq }(L_{m})\times \omega \rightarrow \omega  \end{eqnarray*}
</div>Por hipotesis inductiva tenemos que \(f^{\#^{\leq }}\) y cada \(\mathcal{G}_{a}^{\#^{\leq }}\) son \(\emptyset \)-recursivas (resp. \(\emptyset \)-p.r.). Sea \[ \begin{array}{rll} i_{0}:\omega &amp; \rightarrow &amp; \omega \\ x &amp; \rightarrow &amp; \left \{ \begin{array}{lll} r &amp; &amp; \text{si }r\text{ divide }x\\ R(x,r) &amp; &amp; \text{caso contrario} \end{array}\right . \end{array} \] y sea \[ B=\lambda x\left [Q(x\dot{-}i_{0}(x),r)\right ] \] (\(R\)
y \(Q\) son definidas en el Lema <a href='#x1-90004r68'>68<!-- tex4ht:ref: cociente y resto  --></a>). Note que \(i_{0}\) y \(B\) son \(\emptyset \)-p.r. y que \[ \ast ^{\leq }(x)=\ast ^{\leq }(B(x))a_{i_{0}(x)}\text{, para }x\geq 1 \] (ejercicio). Tambien
tenemos para cada \((\vec{x},\vec{y},t)\in S_{1}\times ...\times S_{n}\times \#^{\leq }(L_{1})\times ...\times \#^{\leq }(L_{m})\times \omega \) se da <div class='eqnarray'>\begin{eqnarray*} h^{\#^{\leq }}(\vec{x},\vec{y},t+1) &amp; = &amp; \#^{\leq }(h(\vec{x},\ast ^{\leq }(\vec{y}),\ast ^{\leq }(t+1)))\\ &amp; = &amp; \#^{\leq }(h(\vec{x},\ast ^{\leq }(\vec{y}),\ast ^{\leq }(B(t+1))a_{i_{0}(t+1)}))\\ &amp; = &amp; \#^{\leq }\left (\mathcal{G}_{a_{i_{0}(t+1)}}(\vec{x},\ast ^{\leq }(\vec{y}),\ast ^{\leq }(B(t+1)),h(\vec{x},\ast ^{\leq }(\vec{y}),\ast ^{\leq }(B(t+1)))\right )\\ &amp; = &amp; \#^{\leq }\left (\mathcal{G}_{a_{i_{0}(t+1)}}(\vec{x},\ast ^{\leq }(\vec{y}),\ast ^{\leq }(B(t+1)),\ast ^{\leq }(h^{\#^{\leq }}(\vec{x},\vec{y},B(t+1))))\right )\\ &amp; = &amp; \mathcal{G}_{a_{i_{0}(t+1)}}^{\#^{\leq }}(\vec{x},\vec{y},B(t+1),h^{\#^{\leq }}(\vec{x},\vec{y},B(t+1))) \end{eqnarray*}
</div>y ya que \(B(t+1)&lt;t+1\), tenemos que
     <ol class='enumerate1'>
     <li class='enumerate' id='x1-97009x3.2.7'>\(h^{\#^{\leq }}(\vec{x},\vec{y},t+1)=\mathcal{G}_{a_{i_{0}(t+1)}}^{\#^{\leq }}(\vec{x},\vec{y},B(t+1),\left (\left \langle h^{\#^{\leq }}(\vec{x},\vec{y},0),...,h^{\#^{\leq }}(\vec{x},\vec{y},t)\right \rangle \right )_{B(t+1)+1})\), para cada \((\vec{x},\vec{y},t)\in S_{1}\times ...\times S_{n}\times \#^{\leq }(L_{1})\times ...\times \#^{\leq }(L_{m})\times \omega \)</li></ol>
<!-- l. 6712 --><p class='noindent'>A continuacion aplicaremos la idea del Lema <a href='#x1-96001r80'>80<!-- tex4ht:ref: f-flecha  --></a>. Sera mas claro asi ya que para aplicarlo
directamente deberiamos cambiar el orden de los parametros de las funciones \(h^{\#^{\leq }}\), \(\mathcal{G}_{a_{i}}^{\#^{\leq }}\)
componiendolas adecuadamente y seria muy engorroso notacionalmente.
</p><!-- l. 6717 --><p class='indent'>   Definamos \[ H=\lambda t\vec{x}\vec{y}\left [\left \langle h^{\#^{\leq }}(\vec{x},\vec{y},0),...,h^{\#^{\leq }}(\vec{x},\vec{y},t)\right \rangle \right ] \] Notar que \[ D_{H}=\omega \times S_{1}\times ...\times S_{n}\times \#^{\leq }(L_{1})\times ...\times \#^{\leq }(L_{m}) \] Tenemos que </p><div class='eqnarray'>\begin{eqnarray*} H(0,\vec{x},\vec{y}) &amp; = &amp; \left \langle h^{\#^{\leq }}(\vec{x},\vec{y},0)\right \rangle =\left \langle f^{\#^{\leq }}(\vec{x},\vec{y})\right \rangle =2^{f^{\#^{\leq }}(\vec{x},\vec{y})}\\ H(t+1,\vec{x},\vec{y}) &amp; = &amp; \left (H(t,\vec{x},\vec{y}).pr(t+2)^{h^{\#^{\leq }}(\vec{x},\vec{y},t+1)}\right )\\ &amp; = &amp; \left (H(t,\vec{x},\vec{y}).pr(t+2)^{\mathcal{G}_{a_{i_{0}(t+1)}}^{\#^{\leq }}(\vec{x},\vec{y},B(t+1),(H(t,\vec{x},\vec{y}))_{B(t+1)+1})}\right )\text{ (por (**))} \end{eqnarray*}
</div>para cada \((t,\vec{x},\vec{y})\in \omega \times S_{1}\times ...\times S_{n}\times \#^{\leq }(L_{1})\times ...\times \#^{\leq }(L_{m})\). O sea que si definimos \[ g:\omega \times \omega \times S_{1}\times ...\times S_{n}\times \#^{\leq }(L_{1})\times ...\times \#^{\leq }(L_{m})\rightarrow \omega \] por \[ g(A,t,\vec{x},\vec{y})=\left \{ \begin{array}{clc} \left (A.pr(t+2)^{\mathcal{G}_{a_{1}}^{\#^{\leq }}(\vec{x},\vec{y},B(t+1),(A)_{B(t+1)+1})}\right ) &amp; \text{si} &amp; i_{0}(t+1)=1\\ \vdots &amp; &amp; \vdots \\ \left (A.pr(t+2)^{\mathcal{G}_{a_{r}}^{\#^{\leq }}(\vec{x},\vec{y},B(t+1),(A)_{B(t+1)+1})}\right ) &amp; \text{si} &amp; i_{0}(t+1)=r \end{array}\right . \] tenemos que \(H=R(\lambda x\left [2^{x}\right ]\circ f^{\#^{\leq }},g)\). Note que \(g\) es \(\emptyset \)-recursiva (resp.
\(\emptyset \)-p.r.), ya que \[ g=\lambda At\vec{x}\vec{y}\left [f_{1}(A,t,\vec{x},\vec{y})P_{1}(A,t,\vec{x},\vec{y})+...+f_{r}(A,t,\vec{x},\vec{y})P_{r}(A,t,\vec{x},\vec{y})\right ]\text{,} \] con <div class='eqnarray'>\begin{eqnarray*} f_{i} &amp; = &amp; \lambda At\vec{x}\vec{y}\left [\left (A.pr(t+2)^{\mathcal{G}_{a_{i}}^{\#^{\leq }}(\vec{x},\vec{y},B(t+1),(A)_{B(t+1)})}\right )\right ]\\ P_{i} &amp; = &amp; \lambda At\vec{x}\vec{y}\left [i_{0}(t+1)=i\right ] \end{eqnarray*}
</div>O sea que \(H\) es \(\emptyset \)-recursiva (resp. \(\emptyset \)-p.r.) y por lo tanto lo es \[ h^{\#^{\leq }}=\lambda \vec{x}\vec{y}t\left [(H(t,\vec{x},\vec{y}))_{t+1}\right ] \] Los otros casos en los cuales \(h\)
es obtenida por recursion primitiva son similares.                                     □
   </div>
<!-- l. 6765 --><p class='indent'>   Ahora podemos probar el anunciado resultado de independencia.
</p>
   <div class='newtheorem'>
<!-- l. 6766 --><p class='noindent'><span class='head'>
<a id='x1-97010r84'></a>
<span class='cmbx-10'>Teorema 84.</span>  </span><span class='cmti-10'>Sean</span> \(\Sigma \) <span class='cmti-10'>y</span> \(\Gamma \) <span class='cmti-10'>alfabetos cualesquiera.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-97011x84'><span class='cmti-10'>Supongamos una funcion</span> \(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-mixta y</span> \(\Gamma \)<span class='cmti-10'>-mixta, entonces</span> \(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva (resp.</span>
     \(\Sigma \)<span class='cmti-10'>-p.r.) sii</span> \(f\) <span class='cmti-10'>es</span> \(\Gamma \)<span class='cmti-10'>-recursiva (resp.</span> \(\Gamma \)<span class='cmti-10'>-p.r.).</span>
     </li>
     <li class='enumerate' id='x1-97012x84'><span class='cmti-10'>Supongamos un conjunto</span> \(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-mixto y</span> \(\Gamma \)<span class='cmti-10'>-mixto, entonces</span> \(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursivo (resp.</span>
     \(\Sigma \)<span class='cmti-10'>-r.e.,</span> \(\Sigma \)<span class='cmti-10'>-p.r.) sii</span> \(S\) <span class='cmti-10'>es</span> \(\Gamma \)<span class='cmti-10'>-recursivo (resp.</span> \(\Gamma \)<span class='cmti-10'>-r.e.,</span> \(\Gamma \)<span class='cmti-10'>-p.r.).</span></li></ol>
   </div>
<!-- l. 6778 --><p class='indent'>

</p>
   <div class='proof'>
<!-- l. 6779 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Ya que \(f\) es \((\Sigma \cap \Gamma )\)-mixta, podemos suponer sin perdida de generalidad que \(\Sigma \subseteq \Gamma \) (por
que?). Sea \(\leq \) un orden total sobre \(\Sigma \) y sea \(\leq ^{\prime }\) un orden total sobre \(\Gamma \). Primero supongamos
que \(f\) es \(\Sigma \)-recursiva (resp. \(\Sigma \)-p.r.). Probaremos que \(f\) es \(\Gamma \)-recursiva (resp. \(\Gamma \)-p.r.). Ya que \(f\) es \(\Sigma \)
mixta, tenemos que \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\), con \(O\in \{\omega ,\Sigma ^{\ast }\}\). Haremos el caso \(O=\Sigma ^{\ast }\). Ya que las funciones \(\#^{\leq ^{\prime }}|_{\Sigma ^{\ast }}\) y \(\ast ^{\leq ^{\prime }}|_{\#^{\leq ^{\prime }}(\Sigma ^{\ast })}\) son \(\Sigma \)-p.r. (Lema
<a href='#x1-97001r81'>81<!-- tex4ht:ref: aux  --></a>) y ademas </p><div class='eqnarray'>\begin{eqnarray*} f^{\#^{\leq ^{\prime }}} &amp; = &amp; \#^{\leq ^{\prime }}\circ f\circ \left [p_{1}^{n+m,0},...,p_{n}^{n+m,0},\ast ^{\leq ^{\prime }}\circ p_{n+1}^{n+m,0},...,\ast ^{\leq ^{\prime }}\circ p_{n+m}^{n+m,0}\right ]\\ &amp; = &amp; \#^{\leq ^{\prime }}|_{\Sigma ^{\ast }}\circ f\circ \left [p_{1}^{n+m,0},...,p_{n}^{n+m,0},\ast ^{\leq ^{\prime }}|_{\#^{\leq ^{\prime }}(\Sigma ^{\ast })}\circ p_{n+1}^{n+m,0},...,\ast ^{\leq ^{\prime }}|_{\#^{\leq ^{\prime }}(\Sigma ^{\ast })}\circ p_{n+m}^{n+m,0}\right ] \end{eqnarray*}
</div>(justifique) tenemos que \(f^{\#^{\leq ^{\prime }}}\) es \(\Sigma \)-recursiva (resp. \(\Sigma \)-p.r.). Por el lema anterior tenemos que \(\left (f^{\#^{\leq ^{\prime }}}\right )^{\#^{\leq }}\)
es \(\emptyset \)-recursiva (resp. \(\emptyset \)-p.r.), pero notese que \(\left (f^{\#^{\leq ^{\prime }}}\right )^{\#^{\leq }}=f^{\#^{\leq ^{\prime }}}\) ya que \(f^{\#^{\leq ^{\prime }}}\) es de tipo \((n+m,0,\#)\), por lo cual tenemos
que \(f^{\#^{\leq ^{\prime }}}\) es \(\emptyset \)-recursiva (resp. \(\emptyset \)-p.r.). Pero esto por el lema anterior nos dice que \(f\) es
\(\Gamma \)-recursiva (resp. \(\Gamma \)-p.r.).
<!-- l. 6802 --><p class='indent'>   Supongamos ahora que \(f\) es \(\Gamma \)-recursiva (resp. \(\Gamma \)-p.r.). Probaremos que \(f\) es \(\Sigma \)-recursiva
(resp. \(\Sigma \)-p.r.). Ya que \(\#^{\leq }\) y \(\ast ^{\leq }\) son \(\Gamma \)-p.r. (Lema <a href='#x1-97001r81'>81<!-- tex4ht:ref: aux  --></a>), la funcion \[ f^{\#^{\leq }}=\#^{\leq }\circ f\circ \left [p_{1}^{n+m,0},...,p_{n}^{n+m,0},\ast ^{\leq }\circ p_{n+1}^{n+m,0},...,\ast ^{\leq }\circ p_{n+m}^{n+m,0}\right ] \] es \(\Gamma \)-recursiva (resp. \(\Gamma \)-p.r.). Por
el lema anterior \(\left (f^{\#^{\leq }}\right )^{\#^{\leq ^{\prime }}}\) es \(\emptyset \)-recursiva (resp. \(\emptyset \)-p.r.). Pero notese que \(\left (f^{\#^{\leq }}\right )^{\#^{\leq ^{\prime }}}=f^{\#^{\leq }}\) ya que \(f^{\#^{\leq }}\) es de tipo \((n+m,0,\#)\), por lo
cual \(f^{\#^{\leq }}\) es \(\emptyset \)-recursiva (resp. \(\emptyset \)-p.r.). Esto por el lema anterior nos dice que \(f\) es \(\Sigma \)-recursiva
(resp. \(\Sigma \)-p.r.).
</p><!-- l. 6816 --><p class='indent'>   (b) Supongamos \(S\) es \(\Sigma \)-mixto y \(\Gamma \)-mixto. Ya que \(S\) es \((\Sigma \cap \Gamma )\)-mixto, podemos suponer sin
perdida de generalidad que \(\Sigma \subseteq \Gamma \). Que \[ S\text{ es }\Sigma \text{-r.e. sii }S\text{ es }\Gamma \text{-r.e.} \] sigue directo de (a). Supongamos ahora que \(S\) es
\(\Sigma \)-recursivo. Veremos que \(S\) es \(\Gamma \)-recursivo. Supongamos \(S\) es de tipo \((n,m)\) es decir \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\). Por
definicion tenemos que \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) es \(\Sigma \)-recursiva. Pero \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) es tambien \(\Gamma \)-mixta, por lo cual (a) nos
dice que \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) es \(\Gamma \)-recursiva. Ademas es claro que el conjunto \((\omega ^{n}\times \Gamma ^{\ast m})-(\omega ^{n}\times \Sigma ^{\ast m})\) es \(\Gamma \)-recursivo. Ya que \[ \chi _{S}^{\omega ^{n}\times \Gamma ^{\ast m}}=\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\cup C_{0}^{n,m}|_{(\omega ^{n}\times \Gamma ^{\ast m})-(\omega ^{n}\times \Sigma ^{\ast m})} \] los
Lemas <a href='#x1-95004r75'>75<!-- tex4ht:ref: restriccion de recursivas a conj recursivos  --></a> y <a href='#x1-95006r77'>77<!-- tex4ht:ref: dpc para recursivas con dominio recursivo  --></a> nos dicen que \(\chi _{S}^{\omega ^{n}\times \Gamma ^{\ast m}}\) es \(\Gamma \)-recursiva (aqui \(C_{0}^{n,m}\) es respecto del alfabeto
\(\Gamma \)).
</p><!-- l. 6837 --><p class='indent'>   Supongamos ahora que \(S\) es \(\Gamma \)-recursivo. Veremos que \(S\) es \(\Sigma \)-recursivo. Por definicion
tenemos que \(\chi _{S}^{\omega ^{n}\times \Gamma ^{\ast m}}\) es \(\Gamma \)-recursiva. Ya que \(\omega ^{n}\times \Sigma ^{\ast m}\) es \(\Gamma \)-recursivo, tenemos que \(\chi _{S}^{\omega ^{n}\times \Gamma ^{\ast m}}|_{\omega ^{n}\times \Sigma ^{\ast m}}\) es \(\Gamma \)-recursiva. Por (a)
tenemos que \(\chi _{S}^{\omega ^{n}\times \Gamma ^{\ast m}}|_{\omega ^{n}\times \Sigma ^{\ast m}}\) es \(\Sigma \)-recursiva. Pero \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}=\chi _{S}^{\omega ^{n}\times \Gamma ^{\ast m}}|_{\omega ^{n}\times \Sigma ^{\ast m}}\) por lo cual \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) es \(\Sigma \)-recursiva, obteniendo que \(S\) es
\(\Sigma \)-recursivo.
</p><!-- l. 6846 --><p class='indent'>   El caso primitivo recursivo es analogo y dejado al lector.                       □
</p>
   </div>
<!-- l. 6850 --><p class='indent'>   @@finpagina@@
</p><!-- l. 6855 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.3   </span> <a id='x1-980003.3'></a>El paradigma imperativo de Neumann: El lenguaje \(\mathcal{S}^{\Sigma }\)</h4>
<!-- l. 6857 --><p class='noindent'>En esta seccion daremos una modelizacion matematica del concepto de funcion
\(\Sigma \)-efectivamente computable utilizando un lenguaje de programacion teorico el
cual depende del alfabeto \(\Sigma \). Lo llamaremos \(\mathcal{S}^{\Sigma }\) a dicho lenguaje. Dado que fue

el matematico Von Neumann quien contribuyo al desarrollo de la primera
computadora de proposito general (es decir a la cual se le pueden hacer
correr programas tal como a las computadoras actuales), nos referiremos
a este paradigma de computabilidad efectiva como el paradigma de Von
Neumann.
</p><!-- l. 6867 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.3.1   </span> <a id='x1-990003.3.1'></a>Sintaxis de \(\mathcal{S}^{\Sigma }\)</h5>
<!-- l. 6869 --><p class='noindent'>Necesitaremos algunas funciones basicas para poder describir la sintaxis de \(\mathcal{S}^{\Sigma }\) en forma
precisa. Llamaremos <span class='cmti-10'>numerales </span>a los siguientes simbolos \[ 0\ 1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9 \] Usaremos \(Num\) para denotar el
conjunto de numerales. Notese que \(Num\cap \omega =\emptyset \). Sea \(S:Num^{\ast }\rightarrow Num^{\ast }\) definida de la siguiente manera
</p><div class='eqnarray'>\begin{eqnarray*} S(\varepsilon ) &amp; = &amp; 1\\ S(\alpha 0) &amp; = &amp; \alpha 1\\ S(\alpha 1) &amp; = &amp; \alpha 2\\ S(\alpha 2) &amp; = &amp; \alpha 3\\ S(\alpha 3) &amp; = &amp; \alpha 4\\ S(\alpha 4) &amp; = &amp; \alpha 5\\ S(\alpha 5) &amp; = &amp; \alpha 6\\ S(\alpha 6) &amp; = &amp; \alpha 7\\ S(\alpha 7) &amp; = &amp; \alpha 8\\ S(\alpha 8) &amp; = &amp; \alpha 9\\ S(\alpha 9) &amp; = &amp; S(\alpha )0 \end{eqnarray*}
</div>Definamos \(\overline{\ \ \ \;}:\omega \rightarrow Num^{\ast }\) de la siguiente manera <div class='eqnarray'>\begin{eqnarray*} \bar{0} &amp; = &amp; \varepsilon \\ \overline{n+1} &amp; = &amp; S(\bar{n}) \end{eqnarray*}
</div>Notese que para \(n\in \mathbf{N}\), la palabra \(\bar{n}\) es la notacion usual decimal de \(n\). Recordemos que para \(\alpha \in \Sigma ^{\ast }\),
definiamos \[ ^{\curvearrowright }\alpha =\left \{ \begin{array}{lll} \left [\alpha \right ]_{2}...\left [\alpha \right ]_{\left \vert \alpha \right \vert } &amp; \text{si} &amp; \left \vert \alpha \right \vert \geq 2\\ \varepsilon &amp; \text{si} &amp; \left \vert \alpha \right \vert \leq 1 \end{array}\right . \] La sintaxis de \(\mathcal{S}^{\Sigma }\) sera dada utilizando solo simbolos del alfabeto \(\Sigma \cup \Sigma _{p}\), donde
\[ \Sigma _{p}=Num\cup \left \{ \leftarrow ,+,\dot{-},.,\neq ,^{\curvearrowright },\varepsilon ,\mathrm{N},\mathrm{K},\mathrm{P},\mathrm{L},\mathrm{I},\mathrm{F},\mathrm{G},\mathrm{O},\mathrm{T},\mathrm{B},\mathrm{E},\mathrm{S}\right \} . \]
<!-- l. 6916 --><p class='indent'>   Cabe aclarar que la palabra de longitud \(0\) no es un elemento de \(\Sigma _{p}\) sino que la letra
griega \(\varepsilon \) que usualmente denota esta palabra, lo es. Tambien notese que en \(\Sigma _{p}\) hay
simbolos que a veces representan operaciones como por ejemplo \(+\) y \(\dot{-}\), pero deberia
quedar claro que en \(\Sigma _{p}\) estan los simbolos \(+\) y \(\dot{-}\) y no las operaciones que ellos
denotan.
</p><!-- l. 6923 --><p class='indent'>   Las palabras de la forma \(\mathrm{N}\bar{k}\) con \(k\in \mathbf{N}\), son llamadas <span class='cmti-10'>variables numericas de</span> \(\mathcal{S}^{\Sigma }\). Las
palabras de la forma \(\mathrm{P}\bar{k}\) con \(k\in \mathbf{N}\), son llamadas <span class='cmti-10'>variables alfabeticas de</span> \(\mathcal{S}^{\Sigma }\). Las palabras de la
forma \(\mathrm{L}\bar{k}\) con \(k\in \mathbf{N}\), son llamadas <span class='cmti-10'>labels de</span> \(\mathcal{S}^{\Sigma }\).
</p><!-- l. 6930 --><p class='indent'>   Una <span class='cmti-10'>instruccion basica de</span> \(\mathcal{S}^{\Sigma }\) es una palabra de \((\Sigma \cup \Sigma _{p})^{\ast }\) la cual es de alguna de las
siguientes formas
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-99001x3.3.1'>\(\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k}+1\)
     </li>
     <li class='enumerate' id='x1-99002x3.3.1'>\(\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k}\dot{-}1\)
     </li>
     <li class='enumerate' id='x1-99003x3.3.1'>\(\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{n}\)
     </li>
     <li class='enumerate' id='x1-99004x3.3.1'>\(\mathrm{N}\bar{k}\leftarrow 0\)
     </li>
     <li class='enumerate' id='x1-99005x3.3.1'>\(\mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{k}.a\)
     </li>
     <li class='enumerate' id='x1-99006x3.3.1'>\(\mathrm{P}\bar{k}\leftarrow \) \(^{\curvearrowright }\mathrm{P}\bar{k}\)
     </li>
     <li class='enumerate' id='x1-99007x3.3.1'>\(\mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{n}\)

     </li>
     <li class='enumerate' id='x1-99008x3.3.1'>\(\mathrm{P}\bar{k}\leftarrow \varepsilon \)
     </li>
     <li class='enumerate' id='x1-99009x3.3.1'>\(\mathrm{IF}\;\mathrm{N}\bar{k}\neq 0\;\mathrm{GOTO}\;\mathrm{L}\bar{n}\)
     </li>
     <li class='enumerate' id='x1-99010x3.3.1'>\(\mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{n}\)
     </li>
     <li class='enumerate' id='x1-99011x3.3.1'>\(\mathrm{GOTO}\;\mathrm{L}\bar{n}\)
     </li>
     <li class='enumerate' id='x1-99012x3.3.1'>\(\mathrm{SKIP}\)</li></ol>
<!-- l. 6947 --><p class='noindent'>donde \(a\in \Sigma \) y \(k,n\in \mathbf{N}\). Como puede observarse para que las instrucciones basicas sean mas lejibles
usamos espacios entre ciertos simbolos. Por ejemplo, hemos escrito \(\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k}+1\) pero
en realidad nos referimos a la palabra \[ \mathrm{N}\bar{k}\mathrm{\leftarrow }\text{\textrm{N}}\bar{k}\mathrm{+1} \] cuya longitud es \(2\left \vert \bar{k}\right \vert +5\). Otro ejemplo,
hemos escrito \(\mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{n}\) pero en realidad nos referiamos a la palabra \(\mathrm{IFP}\bar{k}\mathrm{BEGINS}a\mathrm{GOTOL}\bar{n}\) cuya longitud es
\(\left \vert \bar{k}\right \vert +\left \vert \bar{n}\right \vert +15\).
</p><!-- l. 6959 --><p class='indent'>   Una <span class='cmti-10'>instruccion de</span> \(\mathcal{S}^{\Sigma }\) es ya sea una instruccion basica de \(\mathcal{S}^{\Sigma }\) o una palabra de la
forma \(\alpha I\), donde \(\alpha \in \{\mathrm{L}\bar{n}:n\in \mathbf{N}\}\) y \(I\) es una instruccion basica de \(\mathcal{S}^{\Sigma }\). Usaremos \(\mathrm{Ins}^{\Sigma }\) para denotar el conjunto
de todas las instrucciones de \(\mathcal{S}^{\Sigma }\). Cuando la instruccion \(I\) es de la forma \(\mathrm{L}\bar{n}J\) con \(J\) una
instruccion basica, diremos que \(\mathrm{L}\bar{n}\) es el <span class='cmti-10'>label </span>de \(I\). Damos a continuacion, a modo de
ejemplo, la interpretacion intuitiva asociada a ciertas instrucciones basicas de \(\mathcal{S}^{\Sigma }\):
</p><div class='eqnarray'>\begin{eqnarray*} \text{INSTRUCCION} &amp; : &amp; \mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k}\dot{-}1\\ \text{INTERPRETACION} &amp; : &amp; \begin{array}[t]{c} \text{Si el contenido de }\mathrm{N}\bar{k}\text{ es }0\text{ dejarlo sin modificar; en}\\ \text{caso contrario disminuya en 1 el contenido de }\mathrm{N}\bar{k}\; \end{array}\\ \text{INSTRUCCION} &amp; : &amp; \mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{n}\\ \text{INTERPRETACION} &amp; : &amp; \begin{array}[t]{l} \text{Copiar en }\mathrm{N}\bar{k}\text{ el contenido de }\mathrm{N}\bar{n}\text{ (sin modificar el}\\ \text{contenido de }\mathrm{N}\bar{n}\text{)} \end{array}\\ \text{INSTRUCCION} &amp; : &amp; \mathrm{P}\bar{k}\leftarrow ^{\curvearrowright }\mathrm{P}\bar{k}\\ \text{INTERPRETACION} &amp; : &amp; \begin{array}[t]{l} \text{Si el contenido de }\mathrm{P}\bar{k}\text{ es }\varepsilon \text{ dejarlo sin modificar;}\\ \text{en caso contrario remueva el 1er simbolo del}\\ \text{contenido de }\mathrm{P}\bar{k} \end{array} \end{eqnarray*}
</div>
   <div class='eqnarray'>\begin{eqnarray*} \text{INSTRUCCION} &amp; : &amp; \mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{k}.a\\ \text{INTERPRETACION} &amp; : &amp; \begin{array}[t]{l} \text{Modificar el contenido de }\mathrm{P}\bar{k}\text{ agregandole}\\ \text{el simbolo }a\text{ a la derecha} \end{array}\\ \text{INSTRUCCION} &amp; : &amp; \mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{m}\\ \text{INTERPRETACION} &amp; : &amp; \begin{array}[t]{l} \text{Si el contenido de }\mathrm{P}\bar{k}\text{ comiensa con }a,\text{ejecute}\\ \text{la primer instruccion con label }\mathrm{L}\bar{m}\text{; en caso}\\ \text{contrario ejecute la siguiente instruccion} \end{array} \end{eqnarray*}
</div>
<!-- l. 7004 --><p class='indent'>   Un <span class='cmti-10'>programa de</span> \(\mathcal{S}^{\Sigma }\) es una palabra de la forma \[ I_{1}I_{2}...I_{n} \] donde \(n\geq 1\), \(I_{1},...,I_{n}\in \mathrm{Ins}^{\Sigma }\) y ademas se cumple la
siguiente propiedad, llamada <span class='cmti-10'>la ley de los GOTO</span>,
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-99013x3.3.1'>Para cada \(i\in \{1,...,n\}\), si \(\mathrm{GOTOL}\bar{m}\) es un tramo final de \(I_{i}\), entonces existe \(j\in \{1,...,n\}\) tal que \(I_{j}\) tiene label
     \(\mathrm{L}\bar{m}\)</li></ol>
<!-- l. 7016 --><p class='noindent'>Usaremos \(\mathrm{Pro}^{\Sigma }\) para denotar el conjunto de todos los programas de \(\mathcal{S}^{\Sigma }\). Como es usual cuando
escribamos un programa lo haremos linea por linea, con la finalidad de que sea mas
lejible. Por ejemplo, escribiremos \[ \begin{array}{ll} \mathrm{L}2 &amp; \mathrm{N}12\leftarrow \mathrm{N}12\dot{-}1\\ &amp; \mathrm{P}1\leftarrow \text{ }^{\curvearrowright }\mathrm{P}1\\ &amp; \mathrm{IF\;N}12\neq 0\;\mathrm{GOTO}\;\mathrm{L}2 \end{array} \] en lugar de \[ \mathrm{L}2\mathrm{N}12\mathrm{\leftarrow }\text{N}12\mathrm{\dot{-}}1\mathrm{P}1\mathrm{\leftarrow }^{\curvearrowright }\mathrm{P}1\mathrm{IFN}12\mathrm{\neq }0\mathrm{GOTOL}2 \] Un importante resultado es el
siguiente lema que garantiza que los programas pueden ser parseados en forma unica
como concatenacion de instrucciones.
</p>
   <div class='newtheorem'>
<!-- l. 7034 --><p class='noindent'><span class='head'>
<a id='x1-99014r85'></a>
<span class='cmbx-10'>Lema 85.</span>  </span><span class='cmti-10'>Se tiene que:</span>

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-99015x85'><span class='cmti-10'>Si</span> \(I_{1}...I_{n}=J_{1}...J_{m}\)<span class='cmti-10'>, con</span> \(I_{1},...,I_{n},J_{1},...,J_{m}\in \mathrm{Ins}^{\Sigma }\)<span class='cmti-10'>, entonces</span> \(n=m\) <span class='cmti-10'>y</span> \(I_{j}=J_{j}\) <span class='cmti-10'>para cada</span> \(j\geq 1\)<span class='cmti-10'>.</span>
     </li>
     <li class='enumerate' id='x1-99016x85'><span class='cmti-10'>Si</span> \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\)<span class='cmti-10'>, entonces existe una unica sucesion de instrucciones</span> \(I_{1},...,I_{n}\) <span class='cmti-10'>tal que</span> \(\mathcal{P}=I_{1}...I_{n}\)</li></ol>
   </div>
<!-- l. 7044 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 7045 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Supongamos \(I_{n}\) es un tramo final propio de \(J_{m}.\) Notar que entonces \(n&gt;1\). Es facil ver
que entonces ya sea \(J_{m}=\mathrm{L}\bar{u}I_{n}\) para algun \(u\in \mathbf{N}\), o \(I_{n}\) es de la forma \(\mathrm{GOTO}\;\mathrm{L}\bar{n}\) y \(J_{m}\) es de la forma \(w\mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{n}\) donde \(w\in \{\mathrm{L}\bar{n}:n\in \mathbf{N}\}\cup \{\varepsilon \}\). El
segundo caso no puede darse porque entonces el anteultimo simbolo de \(I_{n-1}\) deberia
ser \(\mathrm{S}\) lo cual no sucede para ninguna instruccion. O sea que \[ I_{1}...I_{n}=J_{1}...J_{m-1}\mathrm{L}\bar{u}I_{n} \] lo cual dice
que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-99017x3.3.1'>\(I_{1}...I_{n-1}=J_{1}...J_{m-1}\mathrm{L}\bar{u}.\)</li></ol>
<!-- l. 7060 --><p class='noindent'>Es decir que \(\mathrm{L}\bar{u}\) es tramo final de \(I_{n-1}\) y por lo tanto \(\mathrm{GOTO}\;\mathrm{L}\bar{u}\) es tramo final de \(I_{n-1}.\) Por (*), \(\mathrm{GOTO}\) es
tramo final de \(J_{1}...J_{m-1}\), lo cual es impossible. Hemos llegado a una contradiccion lo
cual nos dice que \(I_{n}\) no es un tramo final propio de \(J_{m}.\) Por simetria tenemos
que \(I_{n}=J_{m}\), lo cual usando un razonamiento inductivo nos dice que \(n=m\) y \(I_{j}=J_{j}\) para cada
\(j\geq 1\).
</p><!-- l. 7068 --><p class='indent'>   (b) Es consecuencia directa de (a).                                                    □
</p>
   </div>
<!-- l. 7072 --><p class='indent'>   (b) del lema anterior nos dice que dado un programa \(\mathcal{P}\), tenemos univocamente
determinados \(n(\mathcal{P})\in \mathbf{N}\) y \(I_{1}^{\mathcal{P}},...,I_{n(\mathcal{P})}^{\mathcal{P}}\in \mathrm{Ins}^{\Sigma }\) tales que \(\mathcal{P}=I_{1}^{\mathcal{P}}...I_{n(\mathcal{P})}^{\mathcal{P}}\). Definamos tambien \[ I_{i}^{\mathcal{P}}=\varepsilon \] cuando \(i=0\) o \(i&gt;n(\mathcal{P})\). Notese que las
expresiones \(n(\alpha )\) y \(I_{i}^{\alpha }\) estan definidas solo cuando \(\alpha \) es un programa (y \(i\) es un elemento de \(\omega \)),
es decir, cierta palabra del alfabeto \(\Sigma \cup \Sigma _{p}\). O sea que cuando usemos notacion lambda que
involucre dichas expresiones, el alfabeto respecto del cual usaremos dicha notacion
sera \(\Sigma \cup \Sigma _{p}\). Esto nos dice entonces que \(\lambda \alpha [n(\alpha )]\) tiene dominio igual a \(\mathrm{Pro}^{\Sigma }\subseteq (\Sigma \cup \Sigma _{p})^{\ast }\) y \(\lambda i\alpha [I_{i}^{\alpha }]\) tiene dominio igual a \(\omega \times \mathrm{Pro}^{\Sigma }\).
Para hacer mas sugestiva la notacion a veces escribiremos \(\lambda \mathcal{P}[n(\mathcal{P})]\) y \(\lambda i\mathcal{P}[I_{i}^{\mathcal{P}}]\) en lugar de \(\lambda \alpha [n(\alpha )]\) y
\(\lambda i\alpha [I_{i}^{\alpha }]\).
</p><!-- l. 7093 --><p class='indent'>   Sera necesaria la funcion \(Bas:\mathrm{Ins}^{\Sigma }\rightarrow (\Sigma \cup \Sigma _{p})^{\ast }\), dada por \[ Bas(I)=\left \{ \begin{array}{ccl} J &amp; &amp; \text{si }I\text{ es de la forma }\mathrm{L}\bar{k}J\text{ con }J\in \mathrm{Ins}^{\Sigma }\\ I &amp; &amp; \text{caso contrario} \end{array}\right . \]

</p><!-- l. 7105 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.3.2   </span> <a id='x1-1000003.3.2'></a>Semantica de \(\mathcal{S}^{\Sigma }\)</h5>
<!-- l. 7107 --><p class='noindent'>Definamos
</p>
   <div class='eqnarray'>\begin{eqnarray*} \omega ^{\left [\mathbf{N}\right ]} &amp; = &amp; \left \{ (s_{1},s_{2},...)\in \omega ^{\mathbf{N}}:\text{ hay }n\in \mathbf{N}\text{ tal que }s_{i}=0,\text{para }i\geq n\right \} \\ \Sigma ^{\ast \left [\mathbf{N}\right ]} &amp; = &amp; \left \{ (\sigma _{1},\sigma _{2},...)\in \Sigma ^{\ast \mathbf{N}}:\text{ hay }n\in \mathbf{N}\text{ tal que }\sigma _{i}=\varepsilon ,\text{para }i\geq n\right \} . \end{eqnarray*}
</div>Asumiremos siempre que en una computacion via un programa de \(\mathcal{S}^{\Sigma }\), todas exepto una
cantidad finita de las variables numericas tienen el valor \(0\) y todas exepto una cantiad
finita de las variables alfabeticas tienen el valor \(\varepsilon \). Esto no quita generalidad a nuestra
modelizacion del funcionamiento de los programas ya que todo programa envuelve
una cantidad finita de variables.
<!-- l. 7120 --><p class='indent'>   Un <span class='cmti-10'>estado </span>es un par \[ (\vec{s},\vec{\sigma })=((s_{1},s_{2},...),(\sigma _{1},\sigma _{2},...))\in \omega ^{\left [\mathbf{N}\right ]}\times \Sigma ^{\ast \left [\mathbf{N}\right ]}. \] Si \(i\geq 1\), entonces diremos que \(s_{i}\) es el <span class='cmti-10'>contenido </span>o<span class='cmti-10'> valor </span>de la
variable \(\mathrm{N}\bar{\imath }\) en el estado \((\vec{s},\vec{\sigma })\) y \(\sigma _{i}\) es el <span class='cmti-10'>contenido </span>o<span class='cmti-10'> valor </span>de la variable \(\mathrm{P}\bar{\imath }\) en el estado \((\vec{s},\vec{\sigma })\).
Intuitivamente hablando, un estado es un par de infinituplas que contiene la
informacion de que valores tienen alojados las distintas variables.
</p><!-- l. 7132 --><p class='indent'>   Imaginemos que corremos un programa \(\mathcal{P}\) partiendo de un estado inicial \((\vec{s},\vec{\sigma })\). Por
supuesto la primera instruccion a realizar sera \(I_{1}^{\mathcal{P}}\) pero, dado que \(I_{1}^{\mathcal{P}}\) puede ser de tipo
GOTO, la segunda instruccion que realizaremos puede no ser \(I_{2}^{\mathcal{P}}\). Es decir en cada
paso iremos decidiendo en funcion de la instruccion ejecutada cual es la
siguiente instruccion a realizar. O sea que mientras corremos \(\mathcal{P}\), en cada paso la
informacion importante a tener en cuenta es, por una parte, cuales son los
valores que tienen cada una de las variables y, por otra parte, cual es la
instruccion que nos tocara realizar a continuacion. Esto da lugar al concepto de
descripcion instantanea, a saber, un objeto matematico que describe en
un instante dado de la computacion cuales son los valores de las variables
y cual es la instruccion que se debe realizar en el instante siguiente. Mas
formalmente una <span class='cmti-10'>descripcion instantanea </span>es una terna \((i,\vec{s},\vec{\sigma })\) tal que \((\vec{s},\vec{\sigma })\) es un estado e \(i\in \omega \). Es
decir que \(\omega \times \omega ^{\left [\mathbf{N}\right ]}\times \Sigma ^{\ast \left [\mathbf{N}\right ]}\) es el conjunto formado por todas las descripciones instantaneas.
Intuitivamente hablando, cuando \(i\in \{1,...,n(\mathcal{P})\}\), la descripcion instantanea \((i,\vec{s},\vec{\sigma })\) nos dice que
las variables estan en el estado \((\vec{s},\vec{\sigma })\) y que la instruccion que <span class='cmti-10'>debemos realizar</span>
es \(I_{i}^{\mathcal{P}}\). Dado que sera conveniente para simplificar el tratamiento formal, nos
abstraeremos un poco y cuando \(i=0\) o \(i&gt;n(\mathcal{P})\) pensaremos tambien que la descripcion
instantanea \((i,\vec{s},\vec{\sigma })\) nos dice que las variables estan en el estado \((\vec{s},\vec{\sigma })\) y que debemos
realizar \(I_{i}^{\mathcal{P}}=\varepsilon \) (aunque por supuesto no podremos realizarla ya que no es una
instruccion).
</p><!-- l. 7161 --><p class='indent'>   Dado un programa \(\mathcal{P}\) definiremos a continuacion una funcion \[ S_{\mathcal{P}}:\omega \times \omega ^{\left [\mathbf{N}\right ]}\times \Sigma ^{\ast \left [\mathbf{N}\right ]}\rightarrow \omega \times \omega ^{\left [\mathbf{N}\right ]}\times \Sigma ^{\ast \left [\mathbf{N}\right ]} \] la cual le
asignara a una descripcion instantanea \((i,\vec{s},\vec{\sigma })\) la <span class='cmti-10'>descripcion instantanea sucesora de</span>
\((i,\vec{s},\vec{\sigma })\) <span class='cmti-10'>con respecto a</span> \(\mathcal{P}\). Cuando \(i\in \{1,...,n(\mathcal{P})\}\), intuitivamente hablando, \(S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })\) sera la descripcion
instantanea que resulta luego de realizar \(I_{i}^{\mathcal{P}}\) estando en el estado \((\vec{s},\vec{\sigma })\). Cuando \(i=0\) o \(i&gt;n(\mathcal{P})\)
definiremos \(S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i,\vec{s},\vec{\sigma })\), lo cual es bastante intuitivo ya que si estamos en estado \((\vec{s},\vec{\sigma })\) y
debemos realizar \(I_{i}^{\mathcal{P}}=\varepsilon \), dado que \(\varepsilon \) no es una instruccion y por lo tanto no la
podremos realizar, seguiremos en el mismo estado y teniendo que realizar
\(I_{i}^{\mathcal{P}}\).
</p><!-- l. 7177 --><p class='indent'>   Para darle una semantica mas unificada al concepto de descripcion instantanea
sucesora debemos crear un nuevo verbo. El verbo ”realizarp”. Dada una actividad
A, diremos que un individuo P <span class='cmti-10'>realizap </span>la actividad A, si P realiza A, en

caso de que pueda hacerlo. O sea realizarp una actividad es realizarla si se
puede.
</p><!-- l. 7183 --><p class='indent'>   Para dar otro ejemplo de este tipo de verbos, consideremos el verbo ”comprarp”,
es decir ”comprar si se puede”. Un hijo le pide a su padre que le compre un
determinado juguete y el padre le dice ”si, hijo mio, te lo voy a comprarp”. Luego el
padre es despedido de su empleo y su cituacion economica hace que no le sea posible
comprar dicho juguete. Sin envargo el padre no mintio ya que si bien no compro
dicho juguete, él si lo comprop.
</p><!-- l. 7191 --><p class='indent'>   Con este verbo podemos describir intuitivamente \(S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })\): </p><div class='eqnarray'>\begin{eqnarray*} S_{\mathcal{P}}(i,\vec{s},\vec{\sigma }) &amp; = &amp; \mathrm{desc\ inst\ que\ resulta\ luego\ de}\\ &amp; &amp; \mathrm{rea}\text{l}\mathrm{izarp\ }I_{i}^{\mathcal{P}}\text{, estando en estado }(\vec{s},\vec{\sigma }) \end{eqnarray*}
</div>Ahora si, daremos la definicion matematica de \(S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })\), segun se den distintos casos
posibles.
<!-- l. 7199 --><p class='indent'>   Caso \(i\notin \{1,...,n(\mathcal{P})\}\). Entonces \(S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i,\vec{s},\vec{\sigma })\)
</p><!-- l. 7201 --><p class='indent'>   Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k}\dot{-}1.\) Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i+1,(s_{1},...,s_{k-1},s_{k}\dot{-}1,s_{k+1},...),\vec{\sigma }) \]
</p><!-- l. 7207 --><p class='indent'>   Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k}+1.\) Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i+1,(s_{1},...,s_{k-1},s_{k}+1,s_{k+1},...),\vec{\sigma }) \]
</p><!-- l. 7213 --><p class='indent'>   Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{n}\). Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i+1,(s_{1},...,s_{k-1},s_{n},s_{k+1},...),\vec{\sigma }) \]
</p><!-- l. 7219 --><p class='indent'>   Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{k}\leftarrow 0.\) Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i+1,(s_{1},...,s_{k-1},0,s_{k+1},...),\vec{\sigma }) \]
</p><!-- l. 7224 --><p class='indent'>   Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{IF}\) \(\mathrm{N}\bar{k}\) \(\neq 0\) \(\mathrm{GOTO}\) \(\mathrm{L}\bar{m}.\) Entonces tenemos dos subcasos.
</p><!-- l. 7228 --><p class='indent'>   Subcaso a. El valor de \(\mathrm{N}\bar{k}\) en \((\vec{s},\vec{\sigma })\) es 0. Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i+1,\vec{s},\vec{\sigma }) \]
</p><!-- l. 7234 --><p class='indent'>   Subcaso b. El valor de \(\mathrm{N}\bar{k}\) en \((\vec{s},\vec{\sigma })\) es no nulo. Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(\min \{l:I_{l}^{\mathcal{P}}\ \mathrm{tiene\ label\ L}\bar{m}\},\vec{s},\vec{\sigma }) \]
</p><!-- l. 7240 --><p class='indent'>   Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{k}\leftarrow \) \(^{\curvearrowright }\mathrm{P}\bar{k}.\) Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i+1,\vec{s},(\sigma _{1},...,\sigma _{k-1},^{\curvearrowright }\sigma _{k},\sigma _{k+1},...)) \]
</p><!-- l. 7246 --><p class='indent'>   Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{k}.a\). Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i+1,\vec{s},(\sigma _{1},...,\sigma _{k-1},\sigma _{k}a,\sigma _{k+1},...)) \]
</p><!-- l. 7252 --><p class='indent'>   Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{n}\). Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i+1,\vec{s},(\sigma _{1},...,\sigma _{k-1},\sigma _{n},\sigma _{k+1},...)) \]
</p><!-- l. 7258 --><p class='indent'>   Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{k}\leftarrow \varepsilon .\) Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i+1,\vec{s},(\sigma _{1},...,\sigma _{k-1},\varepsilon ,\sigma _{k+1},...)) \]
</p><!-- l. 7264 --><p class='indent'>   Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{m}.\) Entonces tenemos dos subcasos.
</p><!-- l. 7267 --><p class='indent'>   Subcaso a. El valor de \(\mathrm{P}\bar{k}\) en \((\vec{s},\vec{\sigma })\) comiensa con \(a\). Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(\min \{l:I_{l}^{\mathcal{P}}\ \mathrm{tiene\ label\ L}\bar{m}\},\vec{s},\vec{\sigma }) \]
</p><!-- l. 7273 --><p class='indent'>   Subcaso b. El valor de \(\mathrm{P}\bar{k}\) en \((\vec{s},\vec{\sigma })\) no comiensa con \(a\). Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i+1,\vec{s},\vec{\sigma }) \]
</p><!-- l. 7279 --><p class='indent'>   Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{GOTO}\;\mathrm{L}\bar{m}\). Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(\min \{l:I_{l}^{\mathcal{P}}\ \mathrm{tiene\ label\ L}\bar{m}\},\vec{s},\vec{\sigma }) \]
</p><!-- l. 7285 --><p class='indent'>   Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{SKIP}\). Entonces \[ S_{\mathcal{P}}(i,\vec{s},\vec{\sigma })=(i+1,\vec{s},\vec{\sigma }) \]
</p>
<!-- l. 7291 --><p class='noindent'><span class='paragraphHead'><a id='x1-1010003.3.2'></a><span class='cmbx-10'>La computacion partiendo de un estado</span></span>
   Dado un programa \(\mathcal{P}\) y un estado \((\vec{s},\vec{\sigma })\) a la infinitupla \[ ((1,\vec{s},\vec{\sigma }),S_{\mathcal{P}}(1,\vec{s},\vec{\sigma }),S_{\mathcal{P}}(S_{\mathcal{P}}(1,\vec{s},\vec{\sigma })),S_{\mathcal{P}}(S_{\mathcal{P}}(S_{\mathcal{P}}(1,\vec{s},\vec{\sigma }))),...) \] la llamaremos la <span class='cmti-10'>computacion de</span>
\(\mathcal{P}\)<span class='cmti-10'> partiendo del estado</span> \((\vec{s},\vec{\sigma })\). Diremos que \[ \overset{t\text{ veces}}{\overbrace{S_{\mathcal{P}}(...S_{\mathcal{P}}(S_{\mathcal{P}}(}}1,\vec{s},\vec{\sigma }))...) \] es la <span class='cmti-10'>descripcion instantanea obtenida luego de</span> \(t\)
<span class='cmti-10'>pasos, partiendo del estado</span> \((\vec{s},\vec{\sigma })\). Si \[ \overset{t\text{ veces}}{\overbrace{S_{\mathcal{P}}(...S_{\mathcal{P}}(S_{\mathcal{P}}(}}1,\vec{s},\vec{\sigma }))...)=(j,\vec{u},\vec{\eta }) \] diremos que \((\vec{u},\vec{\eta })\) es el <span class='cmti-10'>estado obtenido luego de</span> \(t\) <span class='cmti-10'>pasos,
</span><span class='cmti-10'>partiendo del estado</span> \((\vec{s},\vec{\sigma })\).
</p><!-- l. 7311 --><p class='indent'>   Es claro que en la infinitupla de mas arriba esta toda la informacion de la
”corrida” del programa \(\mathcal{P}\) cuando partimos del estado \((\vec{s},\vec{\sigma })\). Veamos un ejemplo. Sea \(\Sigma =\{\blacktriangle ,\#\}\)
y sea \(\mathcal{P}\) el siguiente programa \[ \begin{array}{ll} \mathrm{L}3 &amp; \mathrm{N}4\leftarrow \mathrm{N}4+1\\ &amp; \mathrm{P}1\leftarrow \ ^{\curvearrowright }\mathrm{P}1\\ &amp; \mathrm{IF\ P}1\ \mathrm{BEGINS\ }\blacktriangle \ \mathrm{GOTO}\;\mathrm{L}3\\ &amp; \mathrm{P}3\leftarrow \mathrm{P}3.\# \end{array} \] Supongamos que tomamos \((\vec{s},\vec{\sigma })\) igual al estado \[ \left ((2,1,0,5,3,0,0,0,...),(\#\blacktriangle \#\#,\varepsilon ,\blacktriangle \blacktriangle ,\#\blacktriangle ,\#,\varepsilon ,\varepsilon ,\varepsilon ,...)\right ) \]
Tendremos entonces que la computacion de \(\mathcal{P}\) partiendo del estado \((\vec{s},\vec{\sigma })\) es la
siguiente sucesion (de arriba hacia abajo) de descripciones instantaneas:
</p><div class='gather-star'><img alt=' ' src='apunte1x.png' /></div>Notese que en este caso es natural decir que el programa \(\mathcal{P}\) se detiene, partiendo
del estado inicial dado ya que llega a un punto en el que queda intentando
realizar \(I_{n(\mathcal{P})+1}^{\mathcal{P}}\) lo cual no es una instruccion. Veamos un ejemplo de no detencion.

Sea \(\mathcal{Q}\) el siguiente programa \[ \begin{array}{ll} \mathrm{L}3 &amp; \mathrm{N}4\leftarrow \mathrm{N}4+1\\ &amp; \mathrm{IF\ P}1\ \mathrm{BEGINS\ }\blacktriangle \ \mathrm{GOTO}\;\mathrm{L}3 \end{array} \] Supongamos que tomamos \((\vec{s},\vec{\sigma })\) igual al estado \[ \left ((2,1,0,5,3,0,0,0,...),(\blacktriangle \#\#,\varepsilon ,\blacktriangle \blacktriangle ,\#\blacktriangle ,\#,\varepsilon ,\varepsilon ,\varepsilon ,...)\right ) \]
Tendremos entonces que la computacion de \(\mathcal{Q}\) partiendo del estado \((\vec{s},\vec{\sigma })\) es la
siguiente sucesion (de arriba hacia abajo) de descripciones instantaneas:
<div class='gather-star'><img alt=' ' src='apunte2x.png' /></div>Notese que en este caso, es claro que el programa \(\mathcal{Q}\) no se detiene partiendo del
estado inicial dado ya que sigue indefinidamente realizando instrucciones.
<!-- l. 7399 --><p class='noindent'><span class='likeparagraphHead'><a id='x1-1020003.3.2'></a>Definicion matematica de detencion</span>
   Ahora definiremos matematicamente el concepto de detencion. Cuando la
primer coordenada de \[ \overset{t\text{ veces}}{\overbrace{S_{\mathcal{P}}(...S_{\mathcal{P}}(S_{\mathcal{P}}(}}1,\vec{s},\vec{\sigma }))...) \] sea igual a \(n(\mathcal{P})+1\), diremos que \(\mathcal{P}\) <span class='cmti-10'>se detiene (luego de</span> \(t\)<span class='cmti-10'> pasos),
</span><span class='cmti-10'>partiendo desde el estado</span> \((\vec{s},\vec{\sigma })\). Si ninguna de las primeras coordenadas en la
computacion \[ ((1,\vec{s},\vec{\sigma }),S_{\mathcal{P}}(1,\vec{s},\vec{\sigma }),S_{\mathcal{P}}(S_{\mathcal{P}}(1,\vec{s},\vec{\sigma })),S_{\mathcal{P}}(S_{\mathcal{P}}(S_{\mathcal{P}}(1,\vec{s},\vec{\sigma }))),...) \] es igual a \(n(\mathcal{P})+1\), diremos que \(\mathcal{P}\) <span class='cmti-10'>no se detiene partiendo del estado</span>
\((\vec{s},\vec{\sigma })\).
</p><!-- l. 7416 --><p class='indent'>   Cabe destacar que en los conceptos antes definidos por ”1 paso” entendemos
”realizarp una instrucion”, donde tal como se lo explico antes ”realizarp” significa
”realizar si se puede”. Otra observacion importante es que los programas de \(\mathcal{S}^{\Sigma }\) tienen
una sola manera de detenerse, i.e. siempre que se detienen lo hacen habiendo
realizado la ultima de sus instrucciones e intentando realizar la instruccion siguiente a
su ultima instruccion
</p><!-- l. 7428 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.3.3   </span> <a id='x1-1030003.3.3'></a>Funciones \(\Sigma \)-computables</h5>
<!-- l. 7430 --><p class='noindent'>Ahora que hemos definido matematicamente la semantica de \(\mathcal{S}^{\Sigma }\) estamos en condiciones
de definir el concepto de funcion \(\Sigma \)-computable, el cual sera una modelizacion
matematica del concepto de funcion \(\Sigma \)-efectivamente computable. Intuitivamente
hablando una funcion sera \(\Sigma \)-computable cuando haya un programa que la compute.
Para precisar este concepto nos sera util la siguiente notacion. Dados \(x_{1},...,x_{n}\in \omega \) y \(\alpha _{1},...,\alpha _{m}\in \Sigma ^{\ast }\), con \(n,m\in \omega \),
usaremos \[ \left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \] para denotar el estado \[ \left ((x_{1},...,x_{n},0,...),(\alpha _{1},...,\alpha _{m},\varepsilon ,...)\right ) \] Esta notacion requiere aclarar un poco como debe
interpretarse en los casos limite, es decir cuando alguno de los numeros \(n,m\) es igual a \(0\).
Notese que por ejemplo \[ \left \Vert x\right \Vert =\left ((x,0,...),(\varepsilon ,...)\right ) \] (es el caso \(n=1\) y \(m=0\)). Tambien \[ \left \Vert \alpha \right \Vert =\left ((0,...),(\alpha ,\varepsilon ,...)\right ) \] (es el caso \(n=0\) y \(m=1\)). En el caso \(n=m=0\)
pensaremos que \(x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\) se transforma en \(\Diamond \) por lo que se obtiene \[ \left \Vert \Diamond \right \Vert =\left ((0,...),(\varepsilon ,...)\right ) \] Ademas es claro que \[ \left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert =\left \Vert x_{1},...,x_{n},\overset{i}{\overbrace{0,...,0}},\alpha _{1},...,\alpha _{m},\overset{j}{\overbrace{\varepsilon ,...,\varepsilon }}\right \Vert \]
cualesquiera sean \(i,j\in \omega \).
</p><!-- l. 7466 --><p class='indent'>   Dado \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\), definamos para cada par \(n,m\geq 0\), la funcion \(\Psi _{\mathcal{P}}^{n,m,\#}\) de la siguiente manera: \[ \begin{array}{l} D_{\Psi _{\mathcal{P}}^{n,m,\#}}=\{(\vec{x},\vec{\alpha })\in \omega ^{n}\times \Sigma ^{\ast m}:\mathcal{P}\text{ termina, partiendo del}\\ \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{estado }\left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \} \end{array} \] \[ \begin{array}{l} \Psi _{\mathcal{P}}^{n,m,\#}(\vec{x},\vec{\alpha })=\text{valor de }\mathrm{N}1\text{ en el estado obtenido cuando }\mathcal{P}\text{ termina,}\\ \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{partiendo de }\left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \end{array} \]
Analogamente definamos la funcion \(\Psi _{\mathcal{P}}^{n,m,\ast }\) de la siguiente manera: \[ \begin{array}{l} D_{\Psi _{\mathcal{P}}^{n,m,\ast }}=\{(\vec{x},\vec{\alpha })\in \omega ^{n}\times \Sigma ^{\ast m}:\mathcal{P}\text{ termina, partiendo del}\\ \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{estado }\left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \} \end{array} \] \[ \begin{array}{l} \Psi _{\mathcal{P}}^{n,m,\ast }(\vec{x},\vec{\alpha })=\text{valor de }\mathrm{P}1\text{ en el estado obtenido cuando }\mathcal{P}\text{ termina,}\\ \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{partiendo de }\left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \end{array} \] Ahora si daremos la
definicion precisa de funcion \(\Sigma \)-computable. Una funcion \(\Sigma \)-mixta \(f:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) sera llamada
\(\Sigma \)<span class='cmti-10'>-computable </span>si hay un programa \(\mathcal{P}\) tal que \(f=\Psi _{\mathcal{P}}^{n,m,\#}\). En tal caso diremos que la funcion \(f\) es
<span class='cmti-10'>computada </span>por \(\mathcal{P}\). Analogamente una funcion \(\Sigma \)-mixta \(f:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \Sigma ^{\ast }\) sera llamada \(\Sigma \)<span class='cmti-10'>-computable </span>si hay
un programa \(\mathcal{P}\) tal que \(f=\Psi _{\mathcal{P}}^{n,m,\ast }\). En tal caso diremos que la funcion \(f\) es <span class='cmti-10'>computada </span>por
\(\mathcal{P}\).
</p><!-- l. 7505 --><p class='indent'>   Algunos ejemplos:

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-103001x3.3.3'>El  programa  \[ \begin{array}{ll} \mathrm{L}2 &amp; \mathrm{IF}\;\mathrm{N}1\neq 0\;\mathrm{GOTO}\;\mathrm{L}1\\ &amp; \mathrm{GOTO}\;\mathrm{L}2\\ \mathrm{L}1 &amp; \mathrm{N}1\leftarrow \mathrm{N}1\dot{-}1 \end{array} \]  computa  la  funcion  \(Pred\).  Note  que  este  programa  tambien
     computa las funciones \(Pred\circ p_{1}^{n,m}\), para \(n\geq 1\) y \(m\geq 0\).
     </li>
     <li class='enumerate' id='x1-103002x3.3.3'>Sea \(\Sigma =\{\clubsuit ,\triangle \}.\) El programa \[ \begin{array}{ll} \mathrm{L}3 &amp; \mathrm{IF}\;\mathrm{P}2\;\mathrm{BEGINS}\;\clubsuit \;\mathrm{GOTO}\;\mathrm{L}1\\ &amp; \mathrm{IF}\;\mathrm{P}2\;\mathrm{BEGINS}\;\triangle \;\mathrm{GOTO}\;\mathrm{L}2\\ &amp; \mathrm{GOTO}\;\mathrm{L}4\\ \mathrm{L}1 &amp; \mathrm{P}2\leftarrow \text{ }^{\curvearrowright }\mathrm{P}2\\ &amp; \mathrm{P}1\leftarrow \mathrm{P}1\clubsuit \\ &amp; \mathrm{GOTO}\;\mathrm{L}3\\ \mathrm{L}2 &amp; \mathrm{P}2\leftarrow \text{ }^{\curvearrowright }\mathrm{P}2\\ &amp; \mathrm{P}1\leftarrow \mathrm{P}1\triangle \\ &amp; \mathrm{GOTO}\;\mathrm{L}3\\ \mathrm{L}4 &amp; \mathrm{SKIP} \end{array} \] computa la funcion \(\lambda \alpha \beta \left [\alpha \beta \right ].\)</li></ol>
<!-- l. 7534 --><p class='noindent'>Por supuesto para que el concepto de funcion \(\Sigma \)-computable tenga chance de ser una
modelizacion adecuada del concepto de funcion \(\Sigma \)-efectivamente computable, tiene que
ser cierto el siguiente resultado.
</p>
   <div class='newtheorem'>
<!-- l. 7538 --><p class='noindent'><span class='head'>
<a id='x1-103003r86'></a>
<span class='cmbx-10'>Proposition 86.</span>  </span><span class='cmti-10'>Si</span> \(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-computable, entonces</span> \(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable.</span>
</p>
   </div>
<!-- l. 7543 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 7544 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos por ejemplo que \(f:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) es computada por \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\). Un procedimiento
efectivo que compute a \(f\) puede consistir de realizar las sucesivas instrucciones
de \(\mathcal{P}\) (partiendo de \(\left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \)) y eventualmente terminar en caso de que nos toque realizar
la  instruccion  \(n(\mathcal{P})+1\),  y  dar  como  salida  el  contenido  de  la  variable  \(\mathrm{N}1\).  Daremos  a
continuacion una descripcion mas detallada de dicho procedimiento.
</p><!-- l. 7553 --><p class='indent'>   Fijemos primero un numero natural \(k\) que sea mayor que \(\max \{n,m\}\) y tal que toda
variable que ocurre en \(\mathcal{P}\) este en la lista \(\mathrm{N}1,...,\mathrm{N}\bar{k},\mathrm{P}1,...,\mathrm{P}\bar{k}\). Sea \(\mathbb{P}\) el siguiente procedimiento efectivo:
</p><!-- l. 7558 --><p class='indent'>   - Conjunto de datos de entrada de \(\mathbb{P}\) igual a \(\omega ^{n}\times \Sigma ^{\ast }{}^{m}\)
</p><!-- l. 7560 --><p class='indent'>   - Conjunto de datos de salida de \(\mathbb{P}\) contenido en \(\omega \)
</p><!-- l. 7562 --><p class='indent'>   - Funcionamiento:
</p><!-- l. 7564 --><p class='indent'>   Etapa 1
</p><!-- l. 7566 --><p class='noindent'>Asignar los siguientes valores a las variables \(I,X_{1},...,X_{k},A_{1},...,A_{k}\): \[ \begin{array}{ccc} &amp; I\leftarrow 1\\ X_{1}\leftarrow x_{1} &amp; &amp; A_{1}\leftarrow \alpha _{1}\\ \vdots &amp; &amp; \vdots \\ X_{n}\leftarrow x_{n} &amp; &amp; A_{m}\leftarrow \alpha _{m}\\ X_{n+1}\leftarrow 0 &amp; &amp; A_{m+1}\leftarrow \varepsilon \\ \vdots &amp; &amp; \vdots \\ X_{k}\leftarrow 0 &amp; &amp; A_{k}\leftarrow \varepsilon \end{array} \]
</p><!-- l. 7579 --><p class='indent'>   Etapa 2
</p><!-- l. 7581 --><p class='noindent'>Asignar:
</p><!-- l. 7583 --><p class='indent'>   \(I\leftarrow \) 1er coordenada de \(S_{\mathcal{P}}(I,(X_{1},...,X_{k},0,...),(A_{1},...,A_{k},\varepsilon ,...))\)
</p><!-- l. 7585 --><p class='noindent'>Para \(i=1,...,k\):
</p><!-- l. 7587 --><p class='indent'>   \(X_{i}\leftarrow \) \(i\)-esima coordenada de la segunda coordenada de \(S_{\mathcal{P}}(I,(X_{1},...,X_{k},0,...),(A_{1},...,A_{k},\varepsilon ,...))\)
</p><!-- l. 7590 --><p class='indent'>   \(A_{i}\leftarrow \) \(i\)-esima coordenada de la tercer coordenada de \(S_{\mathcal{P}}(I,(X_{1},...,X_{k},0,...),(A_{1},...,A_{k},\varepsilon ,...))\)
</p><!-- l. 7593 --><p class='indent'>   Etapa 3
</p><!-- l. 7595 --><p class='noindent'>Si \(I=n(\mathcal{P})+1\), entonces dar \(X_{1}\) como salida y detenerse. En caso contrario ir a Etapa 2.
</p><!-- l. 7598 --><p class='indent'>   Se deja al lector corroborar que \(\mathbb{P}\) es efectivo.                                        □

</p>
   </div>
<!-- l. 7602 --><p class='indent'>   Sin envargo nuestro modelo imperativo de funcion \(\Sigma \)-efectivamente computable
todavia podria no ser correcto ya que podria pasar que haya una funcion \(\Sigma \)-mixta que
sea computada por un procedimiento efectivo pero que no exista un programa de \(\mathcal{S}^{\Sigma }\)
que la compute. En otras palabras el modelo imperativo o Neumanniano
podria ser incompleto. Por supuesto este no es el caso y los desarrollos que
veremos mas adelante nos convenceran de que el paradigma imperativo es
completo.
</p><!-- l. 7614 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.3.4   </span> <a id='x1-1040003.3.4'></a>Macros</h5>
<!-- l. 7616 --><p class='noindent'>Supongamos que estamos escribiendo un programa \(\mathcal{P}\) de \(\mathcal{S}^{\Sigma }\) con el objeto de que realice
cierta tarea. Supongamos ademas que nos vendria muy bien para nuestros propositos
poder usar una instruccion \[ \mathrm{N}5\leftarrow \mathrm{N}16+\mathrm{N}3 \] la cual por supuesto al correr el programa, deberia
producir el efecto de dejar en la variable \(\mathrm{N}5\) la suma de los contenidos de las variables \(\mathrm{N}16\) y
\(\mathrm{N}3\), sin modificar el contenido de las variables distintas a \(\mathrm{N}5\). Lamentablemente no tenemos
en \(\mathcal{S}^{\Sigma }\) este tipo de instruccion pero podriamos reemplazarla por el siguiente
programa \[ \begin{array}{ll} &amp; \mathrm{N}1111\leftarrow \mathrm{N}16\\ &amp; \mathrm{N}2222\leftarrow \mathrm{N}3\\ &amp; \mathrm{N}5\leftarrow \mathrm{N}1111\\ \mathrm{L}1000 &amp; \mathrm{IF}\;\mathrm{N}2222\neq 0\;\mathrm{GOTO}\;\mathrm{L}2000\\ &amp; \mathrm{GOTO}\;\mathrm{L}3000\\ \mathrm{L}2000 &amp; \mathrm{N}2222\leftarrow \mathrm{N}2222\dot{-}1\\ &amp; \mathrm{N}5\leftarrow \mathrm{N}5+1\\ &amp; \mathrm{GOTO}\;\mathrm{L}1000\\ \mathrm{L}3000 &amp; \mathrm{SKIP} \end{array} \] donde las variables \(\mathrm{N}1111\), \(\mathrm{N}2222\) y los labels \(\mathrm{L}1000\), \(\mathrm{L}2000\), \(\mathrm{L}3000\) solo seran usados aqui,
es decir no apareceran en el resto de nuestro programa \(\mathcal{P}\). Notese que este
programa cuando es corrido termina dejando en la variable \(\mathrm{N}5\) la suma de
los contenidos de las variables \(\mathrm{N}16\) y \(\mathrm{N}3\) y modifica el contenido de las variables \(\mathrm{N}1111\)
y \(\mathrm{N}2222\), lo cual no traera problemas ya que \(\mathrm{N}1111\) y \(\mathrm{N}2222\) no se usan en el resto de \(\mathcal{P}\). La
variables \(\mathrm{N}1111\) y \(\mathrm{N}2222\) son auxiliares y se usan justamente para preservar el valor de las
variables \(\mathrm{N}16\) y \(\mathrm{N}3\) ya que ellas son variables protagonistas de nuestro programa \(\mathcal{P}\)
y en esta instancia no queremos alterar su contenido sino solo realizar la
asignacion \(\mathrm{N}5\leftarrow \mathrm{N}16+\mathrm{N}3\). Dejamos al lector explicar por que es necesario para que la
simulacion sea correcta que los labels \(\mathrm{L}1000\), \(\mathrm{L}2000\) y \(\mathrm{L}3000\) no sean usados en el resto de
\(\mathcal{P}\).
</p><!-- l. 7659 --><p class='indent'>   Es decir el programa anterior simula la instruccion \(\mathrm{N}5\leftarrow \mathrm{N}16+\mathrm{N}3\) que no podiamos
usar por no ser una instruccion de \(\mathcal{S}^{\Sigma }\), con un costo bastante bajo, es decir el
costo de convenir en no usar en el resto de \(\mathcal{P}\) las variables \(\mathrm{N}1111\) y \(\mathrm{N}2222\) ni los labels \(\mathrm{L}1000\), \(\mathrm{L}2000\) y
\(\mathrm{L}3000\).
</p><!-- l. 7665 --><p class='indent'>   Ahora supongamos que seguimos escribiendo el programa \(\mathcal{P}\) y nos hace falta
simular la instruccion \(\mathrm{N}20\leftarrow \mathrm{N}1+\mathrm{N}14\). Entonces es claro que podriamos modificar el programa que
simulaba \(\mathrm{N}5\leftarrow \mathrm{N}16+\mathrm{N}3\) haciendole reemplazos adecuados a sus variables y labels. Por ejemplo
podriamos escribir \[ \begin{array}{ll} &amp; \mathrm{N}9999\leftarrow \mathrm{N}1\\ &amp; \mathrm{N}8888\leftarrow \mathrm{N}14\\ &amp; \mathrm{N}20\leftarrow \mathrm{N}9999\\ \mathrm{L}1001 &amp; \mathrm{IF}\;\mathrm{N}8888\neq 0\;\mathrm{GOTO}\;\mathrm{L}2002\\ &amp; \mathrm{GOTO}\;\mathrm{L}3003\\ \mathrm{L}2002 &amp; \mathrm{N}8888\leftarrow \mathrm{N}8888\dot{-}1\\ &amp; \mathrm{N}20\leftarrow \mathrm{N}20+1\\ &amp; \mathrm{GOTO}\;\mathrm{L}1001\\ \mathrm{L}3003 &amp; \mathrm{SKIP} \end{array} \] donde \(\mathrm{N}9999\), \(\mathrm{N}8888\), \(\mathrm{L}1001\), \(\mathrm{L}2002\) y \(\mathrm{L}3003\) solo seran usados aqui, es decir no apareceran en el
resto de nuestro programa \(\mathcal{P}\).
</p><!-- l. 7687 --><p class='indent'>   Consideremos el siguiente ”molde” que llamaremos \(M\) \[ \begin{array}{ll} &amp; \mathrm{V}4\leftarrow \mathrm{V}2\\ &amp; \mathrm{V}5\leftarrow \mathrm{V}3\\ &amp; \mathrm{V}1\leftarrow \mathrm{V}4\\ \mathrm{A}1 &amp; \mathrm{IF}\;\mathrm{V}5\neq 0\;\mathrm{GOTO}\;\mathrm{A}2\\ &amp; \mathrm{GOTO}\;\mathrm{A}3\\ \mathrm{A}2 &amp; \mathrm{V}5\leftarrow \mathrm{V}5\dot{-}1\\ &amp; \mathrm{V}1\leftarrow \mathrm{V}1+1\\ &amp; \mathrm{GOTO}\;\mathrm{A}1\\ \mathrm{A}3 &amp; \mathrm{SKIP} \end{array} \] Como puede notarse, cuando
reemplazamos en \(M\)
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-104001x3.3.4'>cada ocurrencia de \(\mathrm{V}1\) por \(\mathrm{N}5\)

     </li>
     <li class='enumerate' id='x1-104002x3.3.4'>cada ocurrencia de \(\mathrm{V}2\) por \(\mathrm{N}16\)
     </li>
     <li class='enumerate' id='x1-104003x3.3.4'>cada ocurrencia de \(\mathrm{V}3\) por \(\mathrm{N}3\)
     </li>
     <li class='enumerate' id='x1-104004x3.3.4'>cada ocurrencia de \(\mathrm{V}4\) por \(\mathrm{N}1111\)
     </li>
     <li class='enumerate' id='x1-104005x3.3.4'>cada ocurrencia de \(\mathrm{V}5\) por \(\mathrm{N}2222\)
     </li>
     <li class='enumerate' id='x1-104006x3.3.4'>cada ocurrencia de \(\mathrm{A}1\) por \(\mathrm{L}1000\)
     </li>
     <li class='enumerate' id='x1-104007x3.3.4'>cada ocurrencia de \(\mathrm{A}2\) por \(\mathrm{L}2000\)
     </li>
     <li class='enumerate' id='x1-104008x3.3.4'>cada ocurrencia de \(\mathrm{A}3\) por \(\mathrm{L}3000\)</li></ol>
<!-- l. 7712 --><p class='noindent'>obtenemos el programa que simulaba la instruccion \(\mathrm{N}5\leftarrow \mathrm{N}16+\mathrm{N}3\) dentro de \(\mathcal{P}\). Similarmente, cuando
reemplazamos en \(M\)
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-104009x3.3.4'>cada ocurrencia de \(\mathrm{V}1\) por \(\mathrm{N}20\)
     </li>
     <li class='enumerate' id='x1-104010x3.3.4'>cada ocurrencia de \(\mathrm{V}2\) por \(\mathrm{N}1\)
     </li>
     <li class='enumerate' id='x1-104011x3.3.4'>cada ocurrencia de \(\mathrm{V}3\) por \(\mathrm{N}14\)
     </li>
     <li class='enumerate' id='x1-104012x3.3.4'>cada ocurrencia de \(\mathrm{V}4\) por \(\mathrm{N}9999\)
     </li>
     <li class='enumerate' id='x1-104013x3.3.4'>cada ocurrencia de \(\mathrm{V}5\) por \(\mathrm{N}8888\)
     </li>
     <li class='enumerate' id='x1-104014x3.3.4'>cada ocurrencia de \(\mathrm{A}1\) por \(\mathrm{L}1001\)
     </li>
     <li class='enumerate' id='x1-104015x3.3.4'>cada ocurrencia de \(\mathrm{A}2\) por \(\mathrm{L}2002\)
     </li>
     <li class='enumerate' id='x1-104016x3.3.4'>cada ocurrencia de \(\mathrm{A}3\) por \(\mathrm{L}3003\)</li></ol>
<!-- l. 7724 --><p class='noindent'>obtenemos el programa que simulaba la instruccion \(\mathrm{N}20\leftarrow \mathrm{N}1+\mathrm{N}14\) dentro de \(\mathcal{P}\). La practicidad de tener
el molde \(M\) cae de maduro. Ahora en caso de necesitar una instruccion del tipo \(\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{n}+\mathrm{N}\bar{m}\) solo
tenemos que reemplazar en \(M\)

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-104017x3.3.4'>cada ocurrencia de \(\mathrm{V}1\) por \(\mathrm{N}\bar{k}\)
     </li>
     <li class='enumerate' id='x1-104018x3.3.4'>cada ocurrencia de \(\mathrm{V}2\) por \(\mathrm{N}\bar{n}\)
     </li>
     <li class='enumerate' id='x1-104019x3.3.4'>cada ocurrencia de \(\mathrm{V}3\) por \(\mathrm{N}\bar{m}\)</li></ol>
<!-- l. 7733 --><p class='noindent'>y reemplazar la variable auxiliar de \(M\) y los labels auxiliares de \(M\) por una variable concreta
y tres labels concretos que no se usen en el programa que estamos realizando. El
programa asi obtenido simulara a la instruccion \(\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{n}+\mathrm{N}\bar{m}\).
</p><!-- l. 7738 --><p class='indent'>   En la gerga computacional el molde \(M\) suele llamarse <span class='cmti-10'>macro </span>y los programas
obtenidos luego de realizar los reemplazos son llamados <span class='cmti-10'>expansiones de</span> \(M\). Notese que \(Ti(M)=\mathrm{PALABRA}\)
ya que, como en el caso de los programas, podemos pensar que escribimos a \(M\) linea
por linea para facilitar su manejo pero que en realidad es una sola palabra, a saber: \[ \mathrm{V}1\mathrm{\leftarrow }\text{V}2\mathrm{V}4\mathrm{\leftarrow }\text{V}3\mathrm{A}1\mathrm{IFV}4\mathrm{\neq }0\mathrm{GOTOA}2\mathrm{GOTOA}3\mathrm{A}2\mathrm{V}4\mathrm{\leftarrow }\text{V}4\mathrm{\dot{-}}1\mathrm{V}1\mathrm{\leftarrow }\text{V}1\mathrm{+}1\mathrm{GOTOA}1\mathrm{A}3\mathrm{SKIP} \]
Es decir, como objeto matematico, \(M\) es una palabra. A las palabras de la forma \(\mathrm{V}\bar{n}\), con \(n\in \mathbf{N}\),
las llamaremos <span class='cmti-10'>variables numericas de macro</span>. A las palabras de la forma \(\mathrm{W}\bar{n}\), con \(n\in \mathbf{N}\), las
llamaremos <span class='cmti-10'>variables alfabeticas de macro </span>y a las palabras de la forma \(\mathrm{A}\bar{n}\),
con \(n\in \mathbf{N}\), las llamaremos <span class='cmti-10'>labels de macro</span>. Nuestro macro \(M\) no tiene variables
alfabeticas de macro pero otros macros por supuesto pueden tener este tipo de
variables.
</p><!-- l. 7756 --><p class='indent'>   Las variables \(\mathrm{V}1\), \(\mathrm{V}2\) y \(\mathrm{V}3\) son llamadas <span class='cmti-10'>variables oficiales </span>de \(M\) y \(\mathrm{V}4\) y \(\mathrm{V}5\) son llamadas <span class='cmti-10'>variables
</span><span class='cmti-10'>auxiliares </span>de \(M\). Tambien \(\mathrm{A}1\), \(\mathrm{A}2\) y \(\mathrm{A}3\) son llamados <span class='cmti-10'>labels auxiliares </span>de \(M\) ya que son usados solo
para su funcionamiento interno y no tienen vinculacion con los labels del programa
en el cual se realizara la expansion de \(M\).
</p><!-- l. 7764 --><p class='indent'>   En el siguiente ejemplo veremos un macro que tiene un label que no es auxiliar
sino oficial. Sea \(\Sigma =\{@,!\}\). Supongamos que estamos escribiendo un programa \(\mathcal{P}^{\prime }\) y nos hace falta
simular instrucciones de la forma \[ \mathrm{IF}\;\left \vert \mathrm{P}\bar{n}\right \vert \leq \mathrm{N}\bar{m}\ \mathrm{GOTO}\;\mathrm{L}\bar{k} \] (por supuesto estas instrucciones no pertenecen al
lenguaje \(\mathcal{S}^{\Sigma }\) pero deberia quedar claro como funcionan). Entonces podemos tomar el
macro \(M^{\prime }\): \[ \begin{array}{ll} &amp; \mathrm{W}2\leftarrow \mathrm{W}1\\ &amp; \mathrm{V}2\leftarrow \mathrm{V}1\\ \mathrm{A}4 &amp; \mathrm{IF}\;\mathrm{W}2\;\mathrm{BEGINS}\;@\;\mathrm{GOTO}\;\mathrm{A}2\\ &amp; \mathrm{IF}\;\mathrm{W}2\;\mathrm{BEGINS}\;!\;\mathrm{GOTO}\;\mathrm{A}2\\ &amp; \mathrm{GOTO}\;\mathrm{A}1\\ \mathrm{A}2 &amp; \mathrm{IF}\;\mathrm{V}2\neq 0\;\mathrm{GOTO}\;\mathrm{A}3\\ &amp; \mathrm{GOTO}\;\mathrm{A}5\\ \mathrm{A}3 &amp; \mathrm{W}2\leftarrow ^{\curvearrowright }\mathrm{W}2\\ &amp; \mathrm{V}2\leftarrow \mathrm{V}2\dot{-}1\\ &amp; \mathrm{GOTO}\;\mathrm{A}4\\ \mathrm{A}5 &amp; \mathrm{SKIP} \end{array} \] el cual tiene
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-104020x3.3.4'>variables oficiales \(\mathrm{W}1\) y \(\mathrm{V}1\) (correspondientes a \(\mathrm{P}\bar{n}\) y \(\mathrm{N}\bar{m}\))
     </li>
     <li class='enumerate' id='x1-104021x3.3.4'>variable auxiliares \(\mathrm{W}2\) y \(\mathrm{V}2\)
     </li>
     <li class='enumerate' id='x1-104022x3.3.4'>labels auxiliares \(\mathrm{A}2\), \(\mathrm{A}3\), \(\mathrm{A}4\) y \(\mathrm{A}5\)
     </li>
     <li class='enumerate' id='x1-104023x3.3.4'>un label oficial \(\mathrm{A}1\) (correspondiente a \(\mathrm{L}\bar{k}\))</li></ol>
<!-- l. 7798 --><p class='noindent'>Una descripcion intuitiva del macro \(M^{\prime }\) seria \[ \mathrm{IF}\;\left \vert \mathrm{W}1\right \vert \leq \mathrm{V}1\ \mathrm{GOTO}\;\mathrm{A}1 \] Notese que en las primeras dos lineas el
macro \(M^{\prime }\) guarda los valores de las variables oficiales \(\mathrm{W}1\) y \(\mathrm{V}1\) en las variables auxiliares \(\mathrm{W}2\) y \(\mathrm{V}2\), y
sigue trabajando con las auxiliares. Esto es para preservar el valor de las
variables oficiales. Dado que \(\Sigma =\{@,!\}\), las dos siguientes lineas sirven para decidir si el
contenido de \(\mathrm{W}2\) es \(\varepsilon \) o no. Dejamos al lector entender el resto del funcionamiento de
\(M^{\prime }\).

</p><!-- l. 7810 --><p class='indent'>   Para dar un ejemplo de como usariamos a \(M^{\prime }\), supongamos que para seguir
escribiendo nuestro programa \(\mathcal{P}^{\prime }\) nos hace falta simular la instruccion \[ \mathrm{IF}\;\left \vert \mathrm{P}5\right \vert \leq \mathrm{N}14\ \mathrm{GOTO}\;\mathrm{L}1 \] y supongamos
que las variables \(\mathrm{P}1000\) y \(\mathrm{N}1000\) y los labels \(\mathrm{L}6666\), \(\mathrm{L}7777\), \(\mathrm{L}8888\) y \(\mathrm{L}9999\) no se usaron hasta el momento en \(\mathcal{P}^{\prime }\). Entonces
podemos reemplazar en \(M^{\prime }\)
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-104024x3.3.4'>cada ocurrencia de \(\mathrm{W}1\) por \(\mathrm{P}5\)
     </li>
     <li class='enumerate' id='x1-104025x3.3.4'>cada ocurrencia de \(\mathrm{V}1\) por \(\mathrm{N}14\)
     </li>
     <li class='enumerate' id='x1-104026x3.3.4'>cada ocurrencia de \(\mathrm{W}2\) por \(\mathrm{P}1000\)
     </li>
     <li class='enumerate' id='x1-104027x3.3.4'>cada ocurrencia de \(\mathrm{V}2\) por \(\mathrm{N}1000\)
     </li>
     <li class='enumerate' id='x1-104028x3.3.4'>cada ocurrencia de \(\mathrm{A}1\) por \(\mathrm{L}1\)
     </li>
     <li class='enumerate' id='x1-104029x3.3.4'>cada ocurrencia de \(\mathrm{A}2\) por \(\mathrm{L}6666\)
     </li>
     <li class='enumerate' id='x1-104030x3.3.4'>cada ocurrencia de \(\mathrm{A}3\) por \(\mathrm{L}7777\)
     </li>
     <li class='enumerate' id='x1-104031x3.3.4'>cada ocurrencia de \(\mathrm{A}4\) por \(\mathrm{L}8888\)
     </li>
     <li class='enumerate' id='x1-104032x3.3.4'>cada ocurrencia de \(\mathrm{A}5\) por \(\mathrm{L}9999\)</li></ol>
<!-- l. 7831 --><p class='noindent'>y la expansion de \(M^{\prime }\) asi obtenida simulara la instruccion \(\mathrm{IF}\;\left \vert \mathrm{P}5\right \vert \leq \mathrm{N}14\ \mathrm{GOTO}\;\mathrm{L}1\). Cabe destacar que para
asegurarnos que la simulacion funcione, tambien deberemos no usar en el resto de \(\mathcal{P}^{\prime }\) las
variables \(\mathrm{P}1000\) y \(\mathrm{N}1000\) y los labels \(\mathrm{L}6666\), \(\mathrm{L}7777\), \(\mathrm{L}8888\) y \(\mathrm{L}9999\).
</p><!-- l. 7838 --><p class='indent'>   Es decir \(M^{\prime }\) funciona como un molde con el cual haciendo reemplazos adecuados
podemos simular cualquier instruccion del tipo \(\mathrm{IF}\;\left \vert \mathrm{P}\bar{n}\right \vert \leq \mathrm{N}\bar{m}\ \mathrm{GOTO}\;\mathrm{L}\bar{k}\), con \(n,m,k\in \mathbf{N}\).
</p><!-- l. 7843 --><p class='indent'>   Deberia quedar claro el caracter oficial del label \(\mathrm{A}1\) en \(M^{\prime }\) ya que el label por el que se
lo reemplaza para hacer la expansion es uno de los labels protagonistas del programa
que se esta escribiendo.
</p><!-- l. 7848 --><p class='indent'>   Cabe destacar que las expansiones de \(M^{\prime }\) no son programas ya que si bien son
concatenaciones de instrucciones, no cumplen la ley de los GOTO (llamada (G) en la
definicion de programa) respecto del label que reemplazo a \(\mathrm{A}1\).
</p><!-- l. 7855 --><p class='indent'>   <span class='cmbx-10'>Nota: </span>Siempre supondremos que la primera instruccion de los macros no es
labelada. Esto es porque muchas veces cuando expandamos un macro nos interesara
labelar la primera instruccion de dicha expansion. Por supuesto, esto es facil de
conseguir ya que si \(M\) es un macro, entonces \(\mathrm{SKIP}M\) es tambien un macro que posee las
mismas propiedades.
</p><!-- l. 7864 --><p class='indent'>   Como hemos visto recien hay dos tipos de macros:

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-104033x3.3.4'>los de asignacion que cuando son expandidos nos dan un programa que
     simula la asignacion a una variable dada del resultado de aplicar una
     funcion a los contenidos de ciertas otras variables; y
     </li>
     <li class='enumerate' id='x1-104034x3.3.4'>los de tipo IF que cuando son expandidos nos dan un programa salvo
     por la ley (G), el cual direcciona al label que fue a reemplazar a \(\mathrm{A}1\) cuando
     se cumple cierta propiedad (predicado) relativa a los contenidos de las
     variables que fueron a reemplazar a las variables oficiales.</li></ol>
<!-- l. 7878 --><p class='noindent'><span class='paragraphHead'><a id='x1-1050003.3.4'></a><span class='cmbx-10'>Ejemplo concreto de uso de macros</span></span>
   Ya vimos recien que la palabra \[ \begin{array}{ll} &amp; \mathrm{V}4\leftarrow \mathrm{V}2\\ &amp; \mathrm{V}5\leftarrow \mathrm{V}3\\ &amp; \mathrm{V}1\leftarrow \mathrm{V}4\\ \mathrm{A}1 &amp; \mathrm{IF}\;\mathrm{V}5\neq 0\;\mathrm{GOTO}\;\mathrm{A}2\\ &amp; \mathrm{GOTO}\;\mathrm{A}3\\ \mathrm{A}2 &amp; \mathrm{V}5\leftarrow \mathrm{V}5\dot{-}1\\ &amp; \mathrm{V}1\leftarrow \mathrm{V}1+1\\ &amp; \mathrm{GOTO}\;\mathrm{A}1\\ \mathrm{A}3 &amp; \mathrm{SKIP} \end{array} \] es un macro que sirve para simular instrucciones
de la forma \(\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{n}+\mathrm{N}\bar{m}\). Notemos que este macro es de asignacion ya que cuando es expandido
nos da un programa que simula la asignacion a una variable dada del resultado de
aplicar una funcion a los contenidos de ciertas otras variables. En este caso la funcion
es \(SUMA=\lambda xy[x+y]\) por lo cual usaremos \(\left [\mathrm{V}3\leftarrow SUMA(\mathrm{V}1,\mathrm{V}2)\right ]\) para denotar a dicho macro. Usaremos este macro para dar
un programa \(\mathcal{P}\) que compute a la funcion \(\lambda xy[x.y]\). Notese que podemos tomar \(\mathcal{P}\) igual al
siguiente programa
</p><!-- l. 7913 --><p class='indent'>   \[ \begin{array}{ll} \mathrm{L}1 &amp; \mathrm{IF}\;\mathrm{N}2\neq 0\;\mathrm{GOTO}\;\mathrm{L}2\\ &amp; \mathrm{GOTO}\;\mathrm{L}3\\ \mathrm{L}2 &amp; \left [\mathrm{N}3\leftarrow SUMA(\mathrm{N}3,\mathrm{N}1)\right ]\\ &amp; \mathrm{N}2\leftarrow \mathrm{N}2\dot{-}1\\ &amp; \mathrm{GOTO}\;\mathrm{L}1\\ \mathrm{L}3 &amp; \mathrm{N}1\leftarrow \mathrm{N}3 \end{array} \] donde \(\left [\mathrm{N}3\leftarrow SUMA(\mathrm{N}3,\mathrm{N}1)\right ]\) es una expansion del macro \(\left [\mathrm{V}3\leftarrow SUMA(\mathrm{V}1,\mathrm{V}2)\right ]\) hecha haciendo el reemplazo de las variables
oficiales \(\mathrm{V}3,\mathrm{V}1\) y \(\mathrm{V}2\) por \(\mathrm{N}3,\mathrm{N}3\) y \(\mathrm{N}1\), respectivamente, y haciendo reemplazos adecuados de sus
variables y labels auxiliares. Hay muchas formas de hacer los reemplazos de variables
y labels auxiliares pero en general no lo especificaremos explicitamente cuando
expandamos un macro ya que es facil imaginar como hacerlo dependiendo del
programa que estemos realizando. Por ejemplo en el caso de \(\mathcal{P}\) podriamos hacer los
siguientes reemplazos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-105001x3.3.4'>cada ocurrencia de \(\mathrm{V}4\) por \(\mathrm{N}1111\)
     </li>
     <li class='enumerate' id='x1-105002x3.3.4'>cada ocurrencia de \(\mathrm{V}5\) por \(\mathrm{N}2222\)
     </li>
     <li class='enumerate' id='x1-105003x3.3.4'>cada ocurrencia de \(\mathrm{A}1\) por \(\mathrm{L}1000\)
     </li>
     <li class='enumerate' id='x1-105004x3.3.4'>cada ocurrencia de \(\mathrm{A}2\) por \(\mathrm{L}2000\)
     </li>
     <li class='enumerate' id='x1-105005x3.3.4'>cada ocurrencia de \(\mathrm{A}3\) por \(\mathrm{L}3000\)</li></ol>
<!-- l. 7932 --><p class='noindent'>y claramente esto no afectara la ”logica” o ”idea” de nuestro programa \(\mathcal{P}\). De esta forma
la expansion \(\left [\mathrm{N}3\leftarrow SUMA(\mathrm{N}3,\mathrm{N}1)\right ]\) es el siguiente programa: \[ \begin{array}{ll} &amp; \mathrm{N}1111\leftarrow \mathrm{N}1\\ &amp; \mathrm{N}2222\leftarrow \mathrm{N}3\\ &amp; \mathrm{N}3\leftarrow \mathrm{N}1111\\ \mathrm{L}1000 &amp; \mathrm{IF}\;\mathrm{N}2222\neq 0\;\mathrm{GOTO}\;\mathrm{L}2000\\ &amp; \mathrm{GOTO}\;\mathrm{L}3000\\ \mathrm{L}2000 &amp; \mathrm{N}2222\leftarrow \mathrm{N}2222\dot{-}1\\ &amp; \mathrm{N}3\leftarrow \mathrm{N}3+1\\ &amp; \mathrm{GOTO}\;\mathrm{L}1000\\ \mathrm{L}3000 &amp; \mathrm{SKIP} \end{array} \] el cual por supuesto esta escrito con espacios
y en forma vertical pero es una mera palabra. Tenemos entonces que \(\mathcal{P}\) es el
programa:

</p><!-- l. 7969 --><p class='indent'>   \[ \begin{array}{ll} \mathrm{L}1 &amp; \mathrm{IF}\;\mathrm{N}2\neq 0\;\mathrm{GOTO}\;\mathrm{L}2\\ &amp; \mathrm{GOTO}\;\mathrm{L}3\\ \mathrm{L}2 &amp; \mathrm{N}1111\leftarrow \mathrm{N}1\\ &amp; \mathrm{N}2222\leftarrow \mathrm{N}3\\ &amp; \mathrm{N}3\leftarrow \mathrm{N}1111\\ \mathrm{L}1000 &amp; \mathrm{IF}\;\mathrm{N}2222\neq 0\;\mathrm{GOTO}\;\mathrm{L}2000\\ &amp; \mathrm{GOTO}\;\mathrm{L}3000\\ \mathrm{L}2000 &amp; \mathrm{N}2222\leftarrow \mathrm{N}2222\dot{-}1\\ &amp; \mathrm{N}3\leftarrow \mathrm{N}3+1\\ &amp; \mathrm{GOTO}\;\mathrm{L}1000\\ \mathrm{L}3000 &amp; \mathrm{SKIP}\\ &amp; \mathrm{N}2\leftarrow \mathrm{N}2\dot{-}1\\ &amp; \mathrm{GOTO}\;\mathrm{L}1\\ \mathrm{L}3 &amp; \mathrm{N}1\leftarrow \mathrm{N}3 \end{array} \] el cual por supuesto esta escrito con espacios y en forma vertical pero es una
mera palabra.
</p>
<!-- l. 7976 --><p class='noindent'><span class='paragraphHead'><a id='x1-1060003.3.4'></a><span class='cmbx-10'>Macros asociados a funciones</span> \(\Sigma \)<span class='cmbx-10'>-computables</span></span>
   Dada una funcion \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \), usaremos \[ \left [\mathrm{V}\overline{n+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right ] \] para denotar un macro \(M\) el cual cumpla las
siguientes propiedades. Cabe destacar que no siempre existira dicho macro, es decir
solo para ciertas funciones \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) habra un tal macro.
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-106001x3.3.4'>Las variables oficiales de \(M\) son \(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{V}\overline{n+1},\mathrm{W}1,...,\mathrm{W}\bar{m}\)
     </li>
     <li class='enumerate' id='x1-106002x3.3.4'>\(M\) no tiene labels oficiales
     </li>
     <li class='enumerate' id='x1-106003x3.3.4'>Si reemplazamos:
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-106005x1'>las variables oficiales de \(M\) (i.e. \(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{V}\overline{n+1},\mathrm{W}1,...,\mathrm{W}\bar{m}\)) por variables concretas \[ \mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{N}\overline{k_{n+1}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}} \] (elejidas
         libremente, es decir los numeros \(k_{1},...,k_{n+1},j_{1},...,j_{m}\) son cualesquiera)
         </li>
         <li class='enumerate' id='x1-106007x2'>las variables auxiliares de \(M\) por variables concretas (distintas de a dos)
         y NO pertenecientes a la lista \(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{N}\overline{k_{n+1}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}\)
         </li>
         <li class='enumerate' id='x1-106009x3'>los labels auxiliares de \(M\) por labels concretos (distintos de a dos)</li></ol>
     <!-- l. 8004 --><p class='noindent'>Entonces la palabra asi obtenida es un programa de \(\mathcal{S}^{\Sigma }\) que denotaremos con \[ \left [\mathrm{N}\overline{k_{n+1}}\leftarrow f(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\right ] \] el
     cual debe tener la siguiente propiedad:
         </p><ol class='enumerate2'>
         <li class='enumerate' id='x1-106010x3.3.4'>Si hacemos correr \(\left [\mathrm{N}\overline{k_{n+1}}\leftarrow f(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\right ]\) partiendo de un estado \(e\) que le asigne a las variables \(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}\)
         valores \(x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\), entonces independientemente de los valores que les asigne \(e\) al
         resto de las variables (incluidas las que fueron a reemplazar a las variables
         auxiliares de \(M\)) se dara que
             <ol class='enumerate3'>
             <li class='enumerate' id='x1-106012x1'>si \((x_{1},...,x_{n},\alpha _{1},...,\alpha _{m})\notin D_{f}\), entonces \(\left [\mathrm{N}\overline{k_{n+1}}\leftarrow f(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\right ]\) no se detiene
             </li>
             <li class='enumerate' id='x1-106014x2'>si \((x_{1},...,x_{n},\alpha _{1},...,\alpha _{m})\in D_{f}\), entonces \(\left [\mathrm{N}\overline{k_{n+1}}\leftarrow f(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\right ]\) se detiene (i.e. intenta realizar la siguiente a su ultima
             instrucion) y llega a un estado \(e^{\prime }\) el cual cumple:
                <ol class='enumerate4'>
                <li class='enumerate' id='x1-106016x1'>\(e^{\prime }\) le asigna a \(\mathrm{N}\overline{k_{n+1}}\) el valor \(f(x_{1},...,x_{n},\alpha _{1},...,\alpha _{m})\)

                </li>
                <li class='enumerate' id='x1-106018x2'>\(e^{\prime }\) solo puede diferir de \(e\) en los valores que le asigna a \(\mathrm{N}\overline{k_{n+1}}\) o a las
                variables que fueron a reemplazar a las variables auxiliares
                de \(M\). Al resto de las variables, incluidas \(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}\) no las modifica (salvo
                en el caso de que alguna \(\mathrm{N}\overline{k_{i}}\) sea la variable \(\mathrm{N}\overline{k_{n+1}}\), situacion en la cual
                el valor final de la variable \(\mathrm{N}\overline{k_{i}}\) sera \(f(x_{1},...,x_{n},\alpha _{1},...,\alpha _{m})\))</li></ol>
             </li></ol>
         </li></ol>
     </li></ol>
<!-- l. 8039 --><p class='noindent'>El programa \(\left [\mathrm{N}\overline{k_{n+1}}\leftarrow f(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\right ]\) es comunmente llamado la expansion del macro \(\left [\mathrm{V}\overline{n+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right ]\) con respecto a la eleccion
de variables y labels realizada.
</p><!-- l. 8045 --><p class='indent'>   Tambien, dada una funcion \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \Sigma ^{\ast }\), con \[ \left [\mathrm{W}\overline{m+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right ] \] denotaremos un macro el cual cumpla
condiciones analogas a las descriptas recien. Dejamos al lector escribirlas en detalle
para este caso.
</p>
   <div class='newtheorem'>
<!-- l. 8052 --><p class='noindent'><span class='head'>
<a id='x1-106019r87'></a>
<span class='cmbx-10'>Proposition 87.</span>  </span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-106020x87'><span class='cmti-10'>Sea</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>una funcion</span> \(\Sigma \)<span class='cmti-10'>-computable. Entonces en</span> \(\mathcal{S}^{\Sigma }\) <span class='cmti-10'>hay un macro </span>\[ \left [\mathrm{V}\overline{n+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right ] \]
     </li>
     <li class='enumerate' id='x1-106021x87'><span class='cmti-10'>Sea</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \Sigma ^{\ast }\) <span class='cmti-10'>una funcion</span> \(\Sigma \)<span class='cmti-10'>-computable. Entonces en</span> \(\mathcal{S}^{\Sigma }\) <span class='cmti-10'>hay un macro </span>\[ \left [\mathrm{W}\overline{m+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right ] \]</li></ol>
   </div>
<!-- l. 8070 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 8071 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Probaremos (b) La prueba de (a) es similar. Sea \(\mathcal{P}\) un programa que compute a
\(f\). Tomemos un \(k\) tal que \(k\geq n,m\) y tal que todas las variables y labels de \(\mathcal{P}\) estan en el conjunto \[ \{\mathrm{N}1,...,\mathrm{N}\bar{k},\mathrm{P}1,...,\mathrm{P}\bar{k},\mathrm{L}1,...,\mathrm{L}\bar{k}\}\text{.} \]
Sea \(\mathcal{P}^{\prime }\) la palabra que resulta de reemplazar en \(\mathcal{P}\):
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-106022x3.3.4'>la variable \(\mathrm{N}\overline{j}\) por \(\mathrm{V}\overline{n+j}\), para cada \(j=1,...,k\)
     </li>
     <li class='enumerate' id='x1-106023x3.3.4'>la variable \(\mathrm{P}\overline{j}\) por \(\mathrm{W}\overline{m+j}\), para cada \(j=1,...,k\)

     </li>
     <li class='enumerate' id='x1-106024x3.3.4'>el label \(\mathrm{L}\overline{j}\) por \(\mathrm{A}\overline{j}\), para cada \(j=1,...,k\)</li></ol>
<!-- l. 8088 --><p class='noindent'>Notese que \[ \begin{array}{l} \mathrm{V}\overline{n+1}\leftarrow \mathrm{V}1\\ \ \ \ \ \ \ \ \ \ \vdots \\ \mathrm{V}\overline{n+n}\leftarrow \mathrm{V}\overline{n}\\ \mathrm{V}\overline{n+n+1}\leftarrow 0\\ \ \ \ \ \ \ \ \ \ \vdots \\ \mathrm{V}\overline{n+k}\leftarrow 0\\ \mathrm{W}\overline{m+1}\leftarrow \mathrm{W}1\\ \ \ \ \ \ \ \ \ \ \vdots \\ \mathrm{W}\overline{m+m}\leftarrow \mathrm{W}\overline{m}\\ \mathrm{W}\overline{m+m+1}\leftarrow \varepsilon \\ \ \ \ \ \ \ \ \ \ \vdots \\ \mathrm{W}\overline{m+k}\leftarrow \varepsilon \\ \mathcal{P}^{\prime } \end{array} \] es el macro buscado, el cual tendra sus variables auxiliares y labels en la
lista \[ \mathrm{V}\overline{n+1},...,\mathrm{V}\overline{n+k},\mathrm{W}\overline{m+2},...,\mathrm{W}\overline{m+k},\mathrm{A}1,...,\mathrm{A}\overline{k}. \]                                                                                               □
</p>
   </div>
<!-- l. 8114 --><p class='indent'>   Dejamos al lector probar la resiproca de la proposicion anterior, es decir que si \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) es
tal que en \(\mathcal{S}^{\Sigma }\) hay un macro \[ \left [\mathrm{V}\overline{n+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right ] \] entonces \(f\) es \(\Sigma \)-computable
</p>
<!-- l. 8125 --><p class='noindent'><span class='paragraphHead'><a id='x1-1070003.3.4'></a><span class='cmbx-10'>Macros asociados a predicados</span> \(\Sigma \)<span class='cmbx-10'>-computables</span></span>
   Dado un predicado \(P:D_{P}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \), usaremos \[ \left [\mathrm{IF}\;P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] para denotar un macro \(M\) el cual cumpla las
siguientes propiedades. Cabe destacar que no siempre existira dicho macro, es decir
solo para ciertos predicados \(P:D_{P}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) habra un tal macro.
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-107001x3.3.4'>Las variables oficiales de \(M\) son \(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m}\)
     </li>
     <li class='enumerate' id='x1-107002x3.3.4'>\(\mathrm{A}1\) es el unico label oficial de \(M\)
     </li>
     <li class='enumerate' id='x1-107003x3.3.4'>Si reemplazamos:
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-107005x1'>las variables oficiales de \(M\) (i.e. \(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m}\)) por variables concretas \[ \mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}} \] (elejidas
         libremente, es decir los numeros \(k_{1},...,k_{n},j_{1},...,j_{m}\) son cualesquiera)
         </li>
         <li class='enumerate' id='x1-107007x2'>el label oficial \(\mathrm{A}1\) por el label concreto \(\mathrm{L}\bar{k}\) (elejido libremente, es decir \(k\) es
         cualquier elemento de \(\mathbf{N}\))
         </li>
         <li class='enumerate' id='x1-107009x3'>las variables auxiliares de \(M\) por variables concretas (distintas de a dos)
         y NO pertenecientes a la lista \(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}\)
         </li>
         <li class='enumerate' id='x1-107011x4'>los labels auxiliares de \(M\) por labels concretos (distintos de a dos) y
         ninguno igual a \(\mathrm{L}\bar{k}\)</li></ol>
     <!-- l. 8155 --><p class='noindent'>Entonces la palabra asi obtenida es un programa de \(\mathcal{S}^{\Sigma }\) (salvo por la ley de los
     GOTO respecto de \(\mathrm{L}\bar{k}\)) que denotaremos con \[ \left [\mathrm{IF\ }P(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\ \mathrm{GOTO\ L}\bar{k}\right ] \] el cual debe tener la siguiente
     propiedad:

         </p><ol class='enumerate2'>
         <li class='enumerate' id='x1-107012x3.3.4'>Si hacemos correr \(\left [\mathrm{IF\ }P(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\ \mathrm{GOTO\ L}\bar{k}\right ]\) partiendo de un estado \(e\) que le asigne a las variables \(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}\)
         valores \(x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\), entonces independientemente de los valores que les asigne \(e\) al
         resto de las variables (incluidas las que fueron a reemplazar a las variables
         auxiliares de \(M\)) se dara que
             <ol class='enumerate3'>
             <li class='enumerate' id='x1-107014x1'>si \((x_{1},...,x_{n},\alpha _{1},...,\alpha _{m})\notin D_{P}\), entonces \(\left [\mathrm{IF\ }P(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\ \mathrm{GOTO\ L}\bar{k}\right ]\) no se detiene
             </li>
             <li class='enumerate' id='x1-107016x2'>si \((x_{1},...,x_{n},\alpha _{1},...,\alpha _{m})\in D_{P}\) y \(P(x_{1},...,x_{n},\alpha _{1},...,\alpha _{m})=1\), entonces luego de una cantidad finita de pasos, \(\left [\mathrm{IF\ }P(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\ \mathrm{GOTO\ L}\bar{k}\right ]\) direcciona
             al label \(\mathrm{L}\bar{k}\) quedando en un estado \(e^{\prime }\) el cual solo puede diferir de \(e\) en
             los valores que le asigna a las variables que fueron a reemplazar
             a las variables auxiliares de \(M\). Al resto de las variables, incluidas
             \(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}\) no las modifica
             </li>
             <li class='enumerate' id='x1-107018x3'>si  \((x_{1},...,x_{n},\alpha _{1},...,\alpha _{m})\in D_{P}\)  y  \(P(x_{1},...,x_{n},\alpha _{1},...,\alpha _{m})=0\),  entonces  luego  de  una  cantidad  finita  de  pasos,  \(\left [\mathrm{IF\ }P(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\ \mathrm{GOTO\ L}\bar{k}\right ]\)  se
             detiene (i.e. intenta realizar la siguiente a su ultima instruccion)
             quedando en un estado \(e^{\prime }\) el cual solo puede diferir de \(e\) en los
             valores que le asigna a las variables que fueron a reemplazar a
             las variables auxiliares de \(M\). Al resto de las variables, incluidas \(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}\)
             no las modifica</li></ol>
         </li></ol>
     </li></ol>
<!-- l. 8191 --><p class='noindent'>La palabra \(\left [\mathrm{IF\ }P(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\ \mathrm{GOTO\ L}\bar{k}\right ]\) es llamada la expansion del macro con respecto a la eleccion de variables y
labels realizada
</p>
   <div class='newtheorem'>
<!-- l. 8197 --><p class='noindent'><span class='head'>
<a id='x1-107019r88'></a>
<span class='cmbx-10'>Proposition 88.</span>  </span><span class='cmti-10'>Sea</span> \(P:D_{P}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>un predicado</span> \(\Sigma \)<span class='cmti-10'>-computable. Entonces en</span> \(\mathcal{S}^{\Sigma }\) <span class='cmti-10'>hay un macro </span>\[ \left [\mathrm{IF}\;P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right ] \]
</p>
   </div>
<!-- l. 8206 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 8207 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Por (a) de la proposicion anterior tenemos un macro \(\left [\mathrm{V}\overline{n+1}\leftarrow P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right ]\). Notese que la
palabra \[ \left [\mathrm{V}\overline{n+1}\leftarrow P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right ]\mathrm{IFV}\overline{n+1}\mathrm{\neq }0\mathrm{GOTOA}1 \] es el macro buscado.                                                               □

</p>
   </div>
<!-- l. 8216 --><p class='indent'>   Dejamos al lector probar la resiproca de la proposicion anterior, es decir si \(P:D_{P}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) es tal
que en \(\mathcal{S}^{\Sigma }\) hay un macro \[ \left [\mathrm{IF}\;P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] entonces \(P\) es \(\Sigma \)-computable.
</p><!-- l. 8227 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.3.5   </span> <a id='x1-1080003.3.5'></a>Conjuntos \(\Sigma \)-enumerables</h5>
<!-- l. 8229 --><p class='noindent'>Ya que la nocion de funcion \(\Sigma \)-computable es el modelo matematico Neumanniano o
imperativo del concepto de funcion \(\Sigma \)-efectivamente computable, nos podriamos
preguntar entonces cual es el modelo matematico Neumanniano del concepto de
conjunto \(\Sigma \)-efectivamente enumerable. Si prestamos atencion a la definicion de
conjunto \(\Sigma \)-efectivamente enumerable, notaremos que depende de la existencia de
ciertas funciones \(\Sigma \)-efectivamente computables por lo cual la siguiente definicion cae de
maduro:
</p><!-- l. 8238 --><p class='indent'>   Un conjunto \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) sera llamado \(\Sigma \)<span class='cmti-10'>-enumerable </span>cuando sea vacio o haya una funcion \(F:\omega \rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) tal
que \(I_{F}=S\) y \(F_{(i)}\) sea \(\Sigma \)-computable, para cada \(i\in \{1,...,n+m\}\).
</p><!-- l. 8243 --><p class='indent'>   Deberia entonces quedar claro que si el concepto de funcion \(\Sigma \)-computable modeliza
correctamente al concepto de funcion \(\Sigma \)-efectivamente computable, entonces el
concepto de conjunto \(\Sigma \)-enumerable recien definido modeliza correctamente al concepto
de conjunto \(\Sigma \)-efectivamente enumerable. Notese que segun la definicion que acabamos
de escribir, un conjunto no vacio \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) es \(\Sigma \)-enumerable si y solo si hay programas \(\mathcal{P}_{1},...,\mathcal{P}_{n+m}\) tales
que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-108001x3.3.5'>\(\mathrm{Dom}(\Psi _{\mathcal{P}_{1}}^{1,0,\#})=...=\mathrm{Dom}(\Psi _{\mathcal{P}_{n}}^{1,0,\#})=\omega \)
     </li>
     <li class='enumerate' id='x1-108002x3.3.5'>\(\mathrm{Dom}(\Psi _{\mathcal{P}_{n+1}}^{1,0,\ast })=...=\mathrm{Dom}(\Psi _{\mathcal{P}_{n}+m}^{1,0,\ast })=\omega \)
     </li>
     <li class='enumerate' id='x1-108003x3.3.5'>\(S=\mathrm{Im}[\Psi _{\mathcal{P}_{1}}^{1,0,\#},...,\Psi _{\mathcal{P}_{n}}^{1,0,\#},\Psi _{\mathcal{P}_{n+1}}^{1,0,\ast },...,\Psi _{\mathcal{P}_{n}+m}^{1,0,\ast }]\)</li></ol>
<!-- l. 8256 --><p class='noindent'>Como puede notarse los programas \(\mathcal{P}_{1},...,\mathcal{P}_{n+m}\) puestos en paralelo a funcionar desde el estado \(\left \Vert x\right \Vert \)
producen en forma natural un procedimiento efectivo (con dato de entrada \(x\in \omega \)) que
enumera a \(S\). Por supuesto podemos decir que en tal caso los programas \(\mathcal{P}_{1},...,\mathcal{P}_{n+m}\) enumeran a \(S\).
La siguiente proposicion muestra que tambien las cosas se pueden hacer con un solo
programa
</p>
   <div class='newtheorem'>
<!-- l. 8266 --><p class='noindent'><span class='head'>
<a id='x1-108004r89'></a>

<span class='cmbx-10'>Proposition 89.</span>  </span><span class='cmti-10'>Sea</span> \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>un conjunto no vacio. Entonces son equivalentes:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-108005x89'>\(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-enumerable</span>
     </li>
     <li class='enumerate' id='x1-108006x89'><span class='cmti-10'>Hay un programa</span> \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) <span class='cmti-10'>tal que:</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-108008x1'><span class='cmti-10'>Para cada</span> \(x\in \omega \)<span class='cmti-10'>, tenemos que</span> \(\mathcal{P}\) <span class='cmti-10'>se detiene partiendo desde el estado</span> \(\left \Vert x\right \Vert \) <span class='cmti-10'>y llega
         </span><span class='cmti-10'>a un estado</span> \(\left \Vert x_{1},...x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \)<span class='cmti-10'>, donde</span> \((\vec{x},\vec{\alpha })\in S\)<span class='cmti-10'>.</span>
         </li>
         <li class='enumerate' id='x1-108010x2'><span class='cmti-10'>Para cada</span> \((\vec{x},\vec{\alpha })\in S\) <span class='cmti-10'>hay un</span> \(x\in \omega \) <span class='cmti-10'>tal que</span> \(\mathcal{P}\) <span class='cmti-10'>se detiene partiendo desde el estado</span> \(\left \Vert x\right \Vert \) <span class='cmti-10'>y
         </span><span class='cmti-10'>llega al estado</span> \(\left \Vert x_{1},...x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \)</li></ol>
     </li>
     <li class='enumerate' id='x1-108011x89'><span class='cmti-10'>Hay un programa</span> \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) <span class='cmti-10'>tal que:</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-108013x1'><span class='cmti-10'>Para cada</span> \(x\in \omega \)<span class='cmti-10'>, tenemos que</span> \(\mathcal{P}\) <span class='cmti-10'>se detiene partiendo desde el estado</span> \(\left \Vert x\right \Vert \) <span class='cmti-10'>y llega
         </span><span class='cmti-10'>a un estado de la forma</span> \(((x_{1},...,x_{n},y_{1},...),(\alpha _{1},...,\alpha _{m},\beta _{1},...))\)<span class='cmti-10'>, donde</span> \((x_{1},...,x_{n},\alpha _{1},...,\alpha _{m})\in S\)<span class='cmti-10'>.</span>
         </li>
         <li class='enumerate' id='x1-108015x2'><span class='cmti-10'>Para cada</span> \((x_{1},...x_{n},\alpha _{1},...,\alpha _{m})\in S\) <span class='cmti-10'>hay un</span> \(x\in \omega \) <span class='cmti-10'>tal que</span> \(\mathcal{P}\) <span class='cmti-10'>se detiene partiendo desde el estado</span> \(\left \Vert x\right \Vert \) <span class='cmti-10'>y
         </span><span class='cmti-10'>llega a un estado de la forma</span> \(((x_{1},...,x_{n},y_{1},...),(\alpha _{1},...,\alpha _{m},\beta _{1},...))\)</li></ol>
     </li></ol>
   </div>
<!-- l. 8294 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 8295 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(1)\(\Rightarrow \)(2). Ya que \(S\) es no vacio, por definicion tenemos que hay una \(F:\omega \rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) tal que \(I_{F}=S\) y \(F_{(i)}\) es
\(\Sigma \)-computable, para cada \(i\in \{1,...,n+m\}\). Por la Proposicion <a href='#x1-106019r87'>87<!-- tex4ht:ref: macro funciones  --></a> tenemos que existen macros:
</p><div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left [\mathrm{V}2\leftarrow F_{(1)}(\mathrm{V}1)\right ]\\ &amp; &amp; \ \ \ \ \ \ \ \ \ \ \ \ \vdots \\ &amp; &amp; \left [\mathrm{V}2\leftarrow F_{(n)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{W}1\leftarrow F_{(n+1)}(\mathrm{V}1)\right ]\\ &amp; &amp; \ \ \ \ \ \ \ \ \ \ \ \ \vdots \\ &amp; &amp; \left [\mathrm{W}1\leftarrow F_{(n+m)}(\mathrm{V}1)\right ] \end{eqnarray*}
</div>Sea \(\mathcal{Q}\) el siguiente programa: <div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left [\mathrm{P}\overline{m}\leftarrow F_{(n+m)}(\mathrm{N}1)\right ]\\ &amp; &amp; \ \ \ \ \ \ \ \ \ \ \ \ \vdots \\ &amp; &amp; \left [\mathrm{P}1\leftarrow F_{(n+1)}(\mathrm{N}1)\right ]\\ &amp; &amp; \left [\mathrm{N}\overline{n}\leftarrow F_{(n)}(\mathrm{N}1)\right ]\\ &amp; &amp; \ \ \ \ \ \ \ \ \ \ \ \ \vdots \\ &amp; &amp; \left [\mathrm{N}1\leftarrow F_{(1)}(\mathrm{N}1)\right ] \end{eqnarray*}
</div>donde se supone que las expansiones de los macros usados son hechas usando
variables auxiliares no pertenecientes a la lista \(\mathrm{N}1,...,\mathrm{N}\overline{n},\mathrm{P}1,...,\mathrm{P}\overline{m}\) (por supuesto, dada la fortaleza de
nuestros macros se puede usa una misma variable auxiliar para dos distintas
expansiones), y tambien se supone que los labels auxiliares usados en dichas
expansiones son todos distintos, es decir no usamos el mismo label auxiliar en dos
expansiones distintas (por que?).

<!-- l. 8325 --><p class='indent'>   Sea \(k\) tal que las variables de \(\mathcal{Q}\) estan todas en la lista \(\mathrm{N}1,...,\mathrm{N}\bar{k},\mathrm{P}1,...,\mathrm{P}\bar{k}\). Sea \(\mathcal{P}\) el siguiente programa: \[ \mathcal{Q}\mathrm{N}\overline{n+1}\leftarrow 0\mathrm{N}\overline{n+2}\leftarrow 0...\mathrm{N}\overline{k}\leftarrow 0\mathrm{P}\overline{m+1}\leftarrow \varepsilon \mathrm{P}\overline{m+2}\leftarrow \varepsilon ...\mathrm{P}\overline{k}\leftarrow \varepsilon \]
Dejamos al lector corroborar que el programa \(\mathcal{P}\) cumple las propiedades a y
b
</p><!-- l. 8334 --><p class='indent'>   (2)\(\Rightarrow \)(3). Directo.
</p><!-- l. 8336 --><p class='indent'>   (3)\(\Rightarrow \)(1). Supongamos \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) cumple a y b de (3). Sean </p><div class='eqnarray'>\begin{eqnarray*} \mathcal{P}_{1} &amp; = &amp; \mathcal{P}\mathrm{N}1\leftarrow \mathrm{N}1\\ \mathcal{P}_{2} &amp; = &amp; \mathcal{P}\mathrm{N}1\leftarrow \mathrm{N}2\\ &amp; &amp; \vdots \\ \mathcal{P}_{n} &amp; = &amp; \mathcal{P}\mathrm{N}1\leftarrow \mathrm{N}\overline{n}\\ \mathcal{P}_{n+1} &amp; = &amp; \mathcal{P}\mathrm{P}1\leftarrow \mathrm{P}1\\ \mathcal{P}_{n+2} &amp; = &amp; \mathcal{P}\mathrm{P}1\leftarrow \mathrm{P}2\\ &amp; &amp; \vdots \\ \mathcal{P}_{n+m} &amp; = &amp; \mathcal{P}\mathrm{P}1\leftarrow \mathrm{P}\overline{m} \end{eqnarray*}
</div>Definamos <div class='eqnarray'>\begin{eqnarray*} F_{1} &amp; = &amp; \Psi _{\mathcal{P}_{1}}^{1,0,\#}\\ F_{2} &amp; = &amp; \Psi _{\mathcal{P}_{2}}^{1,0,\#}\\ &amp; &amp; \vdots \\ F_{n} &amp; = &amp; \Psi _{\mathcal{P}_{n}}^{1,0,\#}\\ F_{n+1} &amp; = &amp; \Psi _{\mathcal{P}_{n+1}}^{1,0,\ast }\\ F_{n+2} &amp; = &amp; \Psi _{\mathcal{P}_{n+2}}^{1,0,\ast }\\ &amp; &amp; \vdots \\ F_{n+m} &amp; = &amp; \Psi _{\mathcal{P}_{n+m}}^{1,0,\ast } \end{eqnarray*}
</div>Notese que cada \(F_{i}\) es \(\Sigma \)-computable y tiene dominio igual a \(\omega \). Sea \(F=[F_{1},...,F_{n+m}]\). Tenemos por
definicion que \(D_{F}=\omega \) y ya que \(F_{(i)}=F_{i}\), para cada \(i=1,...,n+m\) tenemos que cada \(F_{(i)}\) es \(\Sigma \)-computable. Dejamos al
lector verificar que \(I_{F}=S\)                                                                            □
   </div>
<!-- l. 8367 --><p class='indent'>   Cuando un programa \(\mathcal{P}\) cumpla las propiedades dadas en (3) de la proposicion
anterior respecto de un conjunto \(S\), diremos que \(\mathcal{P}\) <span class='cmti-10'>enumera </span>a \(S\).
</p><!-- l. 8371 --><p class='indent'>   Cabe destacar que (3)\(\Rightarrow \)(1) de la proposicion anterior es muy util a la hora de
probar que un conjunto dado es \(\Sigma \)-enumerable.
</p><!-- l. 8377 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.3.6   </span> <a id='x1-1090003.3.6'></a>Conjuntos \(\Sigma \)-computables</h5>
<!-- l. 8379 --><p class='noindent'>La version imperativa del concepto de conjunto \(\Sigma \)-efectivamente computable es
facil de dar: un conjunto \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) sera llamado \(\Sigma \)<span class='cmti-10'>-computable </span>cuando la funcion \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) sea
\(\Sigma \)-computable. O sea que \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) es \(\Sigma \)-computable sii hay un programa \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) el cual computa a \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\), es
decir:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-109001x3.3.6'>Si \((\vec{x},\vec{\alpha })\in S\), entonces \(\mathcal{P}\) se detiene partiendo desde \(\left \Vert x_{1},...x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \) y la variable \(\mathrm{N}1\) queda con contenido
     igual a \(1\)
     </li>
     <li class='enumerate' id='x1-109002x3.3.6'>Si \((\vec{x},\vec{\alpha })\in (\omega ^{n}\times \Sigma ^{\ast m})-S\), entonces \(\mathcal{P}\) se detiene partiendo desde \(\left \Vert x_{1},...x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \) y la variable \(\mathrm{N}1\) queda con contenido
     igual a \(0\)</li></ol>
<!-- l. 8394 --><p class='noindent'>Si  \(\mathcal{P}\) es un programa el cual computa a \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\), diremos que \(\mathcal{P}\) <span class='cmti-10'>decide la pertenecia a</span> \(S\), con respecto
al conjunto \(\omega ^{n}\times \Sigma ^{\ast m}\).
</p>
<!-- l. 8401 --><p class='noindent'><span class='likeparagraphHead'><a id='x1-1100003.3.6'></a>Macros asociados a conjuntos \(\Sigma \)-computables</span>
   La proposicion anterior nos dice que si \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) es un conjunto \(\Sigma \)-computable, entonces, ya
que \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) es \(\Sigma \)-computable, hay un macro \[ \left [\mathrm{IF}\;\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Escribiremos el nombre de este macro de la
siguiente manera mas intuitiva: \[ \left [\mathrm{IF}\;(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\in S\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Notese que las expanciones de este macro, dado que \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\)
es \(\Sigma \)-total, ya sea terminan por la ultima instruccion de la expansion o direccionan a
la primera instruccion que tenga label igual al label que reemplazo a \(\mathrm{A}1\) en

la expansion. Es importante notar que para asegurar la existencia de este
macro utilizamos que \(S\) es \(\Sigma \)-computable lo cual no siempre sucedera para un
conjunto \(S\). Por ejemplo, puede pasar que \(S\) sea el dominio de una funcion
\(\Sigma \)<span class='cmti-10'>-</span>computable pero que \(S\) no sea \(\Sigma \)-computable (esto se vera mas adelante) y
en tal caso no existira un macro \[ \left [\mathrm{IF}\;(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\in S\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] ya que si tal macro existiera seria facil
hacer un programa que compute a \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}\) y \(S\) seria \(\Sigma \)-computable. Es muy comun el
error de suponer que existe un macro \(\left [\mathrm{IF}\;(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\in S\;\mathrm{GOTO}\;\mathrm{A}1\right ]\) cuando \(S\) es el dominio de una funcion
\(\Sigma \)-computable.
</p><!-- l. 8433 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.4   </span> <a id='x1-1110003.4'></a>Batallas entre paradigmas</h4>
<!-- l. 8435 --><p class='noindent'>En esta seccion compararemos los tres paradigmas de computabilidad efectiva que
hemos desarrollado anteriormente. Para esto probaremos que cada uno de dichos
paradigmas ”vence” al otro en el sentido que incluye por lo menos todas las funciones
que incluye el otro en su modelizacion del concepto de funcion \(\Sigma \)-efectivamente
computable.
</p><!-- l. 8444 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.4.1   </span> <a id='x1-1120003.4.1'></a>Neumann vence a Godel</h5>
<!-- l. 8446 --><p class='noindent'>Usando macros podemos ahora probar que el paradigma imperativo de Neumann es
por lo menos tan abarcativo como el funcional de Godel. Mas concretamente:
</p>
   <div class='newtheorem'>
<!-- l. 8449 --><p class='noindent'><span class='head'>
<a id='x1-112001r90'></a>
<span class='cmbx-10'>Teorema 90.</span>  </span><span class='cmti-10'>Si</span> \(h\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva, entonces</span> \(h\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-computable.</span>
</p>
   </div>
<!-- l. 8454 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 8455 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Probaremos por induccion en \(k\) que

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-112002x3.4.1'>Si \(h\in \mathrm{R}_{k}^{\Sigma }\), entonces \(h\) es \(\Sigma \)<span class='cmti-10'>-</span>computable.</li></ol>
<!-- l. 8459 --><p class='noindent'>El caso \(k=0\) es dejado al lector. Supongamos (*) vale para \(k\), veremos que vale para \(k+1\). Sea \(h\in \mathrm{R}_{k+1}^{\Sigma }-\mathrm{R}_{k}^{\Sigma }.\) Hay
varios casos
</p><!-- l. 8463 --><p class='indent'>   Caso 1. Supongamos \(h=M(P)\), con \(P:\omega \times \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \), un predicado perteneciente a \(\mathrm{R}_{k}^{\Sigma }\). Por hipotesis
inductiva, \(P\) es \(\Sigma \)<span class='cmti-10'>-</span>computable y por lo tanto tenemos un macro \[ \left [\mathrm{IF}\;P(\mathrm{V}1,...,\mathrm{V}\overline{n+1},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] lo cual nos permite
realizar el siguiente programa \[ \begin{array}{ll} \mathrm{L}2 &amp; \left [\mathrm{IF}\;P(\mathrm{N}\overline{n+1},\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m})\;\mathrm{GOTO}\;\mathrm{L}1\right ]\\ &amp; \mathrm{N}\overline{n+1}\leftarrow \mathrm{N}\overline{n+1}+1\\ &amp; \mathrm{GOTO}\;\mathrm{L}2\\ \mathrm{L}1 &amp; \mathrm{N}1\leftarrow \mathrm{N}\overline{n+1} \end{array} \] Es facil chequear que este programa computa
\(h.\)
</p><!-- l. 8481 --><p class='indent'>   Caso 2. Supongamos \(h=R(f,\mathcal{G})\), con </p><div class='eqnarray'>\begin{eqnarray*} f &amp; : &amp; S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \Sigma ^{\ast }\\ \mathcal{G}_{a} &amp; : &amp; S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\times \Sigma ^{\ast }\times \Sigma ^{\ast }\rightarrow \Sigma ^{\ast }\text{, }a\in \Sigma  \end{eqnarray*}
</div>elementos de \(\mathrm{R}_{k}^{\Sigma }\). Sea \(\Sigma =\{a_{1},...,a_{r}\}.\) Por hipotesis inductiva, las funciones \(f\), \(\mathcal{G}_{a}\), \(a\in \Sigma \), son \(\Sigma \)<span class='cmti-10'>-</span>computables y por
lo tanto podemos hacer el siguiente programa via el uso de macros \[ \begin{array}{rl} &amp; \left [\mathrm{P}\overline{m+3}\leftarrow f(\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m})\right ]\\ \mathrm{L}\overline{r+1} &amp; \mathrm{IF}\;\mathrm{P}\overline{m+1}\ \mathrm{BEGINS\ }a_{1}\text{ }\mathrm{GOTO}\;\mathrm{L}1\\ &amp; \ \ \ \ \ \ \ \ \ \ \ \ \vdots \\ &amp; \mathrm{IF}\;\mathrm{P}\overline{m+1}\ \mathrm{BEGINS\ }a_{r}\text{ }\mathrm{GOTO}\;\mathrm{L}\bar{r}\\ &amp; \mathrm{GOTO}\;\mathrm{L}\overline{r+2}\\ \mathrm{L}1 &amp; \mathrm{P}\overline{m+1}\leftarrow \text{ }^{\curvearrowright }\mathrm{P}\overline{m+1}\\ &amp; \left [\mathrm{P}\overline{m+3}\leftarrow \mathcal{G}_{a_{1}}(\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m},\mathrm{P}\overline{m+2},\mathrm{P}\overline{m+3})\right ]\\ &amp; \mathrm{P}\overline{m+2}\leftarrow \mathrm{P}\overline{m+2}.a_{1}\\ &amp; \mathrm{GOTO}\;\mathrm{L}\overline{r+1}\\ &amp; \ \ \ \ \ \ \ \ \ \ \ \ \vdots \\ \mathrm{L}\bar{r} &amp; \mathrm{P}\overline{m+1}\leftarrow \text{ }^{\curvearrowright }\mathrm{P}\overline{m+1}\\ &amp; \left [\mathrm{P}\overline{m+3}\leftarrow \mathcal{G}_{a_{r}}(\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m},\mathrm{P}\overline{m+2},\mathrm{P}\overline{m+3})\right ]\\ &amp; \mathrm{P}\overline{m+2}\leftarrow \mathrm{P}\overline{m+2}.a_{r}\\ &amp; \mathrm{GOTO}\;\mathrm{L}\overline{r+1}\\ \mathrm{L}\overline{r+2} &amp; \mathrm{P}1\leftarrow \mathrm{P}\overline{m+3} \end{array} \] Es facil chequear
que este programa computa \(h.\)
<!-- l. 8511 --><p class='indent'>   El resto de los casos son dejados al lector.                                          □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 8513 --><p class='noindent'><span class='head'>
<a id='x1-112003r91'></a>
<span class='cmbx-10'>Corollary 91.</span>  </span><span class='cmti-10'>Si</span> </p><div class='eqnarray'>\begin{eqnarray*} f &amp; : &amp; D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast }{}^{m}\rightarrow \omega \\ g &amp; : &amp; D_{g}\subseteq \omega ^{n}\times \Sigma ^{\ast }{}^{m}\rightarrow \Sigma ^{\ast }\\ P &amp; : &amp; D_{P}\subseteq \omega ^{n}\times \Sigma ^{\ast }{}^{m}\rightarrow \{0,1\} \end{eqnarray*}
</div><span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-recursivas, entonces hay macros </span><div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left [\mathrm{V}\overline{n+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right ]\\ &amp; &amp; \left [\mathrm{W}\overline{m+1}\leftarrow g(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right ]\\ &amp; &amp; \left [\mathrm{IF}\;P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right ] \end{eqnarray*}
</div>
   </div>
<!-- l. 8531 --><p class='noindent'><span class='paragraphHead'><a id='x1-1130003.4.1'></a><span class='cmbx-10'>Se lleno de macros</span></span>
   Cabe destacar que el corolario anterior nos dice que hay macros </p><div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left [\mathrm{V}\overline{n+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right ]\\ &amp; &amp; \left [\mathrm{W}\overline{m+1}\leftarrow g(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right ]\\ &amp; &amp; \left [\mathrm{IF}\;P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right ] \end{eqnarray*}
</div>para todas las funciones \(\Sigma \)-mixtas y predicados \(\Sigma \)-mixtos que hemos trabajado hasta el
momento en la materia ya que todas eran \(\Sigma \)-p.r.. Esto transforma al lenguaje \(\mathcal{S}^{\Sigma }\) en un
potente y relativamente comodo lenguaje de programacion ya que ahora tenemos
macros para todas las funciones y predicados cotidianos en la matematica. Por
ejemplo a continuacion usaremos la existencia de los macros \([\mathrm{IF\ V}1\) es par\(\ \mathrm{GOTO\ A}1]\) y \([\mathrm{V}2\leftarrow \lfloor \mathrm{V}1/2\rfloor ]\) para probar el
siguiente resultado cuya prueba esta inspirada en su analoga del paradigma de
computabilidad efectiva.
   <div class='newtheorem'>
<!-- l. 8552 --><p class='noindent'><span class='head'>
<a id='x1-113001r92'></a>
<span class='cmbx-10'>Lema 92.</span>  </span><span class='cmti-10'>Supongamos</span> \(S_{1},S_{2}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>son conjuntos</span> \(\Sigma \)<span class='cmti-10'>-enumerables. Entonces</span> \(S_{1}\cup S_{2}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-enumerable.</span>

</p>
   </div>
<!-- l. 8558 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 8559 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Podemos  suponer  que  ni  \(S_{1}\)  ni  \(S_{2}\)  son  vacios  ya  que  de  lo  contrario  los
resultados son triviales. Ademas supondremos que \(n=2\) y \(m=1\).
</p><!-- l. 8563 --><p class='indent'>   La idea de la prueba es la misma que la que usamos para probar que la union de
conjuntos \(\Sigma \)-efectivamente enumerables es \(\Sigma \)-efectivamente enumerable. Daremos usando
macros un programa que enumera a \(S_{1}\cup S_{2}\) y luego aplicaremos la Proposicion <a href='#x1-108004r89'>89<!-- tex4ht:ref: P enumera a S  --></a>. Por
hipotesis hay funciones \(F:\omega \rightarrow \omega \times \omega \times \Sigma ^{\ast }\) y \(G:\omega \rightarrow \omega \times \omega \times \Sigma ^{\ast }\) tales que \(F_{(1)}\), \(F_{(2)}\), \(F_{(3)}\), \(G_{(1)}\), \(G_{(2)}\) y \(G_{(3)}\) son \(\Sigma \)-computables, \(\mathrm{Im}(F)=S_{1}\) y \(\mathrm{Im}(G)=S_{2}\). O sea que hay
macros </p><div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left [\mathrm{V}2\leftarrow F_{(1)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{V}2\leftarrow F_{(2)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{W}1\leftarrow F_{(3)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{V}2\leftarrow G_{(1)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{V}2\leftarrow G_{(2)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{W}1\leftarrow G_{(3)}(\mathrm{V}1)\right ] \end{eqnarray*}
</div>Ya que el predicado \(Par=\lambda x[x\) es par\(]\) es \(\Sigma \)-p.r., el Corolario <a href='#x1-112003r91'>91<!-- tex4ht:ref: recursivo implica macro  --></a> nos dice que hay un
macro: \[ [\mathrm{IF\ }Par(\mathrm{V}1)\ \mathrm{GOTO\ A}1] \] el cual escribiremos de la siguiente manera mas intuitiva \[ [\mathrm{IF\ V}1\text{ es par }\mathrm{GOTO\ A}1] \] Ya que
el predicado \(D=\lambda x[\lfloor x/2\rfloor ]\) es \(\Sigma \)-p.r., el Corolario <a href='#x1-112003r91'>91<!-- tex4ht:ref: recursivo implica macro  --></a> nos dice que hay un macro: \[ [\mathrm{V}2\leftarrow D(\mathrm{V}1)] \] el cual
escribiremos de la siguiente manera mas intuitiva \[ [\mathrm{V}2\leftarrow \lfloor \mathrm{V}1/2\rfloor ] \] Sea \(\mathcal{P}\) el siguiente programa: \[ \begin{array}{ll} &amp; [\mathrm{IF\ N}1\text{ es par }\mathrm{GOTO\ L}1\\ &amp; \mathrm{N}1\leftarrow \mathrm{N}1\dot{-}1\\ &amp; [\mathrm{N}1111\leftarrow \lfloor \mathrm{N}1/2\rfloor ]\\ &amp; \left [\mathrm{N}1\leftarrow G_{(1)}(\mathrm{N}1111)\right ]\\ &amp; \left [\mathrm{N}2\leftarrow G_{(2)}(\mathrm{N}1111)\right ]\\ &amp; \left [\mathrm{P}1\leftarrow G_{(3)}(\mathrm{N}1111)\right ]\\ &amp; \mathrm{GOTO\ L}2\\ \mathrm{L}1 &amp; [\mathrm{N}1111\leftarrow \lfloor \mathrm{N}1/2\rfloor ]\\ &amp; \left [\mathrm{N}1\leftarrow F_{(1)}(\mathrm{N}1111)\right ]\\ &amp; \left [\mathrm{N}2\leftarrow F_{(2)}(\mathrm{N}1111)\right ]\\ &amp; \left [\mathrm{P}1\leftarrow F_{(3)}(\mathrm{N}1111)\right ]\\ \mathrm{L}2 &amp; \mathrm{SKIP} \end{array} \]
Es facil ver que \(\mathcal{P}\) cumple a y b de (3) de la Proposicion <a href='#x1-108004r89'>89<!-- tex4ht:ref: P enumera a S  --></a> por lo cual \(S_{1}\cup S_{2}\) es
\(\Sigma \)-enumerable.                                                                                     □
   </div>
<!-- l. 8620 --><p class='indent'>   Tal como se vio en este ejemplo, el Corolario <a href='#x1-112003r91'>91<!-- tex4ht:ref: recursivo implica macro  --></a> junto con nuestra gran coleccion
de funciones ya probadamente \(\Sigma \)-recursivas, nos permite simular con programas
muchos de los procedimientos efectivos realizados anteriormente. Mas capacidad de
simulacion obtendremos luego de ver que Godel vence a Neumann ya que la
equivalencia de estos dos paradigmas nos asegura la existencia de macros que
permitiran dentro de un programa hablar acerca del funcionamiento de otro
programa. Esto sera clave a la hora de simular con programas a procedimientos
efectivos que en su funcionamiento involucran el funcionamiento de otros
procedimientos.
</p><!-- l. 8634 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.4.2   </span> <a id='x1-1140003.4.2'></a>Godel vence a Neumann</h5>
<!-- l. 8636 --><p class='noindent'>Para probar que toda funcion \(\Sigma \)-computable es \(\Sigma \)-recursiva debemos hacer un profundo
estudio de la recursividad del lenguaje \(\mathcal{S}^{\Sigma }\). Primero analizaremos la recursividad de la
sintaxis de \(\mathcal{S}^{\Sigma }\).

</p>
<!-- l. 8644 --><p class='noindent'><span class='paragraphHead'><a id='x1-1150003.4.2'></a><span class='cmbx-10'>Analisis de la recursividad de la sintaxis de</span> \(\mathcal{S}^{\Sigma }\)</span>
   Primero probaremos dos lemas que muestran que la sintaxis de \(\mathcal{S}^{\Sigma }\) es \((\Sigma \cup \Sigma _{p})\)-recursiva
primitiva. Recordemos que \(S:Num^{\ast }\rightarrow Num^{\ast }\) fue definida de la siguiente manera </p><div class='eqnarray'>\begin{eqnarray*} S(\varepsilon ) &amp; = &amp; 1\\ S(\alpha 0) &amp; = &amp; \alpha 1\\ S(\alpha 1) &amp; = &amp; \alpha 2\\ S(\alpha 2) &amp; = &amp; \alpha 3\\ S(\alpha 3) &amp; = &amp; \alpha 4\\ S(\alpha 4) &amp; = &amp; \alpha 5\\ S(\alpha 5) &amp; = &amp; \alpha 6\\ S(\alpha 6) &amp; = &amp; \alpha 7\\ S(\alpha 7) &amp; = &amp; \alpha 8\\ S(\alpha 8) &amp; = &amp; \alpha 9\\ S(\alpha 9) &amp; = &amp; S(\alpha )0 \end{eqnarray*}
</div>Tambien \(\overline{\ \;}:\omega \rightarrow Num^{\ast }\) fue definida de la siguiente manera <div class='eqnarray'>\begin{eqnarray*} \bar{0} &amp; = &amp; \varepsilon \\ \overline{n+1} &amp; = &amp; S(\bar{n}) \end{eqnarray*}
</div>Es obvio de las definiciones que ambas funciones son \(Num\)-p.r.. Mas aun tenemos
   <div class='newtheorem'>
<!-- l. 8670 --><p class='noindent'><span class='head'>
<a id='x1-115001r93'></a>
<span class='cmbx-10'>Lema 93.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto cualquiera. Las funciones</span> \(S\) <span class='cmti-10'>y</span> \(\overline{\ \;}\) <span class='cmti-10'>son</span> \((\Sigma \cup \Sigma _{p})\)<span class='cmti-10'>-p.r..</span>
</p>
   </div>
<!-- l. 8675 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 8676 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es facil ver que \(S\) y \(\overline{\ \;}\) son \(Num\)-p.r.. Ya que tambien son \((\Sigma \cup \Sigma _{p})\)-mixtas, el Teorema <a href='#x1-97010r84'>84<!-- tex4ht:ref: independencia  --></a>
nos dice que ambas son \((\Sigma \cup \Sigma _{p})\)-p.r..                                                                □
</p>
   </div>
<!-- l. 8682 --><p class='indent'>   Recordemos que \(Bas:\mathrm{Ins}^{\Sigma }\rightarrow (\Sigma \cup \Sigma _{p})^{\ast }\), fue definida por \[ Bas(I)=\left \{ \begin{array}{ccl} J &amp; &amp; \text{si }I\text{ es de la forma }\mathrm{L}\bar{k}J\text{ con }J\in \mathrm{Ins}^{\Sigma }\\ I &amp; &amp; \text{caso contrario} \end{array}\right . \] Definamos \(Lab:\mathrm{Ins}^{\Sigma }\rightarrow (\Sigma \cup \Sigma _{p})^{\ast }\) de la siguiente manera
\[ Lab(I)=\left \{ \begin{array}{lll} \mathrm{L}\bar{k} &amp; &amp; \text{si }I\text{ es de la forma }\mathrm{L}\bar{k}J\text{ con }J\in \mathrm{Ins}^{\Sigma }\\ \varepsilon &amp; &amp; \text{caso contrario} \end{array}\right . \]
</p>
   <div class='newtheorem'>
<!-- l. 8699 --><p class='noindent'><span class='head'>
<a id='x1-115002r94'></a>
<span class='cmbx-10'>Lema 94.</span>  </span><span class='cmti-10'>Para cada</span> \(n,x\in \omega \)<span class='cmti-10'>, tenemos que</span> \(\left \vert \bar{n}\right \vert \leq x\) <span class='cmti-10'>si y solo si</span> \(n\leq 10^{x}-1\)
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 8704 --><p class='noindent'><span class='head'>
<a id='x1-115003r95'></a>
<span class='cmbx-10'>Lema 95.</span>  </span>\(\mathrm{Ins}^{\Sigma }\) <span class='cmti-10'>es un conjunto</span> \((\Sigma \cup \Sigma _{p})\)<span class='cmti-10'>-p.r..</span>

</p>
   </div>
<!-- l. 8708 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 8709 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Para simplificar la prueba asumiremos que \(\Sigma =\{@,\blacktriangle \}\). Ya que \(\mathrm{Ins}^{\Sigma }\) es union de los siguientes
conjuntos </p><div class='eqnarray'>\begin{eqnarray*} L_{1} &amp; = &amp; \left \{ \mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k}+1:k\in \mathbf{N}\right \} \\ L_{2} &amp; = &amp; \left \{ \mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k}\dot{-}1:k\in \mathbf{N}\right \} \\ L_{3} &amp; = &amp; \left \{ \mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{n}:k,n\in \mathbf{N}\right \} \\ L_{4} &amp; = &amp; \left \{ \mathrm{N}\bar{k}\leftarrow 0:k\in \mathbf{N}\right \} \\ L_{5} &amp; = &amp; \left \{ \mathrm{IF}\;\mathrm{N}\bar{k}\neq 0\;\mathrm{GOTO}\;\mathrm{L}\bar{m}:k,m\in \mathbf{N}\right \} \\ L_{6} &amp; = &amp; \left \{ \mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{k}.@:k\in \mathbf{N}\right \} \\ L_{7} &amp; = &amp; \left \{ \mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{k}.\blacktriangle :k\in \mathbf{N}\right \} \\ L_{8} &amp; = &amp; \left \{ \mathrm{P}\bar{k}\leftarrow \text{ }^{\curvearrowright }\mathrm{P}\bar{k}:k\in \mathbf{N}\right \} \\ L_{9} &amp; = &amp; \left \{ \mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{n}:k,n\in \mathbf{N}\right \} \\ L_{10} &amp; = &amp; \left \{ \mathrm{P}\bar{k}\leftarrow \varepsilon :k\in \mathbf{N}\right \} \\ L_{11} &amp; = &amp; \left \{ \mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;@\;\mathrm{GOTO}\;\mathrm{L}\bar{m}:k,m\in \mathbf{N}\right \} \\ L_{12} &amp; = &amp; \left \{ \mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;\blacktriangle \;\mathrm{GOTO}\;\mathrm{L}\bar{m}:k,m\in \mathbf{N}\right \} \\ L_{13} &amp; = &amp; \left \{ \mathrm{GOTO}\;\mathrm{L}\bar{m}:m\in \mathbf{N}\right \} \\ L_{14} &amp; = &amp; \left \{ \mathrm{SKIP}\right \} \\ L_{15} &amp; = &amp; \left \{ \mathrm{L}\bar{k}\alpha :k\in \mathbf{N\;}\text{y }\alpha \in L_{1}\cup ...\cup L_{14}\right \} \end{eqnarray*}
</div>solo debemos probar que \(L_{1},...,L_{15}\) son \((\Sigma \cup \Sigma _{p})\)-p.r.. Veremos primero por ejemplo que \[ L_{11}=\left \{ \mathrm{IFP}\bar{k}\mathrm{BEGINS}@\mathrm{GOTOL}\bar{m}:k,m\in \mathbf{N}\right \} \] es \((\Sigma \cup \Sigma _{p})\)-p.r..
Primero notese que \(\alpha \in L_{11}\) si y solo si existen \(k,m\in \mathbf{N}\) tales que \[ \alpha =\mathrm{IFP}\bar{k}\mathrm{BEGINS}@\mathrm{GOTOL}\bar{m} \] Mas formalmente tenemos que \(\alpha \in L_{11}\) si y
solo si \[ (\exists k\in \mathbf{N})(\exists m\in \mathbf{N})\;\alpha =\mathrm{IFP}\bar{k}\mathrm{BEGINS}@\mathrm{GOTOL}\bar{m} \] Ya que cuando existen tales \(k,m\) tenemos que \(\bar{k}\) y \(\bar{m}\) son subpalabras de \(\alpha \), el lema
anterior nos dice que \(\alpha \in L_{11}\) si y solo si \[ (\exists k\in \mathbf{N})_{k\leq 10^{\left \vert \alpha \right \vert }}(\exists m\in \mathbf{N})_{m\leq 10^{\left \vert \alpha \right \vert }}\;\alpha =\mathrm{IFP}\bar{k}\mathrm{BEGINS}@\mathrm{GOTOL}\bar{m} \] Sea \[ P=\lambda mk\alpha \left [\alpha =\mathrm{IFP}\bar{k}\mathrm{BEGINS}@\mathrm{GOTOL}\bar{m}\right ] \] Ya que \(D_{\lambda k\left [\bar{k}\right ]}=\omega \), tenemos que \(D_{P}=\omega ^{2}\times (\Sigma \cup \Sigma _{p})^{\ast }\). Notese que \[ P=\lambda \alpha \beta \left [\alpha =\beta \right ]\circ \left [p_{3}^{2,1},f\right ] \] donde \[ f=\lambda \alpha _{1}\alpha _{2}\alpha _{3}\alpha _{4}\left [\alpha _{1}\alpha _{2}\alpha _{3}\alpha _{4}\right ]\circ \left [C_{\mathrm{IFP}}^{2,1},\lambda k\left [\bar{k}\right ]\circ p_{2}^{2,1},C_{\mathrm{BEGINS}@\mathrm{GOTOL}}^{2,1},\lambda k\left [\bar{k}\right ]\circ p_{1}^{2,1}\right ] \] lo
cual nos dice que \(P\) es \((\Sigma \cup \Sigma _{p})\)-p.r..
<!-- l. 8763 --><p class='indent'>   Notese que \[ \chi _{L_{11}}^{(\Sigma \cup \Sigma _{p})^{\ast }}=\lambda \alpha \left [(\exists k\in \mathbf{N})_{k\leq 10^{\left \vert \alpha \right \vert }}(\exists m\in \mathbf{N})_{m\leq 10^{\left \vert \alpha \right \vert }}\;P(m,k,\alpha )\right ] \] Esto nos dice que podemos usar dos veces el Lema <a href='#x1-86001r62'>62<!-- tex4ht:ref: cuantificacion  --></a> para ver que \(\chi _{L_{11}}^{(\Sigma \cup \Sigma _{p})^{\ast }}\) es
\((\Sigma \cup \Sigma _{p})\)-p.r.. Veamos como. Sea \[ Q=\lambda k\alpha \left [(\exists m\in \mathbf{N})_{m\leq 10^{\left \vert \alpha \right \vert }}\;P(m,k,\alpha )\right ] \] Por el Lema <a href='#x1-86001r62'>62<!-- tex4ht:ref: cuantificacion  --></a> tenemos que \[ \lambda xk\alpha \left [(\exists m\in \mathbf{N})_{m\leq x}\;P(m,k,\alpha )\right ] \] es \((\Sigma \cup \Sigma _{p})\)-p.r. lo cual nos dice que \[ Q=\lambda xk\alpha \left [(\exists m\in \mathbf{N})_{m\leq x}\;P(m,k,\alpha )\right ]\circ \left [\lambda \alpha \left [10^{\left \vert \alpha \right \vert }\right ]\circ p_{2}^{1,1},p_{1}^{1,1},p_{2}^{1,1}\right ] \] lo
es. Ya que \[ \chi _{L_{11}}^{(\Sigma \cup \Sigma _{p})^{\ast }}=\lambda \alpha \left [(\exists k\in \mathbf{N})_{k\leq 10^{\left \vert \alpha \right \vert }}\;Q(k,\alpha )\right ] \] podemos en forma similar aplicar el Lema <a href='#x1-86001r62'>62<!-- tex4ht:ref: cuantificacion  --></a> y obtener finalmente que \(\chi _{L_{11}}^{(\Sigma \cup \Sigma _{p})^{\ast }}\) es
\((\Sigma \cup \Sigma _{p})\)-p.r..
</p><!-- l. 8789 --><p class='indent'>   En forma similar podemos probar que \(L_{1},...,L_{14}\) son \((\Sigma \cup \Sigma _{p})\)-p.r.. Esto nos dice que \(L_{1}\cup ...\cup L_{14}\) es \((\Sigma \cup \Sigma _{p})\)-p.r..
Notese que \(L_{1}\cup ...\cup L_{14}\) es el conjunto de las instrucciones basicas de \(\mathcal{S}^{\Sigma }\). Llamemos \(\mathrm{InsBas}^{\Sigma }\) a
dicho conjunto. Para ver que \(L_{15}\) es \((\Sigma \cup \Sigma _{p})\)-p.r. notemos que \[ \chi _{L_{15}}^{(\Sigma \cup \Sigma _{p})^{\ast }}=\lambda \alpha \left [(\exists k\in \mathbf{N})_{k\leq 10^{\left \vert \alpha \right \vert }}(\exists \beta \in \mathrm{InsBas}^{\Sigma })_{\left \vert \beta \right \vert \leq \left \vert \alpha \right \vert }\;\alpha =\mathrm{L}\bar{k}\beta \right ] \] lo cual nos dice que
aplicando dos veces el Lema <a href='#x1-86001r62'>62<!-- tex4ht:ref: cuantificacion  --></a> obtenemos que \(\chi _{L_{15}}^{(\Sigma \cup \Sigma _{p})^{\ast }}\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Ya que \(\mathrm{Ins}^{\Sigma }=\mathrm{InsBas}^{\Sigma }\cup L_{15}\) tenemos que \(\mathrm{Ins}^{\Sigma }\) es
\((\Sigma \cup \Sigma _{p})\)-p.r..                                                                                                □
</p>
   </div>
<!-- l. 8803 --><p class='indent'>   @@finpagina@@
</p>
   <div class='newtheorem'>
<!-- l. 8804 --><p class='noindent'><span class='head'>
<a id='x1-115004r96'></a>
<span class='cmbx-10'>Lema 96.</span>  </span>\(Bas\) <span class='cmti-10'>y</span> \(Lab\) <span class='cmti-10'>son funciones</span> \((\Sigma \cup \Sigma _{p})\)<span class='cmti-10'>-p.r.</span>
</p>
   </div>
<!-- l. 8808 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 8809 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea \(\leq \) un orden total sobre \(\Sigma \cup \Sigma _{p}\). Sea \(L=\{\mathrm{L}\bar{k}:k\in \mathbf{N}\}\cup \{\varepsilon \}\). Dejamos al lector probar que \(L\) es un
conjunto \((\Sigma \cup \Sigma _{p})\)-p.r.. Sea \[ P=\lambda I\alpha \left [\alpha \in \mathrm{Ins}^{\Sigma }\wedge I\in \mathrm{Ins}^{\Sigma }\wedge [\alpha ]_{1}\neq \mathrm{L}\wedge (\exists \beta \in L)\ I=\beta \alpha \right ] \] Note que \(D_{P}=(\Sigma \cup \Sigma _{p})^{\ast 2}\). Dejamos al lector probar que \(P\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Notese

ademas que cuando \(I\in \mathrm{Ins}^{\Sigma }\) tenemos que \(P(I,\alpha )=1\) sii \(\alpha =Bas(I)\). Dejamos al lector probar que \(Bas=M^{\leq }\left (P\right )\) por lo que
para ver que \(Bas\) es \((\Sigma \cup \Sigma _{p})\)-p.r., solo nos falta ver que la funcion \(Bas\) es acotada por alguna
funcion \((\Sigma \cup \Sigma _{p})\)-p.r. y \((\Sigma \cup \Sigma _{p})\)-total. Pero esto es trivial ya que \(\left \vert Bas(I)\right \vert \leq \left \vert I\right \vert =\lambda \alpha [\left \vert \alpha \right \vert ](I)\), para cada \(I\in \mathrm{Ins}^{\Sigma }\).
</p><!-- l. 8825 --><p class='indent'>   Finalmente note que \[ Lab=M^{\leq }\left (\lambda I\alpha \left [\alpha Bas(I)=I\right ]\right ) \] lo cual nos dice que \(Lab\) es \((\Sigma \cup \Sigma _{p})\)-p.r..                               □
</p>
   </div>
<!-- l. 8833 --><p class='indent'>   Recordemos que dado un programa \(\mathcal{P}\) habiamos definido \(I_{i}^{\mathcal{P}}=\varepsilon \), para \(i=0\) o \(i&gt;n(\mathcal{P}).\) O sea que la
funcion \((\Sigma \cup \Sigma _{p})\)-mixta \(\lambda i\mathcal{P}\left [I_{i}^{\mathcal{P}}\right ]\) tiene dominio igual a \(\omega \times \mathrm{Pro}^{\Sigma }\). Notese que usamos notacion lambda respecto
del alfabeto \(\Sigma \cup \Sigma _{p}\). Ademas notese que usamos la variable \(\mathcal{P}\) en la notacion lambda por un
tema de comodidad psicologica dado que la expresion \(I_{i}^{\alpha }\) esta definida solo cuando
\(\alpha \) es un programa pero podriamos haber escrito \(\lambda i\alpha \left [I_{i}^{\alpha }\right ]\) y sigue siendo la misma
funcion.
</p>
   <div class='newtheorem'>
<!-- l. 8843 --><p class='noindent'><span class='head'>
<a id='x1-115005r97'></a>
<span class='cmbx-10'>Lema 97.</span>  </span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-115006x97'>\(\mathrm{Pro}^{\Sigma }\) <span class='cmti-10'>es un conjunto</span> \((\Sigma \cup \Sigma _{p})\)<span class='cmti-10'>-p.r.</span>
     </li>
     <li class='enumerate' id='x1-115007x97'>\(\lambda \mathcal{P}\left [n(\mathcal{P})\right ]\) <span class='cmti-10'>y</span> \(\lambda i\mathcal{P}\left [I_{i}^{\mathcal{P}}\right ]\) <span class='cmti-10'>son funciones</span> \((\Sigma \cup \Sigma _{p})\)<span class='cmti-10'>-p.r..</span></li></ol>
   </div>
<!-- l. 8852 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 8853 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que \(\mathrm{Pro}^{\Sigma }=D_{\lambda \mathcal{P}\left [n(\mathcal{P})\right ]}\) tenemos que (b) implica (a). Para probar (b) Sea \(\leq \) un orden total
sobre \(\Sigma \cup \Sigma _{p}\). Sea \(P\) el siguiente predicado
</p><!-- l. 8857 --><p class='indent'>   \(\lambda x\left [Lt(x)&gt;0\wedge (\forall t\in \mathbf{N})_{t\leq Lt(x)}\;\ast ^{\leq }((x)_{t})\in \mathrm{Ins}^{\Sigma }\wedge \right .\)
</p><!-- l. 8859 --><p class='indent'>   \(\ \ \ \ \ \ \ \ \ \ \ \ (\forall t\in \mathbf{N})_{t\leq Lt(x)}(\forall m\in \mathbf{N})\;\lnot (\mathrm{L}\bar{m}\ \)t-final \(\ast ^{\leq }((x)_{t}))\vee \)
</p><!-- l. 8862 --><p class='indent'>   \(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \left .(\exists j\in \mathbf{N})_{j\leq Lt(x)}(\exists \alpha \in (\Sigma \cup \Sigma _{p})-Num)\;\mathrm{L}\bar{m}\alpha \ \text{t-inicial}\ast ^{\leq }((x)_{j})\right ]\)
</p><!-- l. 8864 --><p class='noindent'>Notese que \(D_{P}=\mathbf{N}\) y que \(P(x)=1\) sii \(Lt(x)&gt;0\), \(\ast ^{\leq }((x)_{t})\in \mathrm{Ins}^{\Sigma }\), para cada \(t=1,...,Lt(x)\) y ademas \(\subset _{t=1}^{t=Lt(x)}\ast ^{\leq }((x)_{t})\in \mathrm{Pro}^{\Sigma }\). Para ver que \(P\) es \((\Sigma \cup \Sigma _{p})\)-p.r. solo nos falta
acotar el cuantificador \((\forall m\in \mathbf{N})\) de la expresion lambda que define a \(P\). Ya que nos interesan los
valores de \(m\) para los cuales \(\bar{m}\) es posiblemente una subpalabra de alguna de las palabras
\(\ast ^{\leq }((x)_{j})\), el Lema <a href='#x1-115002r94'>94<!-- tex4ht:ref: cota longitud de la barra  --></a> nos dice que una cota posible es \(10^{\max \{\left \vert \ast ^{\leq }((x)_{j})\right \vert :1\leq j\leq Lt(x)\}}-1\). Dejamos al lector los detalles de la
prueba de que \(P\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Sea \[ Q=\lambda x\alpha \left [P(x)\wedge \alpha =\subset _{t=1}^{t=Lt(x)}\ast ^{\leq }((x)_{t})\right ]\text{.} \] Note que \(D_{Q}=\mathbf{N}\times (\Sigma \cup \Sigma _{p})^{\ast }\). Claramente \(Q\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Ademas note que \(D_{M(Q)}=\mathrm{Pro}^{\Sigma }\).
Notese que para \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\), tenemos que \(M(Q)(\mathcal{P})\) es aquel numero tal que pensado como infinitupla

(via mirar su secuencia de exponentes) codifica la secuencia de instrucciones que
forman a \(\mathcal{P}\). Es decir \[ M(Q)(\mathcal{P})=\left \langle \#^{\leq }(I_{1}^{\mathcal{P}}),\#^{\leq }(I_{2}^{\mathcal{P}}),...,\#^{\leq }(I_{n(\mathcal{P})}^{\mathcal{P}}),0,0,...\right \rangle \] Por (b) del Lema <a href='#x1-90001r67'>67<!-- tex4ht:ref: minimizacion  --></a>, \(M(Q)\) es \((\Sigma \cup \Sigma _{p})\)-p.r. ya que para cada \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) tenemos que
</p><div class='eqnarray'>\begin{eqnarray*} M(Q)(\mathcal{P}) &amp; = &amp; \left \langle \#^{\leq }(I_{1}^{\mathcal{P}}),\#^{\leq }(I_{2}^{\mathcal{P}}),...,\#^{\leq }(I_{n(\mathcal{P})}^{\mathcal{P}}),0,0,...\right \rangle \\ &amp; = &amp; \underset{i=1}{\overset{n(\mathcal{P})}{\Pi }}pr(i)^{\#^{\leq }(I_{1}^{\mathcal{P}})}\\ &amp; \leq &amp; \underset{i=1}{\overset{\left \vert \mathcal{P}\right \vert }{\Pi }}pr(i)^{\#^{\leq }(\mathcal{P})} \end{eqnarray*}
</div>Ademas tenemos que <div class='eqnarray'>\begin{eqnarray*} \lambda \mathcal{P}\left [n(\mathcal{P})\right ] &amp; = &amp; \lambda x\left [Lt(x)\right ]\circ M(Q)\\ \lambda i\mathcal{P}\left [I_{i}^{\mathcal{P}}\right ] &amp; = &amp; \ast ^{\leq }\circ g\circ \left [p_{1}^{1,1},M(Q)\circ p_{2}^{1,1}\right ] \end{eqnarray*}
</div>donde \(g=C_{0}^{1,1}|_{\{0\}\times \omega }\cup \lambda ix\left [(x)_{i}\right ]\), lo cual dice que \(\lambda \mathcal{P}\left [n(\mathcal{P})\right ]\) y \(\lambda i\mathcal{P}\left [I_{i}^{\mathcal{P}}\right ]\) son funciones \((\Sigma \cup \Sigma _{p})\)-p.r..                                        □
   </div>
<!-- l. 8907 --><p class='noindent'><span class='paragraphHead'><a id='x1-1160003.4.2'></a><span class='cmbx-10'>Analisis de la recursividad de la semantica de</span> \(\mathcal{S}^{\Sigma }\)</span>
   Para estudiar la recursividad de la semantica de \(\mathcal{S}^{\Sigma }\) deberemos definir varias
funciones que tienen que ver con el funcionamiento de un programa y estudiar su
recursividad.
</p>
<!-- l. 8913 --><p class='indent'>   <span class='subparagraphHead'> <a id='x1-1170003.4.2'></a><span class='cmbx-10'>Las funciones</span> \(i^{n,m}\)<span class='cmbx-10'>,</span> \(E_{\#}^{n,m}\) <span class='cmbx-10'>y</span> \(E_{\ast }^{n,m}\)</span>
   Sean \(n,m\geq 0\) fijos. Definamos entonces las funciones
</p>
   <div class='eqnarray'>\begin{eqnarray*} i^{n,m} &amp; : &amp; \omega \times \omega ^{n}\times \Sigma ^{\ast m}\times \mathrm{Pro}^{\Sigma }\rightarrow \omega \\ E_{\#}^{n,m} &amp; : &amp; \omega \times \omega ^{n}\times \Sigma ^{\ast m}\times \mathrm{Pro}^{\Sigma }\rightarrow \omega ^{[\mathbf{N}]}\\ E_{\ast }^{n,m} &amp; : &amp; \omega \times \omega ^{n}\times \Sigma ^{\ast m}\times \mathrm{Pro}^{\Sigma }\rightarrow \Sigma ^{\ast [\mathbf{N}]} \end{eqnarray*}
</div>de la siguiente manera
   <div class='eqnarray'>\begin{eqnarray*} (i^{n,m}(0,\vec{x},\vec{\alpha },\mathcal{P}),E_{\#}^{n,m}(0,\vec{x},\vec{\alpha },\mathcal{P}),E_{\ast }^{n,m}(0,\vec{x},\vec{\alpha },\mathcal{P})) &amp; = &amp; (1,(x_{1},...,x_{n},0,...),(\alpha _{1},...,\alpha _{m},\varepsilon ,...))\\ (i^{n,m}(t+1,\vec{x},\vec{\alpha },\mathcal{P}),E_{\#}^{n,m}(t+1,\vec{x},\vec{\alpha },\mathcal{P}),E_{\ast }^{n,m}(t+1,\vec{x},\vec{\alpha },\mathcal{P})) &amp; = &amp; S_{\mathcal{P}}(i^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),E_{\#}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),E_{\ast }^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P})) \end{eqnarray*}
</div>Notese que \[ (i^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),E_{\#}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),E_{\ast }^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P})) \] es la descripcion instantanea que se obtiene luego de correr \(\mathcal{P}\) una cantidad
\(t\) de pasos partiendo del estado \[ ((x_{1},...,x_{n},0,...),(\alpha _{1},...,\alpha _{m},\varepsilon ,...)) \] Es importante notar que si bien \(i^{n,m}\) es una funcion
\((\Sigma \cup \Sigma _{p})\)-mixta, ni \(E_{\#}^{n,m}\) ni \(E_{\ast }^{n,m}\) lo son.
<!-- l. 8940 --><p class='indent'>   Definamos para cada \(j\in \mathbf{N}\), funciones
</p>
   <div class='eqnarray'>\begin{eqnarray*} E_{\#j}^{n,m} &amp; : &amp; \omega \times \omega ^{n}\times \Sigma ^{\ast m}\times \mathrm{Pro}^{\Sigma }\rightarrow \omega \\ E_{\ast j}^{n,m} &amp; : &amp; \omega \times \omega ^{n}\times \Sigma ^{\ast m}\times \mathrm{Pro}^{\Sigma }\rightarrow \Sigma ^{\ast } \end{eqnarray*}
</div>de la siguiente manera <div class='eqnarray'>\begin{eqnarray*} E_{\#j}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}) &amp; = &amp; j\text{-esima coordenada de }E_{\#}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P})\\ E_{\ast j}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}) &amp; = &amp; j\text{-esima coordenada de }E_{\ast }^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}) \end{eqnarray*}
</div>Notese que <div class='eqnarray'>\begin{eqnarray*} E_{\#}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}) &amp; = &amp; (E_{\#1}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),E_{\#2}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),...)\\ E_{\ast }^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}) &amp; = &amp; (E_{\ast 1}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),E_{\ast 2}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),...) \end{eqnarray*}
</div>Nuestro proximo objetivo es mostrar que las funciones \(i^{n,m}\), \(E_{\#j}^{n,m}\), \(E_{\ast j}^{n,m}\) son \((\Sigma \cup \Sigma _{p})\)-p.r.
<!-- l. 8959 --><p class='indent'>   Para esto primero debemos probar un lema el cual muestre que una ves
codificadas las descripciones instantaneas en forma numerica, las funciones
que dan la descripcion instantanea sucesora son \((\Sigma \cup \Sigma _{p})\)-p.r.. Dado un orden total
\(\leq \) sobre \(\Sigma \cup \Sigma _{p}\), codificaremos las descripciones instantaneas haciendo uso de las
biyecciones \[ \begin{array}{rcl} \omega ^{\left [\mathbf{N}\right ]} &amp; \rightarrow &amp; \mathbf{N}\\ (s_{1},s_{2},...) &amp; \rightarrow &amp; \left \langle s_{1},s_{2},...\right \rangle \end{array}\;\;\;\;\;\;\;\;\;\;\;\;\begin{array}{rcl} \Sigma ^{\ast \left [\mathbf{N}\right ]} &amp; \rightarrow &amp; \mathbf{N}\\ (\sigma _{1},\sigma _{2},...) &amp; \rightarrow &amp; \left \langle \#^{\leq }(\sigma _{1}),\#^{\leq }(\sigma _{2}),...\right \rangle \end{array} \] Es decir que a la descripcion instantanea \[ (i,(s_{1},s_{2},...),(\sigma _{1},\sigma _{2},...)) \] la codificaremos con
la terna \[ (i,\left \langle s_{1},s_{2},...\right \rangle ,\left \langle \#^{\leq }(\sigma _{1}),\#^{\leq }(\sigma _{2}),...\right \rangle )\in \omega \times \mathbf{N}\times \mathbf{N} \] Es decir que una terna \((i,x,y)\in \omega \times \mathbf{N}\times \mathbf{N}\) codificara a la descripcion instantanea \[ (i,((x)_{1},(x)_{2},...),(\ast ^{\leq }((y)_{1}),\ast ^{\leq }((y)_{2}),...)) \]
Definamos
</p>
   <div class='eqnarray'>\begin{eqnarray*} s &amp; : &amp; \omega \times \mathbf{N}\times \mathbf{N}\times \mathrm{Pro}^{\Sigma }\rightarrow \omega \\ S_{\#} &amp; : &amp; \omega \times \mathbf{N}\times \mathbf{N}\times \mathrm{Pro}^{\Sigma }\rightarrow \omega \\ S_{\ast } &amp; : &amp; \omega \times \mathbf{N}\times \mathbf{N}\times \mathrm{Pro}^{\Sigma }\rightarrow \omega  \end{eqnarray*}
</div>de la siguiente manera
<!-- l. 9000 --><p class='indent'>   \[ \begin{array}[t]{ll} s(i,x,y,\mathcal{P})= &amp; \text{primera coordenada de la codificacion de la descripcion instantanea}\\ &amp; \text{sucesora de }(i,((x)_{1},(x)_{2},...),(\ast ^{\leq }((y)_{1}),\ast ^{\leq }((y)_{2}),...))\text{ en }\mathcal{P} \end{array} \]
</p><!-- l. 9007 --><p class='indent'>   \[ \begin{array}[t]{ll} S_{\#}(i,x,y,\mathcal{P})= &amp; \text{segunda coordenada de la codificacion de la descripcion instantanea}\\ &amp; \text{sucesora de }(i,((x)_{1},(x)_{2},...),(\ast ^{\leq }((y)_{1}),\ast ^{\leq }((y)_{2}),...))\text{ en }\mathcal{P} \end{array} \]
</p><!-- l. 9014 --><p class='indent'>   \[ \begin{array}[t]{ll} S_{\ast }(i,x,y,\mathcal{P})= &amp; \text{tercera coordenada de la codificacion de la descripcion instantanea}\\ &amp; \text{sucesora de }(i,((x)_{1},(x)_{2},...),(\ast ^{\leq }((y)_{1}),\ast ^{\leq }((y)_{2}),...))\text{ en }\mathcal{P} \end{array} \] Notese que la definicion de estas funciones depende del orden total \(\leq \) sobre
\(\Sigma \cup \Sigma _{p}\).

</p><!-- l. 9018 --><p class='indent'>   @@finpagina@@
</p>
   <div class='newtheorem'>
<!-- l. 9019 --><p class='noindent'><span class='head'>
<a id='x1-117001r98'></a>
<span class='cmbx-10'>Lema 98.</span>  </span><span class='cmti-10'>Dado un orden total</span> \(\leq \) <span class='cmti-10'>sobre</span> \(\Sigma \cup \Sigma _{p}\)<span class='cmti-10'>, las funciones</span> \(s\)<span class='cmti-10'>,</span> \(S_{\#}\) <span class='cmti-10'>y</span> \(S_{\ast }\) <span class='cmti-10'>son</span> \((\Sigma \cup \Sigma _{p})\)<span class='cmti-10'>-p.r..</span>
</p>
   </div>
<!-- l. 9025 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9026 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Necesitaremos algunas funciones \((\Sigma \cup \Sigma _{p})\)-p.r.. Dada una instruccion \(I\) en la cual al
menos ocurre una variable, usaremos \(\#Var1(I)\) para denotar el numero de la primer variable
que ocurre en \(I\). Por ejemplo \[ \#Var1\left (\mathrm{L}\bar{n}\;\mathrm{IF\;N}\bar{k}\neq 0\;\mathrm{GOTO\;L}\bar{m}\right )=k \] Notese que \(\lambda I[\#Var1(I)]\) tiene dominio igual a \(\mathrm{Ins}^{\Sigma }-L\), donde \(L\) es la union de
los siguientes conjuntos </p><div class='gather-star'><img alt=' ' src='apunte3x.png' /></div>Dada una instruccion \(I\) en la cual ocurren dos variables, usaremos \(\#Var2(I)\) para denotar el
numero de la segunda variable que ocurre en \(I\). Por ejemplo \[ \#Var2\left (\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{m}\right )=m \] Notese que el dominio de \(\lambda I[\#Var2(I)]\)
es igual a la union de los siguientes conjuntos <div class='eqnarray'>\begin{eqnarray*} \{\mathrm{N}\bar{k} &amp; \leftarrow &amp; \mathrm{N}\bar{m}:k,m\in \mathbf{N\}\cup }\{\mathrm{L}\bar{j}\ \mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{m}:j,k,m\in \mathbf{N\}}\\ \{\mathrm{P}\bar{k} &amp; \leftarrow &amp; \mathrm{P}\bar{m}:k,m\in \mathbf{N\}\cup }\{\mathrm{L}\bar{j}\ \mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{m}:j,k,m\in \mathbf{N\}} \end{eqnarray*}
</div>Ademas notese que para una instruccion \(I\) tenemos que <div class='eqnarray'>\begin{eqnarray*} \#Var1(I) &amp; = &amp; \min _{k}(\mathrm{N}\bar{k}\mathrm{\leftarrow }\text{ }\mathrm{ocu}\text{ }I\vee \mathrm{N}\bar{k}\mathrm{\neq }\text{ }\mathrm{ocu}\text{ }I\vee \mathrm{P}\bar{k}\mathrm{\leftarrow }\text{ }\mathrm{ocu}\text{ }I\vee \mathrm{P}\bar{k}\mathrm{B}\;\mathrm{ocu}\text{ }I)\\ \#Var2(I) &amp; = &amp; \min _{k}(\mathrm{N}\bar{k}\ \text{t-final }I\vee \mathrm{N}\bar{k}\mathrm{+}\text{ }\mathrm{ocu}\text{ }I\vee \mathrm{N}\bar{k}\mathrm{\dot{-}}\text{ }\mathrm{ocu}\text{ }I\vee \mathrm{P}\bar{k}\ \text{t-final }I\vee \mathrm{P}\bar{k}.\text{ }\mathrm{ocu}\text{ }I) \end{eqnarray*}
</div>Esto nos dice que si llamamos \(P\) al predicado \[ \lambda k\alpha \left [\alpha \in \mathrm{Ins}^{\Sigma }\wedge (\mathrm{N}\bar{k}\mathrm{\leftarrow }\text{ }\mathrm{ocu}\text{ }\alpha \vee \mathrm{N}\bar{k}\mathrm{\neq }\text{ }\mathrm{ocu}\text{ }\alpha \vee \mathrm{P}\bar{k}\mathrm{\leftarrow }\text{ }\mathrm{ocu}\text{ }\alpha \vee \mathrm{P}\bar{k}\mathrm{B}\;\mathrm{ocu}\text{ }\alpha )\right ] \] entonces \(\lambda I[\#Var1(I)]=M(P)\) por lo cual \(\lambda I[\#Var1(I)]\) es \((\Sigma \cup \Sigma _{p})\)-p.r.
Similarmente se puede ver que \(\lambda I[\#Var2(I)]\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Sea \[ \begin{array}{rll} F_{\dot{-}}:\mathbf{N}\times \mathbf{N} &amp; \rightarrow &amp; \omega \\ (x,j) &amp; \rightarrow &amp; \left \langle (x)_{1},....,(x)_{j-1},(x)_{j}\dot{-}1,(x)_{j+1},...\right \rangle \end{array} \] Ya que \[ F_{\dot{-}}(x,j)=\left \{ \begin{array}{lll} Q(x,pr(j)) &amp; &amp; \text{si }pr(j)\text{ divide }x\\ x &amp; &amp; \text{caso contrario} \end{array}\right . \] tenemos que \(F_{\dot{-}}\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Sea \[ \begin{array}{rll} F_{+}:\mathbf{N}\times \mathbf{N} &amp; \rightarrow &amp; \omega \\ (x,j) &amp; \rightarrow &amp; \left \langle (x)_{1},....,(x)_{j-1},(x)_{j}+1,(x)_{j+1},...\right \rangle \end{array} \] Ya
que \(F_{+}(x,j)=x.pr(j)\) tenemos que \(F_{+}\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Sea \[ \begin{array}{rll} F_{\leftarrow }:\mathbf{N}\times \mathbf{N}\times \mathbf{N} &amp; \rightarrow &amp; \omega \\ (x,j,k) &amp; \rightarrow &amp; \left \langle (x)_{1},....,(x)_{j-1},(x)_{k},(x)_{j+1},...\right \rangle \end{array} \] Ya que \(F_{\leftarrow }(x,j,k)=Q(x,pr(j)^{(x)_{j}}).pr(j)^{(x)_{k}}\) tenemos que \(F_{\leftarrow }\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Sea \[ \begin{array}{rll} F_{0}:\mathbf{N}\times \mathbf{N} &amp; \rightarrow &amp; \omega \\ (x,j) &amp; \rightarrow &amp; \left \langle (x)_{1},....,(x)_{j-1},0,(x)_{j+1},...\right \rangle \end{array} \] Es facil ver que \(F_{0}\) es
\((\Sigma \cup \Sigma _{p})\)-p.r.. Para cada \(a\in \Sigma \), sea \[ \begin{array}{rll} F_{a}:\mathbf{N}\times \mathbf{N} &amp; \rightarrow &amp; \omega \\ (x,j) &amp; \rightarrow &amp; \left \langle (x)_{1},....,(x)_{j-1},\#^{\leq }(\ast ^{\leq }((x)_{j})a),(x)_{j+1},...\right \rangle \end{array} \] Es facil ver que \(F_{a}\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. En forma similar puede ser probado
que \[ \begin{array}{rll} F_{\curvearrowright }:\mathbf{N}\times \mathbf{N} &amp; \rightarrow &amp; \omega \\ (x,j) &amp; \rightarrow &amp; \left \langle (x)_{1},....,(x)_{j-1},\#^{\leq }(^{\curvearrowright }(\ast ^{\leq }((x)_{j}))),(x)_{j+1},...\right \rangle \end{array} \] es \((\Sigma \cup \Sigma _{p})\)-p.r.
<!-- l. 9117 --><p class='indent'>   Dado \((i,x,y,\mathcal{P})\in \omega \times \mathbf{N}\times \mathbf{N}\times \mathrm{Pro}^{\Sigma }\), tenemos varios casos en los cuales los valores \(s(i,x,y,\mathcal{P}),S_{\#}(i,x,y,\mathcal{P})\) y \(S_{\ast }(i,x,y,\mathcal{P})\) pueden ser obtenidos
usando las funciones antes definidas:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-117002x3.4.2'>CASO \(i=0\vee i&gt;n(\mathcal{P})\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; i\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; x\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; y \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117003x3.4.2'>CASO \((\exists j\in \omega )\;Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{j}\leftarrow \mathrm{N}\bar{j}+1\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; i+1\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; F_{+}(x,\#Var1(I_{i}^{\mathcal{P}}))\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; y \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117004x3.4.2'>CASO \((\exists j\in \omega )\;Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{j}\leftarrow \mathrm{N}\bar{j}\dot{-}1\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; i+1\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; F_{\dot{-}}(x,\#Var1(I_{i}^{\mathcal{P}}))\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; y \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117005x3.4.2'>CASO \((\exists j,k\in \omega )\;Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{j}\leftarrow \mathrm{N}\bar{k}\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; i+1\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; F_{\leftarrow }(x,\#Var1(I_{i}^{\mathcal{P}}),\#Var2(I_{i}^{\mathcal{P}}))\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; y \end{eqnarray*}
     </div>

     </li>
     <li class='enumerate' id='x1-117006x3.4.2'>CASO \((\exists j,k\in \omega )\;Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{j}\leftarrow 0\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; i+1\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; F_{0}(x,\#Var1(I_{i}^{\mathcal{P}}))\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; y \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117007x3.4.2'>CASO \((\exists j,m\in \omega )\;\left (Bas(I_{i}^{\mathcal{P}})=\mathrm{IF}\;\mathrm{N}\bar{j}\neq 0\;\mathrm{GOTO}\;\mathrm{L}\bar{m}\wedge (x)_{j}=0\right )\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; i+1\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; x\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; y \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117008x3.4.2'>CASO \((\exists j,m\in \omega )\;\left (Bas(I_{i}^{\mathcal{P}})=\mathrm{IF}\;\mathrm{N}\bar{j}\neq 0\;\mathrm{GOTO}\;\mathrm{L}\bar{m}\wedge (x)_{j}\neq 0\right )\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; \min _{l}\left (Lab(I_{l}^{\mathcal{P}})\neq \varepsilon \wedge Lab(I_{l}^{\mathcal{P}})\text{ }\mathrm{t}\text{\textrm{-final} }I_{i}^{\mathcal{P}}\right )\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; x\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; y \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117009x3.4.2'>CASO \((\exists j\in \omega )\;Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{j}\leftarrow \mathrm{P}\bar{j}.a\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; i+1\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; x\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; F_{a}(y,\#Var1(I_{i}^{\mathcal{P}})) \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117010x3.4.2'>CASO \((\exists j\in \omega )\;Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{j}\leftarrow \) \(^{\curvearrowright }\mathrm{P}\bar{j}\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; i+1\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; x\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; F_{\curvearrowright }(y,\#Var1(I_{i}^{\mathcal{P}})) \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117011x3.4.2'>CASO \((\exists j,k\in \omega )\;Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{j}\leftarrow \mathrm{P}\bar{k}\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; i+1\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; x\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; F_{\leftarrow }(y,\#Var1(I_{i}^{\mathcal{P}}),\#Var2(I_{i}^{\mathcal{P}})) \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117012x3.4.2'>CASO \((\exists j\in \omega )\;Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{j}\leftarrow \varepsilon \). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; i+1\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; x\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; F_{0}(y,\#Var1(I_{i}^{\mathcal{P}})) \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117013x3.4.2'>CASO \((\exists j,m\in \omega )(\exists a\in \Sigma )\;\left (Bas(I_{i}^{\mathcal{P}})=\mathrm{IF}\;\mathrm{P}\bar{j}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{m}\wedge [\ast ^{\leq }((y)_{j})]_{1}\neq a\right )\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; i+1\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; x\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; y \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117014x3.4.2'>CASO \((\exists j,m\in \omega )(\exists a\in \Sigma )\;\left (Bas(I_{i}^{\mathcal{P}})=\mathrm{IF\;P}\bar{j}\;\mathrm{BEGINS\;}a\;\mathrm{GOTO\;L}\bar{m}\wedge [\ast ^{\leq }((y)_{j})]_{1}=a\right )\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; \min _{l}\left (Lab(I_{l}^{\mathcal{P}})\neq \varepsilon \wedge Lab(I_{l}^{\mathcal{P}})\text{ }\mathrm{t}\text{\textrm{-final} }I_{i}^{\mathcal{P}}\right )\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; x\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; y \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117015x3.4.2'>CASO \((\exists j\in \omega )\;Bas(I_{i}^{\mathcal{P}})=\mathrm{GOTO}\) \(\mathrm{L}\bar{j}\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; \min _{l}\left (Lab(I_{l}^{\mathcal{P}})\neq \varepsilon \wedge Lab(I_{l}^{\mathcal{P}})\text{ }\mathrm{t}\text{\textrm{-final} }I_{i}^{\mathcal{P}}\right )\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; x\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; y \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-117016x3.4.2'>CASO \(Bas(I_{i}^{\mathcal{P}})=\mathrm{SKIP}\). Entonces <div class='eqnarray'>\begin{eqnarray*} s(i,x,y,\mathcal{P}) &amp; = &amp; i+1\\ S_{\#}(i,x,y,\mathcal{P}) &amp; = &amp; x\\ S_{\ast }(i,x,y,\mathcal{P}) &amp; = &amp; y \end{eqnarray*}
     </div></li></ol>
<!-- l. 9226 --><p class='noindent'>O sea que los casos anteriores nos permiten definir conjuntos \(S_{1},...,S_{15}\), los cuales son disjuntos de
a pares y cuya union da el conjunto \(\omega \times \mathbf{N}\times \mathbf{N}\times \mathrm{Pro}^{\Sigma }\), de manera que cada una de las funciones \(s,S_{\#}\) y \(S_{\ast }\)
pueden escribirse como union disjunta de funciones \((\Sigma \cup \Sigma _{p})\)-p.r. restrinjidas respectivamente
a los conjuntos \(S_{1},...,S_{15}\). Ya que los conjuntos \(S_{1},...,S_{15}\) son \((\Sigma \cup \Sigma _{p})\)-p.r. el Lema <a href='#x1-84001r58'>58<!-- tex4ht:ref: dpc  --></a> nos dice que \(s,S_{\#}\) y \(S_{\ast }\) lo
son.                                                                                                 □

</p>
   </div>
<!-- l. 9236 --><p class='indent'>   Aparte del lema anterior, para probar que las funciones \(i^{n,m}\), \(E_{\#j}^{n,m}\) y \(E_{\ast j}^{n,m}\) son \((\Sigma \cup \Sigma _{p})\)-p.r., nos sera
necesario el siguiente resultado. Recordemos que para \(x_{1},...,x_{n}\in \omega \), usabamos \(\left \langle x_{1},...,x_{n}\right \rangle \) para denotar \(\left \langle x_{1},...,x_{n},0,...\right \rangle \).
Ademas recordemos que en el Lema <a href='#x1-90009r70'>70<!-- tex4ht:ref: CodificadorasSonPR  --></a> probamos que para cada \(n\geq 1\), la funcion \(\lambda x_{1}...x_{n}\left [\left \langle x_{1},...,x_{n}\right \rangle \right ]\) es
\(\emptyset \)-p.r.
</p>
   <div class='newtheorem'>
<!-- l. 9244 --><p class='noindent'><span class='head'>
<a id='x1-117017r99'></a>
<span class='cmbx-10'>Lema 99.</span>  </span><span class='cmti-10'>Sean</span> </p><div class='eqnarray'>\begin{eqnarray*} f_{i} &amp; : &amp; S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \\ g_{i} &amp; : &amp; \omega ^{k}\times \omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega \\ F_{i} &amp; : &amp; \omega \times S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\rightarrow \omega  \end{eqnarray*}
</div><span class='cmti-10'>con</span> \(i=1,...,k\)<span class='cmti-10'>, funciones</span> \(\Sigma \)<span class='cmti-10'>-mixtas. Supongamos que </span><div class='eqnarray'>\begin{eqnarray*} F_{i}(0,\vec{x},\vec{\alpha }) &amp; = &amp; f_{i}(0,\vec{x},\vec{\alpha })\\ F_{i}(t+1,\vec{x},\vec{\alpha }) &amp; = &amp; g_{i}(F_{1}(t,\vec{x},\vec{\alpha }),...,F_{k}(t,\vec{x},\vec{\alpha }),t,\vec{x},\vec{\alpha }) \end{eqnarray*}
</div><span class='cmti-10'>para cada</span> \(i=1,...,k\)<span class='cmti-10'>,</span> \(t\in \omega \) <span class='cmti-10'>y</span> \((\vec{x},\vec{\alpha })\in S_{1}\times ...\times S_{n}\times L_{1}\times ...\times L_{m}\)<span class='cmti-10'>. Entonces si las funciones</span> \(f_{1},...,f_{k},g_{1},...,g_{k}\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-p.r., las funciones</span> \(F_{1},...,F_{k}\) <span class='cmti-10'>lo son.</span>
   </div>
<!-- l. 9261 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9262 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Para mayor claridad haremos el caso \(k=2\). Sea \[ F=\lambda t\vec{x}\vec{\alpha }\left [\left \langle F_{1}(t,\vec{x},\vec{\alpha }),F_{2}(t,\vec{x},\vec{\alpha })\right \rangle \right ] \] Es claro que si \(F\) es \(\Sigma \)-p.r., entonces
lo es cada \(F_{i}\). Notese que </p><div class='eqnarray'>\begin{eqnarray*} F(0,\vec{x},\vec{\alpha }) &amp; = &amp; \left \langle f_{1}(\vec{x},\vec{\alpha }),f_{2}(\vec{x},\vec{\alpha })\right \rangle \\ F(t+1,\vec{x},\vec{\alpha }) &amp; = &amp; \left \langle g_{1}((F(t,\vec{x},\vec{\alpha }))_{1},(F(t,\vec{x},\vec{\alpha }))_{2},t,\vec{x},\vec{\alpha }),g_{2}((F(t,\vec{x},\vec{\alpha }))_{1},(F(t,\vec{x},\vec{\alpha }))_{2},t,\vec{x},\vec{\alpha })\right \rangle  \end{eqnarray*}
</div>lo cual nos dice que \(F=R(f,g)\) donde <div class='eqnarray'>\begin{eqnarray*} f &amp; = &amp; \lambda \vec{x}\vec{\alpha }\left [\left \langle f_{1}(\vec{x},\vec{\alpha }),f_{2}(\vec{x},\vec{\alpha })\right \rangle \right ]\\ g &amp; = &amp; \lambda At\vec{x}\vec{\alpha }\left [\left \langle g_{1}((A)_{1},(A)_{2},t,\vec{x},\vec{\alpha }),g_{2}((A)_{1},(A)_{2},t,\vec{x},\vec{\alpha })\right \rangle \right ] \end{eqnarray*}
</div>                                                                 □
   </div>
<!-- l. 9278 --><p class='indent'>   @@finpagina@@
</p><!-- l. 9280 --><p class='indent'>   Ahora usando los dos lemas anteriores podemos probar el siguiente importante
resultado.
</p>
   <div class='newtheorem'>
<!-- l. 9282 --><p class='noindent'><span class='head'>
<a id='x1-117018r100'></a>
<span class='cmbx-10'>Proposition 100.</span>  </span><span class='cmti-10'>Sean</span> \(n,m\geq 0\)<span class='cmti-10'>. Las funciones</span> \(i^{n,m}\)<span class='cmti-10'>,</span> \(E_{\#j}^{n,m}\)<span class='cmti-10'>,</span> \(E_{\ast j}^{n,m}\)<span class='cmti-10'>,</span> \(j=1,2,...\)<span class='cmti-10'>, son</span> \((\Sigma \cup \Sigma _{p})\)<span class='cmti-10'>-p.r.</span>
</p>
   </div>
<!-- l. 9287 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9288 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Sea \(\leq \) un orden total sobre \(\Sigma \cup \Sigma _{p}\) y sean \(s\), \(S_{\#}\) y \(S_{\ast }\) las funciones definidas previamente al
Lema <a href='#x1-117001r98'>98<!-- tex4ht:ref: descripcion instantanea sucesora es PR  --></a>. Definamos </p><div class='eqnarray'>\begin{eqnarray*} K_{\#}^{n,m} &amp; = &amp; \lambda t\vec{x}\vec{\alpha }\mathcal{P}\left [\left \langle E_{\#1}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),E_{\#2}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),...\right \rangle \right ]\\ K_{\ast }^{n,m} &amp; = &amp; \lambda t\vec{x}\vec{\alpha }\mathcal{P}\left [\left \langle \#^{\leq }(E_{\ast 1}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P})),\#^{\leq }(E_{\ast 2}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P})),...\right \rangle \right ] \end{eqnarray*}
</div>Notese que <div class='eqnarray'>\begin{eqnarray*} i^{n,m}(0,\vec{x},\vec{\alpha },\mathcal{P}) &amp; = &amp; 1\\ K_{\#}^{n,m}(0,\vec{x},\vec{\alpha },\mathcal{P}) &amp; = &amp; \left \langle x_{1},...,x_{n}\right \rangle \\ K_{\ast }^{n,m}(0,\vec{x},\vec{\alpha },\mathcal{P}) &amp; = &amp; \left \langle \#^{\leq }(\alpha _{1}),...,\#^{\leq }(\alpha _{m})\right \rangle \\ i^{n,m}(t+1,\vec{x},\vec{\alpha },\mathcal{P}) &amp; = &amp; s(i^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),K_{\#}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),K_{\ast }^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}))\\ K_{\#}^{n,m}(t+1,\vec{x},\vec{\alpha },\mathcal{P}) &amp; = &amp; S_{\#}(i^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),K_{\#}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),K_{\ast }^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}))\\ K_{\ast }^{n,m}(t+1,\vec{x},\vec{\alpha },\mathcal{P}) &amp; = &amp; S_{\ast }(i^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),K_{\#}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}),K_{\ast }^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P})) \end{eqnarray*}
</div>Por el Lema <a href='#x1-117017r99'>99<!-- tex4ht:ref: recursion primitiva multiple  --></a> tenemos que \(i^{n,m}\), \(K_{\#}^{n,m}\) y \(K_{\ast }^{n,m}\) son \((\Sigma \cup \Sigma _{p})\)-p.r.. Ademas notese que <div class='eqnarray'>\begin{eqnarray*} E_{\#j}^{n,m} &amp; = &amp; \lambda t\vec{x}\vec{\alpha }\mathcal{P}\left [(K_{\#}^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}))_{j}\right ]\\ E_{\ast j}^{n,m} &amp; = &amp; \lambda t\vec{x}\vec{\alpha }\mathcal{P}\left [\ast ^{\leq }((K_{\ast }^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}))_{j})\right ] \end{eqnarray*}
</div>por lo cual las funciones \(E_{\#j}^{n,m}\), \(E_{\ast j}^{n,m}\), \(j=1,2,...\), son \((\Sigma \cup \Sigma _{p})\)-p.r.                                                     □
   </div>
<!-- l. 9317 --><p class='indent'>   <span class='subparagraphHead'> <a id='x1-1180003.4.2'></a><span class='cmbx-10'>Las funciones</span> \(Halt^{n,m}\) <span class='cmbx-10'>y</span> \(T^{n,m}\)</span>
   Dados \(n,m\in \omega \), definamos: \[ Halt^{n,m}=\lambda t\vec{x}\vec{\alpha }\mathcal{P}\left [i^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P})=n(\mathcal{P})+1\right ] \] Notese que \(D_{Halt^{n,m}}=\omega \times \omega ^{n}\times \Sigma ^{\ast m}\times \mathrm{Pro}^{\Sigma }\) (ojo que aqui la notacion lambda es respecto del
alfabeto \(\Sigma \cup \Sigma _{p}\)). Ademas notese que usamos la variable \(\mathcal{P}\) en la notacion lambda por un
tema de comodidad psicologica dado que \(i^{n,m}\) esta definida solo cuando la ultima
coordenada es un programa pero podriamos haber escrito \(\lambda t\vec{x}\vec{\alpha }\alpha \left [i^{n,m}(t,\vec{x},\vec{\alpha },\alpha )=n(\alpha )+1\right ]\) y sigue siendo la misma
funcion.
</p><!-- l. 9331 --><p class='indent'>   Cabe destacar que \(Halt^{n,m}\) tiene una descripcion muy intuitiva, ya que dado \((t,\vec{x},\vec{\alpha },\mathcal{P})\in \omega \times \omega ^{n}\times \Sigma ^{\ast m}\times \mathrm{Pro}^{\Sigma }\), tenemos
que \(Halt^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P})=1\) si y solo si el programa \(\mathcal{P}\) se detiene luego de \(t\) pasos partiendo desde el estado
\(\left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \).
</p>
   <div class='newtheorem'>
<!-- l. 9336 --><p class='noindent'><span class='head'>
<a id='x1-118001r101'></a>
<span class='cmbx-10'>Lema 101.</span>  </span>\(Halt^{n,m}\) <span class='cmti-10'>es</span> \((\Sigma \cup \Sigma _{p})\)<span class='cmti-10'>-p.r.</span>
</p>
   </div>
<!-- l. 9340 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9341 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notar que \(Halt^{n,m}=\lambda xy[x=y]\circ \left [i^{n,m},\lambda \mathcal{P}[n(\mathcal{P})+1]\circ p_{1+n+m+1}^{1+n,m+1}\right ]\).                                                                              □
</p>
   </div>
<!-- l. 9345 --><p class='indent'>   Ahora definamos \(T^{n,m}=M(Halt^{n,m})\). Notese que \[ D_{T^{n,m}}=\{(\vec{x},\vec{\alpha },\mathcal{P}):\mathcal{P}\text{ se detiene partiendo de }\left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \} \] y para \((\vec{x},\vec{\alpha },\mathcal{P})\in D_{T^{n,m}}\) tenemos que \(T^{n,m}(\vec{x},\vec{\alpha },\mathcal{P})=\) cantidad de pasos necesarios
para que \(\mathcal{P}\) se detenga partiendo de \(\left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \). En algun sentido, la funcion \(T^{n,m}\) mide el tiempo que
tarda en detenerse \(\mathcal{P}\)
</p>
   <div class='newtheorem'>

<!-- l. 9354 --><p class='noindent'><span class='head'>
<a id='x1-118002r102'></a>
<span class='cmbx-10'>Proposition 102.</span>  </span>\(T^{n,m}\) <span class='cmti-10'>es</span> \((\Sigma \cup \Sigma _{p})\)<span class='cmti-10'>-recursiva</span>
</p>
   </div>
<!-- l. 9358 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9359 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es directo del Lema <a href='#x1-90001r67'>67<!-- tex4ht:ref: minimizacion  --></a> ya que \(Halt^{n,m}\) es \((\Sigma \cup \Sigma _{p})\)-p.r.                                          □
</p>
   </div>
<!-- l. 9364 --><p class='indent'>   <span class='subparagraphHead'> <a id='x1-1190003.4.2'></a><span class='cmbx-10'>Las funciones</span> \(\Phi _{\#}^{n,m}\) <span class='cmbx-10'>y</span> \(\Phi _{\ast }^{n,m}\)</span>
   Para \(n,m\in \omega \) definamos la funcion \(\Phi _{\#}^{n,m}\) de la siguiente manera: </p><div class='eqnarray'>\begin{eqnarray*} D_{\Phi _{\#}^{n,m}} &amp; = &amp; \left \{ (\vec{x},\vec{\alpha },\mathcal{P})\in \omega ^{n}\times \Sigma ^{\ast m}\times \mathrm{Pro}^{\Sigma }:(\vec{x},\vec{\alpha })\in D_{\Psi _{\mathcal{P}}^{n,m,\#}}\right \} \\ \Phi _{\#}^{n,m}(\vec{x},\vec{\alpha },\mathcal{P}) &amp; = &amp; \Psi _{\mathcal{P}}^{n,m,\#}(\vec{x},\vec{\alpha })\text{, para cada }(\vec{x},\vec{\alpha },\mathcal{P})\in D_{\Phi _{\#}^{n,m}} \end{eqnarray*}
</div>Notese que \[ D_{\Phi _{\#}^{n,m}}=\{(\vec{x},\vec{\alpha },\mathcal{P}):\mathcal{P}\text{ se detiene partiendo de }\left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \} \] y para cada \((\vec{x},\vec{\alpha },\mathcal{P})\in D_{\Phi _{\#}^{n,m}}\), se tiene que \(\Phi _{\#}^{n,m}(\vec{x},\vec{\alpha },\mathcal{P})=\) valor que queda en la variable \(\mathrm{N}1\) cuando \(\mathcal{P}\) se
detiene partiendo de \(\left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \).
<!-- l. 9381 --><p class='indent'>   Similarmente, definamos la funcion \(\Phi _{\ast }^{n,m}\) de la siguiente manera: </p><div class='eqnarray'>\begin{eqnarray*} D_{\Phi _{\ast }^{n,m}} &amp; = &amp; \left \{ (\vec{x},\vec{\alpha },\mathcal{P})\in \omega ^{n}\times \Sigma ^{\ast m}\times \mathrm{Pro}^{\Sigma }:(\vec{x},\vec{\alpha })\in D_{\Psi _{\mathcal{P}}^{n,m,\ast }}\right \} \\ \Phi _{\ast }^{n,m}(\vec{x},\vec{\alpha },\mathcal{P}) &amp; = &amp; \Psi _{\mathcal{P}}^{n,m,\ast }(\vec{x},\vec{\alpha })\text{, para cada }(\vec{x},\vec{\alpha },\mathcal{P})\in D_{\Phi _{\ast }^{n,m}} \end{eqnarray*}
</div>Notese que <div class='eqnarray'>\begin{eqnarray*} \Phi _{\#}^{n,m} &amp; = &amp; \lambda \vec{x}\vec{\alpha }\mathcal{P}\left [\Psi _{\mathcal{P}}^{n,m,\#}(\vec{x},\vec{\alpha })\right ]\\ \Phi _{\ast }^{n,m} &amp; = &amp; \lambda \vec{x}\vec{\alpha }\mathcal{P}\left [\Psi _{\mathcal{P}}^{n,m,\ast }(\vec{x},\vec{\alpha })\right ] \end{eqnarray*}
</div>
   <div class='newtheorem'>
<!-- l. 9393 --><p class='noindent'><span class='head'>
<a id='x1-119001r103'></a>
<span class='cmbx-10'>Teorema 103.</span>  </span><span class='cmti-10'>Las funciones</span> \(\Phi _{\#}^{n,m}\) <span class='cmti-10'>y</span> \(\Phi _{\ast }^{n,m}\) <span class='cmti-10'>son</span> \((\Sigma \cup \Sigma _{p})\)<span class='cmti-10'>-recursivas.</span>
</p>
   </div>
<!-- l. 9397 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9398 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Veremos que \(\Phi _{\#}^{n,m}\) es \((\Sigma \cup \Sigma _{p})\)-recursiva. Notar que \(D_{T^{n,m}}=D_{\Phi _{\#}^{n,m}}\). Notese que para \((\vec{x},\vec{\alpha },\mathcal{P})\in D_{T^{n,m}}=D_{\Phi _{\#}^{n,m}}\) tenemos que \[ \Phi _{\#}^{n,m}(\vec{x},\vec{\alpha },\mathcal{P})=E_{\#1}^{n,m}\left (T^{n,m}(\vec{x},\vec{\alpha },\mathcal{P}),\vec{x},\vec{\alpha },\mathcal{P}\right ) \]
lo cual con un poco mas de trabajo nos permite probar que \[ \Phi _{\#}^{n,m}=E_{\#1}^{n,m}\circ \left [T^{n,m},p_{1}^{n,m+1},...,p_{n+m+1}^{n,m+1}\right ] \] Ya que la funcion \(E_{\#1}^{n,m}\)
es \((\Sigma \cup \Sigma _{p})\)-p.r. y \(T^{n,m}\) es \((\Sigma \cup \Sigma _{p})\)-r., tenemos que \(\Phi _{\#}^{n,m}\) es \((\Sigma \cup \Sigma _{p})\)-r.                                                       □

</p>
   </div>
<!-- l. 9415 --><p class='noindent'><span class='paragraphHead'><a id='x1-1200003.4.2'></a><span class='cmbx-10'>Godel vence a Neumann</span></span>
   Ahora nos sera facil probar que el paradigma de Godel es por lo menos tan
abarcativo como el imperativo de Von Neumann. Mas concretamente:
</p>
   <div class='newtheorem'>
<!-- l. 9419 --><p class='noindent'><span class='head'>
<a id='x1-120001r104'></a>
<span class='cmbx-10'>Teorema 104.</span>  </span><span class='cmti-10'>Si</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-computable, entonces</span> \(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva.</span>
</p>
   </div>
<!-- l. 9424 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9425 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Haremos el caso \(O=\Sigma ^{\ast }\). Sea \(\mathcal{P}_{0}\) un programa que compute a \(f\). Primero veremos que
\(f\) es \((\Sigma \cup \Sigma _{p})\)-recursiva. Note que \[ f=\Phi _{\ast }^{n,m}\circ \left [p_{1}^{n,m},...,p_{n+m}^{n,m},C_{\mathcal{P}_{0}}^{n,m}\right ] \] donde cabe destacar que \(p_{1}^{n,m},...,p_{n+m}^{n,m}\) son las proyecciones respecto
del alfabeto \(\Sigma \cup \Sigma _{p}\), es decir que tienen dominio \(\omega ^{n}\times (\Sigma \cup \Sigma _{p})^{\ast m}\). Ya que \(\Phi _{\ast }^{n,m}\) es \((\Sigma \cup \Sigma _{p})\)-recursiva tenemos que \(f\)
lo es. O sea que el Teorema <a href='#x1-97010r84'>84<!-- tex4ht:ref: independencia  --></a> nos dice que \(f\) es \(\Sigma \)-recursiva.                          □
</p>
   </div>
<!-- l. 9440 --><p class='indent'>   Un corolario interesante que se puede obtener del teorema anterior es que toda
funcion \(\Sigma \)-recursiva puede obtenerse combinando las reglas basicas en una forma muy
particular.
</p>
   <div class='newtheorem'>
<!-- l. 9443 --><p class='noindent'><span class='head'>
<a id='x1-120002r105'></a>
<span class='cmbx-10'>Corollary 105.</span>  </span><span class='cmti-10'>Si</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva, entonces existe un predicado</span> \(\Sigma \)<span class='cmti-10'>-p.r.</span> \(P:\mathbf{N}\times \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>y una
</span><span class='cmti-10'>funcion</span> \(\Sigma \)<span class='cmti-10'>-p.r.</span> \(g:\mathbf{N}\rightarrow O\) <span class='cmti-10'>tales que</span> \(f=g\circ M(P).\)

</p>
   </div>
<!-- l. 9451 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9452 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos que \(O=\Sigma ^{\ast }\). Sea \(\mathcal{P}_{0}\) un programa el cual compute a \(f\). Sea \(\leq \) un orden total
sobre \(\Sigma \). Note que podemos tomar </p><div class='eqnarray'>\begin{eqnarray*} P &amp; = &amp; \lambda t\vec{x}\vec{\alpha }[Halt^{n,m}\left ((t)_{1},\vec{x},\vec{\alpha },\mathcal{P}_{0}\right )\wedge (t)_{2}=\#^{\leq }(E_{\ast 1}^{n,m}((t)_{1},\vec{x},\vec{\alpha },\mathcal{P}_{0}))]\\ g &amp; = &amp; \lambda t\left [\ast ^{\leq }((t)_{2})\right ] \end{eqnarray*}
</div>(Justifique por que \(P\) es \(\Sigma \)-p.r..)                                                                □
   </div>
<!-- l. 9463 --><p class='indent'>   A continuacion veremos ejemplos naturales de funciones \((\Sigma \cup \Sigma _{p})\)-recursivas que
no son \((\Sigma \cup \Sigma _{p})\)-recursivas primitivas. Cabe destacar que la prueba se basa en la
Proposicion <a href='#x1-89002r66'>66<!-- tex4ht:ref: recursivo no implica PR  --></a> (enunciada sin demostracion) la cual nos dice que cualquiera sea el
alfabeto finito \(\Sigma \), siempre hay una funcion que es \(\Sigma \)-recursiva y no es \(\Sigma \)-recursiva
primitiva
</p>
   <div class='newtheorem'>
<!-- l. 9472 --><p class='noindent'><span class='head'>
<a id='x1-120003r106'></a>
<span class='cmbx-10'>Proposition 106.</span>  </span><span class='cmti-10'>Cualesquiera sean</span> \(n,m\in \omega \)<span class='cmti-10'>, se tiene que las funciones</span> \(T^{n,m}\)<span class='cmti-10'>,</span> \(\Phi _{\#}^{n,m}\) <span class='cmti-10'>y</span> \(\Phi _{\ast }^{n,m}\) <span class='cmti-10'>no son</span>
\((\Sigma \cup \Sigma _{p})\)<span class='cmti-10'>-p.r.</span>
</p>
   </div>
<!-- l. 9478 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9479 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Fijemos \(n,m\in \omega \). Probaremos que \(\Phi _{\#}^{n,m}\) es \((\Sigma \cup \Sigma _{p})\)-p.r. sii \(\Phi _{\#}^{0,0}\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Sean \(f_{1},f_{2}:\omega ^{n}\times \Sigma ^{\ast m}\rightarrow (\Sigma \cup \Sigma _{p})^{\ast }\) dadas por </p><div class='eqnarray'>\begin{eqnarray*} f_{1}(\vec{x},\vec{\alpha }) &amp; = &amp; (\mathrm{N}1\leftarrow \mathrm{N}1+1)^{x_{1}}...(\mathrm{N}\bar{n}\leftarrow \mathrm{N}\bar{n}+1)^{x_{n}}\\ f_{1}(\vec{x},\vec{\alpha }) &amp; = &amp; \left (\subset _{i=1}^{i=\left \vert \alpha _{1}\right \vert }\mathrm{P}1\leftarrow \mathrm{P}1.[\alpha _{1}]_{i}\right )...\left (\subset _{i=1}^{i=\left \vert \alpha _{m}\right \vert }\mathrm{P}1\leftarrow \mathrm{P}1.[\alpha _{m}]_{i}\right ) \end{eqnarray*}
</div>Sea \(f:\omega ^{n}\times \Sigma ^{\ast m}\times \mathrm{Pro}^{\Sigma }\rightarrow (\Sigma \cup \Sigma _{p})^{\ast }\) dada por \[ f(\vec{x},\vec{\alpha },\mathcal{P})=f_{1}(\vec{x},\vec{\alpha })f_{1}(\vec{x},\vec{\alpha })\mathcal{P} \] Es facil ver que \(f\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Notese que \(\Phi _{\#}^{n,m}=\Phi _{\#}^{0,0}\circ f\). Ademas notese que \[ \Phi _{\#}^{0,0}=\Phi _{\#}^{n,m}\circ \left [C_{0}^{0,1},...,C_{0}^{0,1},C_{\varepsilon }^{0,1},...,C_{\varepsilon }^{0,1},p_{1}^{0,1}\right ] \] Ya que \(f\) y
las funciones \(C_{0}^{0,1},C_{\varepsilon }^{0,1},p_{1}^{0,1}\) son \((\Sigma \cup \Sigma _{p})\)-p.r., tenemos que \(\Phi _{\#}^{n,m}\) es \((\Sigma \cup \Sigma _{p})\)-p.r. sii \(\Phi _{\#}^{0,0}\) lo es.
<!-- l. 9500 --><p class='indent'>   Supongamos ahora que para algunos \(k,l\in \omega \) se tiene que \(\Phi _{\#}^{k,l}\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Llegaremos a un
absurdo. Por lo antes probado tenemos que \(\Phi _{\#}^{n,m}\) es \((\Sigma \cup \Sigma _{p})\)-p.r., cualesquiera sean \(n,m\in \omega \). Notese que
de la prueba del teorema anterior sigue que toda funcion \(\Sigma \)-computable con imagen
contenida en \(\omega \) es de la forma \(\Phi _{\#}^{n,m}\circ \left [p_{1}^{n,m},...,p_{n+m}^{n,m},C_{\mathcal{P}_{0}}^{n,m}\right ]\), para algunos \(n,m\in \omega \) y \(\mathcal{P}_{0}\in \mathrm{Pro}^{\Sigma }\). Pero entonces toda funcion
\(\Sigma \)-computable con imagen contenida en \(\omega \) es \((\Sigma \cup \Sigma _{p})\)-p.r., lo cual por el Teorema <a href='#x1-120001r104'>104<!-- tex4ht:ref: computable-implica-recursiva  --></a> nos dice
que toda funcion \(\Sigma \)-computable con imagen contenida en \(\omega \) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Esto contradice la

Proposicion <a href='#x1-89002r66'>66<!-- tex4ht:ref: recursivo no implica PR  --></a>.
</p><!-- l. 9513 --><p class='indent'>   Ahora supongamos que hay \(n,m\in \omega \) tales que \(T^{n,m}\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Llegaremos a un absurdo. Como
ya vimos en la prueba de un teorema reciente, se tiene que \[ \Phi _{\#}^{n,m}=E_{\#1}^{n,m}\circ \left [T^{n,m},p_{1}^{n,m+1},...,p_{n+m+1}^{n,m+1}\right ] \] Pero entonces ya que \(E_{\#1}^{n,m}\) es
\((\Sigma \cup \Sigma _{p})\)-p.r., tenemos que \(\Phi _{\#}^{n,m}\) es \((\Sigma \cup \Sigma _{p})\)-p.r., lo cual como ya vimos recien no es cierto. El absurdo nos
dice que \(T^{n,m}\) no es \((\Sigma \cup \Sigma _{p})\)-p.r..                                                                           □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 9524 --><p class='noindent'><span class='head'>
<a id='x1-120004r107'></a>
<span class='cmbx-10'>Corollary 107.</span>  </span><span class='cmti-10'>La minimizacion de un predicado</span> \(\Sigma \)<span class='cmti-10'>-p.r. no necesariamente es</span>
\(\Sigma \)<span class='cmti-10'>-p.r.</span>
</p>
   </div>
<!-- l. 9529 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9530 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Por definicion \(T^{n,m}=M(Halt^{n,m})\).                                                                         □
</p>
   </div>
<!-- l. 9536 --><p class='noindent'><span class='paragraphHead'><a id='x1-1210003.4.2'></a><span class='cmbx-10'>Uso de macros asociados a las funciones</span> \(Halt^{n,m}\)<span class='cmbx-10'>,</span> \(E_{\#}^{n,m}\) <span class='cmbx-10'>y</span> \(E_{\ast }^{n,m}\)</span>
   Aqui veremos, con ejemplos, como ciertos macros nos permitiran dentro de un
programa hablar acerca del funcionamiento de otro programa. Esto junto con el
hecho que cada funcion \(\Sigma \)-recursiva y cada predicado \(\Sigma \)-recursivo tienen su macro
asociado (Corolario <a href='#x1-112003r91'>91<!-- tex4ht:ref: recursivo implica macro  --></a>), sera muy util a la hora del diseño de programas y nos
permitira simular dentro del paradigma imperativo muchas ideas usadas para el
diseño de procedimientos efectivos. En este sentido la convinacion de los dos
paradigmas (recursivo e imperativo) nos permite fortalecer notablemente al
paradigma imperativo en su roll modelizador (o simulador) de los procedimientos
efectivos. Esto es importante ya que el paradigma mas comodo, amplio e intuitivo,
a la hora de decidir si algo es o no computable, es sin duda el filosofico o
efectivo.
</p><!-- l. 9552 --><p class='indent'>   Veamos el primer ejemplo. Sea \(\Sigma =\{@,!\}\) y sea \(\mathcal{P}_{0}\in \mathrm{Pro}^{\Sigma }\) tal que \(0\in \mathrm{Dom}\Psi _{\mathcal{P}_{0}}^{1,0,\#}\) y \(\Psi _{\mathcal{P}_{0}}^{1,0,\#}(0)=2\). Probaremos que \[ S=\{x\in \mathrm{Dom}\Psi _{\mathcal{P}_{0}}^{1,0,\#}:\Psi _{\mathcal{P}_{0}}^{1,0,\#}(x)\neq 0\} \] es
\(\Sigma \)-enumerable. Notese que \(0\in S\). Por definicion de conjunto \(\Sigma \)-enumerable, deberemos
encontrar un programa \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) tal que \(\mathrm{Dom}\Psi _{\mathcal{P}}^{1,0,\#}=\omega \) y \(\mathrm{Im}\Psi _{\mathcal{P}}^{1,0,\#}=S\). Dicho en palabras, el programa \(\mathcal{P}\) debera
cumplir:

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-121001x3.4.2'>siempre que lo corramos desde un estado de la forma \(\left \Vert x\right \Vert \), con \(x\in \omega \), debe detenerse
     y el contenido de la variable \(\mathrm{N}1\) bajo detencion debera ser un elemento de \(S\)
     </li>
     <li class='enumerate' id='x1-121002x3.4.2'>para cada \(s\in S\) debera haber un \(x\in \omega \) tal que \(s\) es el valor de la variable \(\mathrm{N}1\) bajo
     detencion cuando corremos \(\mathcal{P}\) desde \(\left \Vert x\right \Vert \)</li></ol>
<!-- l. 9572 --><p class='indent'>   A continuacion daremos una descripcion intuitiva del funcionamiento de \(\mathcal{P}\)
(pseudocodigo) para luego escribirlo correctamente usando macros. El programa \(\mathcal{P}\)
comenzara del estado \(\left \Vert x\right \Vert \) y hara las siguientes tareas
</p><!-- l. 9579 --><p class='indent'>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-121003x3.4.2'>Etapa 1: si \(x=0\) ir a Etapa 6, en caso contrario ir a Etapa 2.
     </li>
     <li class='enumerate' id='x1-121004x3.4.2'>Etapa 2: calcular \((x)_{1}\) y \((x)_{2}\) e ir a Etapa 3.
     </li>
     <li class='enumerate' id='x1-121005x3.4.2'>Etapa 3: si \(\mathcal{P}_{0}\) termina desde \(\left \Vert (x)_{1}\right \Vert \) en \((x)_{2}\) pasos ir a Etapa 4, en caso contrario ir a
     Etapa 6
     </li>
     <li class='enumerate' id='x1-121006x3.4.2'>Etapa 4: si el valor que queda en \(\mathrm{N}1\) luego de correr \(\mathcal{P}_{0}\) una cantidad \((x)_{2}\) de pasos,
     partiendo de \(\left \Vert (x)_{1}\right \Vert \), es distinto de 0, entonces ir a Etapa 5. En caso contrario ir
     a Etapa 6.
     </li>
     <li class='enumerate' id='x1-121007x3.4.2'>Etapa 5: asignar a \(\mathrm{N}1\) el valor \((x)_{1}\) y terminar
     </li>
     <li class='enumerate' id='x1-121008x3.4.2'>Etapa 6: asignar a \(\mathrm{N}1\) el valor \(0\) y terminar</li></ol>
<!-- l. 9593 --><p class='indent'>   Notese que la descripcion anterior no es ni mas ni menos que un procedimiento
efectivo que enumera a \(S\), y nuestra mision es simularlo dentro del lenguaje \(\mathcal{S}^{\Sigma }\). Para
esto usaremos varios macros. Ya que la funcion \(f=\lambda x[(x)_{1}]\) es \(\Sigma \)-p.r., el Corolario <a href='#x1-112003r91'>91<!-- tex4ht:ref: recursivo implica macro  --></a>
nos dice que hay un macro: \[ [\mathrm{V}2\leftarrow f(\mathrm{V}1)] \] el cual escribiremos de la siguiente manera
mas intuitiva: \[ [\mathrm{V}2\leftarrow (\mathrm{V}1)_{1}] \] Similarmente hay un macro: \[ [\mathrm{V}2\leftarrow (\mathrm{V}1)_{2}] \] Tambien, ya que el predicado \(P=\lambda x[x=0]\)
es \(\Sigma \)-recursivo, hay un macro: \[ \left [\mathrm{IF}\;P(\mathrm{V}1)\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] el cual escribiremos de la siguiente manera: \[ \left [\mathrm{IF}\;\mathrm{V}1=0\;\mathrm{GOTO}\;\mathrm{A}1\right ] \]
Definamos \[ H=\lambda tx\left [Halt^{1,0}(t,x,\mathcal{P}_{0})\right ] \] Notar que \(D_{H}=\omega ^{2}\) y que \(H\) es \(\Sigma \)-mixta. Ademas sabemos que la funcion \(Halt^{1,0}\)
es \((\Sigma \cup \Sigma _{p})\)-p.r. por lo cual resulta facilmente que \(H\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Por la Proposicion de
Independencia del Alfabeto tenemos que \(H\) es \(\Sigma \)-p.r.. O sea que el Corolario <a href='#x1-112003r91'>91<!-- tex4ht:ref: recursivo implica macro  --></a> nos
dice que hay un macro: \[ \left [\mathrm{IF}\;H(\mathrm{V}1,\mathrm{V}2)\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Para hacer mas intuitivo el uso de este macro lo
escribiremos de la siguiente manera \[ \left [\mathrm{IF}\;Halt^{1,0}(\mathrm{V}1,\mathrm{V}2,\mathcal{P}_{0})\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Sea \[ g=\lambda tx\left [E_{\#1}^{1,0}(t,x,\mathcal{P}_{0})\right ] \] Ya que \(g\) es \(\Sigma \)-recursiva (por que?), hay un
macro: \[ \left [\mathrm{V}3\leftarrow g(\mathrm{V}1,\mathrm{V}2)\right ] \] Para hacer mas intuitivo el uso de este macro lo escribiremos de la
siguiente manera \[ \left [\mathrm{V}3\leftarrow E_{\#1}^{1,0}(\mathrm{V}1,\mathrm{V}2,\mathcal{P}_{0})\right ] \] Ahora si podemos dar nuestro progama \(\mathcal{P}\) que enumera a \(S\):
\[ \begin{array}{ll} &amp; \mathrm{IF}\;\mathrm{N}1\neq 0\;\mathrm{GOTO}\;\mathrm{L}1\\ &amp; \mathrm{GOTO}\;\mathrm{L}2\\ \mathrm{L}1 &amp; [\mathrm{N}3\leftarrow (\mathrm{N}1)_{1}]\\ &amp; [\mathrm{N}4\leftarrow (\mathrm{N}1)_{2}]\\ &amp; \left [\mathrm{IF}\;Halt^{1,0}(\mathrm{N}4,\mathrm{N}3,\mathcal{P}_{0})\;\mathrm{GOTO}\;\mathrm{L}3\right ]\\ &amp; \mathrm{GOTO}\;\mathrm{L}2\\ \mathrm{L}3 &amp; \left [\mathrm{N}5\leftarrow E_{\#1}^{1,0}(\mathrm{N}4,\mathrm{N}3,\mathcal{P}_{0})\right ]\\ &amp; [\mathrm{IF}\;\mathrm{N}5=0\;\mathrm{GOTO}\;\mathrm{L}2]\\ &amp; \mathrm{N}1\leftarrow \mathrm{N}3\\ &amp; \mathrm{GOTO}\;\mathrm{L}4\\ \mathrm{L}2 &amp; \mathrm{N}1\leftarrow 0\\ \mathrm{L}4 &amp; \mathrm{SKIP} \end{array} \]

</p>
<!-- l. 9671 --><p class='indent'>   <span class='subparagraphHead'> <a id='x1-1220003.4.2'></a><span class='cmbx-10'>Enumeracion de conjuntos de programas</span></span>
   Ya que los programas de \(\mathcal{S}^{\Sigma }\) son palabras del alfabeto \(\Sigma \cup \Sigma _{p}\), nos podemos preguntar
cuando un conjunto \(L\) de programas es \((\Sigma \cup \Sigma _{p})\)-enumerable. Daremos un ejemplo. Sea \(\Sigma =\{@,!\}\) y sea \[ L=\{\mathcal{P}\in \mathrm{Pro}^{\Sigma }:\Psi _{\mathcal{P}}^{1,0,\#}(10)=10\} \]
Veremos que \(L\) es \((\Sigma \cup \Sigma _{p})\)-enumerable, dando un programa \(\mathcal{Q}\in \mathrm{Pro}^{\Sigma \cup \Sigma _{p}}\) que enumere a \(L\), es decir tal que
Dom\((\Psi _{\mathcal{Q}}^{1,0,\ast })=\omega \) y \(\mathrm{Im}(\Psi _{\mathcal{Q}}^{1,0,\ast })=L\). Cabe destacar que aqui hay en juego dos versiones de nuestro lenguaje
imperativo, es decir enumeraremos un conjunto de programas de \(\mathcal{S}^{\Sigma }\) usando un
programa de \(\mathcal{S}^{\Sigma \cup \Sigma _{p}}\). Sea \(\leq \) un orden total sobre el conjunto \(\Sigma \cup \Sigma _{p}\).
</p><!-- l. 9689 --><p class='indent'>   A continuacion daremos una descripcion intuitiva del funcionamiento de \(\mathcal{Q}\)
(pseudocodigo) para luego escribirlo correctamente usando macros. Notese que \(\mathrm{SKIP}\in L\). El
programa \(\mathcal{Q}\) comenzara del estado \(\left \Vert x\right \Vert \) y hara las siguientes tareas
</p><!-- l. 9697 --><p class='indent'>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-122001x3.4.2'>Etapa 1: si \(x=0\) ir a Etapa 6, en caso contrario ir a Etapa 2.
     </li>
     <li class='enumerate' id='x1-122002x3.4.2'>Etapa 2: calcular \((x)_{1}\), \((x)_{2}\) y \(\ast ^{\leq }((x)_{1})\) e ir a Etapa 3.
     </li>
     <li class='enumerate' id='x1-122003x3.4.2'>Etapa 3: si \(\ast ^{\leq }((x)_{1})\in \mathrm{Pro}^{\Sigma }\) y termina partiendo desde \(\left \Vert 10\right \Vert \) en \((x)_{2}\) pasos ir a Etapa 4, en caso
     contrario ir a Etapa 6
     </li>
     <li class='enumerate' id='x1-122004x3.4.2'>Etapa 4: si el valor que queda en \(\mathrm{N}1\) luego de correr \(\ast ^{\leq }((x)_{1})\) una cantidad \((x)_{2}\) de pasos,
     partiendo de \(\left \Vert 10\right \Vert \) es igual a 10, entonces ir a Etapa 5. En caso contrario ir a
     Etapa 6.
     </li>
     <li class='enumerate' id='x1-122005x3.4.2'>Etapa 5: asignar a \(\mathrm{P}1\) la palabra \(\ast ^{\leq }((x)_{1})\) y terminar
     </li>
     <li class='enumerate' id='x1-122006x3.4.2'>Etapa 6: asignar a \(\mathrm{P}1\) la palabra \(\mathrm{SKIP}\) y terminar</li></ol>
<!-- l. 9714 --><p class='indent'>   Notese que la descripcion anterior no es ni mas ni menos que un procedimiento
efectivo que enumera a \(L\), y nuestra mision es simularlo dentro del lenguaje \(\mathcal{S}^{\Sigma \cup \Sigma _{p}}\). Para esto
usaremos varios macros. Es importante notar que los macros que usaremos
corresponden al lenguaje \(\mathcal{S}^{\Sigma \cup \Sigma _{p}}\) ya que los usaremos en \(\mathcal{Q}\) el cual sera un programa de
\(\mathcal{S}^{\Sigma \cup \Sigma _{p}}\).
</p><!-- l. 9721 --><p class='indent'>   Ya que las funciones \(\lambda x[(x)_{1}]\) y \(\lambda x[(x)_{2}]\) son \((\Sigma \cup \Sigma _{p})\)-recursivas el Corolario <a href='#x1-112003r91'>91<!-- tex4ht:ref: recursivo implica macro  --></a> nos dice que hay macros
asociados a estas funciones los cuales escribiremos de la siguiente manera mas
intuitiva: </p><div class='eqnarray'>\begin{eqnarray*} [\mathrm{V}2 &amp; \leftarrow &amp; (\mathrm{V}1)_{1}]\\{} [\mathrm{V}2 &amp; \leftarrow &amp; (\mathrm{V}1)_{2}] \end{eqnarray*}
</div>Ya que el predicado \(P=\lambda x[x=10]\) es \((\Sigma \cup \Sigma _{p})\)-recursivo tenemos su macro asociado el cual escribiremos de
la siguiente manera: \[ \left [\mathrm{IF}\;\mathrm{V}1=10\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Por un lema anterior sabemos que \(\mathrm{Pro}^{\Sigma }\) es un conjunto \((\Sigma \cup \Sigma _{p})\)-p.r. por lo

cual \(\chi _{\mathrm{Pro}^{\Sigma }}^{(\Sigma \cup \Sigma _{p})^{\ast }}\) es \((\Sigma \cup \Sigma _{p})\)-p.r., por lo cual hay un macro \[ \left [\mathrm{IF}\;\chi _{\mathrm{Pro}^{\Sigma }}^{(\Sigma \cup \Sigma _{p})^{\ast }}(\mathrm{W}1)\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] el cual escribiremos de la siguiente manera \[ \left [\mathrm{IF}\;\mathrm{W}1\in \mathrm{Pro}^{\Sigma }\;\mathrm{GOTO}\;\mathrm{A}1\right ] \]
Ya que el predicado \(Halt^{1,0}\) es \((\Sigma \cup \Sigma _{p})\)-recursivo tenemos un macro asociado a el, el cual
escribiremos de la siguiente forma \[ \left [\mathrm{IF}\;Halt^{1,0}(\mathrm{V}1,\mathrm{V}2,\mathrm{W}1)\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Ya que \(E_{\#1}^{1,0}\) es \((\Sigma \cup \Sigma _{p})\)-recursivo tenemos un macro asociado
a ella, el cual escribiremos de la siguiente forma \[ \left [\mathrm{V}3\leftarrow E_{\#1}^{1,0}(\mathrm{V}1,\mathrm{V}2,\mathrm{W}1)\right ] \] Tambien usaremos macros
<div class='gather-star'><img alt=' ' src='apunte4x.png' /></div>(dejamos al lector hacerlos a mano o tambien se puede justificar su existencia via la
proposicion de existencia de macros aplicada a las funciones \(C_{10}^{0,0}\) y \(C_{\mathrm{SKIP}}^{0,0}\)).
<!-- l. 9764 --><p class='indent'>   Ahora si podemos hacer el programa \(\mathcal{Q}\) que enumera a \(L\):
</p><!-- l. 9783 --><p class='indent'>   \[ \begin{array}{ll} &amp; \mathrm{IF}\;\mathrm{N}1\neq 0\;\mathrm{GOTO}\;\mathrm{L}1\\ &amp; \mathrm{GOTO}\;\mathrm{L}2\\ \mathrm{L}1 &amp; [\mathrm{N}2\leftarrow (\mathrm{N}1)_{1}]\\ &amp; [\mathrm{N}3\leftarrow (\mathrm{N}1)_{2}]\\ &amp; [\mathrm{P}1\leftarrow \ast ^{\leq }(\mathrm{N}2)]\\ &amp; \left [\mathrm{IF}\;\mathrm{P}1\in \mathrm{Pro}^{\Sigma }\;\mathrm{GOTO}\;\mathrm{L}3\right ]\\ &amp; \mathrm{GOTO}\;\mathrm{L}2\\ \mathrm{L}3 &amp; [\mathrm{N}4\leftarrow 10]\\ &amp; \left [\mathrm{IF}\;Halt^{1,0}(\mathrm{N}3,\mathrm{N}4,\mathrm{P}1)\;\mathrm{GOTO}\;\mathrm{L}4\right ]\\ &amp; \mathrm{GOTO}\;\mathrm{L}2\\ \mathrm{L}4 &amp; \left [\mathrm{N}5\leftarrow E_{\#1}^{1,0}(\mathrm{N}3,\mathrm{N}4,\mathrm{P}1)\right ]\\ &amp; [\mathrm{IF}\;\mathrm{N}5=10\;\mathrm{GOTO}\;\mathrm{L}4]\\ \mathrm{L}2 &amp; \left [\mathrm{P}1\leftarrow \mathrm{SKIP}\right ]\\ \mathrm{L}4 &amp; \mathrm{SKIP} \end{array} \]
</p><!-- l. 9788 --><p class='indent'>   Cuando \(\Sigma \supseteq \Sigma _{p}\) podemos correr un programa \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) partiendo de un estado que asigne a sus
variables alfabeticas programas (ya que los programas son meras palabras de \(\Sigma ^{\ast }\)). En
particular podriamos correr un programa \(\mathcal{P}\) desde el estado \(\left \Vert \mathcal{P}\right \Vert \). Llamaremos \(A\) al conjunto
formado por aquellos programas \(\mathcal{P}\) tales que \(\mathcal{P}\) se detiene partiendo del estado \(\left \Vert \mathcal{P}\right \Vert \). Es decir \[ A=\{\mathcal{P}\in \mathrm{Pro}^{\Sigma }:\exists t\in \omega \text{ tal que }Halt^{0,1}(t,\mathcal{P},\mathcal{P})=1\} \]
Por ejemplo \(\mathrm{SKIP}\in A\). Dicho rapida y sugestivamente \(A\) es el conjunto formado por aquellos
programas que se detienen partiendo de si mismos. Dejamos al lector hacer un
programa que enumere a \(A\). Como veremos mas adelante este conjunto, si bien es
\(\Sigma \)-enumerable, no es \(\Sigma \)-computable.
</p><!-- l. 9808 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.4.3   </span> <a id='x1-1230003.4.3'></a>Godel vence a Turing</h5>
<!-- l. 9810 --><p class='noindent'>Para probar que toda funcion \(\Sigma \)-Turing computable es \(\Sigma \)-recursiva debemos estudiar la
recursividad del funcionamiento de las maquinas de Turing. Cabe destacar
que tal como se lo explico en la Subseccion <a href='#x1-600003.1'>3.1<!-- tex4ht:ref: BasicosMaquinasDeTuring  --></a> supondremos siempre que el
conjunto de estados de una maquina de Turing \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,F\right )\) es un alfabeto disjunto con
\(\Gamma \).
</p><!-- l. 9817 --><p class='indent'>   Primero probaremos algunos lemas basicos.
</p>
   <div class='newtheorem'>
<!-- l. 9818 --><p class='noindent'><span class='head'>
<a id='x1-123001r108'></a>
<span class='cmbx-10'>Lema 108.</span>  </span><span class='cmti-10'>Sea</span> \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,F\right )\) <span class='cmti-10'>una maquina de Turing. Entonces</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-123002x108'>\(Des\) <span class='cmti-10'>es un conjunto</span> \((\Gamma \cup Q)\)<span class='cmti-10'>-p.r.</span>
     </li>
     <li class='enumerate' id='x1-123003x108'>\(St:Des\rightarrow Q\) <span class='cmti-10'>es una funcion</span> \((\Gamma \cup Q)\)<span class='cmti-10'>-p.r.</span></li></ol>

   </div>
<!-- l. 9829 --><p class='indent'>   Notese que la funcion \(\delta \) de una maquina de Turing \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,F\right )\) no es \((\Gamma \cup Q)\)-mixta. Sin
envargo los siguientes predicados \((\Gamma \cup Q)\)-mixtos contienen toda la informacion de \(\delta \): \[ \begin{array}{rcl} P_{L}:Q\times \Gamma \times Q\times \Gamma &amp; \rightarrow &amp; \omega \\ (p,\sigma ,q,\gamma ) &amp; \rightarrow &amp; \left \{ \begin{array}{ccl} 1 &amp; &amp; \text{si }(p,\sigma ,L)\in \delta (q,\gamma )\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \end{array} \] \[ \begin{array}{rcl} P_{L}:Q\times \Gamma \times Q\times \Gamma &amp; \rightarrow &amp; \omega \\ (p,\sigma ,q,\gamma ) &amp; \rightarrow &amp; \left \{ \begin{array}{ccl} 1 &amp; &amp; \text{si }(p,\sigma ,L)\in \delta (q,\gamma )\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \end{array} \] \[ \begin{array}{rcl} P_{R}:Q\times \Gamma \times Q\times \Gamma &amp; \rightarrow &amp; \omega \\ (p,\sigma ,q,\gamma ) &amp; \rightarrow &amp; \left \{ \begin{array}{ccl} 1 &amp; &amp; \text{si }(p,\sigma ,R)\in \delta (q,\gamma )\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \end{array} \]
\[ \begin{array}{rcl} P_{K}:Q\times \Gamma \times Q\times \Gamma &amp; \rightarrow &amp; \omega \\ (p,\sigma ,q,\gamma ) &amp; \rightarrow &amp; \left \{ \begin{array}{ccl} 1 &amp; &amp; \text{si }(p,\sigma ,K)\in \delta (q,\gamma )\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \end{array} \]
</p>
   <div class='newtheorem'>
<!-- l. 9869 --><p class='noindent'><span class='head'>
<a id='x1-123004r109'></a>
<span class='cmbx-10'>Lema 109.</span>  </span><span class='cmti-10'>Sea</span> \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,F\right )\) <span class='cmti-10'>una maquina de Turing. Entonces los predicados</span> \(P_{L},P_{R}\) <span class='cmti-10'>y</span> \(P_{K}\) <span class='cmti-10'>son</span> \((\Gamma \cup Q)\)<span class='cmti-10'>-p.r.</span>
</p>
   </div>
<!-- l. 9874 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9875 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que los tres predicados tienen dominio finito, el Corolario <a href='#x1-84002r59'>59<!-- tex4ht:ref: dom-finito  --></a> nos dice
que son \((\Gamma \cup Q)\)-p.r.                                                                                     □
</p>
   </div>
<!-- l. 9880 --><p class='indent'>   Recordemos que dado \(\alpha \in (Q\cup \Gamma )^{\ast }\), definimos \(\left \lfloor \alpha \right \rfloor \) de la siguiente manera </p><div class='eqnarray'>\begin{eqnarray*} \left \lfloor \varepsilon \right \rfloor &amp; = &amp; \varepsilon \\ \left \lfloor \alpha \sigma \right \rfloor &amp; = &amp; \alpha \sigma \text{, si }\sigma \neq B\\ \left \lfloor \alpha B\right \rfloor &amp; = &amp; \left \lfloor \alpha \right \rfloor  \end{eqnarray*}
</div>Es decir \(\left \lfloor \alpha \right \rfloor \) es el resultado de remover de \(\alpha \) el tramo final mas grande de la forma
\(B^{n}\).
<!-- l. 9890 --><p class='indent'>   Tambien dada cualquier palabra \(\alpha \) definimos
</p>
   <div class='eqnarray'>\begin{eqnarray*} ^{\curvearrowright }\alpha &amp; = &amp; \left \{ \begin{array}{lll} \left [\alpha \right ]_{2}...\left [\alpha \right ]_{\left \vert \alpha \right \vert } &amp; \text{si} &amp; \left \vert \alpha \right \vert \geq 2\\ \varepsilon &amp; \text{si} &amp; \left \vert \alpha \right \vert \leq 1 \end{array}\right .\\ \alpha ^{\curvearrowleft } &amp; = &amp; \left \{ \begin{array}{lll} \left [\alpha \right ]_{1}...\left [\alpha \right ]_{\left \vert \alpha \right \vert -1} &amp; \text{si} &amp; \left \vert \alpha \right \vert \geq 2\\ \varepsilon &amp; \text{si} &amp; \left \vert \alpha \right \vert \leq 1 \end{array}\right . \end{eqnarray*}
</div>
   <div class='newtheorem'>
<!-- l. 9903 --><p class='noindent'><span class='head'>
<a id='x1-123005r110'></a>
<span class='cmbx-10'>Lema 110.</span>  </span><span class='cmti-10'>Las funciones</span> \(\lambda \alpha [\left \lfloor \alpha \right \rfloor ]\)<span class='cmti-10'>,</span> \(\lambda \alpha [^{\curvearrowright }\alpha ]\) <span class='cmti-10'>y</span> \(\lambda \alpha [\alpha ^{\curvearrowleft }]\) <span class='cmti-10'>son</span> \((\Gamma \cup Q)\)<span class='cmti-10'>-p.r.. (Notar que la notacion</span> \(\lambda \) <span class='cmti-10'>aqui es
</span><span class='cmti-10'>respecto del alfabeto</span> \(\Gamma \cup Q\) <span class='cmti-10'>por lo cual las tres funciones tienen dominio igual a</span> \((\Gamma \cup Q)^{\ast }\)<span class='cmti-10'>.)</span>
</p>
   </div>
<!-- l. 9913 --><p class='indent'>   Notese que dada una maquina de Turing \(M\), la expresion \(d\underset{M}{\vdash }d^{\prime }\) fue definida solo en el
caso en que \(d\) y \(d^{\prime }\) son descripciones instantaneas. Es decir que el predicado \(\lambda dd^{\prime }\left [d\vdash d^{\prime }\right ]\) tiene
dominio igual a \(Des\times Des\).

</p>
   <div class='newtheorem'>
<!-- l. 9917 --><p class='noindent'><span class='head'>
<a id='x1-123006r111'></a>
<span class='cmbx-10'>Lema 111.</span>  </span><span class='cmti-10'>El predicado</span> \(\lambda dd^{\prime }\left [d\underset{M}{\vdash }d^{\prime }\right ]\) <span class='cmti-10'>es</span> \((\Gamma \cup Q)\)<span class='cmti-10'>-p.r..</span>
</p>
   </div>
<!-- l. 9922 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9923 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea \(\tilde{P}_{L}:Des\times Des\times \Gamma \times \Gamma ^{\ast }\times \Gamma ^{\ast }\times Q\times Q\rightarrow \omega \) definido por \(\tilde{P}_{L}(d,d^{\prime },\sigma ,\alpha ,\beta ,p,q)=1\) sii \[ d=\alpha p\beta \wedge (q,\sigma ,L)\in \delta \left (p,\left [\beta B\right ]_{1}\right )\wedge \alpha \neq \varepsilon \wedge d^{\prime }=\left \lfloor \alpha ^{\curvearrowleft }q\left [\alpha \right ]_{\left \vert \alpha \right \vert }\sigma ^{\curvearrowright }\beta \right \rfloor \] Sea \(\tilde{P}_{R}:Des\times Des\times \Gamma \times \Gamma ^{\ast }\times \Gamma ^{\ast }\times Q\times Q\rightarrow \omega \) definido por \(\tilde{P}_{R}(d,d^{\prime },\sigma ,\alpha ,\beta ,p,q)=1\) sii \[ d=\alpha p\beta \wedge (q,\sigma ,R)\in \delta \left (p,\left [\beta B\right ]_{1}\right )\wedge d^{\prime }=\alpha \sigma q^{\curvearrowright }\beta \] Sea \(\tilde{P}_{K}:Des\times Des\times \Gamma \times \Gamma ^{\ast }\times \Gamma ^{\ast }\times Q\times Q\rightarrow \omega \) definido por \(\tilde{P}_{K}(d,d^{\prime },\sigma ,\alpha ,\beta ,p,q)=1\) sii \[ d=\alpha p\beta \wedge (q,\sigma ,K)\in \delta \left (p,\left [\beta B\right ]_{1}\right )\wedge d^{\prime }=\left \lfloor \alpha q\sigma ^{\curvearrowright }\beta \right \rfloor \] Se deja
al lector la verificacion de que estos predicados son \((\Gamma \cup Q)\)-p.r.. Notese que \(\lambda dd^{\prime }\left [d\underset{M}{\vdash }d^{\prime }\right ]\) es igual al
predicado \[ \lambda dd^{\prime }\left [(\exists \sigma \in \Gamma )(\exists \alpha ,\beta \in \Gamma ^{\ast })(\exists p,q\in Q)(\tilde{P}_{R}\vee \tilde{P}_{L}\vee \tilde{P}_{K})(d,d^{\prime },\sigma ,\alpha ,\beta ,p,q)\right ] \] lo cual por el Lema <a href='#x1-86001r62'>62<!-- tex4ht:ref: cuantificacion  --></a> nos dice que \(\lambda dd^{\prime }\left [d\underset{M}{\vdash }d^{\prime }\right ]\) es \((\Gamma \cup Q)\)-p.r.                              □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 9950 --><p class='noindent'><span class='head'>
<a id='x1-123007r112'></a>
<span class='cmbx-10'>Proposition 112.</span>  </span>\(\lambda ndd^{\prime }\left [d\underset{M}{\overset{n}{\vdash }}d^{\prime }\right ]\) <span class='cmti-10'>es</span> \((\Gamma \cup Q)\)<span class='cmti-10'>-p.r..</span>
</p>
   </div>
<!-- l. 9955 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9956 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea \(Q=\lambda dd^{\prime }\left [d\underset{M}{\vdash }d^{\prime }\right ]\cup C_{0}^{0,2}|_{(\Gamma \cup Q)^{\ast 2}-Des^{2}}\) es decir \(Q\) es el resultado de extender con el valor \(0\) al predicado \(\lambda dd^{\prime }\left [d\underset{M}{\vdash }d^{\prime }\right ]\) de
manera que este definido en todo \((\Gamma \cup Q)^{\ast 2}\). Sea \(\leq \) un orden total sobre \(\Gamma \cup Q\) y sea \(Q_{1}:\mathbf{N}\times Des\times Des\rightarrow \omega \) definido
por \(Q_{1}(x,d,d^{\prime })=1\) sii
</p><!-- l. 9963 --><p class='indent'>   \(\left ((\forall i\in \mathbf{N})_{i\leq Lt(x)}\ast ^{\leq }((x)_{i})\in Des\right )\wedge \ast ^{\leq }((x)_{1})=d\wedge \)
</p><!-- l. 9965 --><p class='indent'>   \(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ast ^{\leq }((x)_{Lt(x)})=d^{\prime }\wedge \left ((\forall i\in \mathbf{N})_{i\leq Lt(x)\dot{-}1}\;Q(\ast ^{\leq }((x)_{i}),\ast ^{\leq }((x)_{i+1}))\right )\)
</p><!-- l. 9967 --><p class='noindent'>Notese que dicho rapidamente \(Q_{1}(x,d,d^{\prime })=1\) sii \(x\) codifica una computacion que parte de \(d\) y
llega a \(d^{\prime }\). Se deja al lector la verificacion de que este predicado es \((\Gamma \cup Q)\)-p.r.. Notese
que \[ \lambda ndd^{\prime }\left [d\underset{M}{\overset{n}{\vdash }}d^{\prime }\right ]=\lambda ndd^{\prime }\left [\left (\exists x\in \mathbf{N}\right )\;Lt(x)=n+1\wedge Q_{1}(x,d,d^{\prime })\right ] \] Es decir que solo nos falta acotar el cuantificador existencial, para poder
aplicar el lema de cuantificacion acotada. Ya que cuando \(d_{1},...,d_{n+1}\in Des\) son tales que \(d_{1}\underset{M}{\vdash }d_{2}\underset{M}{\vdash }\cdots \underset{M}{\vdash }d_{n+1}\) tenemos

que \[ \left \vert d_{i}\right \vert \leq \left \vert d_{1}\right \vert +n\text{, para }i=1,...,n \] una posible cota para dicho cuantificador es \[ \prod _{i=1}^{n+1}pr(i)^{\left \vert \Gamma \cup Q\right \vert ^{\left \vert d\right \vert +n}}\text{.} \] O sea que, por el lema de
cuantificacion acotada, tenemos que el predicado \(\lambda ndd^{\prime }\left [d\underset{M}{\overset{n}{\vdash }}d^{\prime }\right ]\) es \((\Gamma \cup Q)\)-p.r.                           □
</p>
   </div>
<!-- l. 9991 --><p class='indent'>   @@finpagina@@
</p>
   <div class='newtheorem'>
<!-- l. 9992 --><p class='noindent'><span class='head'>
<a id='x1-123008r113'></a>
<span class='cmbx-10'>Teorema 113.</span>  </span><span class='cmti-10'>Supongamos</span> \(f:S\subseteq \omega ^{n}\times \Sigma ^{\ast }{}^{m}\rightarrow O\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-Turing computable. Entonces</span> \(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva.</span>
</p>
   </div>
<!-- l. 9997 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 9998 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(O=\Sigma ^{\ast }\) y sea \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,\shortmid ,F\right )\) una maquina de Turing deterministica con unit la cual
compute a \(f\). Sea \(\leq \) un orden total sobre \(\Sigma \). Notese que por el Teorema <a href='#x1-97010r84'>84<!-- tex4ht:ref: independencia  --></a>, la funcion \(\ast ^{\leq }\) es
\((\Gamma \cup Q)\)-p.r.. Sea \(P:\mathbf{N}\times \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) dado por \(P(x,\vec{x},\vec{\alpha })=1\) sii
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-123010x1'>\((\exists q\in Q)\;\left \lfloor q_{0}B\shortmid ^{x_{1}}...B\shortmid ^{x_{n}}B\alpha _{1}...B\alpha _{m}\right \rfloor \underset{M}{\overset{(x)_{1}}{\vdash }}\left \lfloor qB\ast ^{\leq }((x)_{2})\right \rfloor \wedge \)
     </li>
     <li class='enumerate' id='x1-123012x2'>\(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \wedge (\forall d\in Des)_{\left \vert d\right \vert \leq \left \vert \ast ^{\leq }((x)_{2})\right \vert +2}\;\lnot \left (\left \lfloor qB\ast ^{\leq }((x)_{2})\right \rfloor \underset{M}{\vdash }d\right )\)</li></ol>
<!-- l. 10008 --><p class='noindent'>Dejamos al lector la prueba de que \(P\) es \((\Gamma \cup Q)\)-p.r.. Ya que \(P\) es \(\Sigma \)-mixto, el Teorema <a href='#x1-97010r84'>84<!-- tex4ht:ref: independencia  --></a> nos dice
que \(P\) es \(\Sigma \)-p.r.. Notese que \[ f=\lambda \vec{x}\vec{\alpha }\left [\ast ^{\leq }\left (\left (\min _{x}P(x,\vec{x},\vec{\alpha })\right )_{2}\right )\right ]\text{,} \] lo cual nos dice que \(f\) es \(\Sigma \)-recursiva.                       □
</p>
   </div>
<!-- l. 10019 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.4.4   </span> <a id='x1-1240003.4.4'></a>Turing vence a Neumann</h5>

<!-- l. 10021 --><p class='noindent'>Probaremos que toda funcion \(\Sigma \)-computable es \(\Sigma \)-Turing computable. Para esto
probaremos un resultado general que nos enseñara a simular el comportamiento
de un programa con una maquina de Turing. Es importante notar que la
simulacion que nos interesa que haga la maquina simuladora no es a nivel de la
funcion que computa el programa sino a un nivel mas general, es decir nos
interesa que simule a dicho programa como transformador de estados. En
particular y usada adecuadamente, la maquina simuladora nos servira para
confeccionar una maquina que compute una funcion computada por un programa
dado.
</p>
<!-- l. 10031 --><p class='noindent'><span class='paragraphHead'><a id='x1-1250003.4.4'></a><span class='cmbx-10'>Construccion de la maquina simuladora de un programa</span></span>
   Dado \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\), definamos
</p>
   <div class='eqnarray'>\begin{eqnarray*} N(\mathcal{P}) &amp; = &amp; \mathrm{menor}\ k\in \mathbf{N}\ \mathrm{tal\ que\ las\ variables\ que\ ocurren\ en\ }\mathcal{P}\\ &amp; &amp; \mathrm{esta}\text{n}\mathrm{\ todas\ en\ la\ lista\ N}1,...,\mathrm{N}\bar{k},\mathrm{P}1,...,\mathrm{P}\bar{k} \end{eqnarray*}
</div>Por ejemplo si \(\mathcal{P}\) es el siguiente programa (aqui \(\Sigma =\{\blacktriangle ,\#\}\)) \[ \begin{array}{ll} \mathrm{L}1 &amp; \mathrm{N}4\leftarrow \mathrm{N}4+1\\ &amp; \mathrm{P}1\leftarrow \mathrm{P}1.\blacktriangle \\ &amp; \mathrm{IF\ N}1\neq 0\ \mathrm{GOTO}\;\mathrm{L}1 \end{array} \] entonces tenemos \(N(\mathcal{P})=4\)
<!-- l. 10049 --><p class='indent'>   Sea \(\mathcal{P}\) un programa y sea \(k\) fijo y mayor o igual a \(N(\mathcal{P})\). La construccion de la maquina
simuladora dependera de \(\mathcal{P}\) y de \(k\). Notese que cuando \(\mathcal{P}\) se corre desde algun estado
de la forma \[ \left \Vert x_{1},...,x_{k},\alpha _{1},...,\alpha _{k}\right \Vert \] los sucesivos estados por los que va pasando son todos de la
forma
</p><!-- l. 10060 --><p class='indent'>   \[ \left \Vert y_{1},...,y_{k},\beta _{1},...,\beta _{k}\right \Vert \] es decir en todos ellos las variables con indice mayor que \(k\) valen \(0\) o \(\varepsilon \). La razon es
simple: ya que en \(\mathcal{P}\) no figuran las variables </p><div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \mathrm{N}\overline{k+1},\mathrm{N}\overline{k+2},...\\ &amp; &amp; \mathrm{P}\overline{k+1},\mathrm{P}\overline{k+2},... \end{eqnarray*}
</div>estas variables quedan con valores \(0\) y \(\varepsilon \), respectivamente a lo largo de toda la
computacion.
<!-- l. 10071 --><p class='indent'>   La maquina simuladora que construiremos simulara a \(\mathcal{P}\) en cuanto a su
funcionamiento cuando partimos de estados de la forma \(\left \Vert x_{1},...,x_{k},\alpha _{1},...,\alpha _{k}\right \Vert \). Necesitaremos tener alguna
manera de representar en la cinta los diferentes estados por los cuales se va
pasando, a medida que corremos a \(\mathcal{P}\). Esto lo haremos de la siguiente forma: al
estado
</p><!-- l. 10080 --><p class='indent'>   \[ \left \Vert x_{1},...,x_{k},\alpha _{1},...,\alpha _{k}\right \Vert \] lo representaremos en la cinta de la siguiente manera \[ B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k}BBBB.... \] Por ejemplo consideremos
el programa \(\mathcal{P}\) mostrado recien y fijemos \(k=6\). Entonces al estado \[ \left \Vert 3,2,5,0,4,2,\blacktriangle ,\blacktriangle \blacktriangle ,\varepsilon ,\#\blacktriangle ,\#,\#\#\#\right \Vert \] lo representaremos en la
cinta de la siguiente manera \[ B\mathrm{\shortmid \shortmid \shortmid }B\mathrm{\shortmid \shortmid }B\mathrm{\shortmid \shortmid \shortmid \shortmid \shortmid }BB\mathrm{\shortmid \shortmid \shortmid \shortmid }B\mathrm{\shortmid \shortmid }B\blacktriangle B\blacktriangle \blacktriangle BB\#\blacktriangle B\#B\#\#\#BBBBB.... \] A lo que queda entre dos blancos consecutivos (es decir
que no hay ningun blanco entre ellos) lo llamaremos ”bloque”, por ejemplo en la
cinta de arriba tenemos que los primeros 12 bloques son \[ \shortmid \shortmid \shortmid \ \ \ \shortmid \shortmid \ \ \ \shortmid \shortmid \shortmid \shortmid \shortmid \ \ \ \ \varepsilon \ \ \ \ \shortmid \shortmid \shortmid \shortmid \ \ \ \shortmid \shortmid \ \ \ \blacktriangle \ \ \ \ \ \blacktriangle \blacktriangle \ \ \ \ \ \varepsilon \ \ \ \ \ \#\blacktriangle \ \ \ \ \ \#\ \ \ \ \ \#\#\# \] y despues los bloques
siguientes (que son infinitos ya que la cinta es infinita hacia la derecha) son todos
iguales a \(\varepsilon \).
</p><!-- l. 10103 --><p class='indent'>   Una observacion importante es que esta forma de representacion de estados en
la cinta depende del \(k\) elejido, es decir si tomaramos otro \(k\), por ejemplo \(k=9\),
entonces el estado anterior se representaria de otra forma en la cinta. Aqui se ve
claramente que la maquina simuladora que construiremos dependera del \(k\)
elejido.

</p>
<!-- l. 10112 --><p class='indent'>   <span class='subparagraphHead'> <a id='x1-1260003.4.4'></a><span class='cmbx-10'>Construccion de las maquinas simuladoras de instrucciones</span></span>
   Armaremos la maquina simuladora como concatenacion de maquinas las cuales
simularan, via la representacion anterior, el funcionamiento de las distintas
instrucciones de \(\mathcal{P}\). Asumiremos que en \(\mathcal{P}\) no hay instrucciones de la forma \(\mathrm{GOTO}\;\mathrm{L}\bar{m}\) ni de la
forma \(\mathrm{L}\bar{n}\ \mathrm{GOTO}\;\mathrm{L}\bar{m}\). Esto simplificara un poco la construccion de la maquina simuladora y de
hecho lo podemos hacer ya que toda funcion \(\Sigma \)-computable puede ser computada por
un programa sin este tipo de instrucciones, tal como lo veremos mas adelante (Lema
<a href='#x1-129001r114'>114<!-- tex4ht:ref: simulacion  --></a>).
</p><!-- l. 10124 --><p class='indent'>   Para poder hacer concretamente las maquinas simuladoras de instrucciones
deberemos diseñar antes algunas maquinas auxiliares. Todas las maquinas descriptas
a continuacion tendran a \(\shortmid \) como unit y a \(B\) como blanco, tendran a \(\Sigma \) como su
alfabeto terminal y su alfabeto mayor sera \(\Gamma =\Sigma \cup \{B,\shortmid \}\cup \{\tilde{a}:a\in \Sigma \cup \{\shortmid \}\}\). Ademas tendran uno o dos estados
finales con la propiedad de que si \(q\) es un estado final, entonces \(\delta (q,\sigma )=\emptyset \), para cada
\(\sigma \in \Gamma \).
</p><!-- l. 10133 --><p class='indent'>   Para cada \(j\geq 1\), sea \(D_{j}\) la siguiente maquina:
</p><!-- l. 10135 --><p class='indent'>   @@figura:figure1.png@@
</p><!-- l. 10137 --><p class='noindent'>Notese que \[ \begin{array}{lcr} \alpha B\beta _{1}B\beta _{2}B...B\beta _{j}B\gamma &amp; \overset{\ast }{\vdash } &amp; \alpha B\beta _{1}B\beta _{2}B...B\beta _{j}B\gamma \\ \ \ \uparrow &amp; &amp; \uparrow \ \ \\ \ \ q_{0} &amp; &amp; q_{f}\ \\end{array} \] siempre que \(\alpha ,\gamma \in \Gamma ^{\ast }\), \(\beta _{1},...,\beta _{j}\in (\Gamma -\{B\})^{\ast }\). Es decir la maquina \(D_{j}\) lo unico que hace es mover el
cabezal desde el blanco de la izquierda de un bloque determinado, exactamente \(j\)
bloques a la derecha
</p><!-- l. 10150 --><p class='indent'>   Analogamente \(I_{j}\) sera una maquina que desplaza el cabezal \(j\) bloques a la izquierda
del blanco que esta escaneando. Es decir \(I_{j}\) cumplira que \[ \begin{array}{lcr} \alpha B\beta _{j}B...B\beta _{2}B\beta _{1}B\gamma &amp; \overset{\ast }{\vdash } &amp; \alpha B\beta _{j}B...B\beta _{2}B\beta _{1}B\gamma \\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \uparrow &amp; &amp; \uparrow \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ q_{0} &amp; &amp; q_{f}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\end{array} \] siempre que \(\alpha ,\gamma \in \Gamma ^{\ast }\), \(\beta _{1},...,\beta _{j}\in (\Gamma -\{B\})^{\ast }\). Dejamos al
lector la manufactura de esta maquina.
</p><!-- l. 10163 --><p class='indent'>   Para \(j\geq 1\), sea \(TD_{j}\) una maquina con un solo estado final \(q_{f}\) y tal que \[ \begin{array}{ccc} \alpha B\gamma &amp; \overset{\ast }{\vdash } &amp; \alpha BB\gamma \\ \uparrow &amp; &amp; \uparrow \ \ \\ q_{0} &amp; &amp; q_{f}\ \\end{array} \] cada vez que \(\alpha ,\gamma \in \Gamma ^{\ast }\) y \(\gamma \) tiene
exactamente \(j\) ocurrencias de \(B\). Es decir la maquina \(TD_{j}\) corre un espacio a la
derecha todo el segmento \(\gamma \) y agrega un blanco en el espacio que se genera a la
izquierda. Por ejemplo, para el caso de \(\Sigma =\{a\}\) podemos tomar \(TD_{3}\) igual a la siguiente
maquina:
</p><!-- l. 10178 --><p class='indent'>   @@figura:figure2.png@@
</p><!-- l. 10180 --><p class='indent'>   Analogamente, para \(j\geq 1\), sea \(TI_{j}\) una maquina tal que \[ \begin{array}{ccc} \alpha B\sigma \gamma &amp; \overset{\ast }{\vdash } &amp; \alpha B\gamma \\ \uparrow \ &amp; &amp; \uparrow \\ q_{0}\ \ &amp; &amp; q_{f} \end{array} \] cada vez que \(\alpha \in \Gamma ^{\ast }\), \(\sigma \in \Gamma \) y \(\gamma \) tiene
exactamente \(j\) ocurrencias de \(B\). Es decir la maquina \(TI_{j}\) corre un espacio a la izquierda
todo el segmaneto \(\gamma \) (por lo cual en el lugar de \(\sigma \) queda el primer simbolo de \(\gamma \)). Dejamos
al lector la construccion de por ejemplo \(TI_{3}\) para \(\Sigma =\{a\}\).
</p><!-- l. 10194 --><p class='indent'>   A continuacion describiremos las distintas maquinas simuladoras de instrucciones
(y para algunos casos mostraremos concretamente como pueden ser hechas usando las
maquinas anteriores).
</p><!-- l. 10198 --><p class='indent'>   Para \(1\leq i\leq k\), sea \(M_{i,k}^{+}\) una maquina tal que cualesquiera sean \(x_{1},...,x_{k}\in \omega \) y \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\): \[ \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} &amp; \overset{\ast }{\vdash } &amp; B\shortmid ^{x_{1}}...B\shortmid ^{x_{i-1}}B\shortmid ^{x_{i}+1}B\shortmid ^{x_{i+1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k}\\ \uparrow &amp; &amp; \uparrow \\ q_{0} &amp; &amp; q_{f} \end{array} \] donde \(q_{0}\) es el
estado inicial y \(q_{f}\) es el unico estado final de \(M_{i,k}^{+}\). Es claro que la maquina \(M_{i,k}^{+}\) simula
la instruccion \(\mathrm{N}\bar{\imath }\leftarrow \mathrm{N}\bar{\imath }+1\), via la representacion de estados en la cinta con respecto a
\(k\).
</p><!-- l. 10212 --><p class='indent'>   Para \(1\leq i\leq k\), sea \(M_{i,k}^{\dot{-}}\) una maquina tal que cualesquiera sean \(x_{1},...,x_{k}\in \omega \) y \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\): \[ \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} &amp; \overset{\ast }{\vdash } &amp; B\shortmid ^{x_{1}}...B\shortmid ^{x_{i-1}}B\shortmid ^{x_{i}\dot{-}1}B\shortmid ^{x_{i+1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k}\\ \uparrow &amp; &amp; \uparrow \\ q_{0} &amp; &amp; q_{f} \end{array} \] donde \(q_{0}\) es el
estado inicial y \(q_{f}\) es el unico estado final de \(M_{i,k}^{\dot{-}}\). Es claro que la maquina \(M_{i,k}^{\dot{-}}\) simula
la instruccion \(\mathrm{P}\bar{\imath }\leftarrow \mathrm{P}\bar{\imath }\dot{-}1\), via la representacion de estados en la cinta con respecto a
\(k\).
</p><!-- l. 10226 --><p class='indent'>   Para \(1\leq i\leq k\) y \(a\in \Sigma \), sea \(M_{i,k}^{a}\) una maquina tal que cualesquiera sean \(x_{1},...,x_{k}\in \omega \) y \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\): \[ \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} &amp; \overset{\ast }{\vdash } &amp; B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{i-1}B\alpha _{i}aB\alpha _{i+1}...B\alpha _{k}\\ \uparrow &amp; &amp; \uparrow \\ q_{0} &amp; &amp; q_{f} \end{array} \] donde \(q_{0}\) es el estado
inicial y \(q_{f}\) es el unico estado final de \(M_{i,k}^{a}\). Es claro que la maquina \(M_{i,k}^{a}\) simula la instruccion \(\mathrm{P}\bar{\imath }\leftarrow \mathrm{P}\bar{\imath }.a\),

via la representacion de estados en la cinta con respecto a \(k\). La maquina \(M_{i,k}^{a}\).puede
hacerse de la siguiente manera:
</p><!-- l. 10241 --><p class='indent'>   @@figura:figure3.png@@
</p><!-- l. 10243 --><p class='indent'>   Para \(1\leq i\leq k\), sea \(M_{i,k}^{\curvearrowright }\) una maquina tal que cualesquiera sean \(x_{1},...,x_{k}\in \omega \) y \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\): \[ \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} &amp; \overset{\ast }{\vdash } &amp; B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{i-1}B^{\curvearrowright }\alpha _{i}B\alpha _{i+1}...B\alpha _{k}\\ \uparrow &amp; &amp; \uparrow \\ q_{0} &amp; &amp; q_{f} \end{array} \] donde \(q_{0}\) es el
estado inicial y \(q_{f}\) es el unico estado final de \(M_{i,k}^{\curvearrowright }\). Es claro que la maquina \(M_{i,k}^{\curvearrowright }\) simula
la instruccion \(\mathrm{P}\bar{\imath }\leftarrow \ ^{\curvearrowright }\mathrm{P}\bar{\imath }\), via la representacion de estados en la cinta con respecto a
\(k\).
</p><!-- l. 10257 --><p class='indent'>   Para \(1\leq i,j\leq k\), sea \(M_{i\leftarrow j}^{\#,k}\) una maquina tal que cualesquiera sean \(x_{1},...,x_{k}\in \omega \) y \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\): \[ \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} &amp; \overset{\ast }{\vdash } &amp; B\shortmid ^{x_{1}}...B\shortmid ^{x_{i-1}}B\shortmid ^{x_{j}}B\shortmid ^{x_{i+1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k}\\ \uparrow &amp; &amp; \uparrow \\ q_{0} &amp; &amp; q_{f} \end{array} \] donde \(q_{0}\) es el
estado inicial y \(q_{f}\) es el unico estado final de \(M_{i\leftarrow j}^{\#,k}\). Es claro que la maquina \(M_{i\leftarrow j}^{\#,k}\) simula
la instruccion \(\mathrm{N}\bar{\imath }\leftarrow \mathrm{N}\bar{j}\), via la representacion de estados en la cinta con respecto a
\(k\).
</p><!-- l. 10271 --><p class='indent'>   Para \(1\leq i,j\leq k\), sea \(M_{i\leftarrow j}^{\ast ,k}\) una maquina tal que cualesquiera sean \(x_{1},...,x_{k}\in \omega \) y \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\): \[ \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} &amp; \overset{\ast }{\vdash } &amp; B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{i-1}B\alpha _{j}B\alpha _{i+1}...B\alpha _{k}\\ \uparrow &amp; &amp; \uparrow \\ q_{0} &amp; &amp; q_{f} \end{array} \] donde \(q_{0}\) es el estado inicial
y \(q_{f}\) es el unico estado final de \(M_{i\leftarrow j}^{\ast ,k}\). Es claro que la maquina \(M_{i\leftarrow j}^{\ast ,k}\) simula la instruccion \(\mathrm{P}\bar{\imath }\leftarrow \mathrm{P}\bar{j}\), via la
representacion de estados en la cinta con respecto a \(k\). La maquina \(M_{i\leftarrow j}^{\ast ,k}\), para el caso \(\Sigma =\{a,b\}\) y \(i&lt;j\)
puede hacerse de la siguiente manera:
</p><!-- l. 10287 --><p class='indent'>   @@figura:figure4.png@@
</p><!-- l. 10289 --><p class='indent'>   Para \(1\leq i\leq k\), sea \(M_{i\leftarrow 0}^{k}\) una maquina tal que cualesquiera sean \(x_{1},...,x_{k}\in \omega \) y \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\): \[ \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} &amp; \overset{\ast }{\vdash } &amp; B\shortmid ^{x_{1}}...B\shortmid ^{x_{i-1}}BB\shortmid ^{x_{i+1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k}\\ \uparrow &amp; &amp; \uparrow \\ q_{0} &amp; &amp; q_{f} \end{array} \] donde \(q_{0}\) es el
estado inicial y \(q_{f}\) es el unico estado final de \(M_{i\leftarrow 0}^{k}\). Es claro que la maquina \(M_{i\leftarrow 0}^{k}\) simula
la instruccion \(\mathrm{N}\bar{\imath }\leftarrow 0\), via la representacion de estados en la cinta con respecto a
\(k\).
</p><!-- l. 10303 --><p class='indent'>   Para \(1\leq i\leq k\), sea \(M_{i\leftarrow \varepsilon }^{k}\) una maquina tal que cualesquiera sean \(x_{1},...,x_{k}\in \omega \) y \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\): \[ \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} &amp; \overset{\ast }{\vdash } &amp; B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{i-1}BB\alpha _{i+1}...B\alpha _{k}\\ \uparrow &amp; &amp; \uparrow \\ q_{0} &amp; &amp; q_{f} \end{array} \] donde \(q_{0}\) es el
estado inicial y \(q_{f}\) es el unico estado final de \(M_{i\leftarrow \varepsilon }^{k}\). Es claro que la maquina \(M_{i\leftarrow \varepsilon }^{k}\) simula
la instruccion \(\mathrm{P}\bar{\imath }\leftarrow \varepsilon \), via la representacion de estados en la cinta con respecto a
\(k\).
</p><!-- l. 10317 --><p class='indent'>   Sea \[ M_{\mathrm{SKIP}}=\left (\{q_{0},q_{f}\},\Gamma ,\Sigma ,\delta ,q_{0},B,\shortmid ,\{q_{f}\}\right ), \] con \(\delta (q_{0},B)=\{(q_{f},B,K)\}\) y \(\delta =\emptyset \) en cualquier otro caso. Es claro que la maquina \(M_{\mathrm{SKIP}}\) simula la instruccion
\(\mathrm{SKIP}\), via la representacion de estados en la cinta con respecto a \(k\) (cualquiera sea el
\(k\)).
</p><!-- l. 10326 --><p class='indent'>   Para \(1\leq j\leq k\), sea \(IF_{j,k}\) una maquina con estado inicial \(q_{0}\) y dos estados finales \(q_{si}\) y \(q_{no}\) tal que
cualesquiera sean \(x_{1},...,x_{k}\in \omega \) y \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\), si \(x_{j}\neq 0\), entonces \[ \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} &amp; \overset{\ast }{\vdash } &amp; B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k}\\ \uparrow &amp; &amp; \uparrow \\ q_{0} &amp; &amp; q_{si} \end{array} \] y si \(x_{j}=0\), entonces \[ \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} &amp; \overset{\ast }{\vdash } &amp; B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k}\\ \uparrow &amp; &amp; \uparrow \\ q_{0} &amp; &amp; q_{no} \end{array} \]
</p><!-- l. 10347 --><p class='indent'>   Para \(1\leq i\leq k\) y \(a\in \Sigma \), sea \(IF_{j,k}^{a}\) una maquina con estado inicial \(q_{0}\) y dos estados finales \(q_{si}\) y \(q_{no}\) tal que
cualesquiera sean \(x_{1},...,x_{k}\in \omega \) y \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\), si \(\alpha _{j}\) comienza con \(a\), entonces \[ \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} &amp; \overset{\ast }{\vdash } &amp; B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k}\\ \uparrow &amp; &amp; \uparrow \\ q_{0} &amp; &amp; q_{si} \end{array} \] y en caso contrario \[ \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} &amp; \overset{\ast }{\vdash } &amp; B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k}\\ \uparrow &amp; &amp; \uparrow \\ q_{0} &amp; &amp; q_{no} \end{array} \] La maquina \(IF_{j,k}^{a}\)
puede hacerse de la siguinete manera:
</p><!-- l. 10368 --><p class='indent'>   @@figura:figure5.png@@
</p>
<!-- l. 10373 --><p class='indent'>   <span class='subparagraphHead'> <a id='x1-1270003.4.4'></a><span class='cmbx-10'>Ejemplo de maquina simuladora de un programa</span></span>
   A continuacion veremos un ejemplo de como se arma la maquina simuladora de
un programa dado. Sea \(\Sigma =\{\blacktriangle ,\#\}\) y sea \(\mathcal{P}\) el siguiente programa \[ \begin{array}{ll} \mathrm{L}3 &amp; \mathrm{N}4\leftarrow \mathrm{N}4+1\\ &amp; \mathrm{P}1\leftarrow \ ^{\curvearrowright }\mathrm{P}1\\ &amp; \mathrm{IF\ P}1\ \mathrm{BEGINS\ }\blacktriangle \ \mathrm{GOTO}\;\mathrm{L}3\\ &amp; \mathrm{P}3\leftarrow \mathrm{P}3.\# \end{array} \] Tomemos \(k=5\). Es claro que \(k\geq N(\mathcal{P})=4\). A la
maquina que simulara a \(\mathcal{P}\) respecto de \(k\), la llamaremos \(M_{sim}\) y sera la siguiente
maquina:
</p><!-- l. 10390 --><p class='indent'>   @@figura:figure6.png@@
</p><!-- l. 10392 --><p class='noindent'>Veamos con un ejemplo como \(M_{sim}\) simula a \(\mathcal{P}\). Supongamos que corremos \(\mathcal{P}\) desde el estado \[ \left \Vert 2,1,0,5,3,\#\blacktriangle \#\#,\varepsilon ,\blacktriangle \blacktriangle ,\#\blacktriangle ,\#\right \Vert \]
Tendremos entonces la siguiente sucesion de descripciones instantaneas:

</p><div class='eqnarray'>\begin{eqnarray*} &amp; &amp; (1,\left \Vert 2,1,0,5,3,\#\blacktriangle \#\#,\varepsilon ,\blacktriangle \blacktriangle ,\#\blacktriangle ,\#\right \Vert )\\ \\ &amp; &amp; (2,\left \Vert 2,1,0,6,3,\#\blacktriangle \#\#,\varepsilon ,\blacktriangle \blacktriangle ,\#\blacktriangle ,\#\right \Vert )\\ \\ &amp; &amp; (3,\left \Vert 2,1,0,6,3,\blacktriangle \#\#,\varepsilon ,\blacktriangle \blacktriangle ,\#\blacktriangle ,\#\right \Vert )\\ \\ &amp; &amp; (1,\left \Vert 2,1,0,6,3,\blacktriangle \#\#,\varepsilon ,\blacktriangle \blacktriangle ,\#\blacktriangle ,\#\right \Vert )\\ \\ &amp; &amp; (2,\left \Vert 2,1,0,7,3,\blacktriangle \#\#,\varepsilon ,\blacktriangle \blacktriangle ,\#\blacktriangle ,\#\right \Vert )\\ \\ &amp; &amp; (3,\left \Vert 2,1,0,7,3,\#\#,\varepsilon ,\blacktriangle \blacktriangle ,\#\blacktriangle ,\#\right \Vert )\\ \\ &amp; &amp; (4,\left \Vert 2,1,0,7,3,\#\#,\varepsilon ,\blacktriangle \blacktriangle ,\#\blacktriangle ,\#\right \Vert )\\ \\ &amp; &amp; (5,\left \Vert 2,1,0,7,3,\#\#,\varepsilon ,\blacktriangle \blacktriangle \#,\#\blacktriangle ,\#\right \Vert ) \end{eqnarray*}
</div>Si hacemos funcionar a \(M_{sim}\) desde \(q_{0}B\shortmid ^{2}B\shortmid BB\shortmid ^{5}B\shortmid ^{3}B\#\blacktriangle \#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\) obtendremos una sucesion de descripciones
instantaneas dentro de la cual estara la siguiente subsucesion que se corresponde con
las descripciones instantaneas de la computacion anterior.
   <div class='eqnarray'>\begin{eqnarray*} q_{0}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{5}B\shortmid ^{3}B\#\blacktriangle \#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ \\ q_{1}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{6}B\shortmid ^{3}B\#\blacktriangle \#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ q_{2}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{6}B\shortmid ^{3}B\#\blacktriangle \#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ \\ q_{3}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{6}B\shortmid ^{3}B\blacktriangle \#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ q_{4}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{6}B\shortmid ^{3}B\blacktriangle \#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ \\ q_{si}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{6}B\shortmid ^{3}B\blacktriangle \#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ q_{0}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{6}B\shortmid ^{3}B\blacktriangle \#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ \\ q_{1}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{7}B\shortmid ^{3}B\blacktriangle \#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ q_{2}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{7}B\shortmid ^{3}B\blacktriangle \#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ \\ q_{3}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{7}B\shortmid ^{3}B\#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ q_{4}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{7}B\shortmid ^{3}B\#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ \\ q_{no}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{7}B\shortmid ^{3}B\#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ q_{5}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{7}B\shortmid ^{3}B\#\#BB\blacktriangle \blacktriangle B\#\blacktriangle B\#B\\ \\ q_{6}B &amp; \shortmid &amp; ^{2}B\shortmid BB\shortmid ^{7}B\shortmid ^{3}B\#\#BB\blacktriangle \blacktriangle \#B\#\blacktriangle B\#B \end{eqnarray*}
</div>Dejamos al lector ver en detalle el paralelismo que hay entre las dos sucesiones de
descripciones instantaneas arriba expuestas.
<!-- l. 10449 --><p class='indent'>   <span class='subparagraphHead'> <a id='x1-1280003.4.4'></a><span class='cmbx-10'>La contruccion de la maquina simuladora</span></span>
   A continuacion describiremos en general como hacer la maquina simuladora de \(\mathcal{P}\),
respecto de \(k\). Supongamos que \(\mathcal{P}=I_{1}...I_{n}\). Para cada \(i=1,...,n\), llamaremos \(M_{i}\) a la maquina que simulara el
efecto que produce la instruccion \(I_{i}\), es decir tomemos
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-128001x3.4.4'>\(M_{i}=M_{j,k}^{+}\), si \(Bas(I_{i})=\mathrm{N}\bar{j}\leftarrow \mathrm{N}\bar{j}+1\)
     </li>
     <li class='enumerate' id='x1-128002x3.4.4'>\(M_{i}=M_{j,k}^{\dot{-}}\), si \(Bas(I_{i})=\mathrm{N}\bar{j}\leftarrow \mathrm{N}\bar{j}\dot{-}1\)
     </li>
     <li class='enumerate' id='x1-128003x3.4.4'>\(M_{i}=M_{j,k}^{a}\), si \(Bas(I_{i})=\mathrm{P}\bar{j}\leftarrow \mathrm{P}\bar{j}.a\)
     </li>
     <li class='enumerate' id='x1-128004x3.4.4'>\(M_{i}=M_{j,k}^{\curvearrowright }\), si \(Bas(I_{i})=\mathrm{P}\bar{j}\leftarrow \ ^{\curvearrowright }\mathrm{P}\bar{j}\)
     </li>
     <li class='enumerate' id='x1-128005x3.4.4'>\(M_{i}=M_{j\leftarrow m}^{\#,k}\), si \(Bas(I_{i})=\mathrm{N}\bar{j}\leftarrow \mathrm{N}\bar{m}\)
     </li>
     <li class='enumerate' id='x1-128006x3.4.4'>\(M_{i}=M_{j\leftarrow m}^{\ast ,k}\), si \(Bas(I_{i})=\mathrm{P}\bar{j}\leftarrow \mathrm{P}\bar{m}\)
     </li>
     <li class='enumerate' id='x1-128007x3.4.4'>\(M_{i}=M_{j\leftarrow 0}^{k}\), si \(Bas(I_{i})=\mathrm{N}\bar{j}\leftarrow 0\)
     </li>
     <li class='enumerate' id='x1-128008x3.4.4'>\(M_{i}=M_{j\leftarrow \varepsilon }^{k}\), si \(Bas(I_{i})=\mathrm{P}\bar{j}\leftarrow \varepsilon \)
     </li>
     <li class='enumerate' id='x1-128009x3.4.4'>\(M_{i}=M_{\mathrm{SKIP}}\), si \(Bas(I_{i})=\mathrm{SKIP}\)
     </li>
     <li class='enumerate' id='x1-128010x3.4.4'>\(M_{i}=IF_{j,k}\), si \(Bas(I_{i})=\mathrm{IF}\;\mathrm{N}\bar{j}\not =0\) \(\mathrm{GOTO}\;\mathrm{L}\bar{m}\), para algun \(m\)
     </li>
     <li class='enumerate' id='x1-128011x3.4.4'>\(M_{i}=IF_{j,k}^{a}\), si \(Bas(I_{i})=\mathrm{IF}\;\mathrm{P}\bar{j}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{m}\), para algun \(m\)</li></ol>

<!-- l. 10470 --><p class='noindent'>Ya que la maquina \(M_{i}\) puede tener uno o dos estados finales, la representaremos como se
muestra a continuacion:
</p><!-- l. 10473 --><p class='indent'>   @@figura:figure7.png@@
</p><!-- l. 10475 --><p class='noindent'>entendiendo que en el caso en que \(M_{i}\) tiene un solo estado final, este esta representado
por el circulo de abajo a la izquierda y en el caso en que \(M_{i}\) tiene dos estados finales,
el circulo de abajo a la izquierda corresponde al estado final \(q_{no}\) y el circulo
de abajo a la derecha corresponde al estado \(q_{si}\). Para armar la maquina que
simulara a \(\mathcal{P}\) hacemos lo siguiente. Primero unimos las maquinas \(M_{1},...,M_{n}\) de la siguiente
manera:
</p><!-- l. 10483 --><p class='indent'>   @@figura:figure8.png@@
</p><!-- l. 10485 --><p class='noindent'>Luego para cada \(i\) tal que \(Bas(I_{i})\) es de la forma \(\alpha \mathrm{GOTO}\;\mathrm{L}\bar{m}\), ligamos con una flecha de la forma \[ \underrightarrow{\;\;\;\;\;\;B,B,K\;\;\;\;\;\;} \] el
estado final \(q_{si}\) de la \(M_{i}\) con el estado inicial de la \(M_{h}\), donde \(h\) es tal que \(I_{h}\) es la primer
instruccion que tiene label \(\mathrm{L}\bar{m}\).
</p>
<!-- l. 10495 --><p class='noindent'><span class='paragraphHead'><a id='x1-1290003.4.4'></a><span class='cmbx-10'>El lema de la simulacion</span></span>
   A continuacion enunciaremos en forma de lema la existencia de la maquina
simuladora y de las propiedades esenciales que usaremos luego para probar que toda
funcion \(\Sigma \)-computable es \(\Sigma \)-Turing computable.
</p>
   <div class='newtheorem'>
<!-- l. 10500 --><p class='noindent'><span class='head'>
<a id='x1-129001r114'></a>
<span class='cmbx-10'>Lema 114.</span>  </span><span class='cmti-10'>Sea</span> \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) <span class='cmti-10'>y sea</span> \(k\geq N(\mathcal{P})\)<span class='cmti-10'>. Supongamos que en</span> \(\mathcal{P}\) <span class='cmti-10'>no hay instrucciones de la forma</span> \(\mathrm{GOTO}\;\mathrm{L}\bar{m}\) <span class='cmti-10'>ni de
</span><span class='cmti-10'>la forma</span> \(\mathrm{L}\bar{n}\ \mathrm{GOTO}\;\mathrm{L}\bar{m}\)<span class='cmti-10'>. Para cada</span> \(a\in \Sigma \cup \{\shortmid \}\)<span class='cmti-10'>, sea</span> \(\tilde{a}\) <span class='cmti-10'>un nuevo simbolo. Sea</span> \(\Gamma =\Sigma \cup \{B,\shortmid \}\cup \{\tilde{a}:a\in \Sigma \cup \{\shortmid \}\}\)<span class='cmti-10'>. Entonces hay una maquina de
</span><span class='cmti-10'>Turing deterministica con unit</span> \(M=\left (Q,\Gamma ,\Sigma ,\delta ,q_{0},B,\shortmid ,\{q_{f}\}\right )\) <span class='cmti-10'>la cual satisface</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-129002x114'>\(\delta (q_{f},\sigma )=\emptyset \)<span class='cmti-10'>, para cada</span> \(\sigma \in \Gamma \)<span class='cmti-10'>.</span>
     </li>
     <li class='enumerate' id='x1-129003x114'><span class='cmti-10'>Cualesquiera sean</span> \(x_{1},...,x_{k}\in \omega \) <span class='cmti-10'>y</span> \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\)<span class='cmti-10'>, el programa</span> \(\mathcal{P}\) <span class='cmti-10'>se detiene partiendo del estado </span>\[ \left \Vert x_{1},...,x_{k},\alpha _{1},...,\alpha _{k}\right \Vert \] <span class='cmti-10'>sii</span> \(M\)
     <span class='cmti-10'>se detiene partiendo de la descripcion instantanea </span>\[ \left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{k}}B\alpha _{1}B...B\alpha _{k}B\right \rfloor \]
     </li>
     <li class='enumerate' id='x1-129004x114'><span class='cmti-10'>Si</span> \(x_{1},...,x_{k}\in \omega \) <span class='cmti-10'>y</span> \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\) <span class='cmti-10'>son tales que</span> \(\mathcal{P}\) <span class='cmti-10'>se detiene partiendo del estado </span>\[ \left \Vert x_{1},...,x_{k},\alpha _{1},...,\alpha _{k}\right \Vert \] <span class='cmti-10'>y llega al estado </span>\[ \left \Vert y_{1},...,y_{k},\beta _{1},...,\beta _{k}\right \Vert \]
     <span class='cmti-10'>entonces </span>\[ \left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{k}}B\alpha _{1}B...B\alpha _{k}B\right \rfloor \overset{\ast }{\underset{M}{\vdash }}\left \lfloor q_{f}B\shortmid ^{y_{1}}B...B\shortmid ^{y_{k}}B\beta _{1}B...B\beta _{k}B\right \rfloor \]</li></ol>
   </div>
<!-- l. 10535 --><p class='indent'>   Cabe destacar que si bien la veracidad de este lema es sustentada en las
explicaciones anteriores, una prueba formal rigurosa del mismo resultaria
extremadamente larga y tediosa. La ventaja de que sea un resultado intuitivamente
claro nos permite aceptarlo y seguir adelante en nuestro analisis.

</p>
<!-- l. 10544 --><p class='noindent'><span class='paragraphHead'><a id='x1-1300003.4.4'></a><span class='cmbx-10'>Turing vence a Neumann</span></span>
   En lo que sigue usaremos la existencia de la maquina simuladora de un programa
para probar que toda funcion \(\Sigma \)-computable es \(\Sigma \)-Turing computable. Antes un
lema.
</p>
   <div class='newtheorem'>
<!-- l. 10549 --><p class='noindent'><span class='head'>
<a id='x1-130001r115'></a>
<span class='cmbx-10'>Lema 115.</span>  </span><span class='cmti-10'>Si</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \Sigma ^{\ast }\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-computable, entonces hay un programa</span> \(\mathcal{Q}\) <span class='cmti-10'>el cual computa a</span> \(f\) <span class='cmti-10'>y el
</span><span class='cmti-10'>cual cumple con las siguientes propiedades</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-130002x115'><span class='cmti-10'>En</span> \(\mathcal{Q}\) <span class='cmti-10'>no hay instrucciones de la forma</span> \(\mathrm{GOTO}\;\mathrm{L}\bar{\imath }\) <span class='cmti-10'>ni de la forma</span> \(\mathrm{L}\bar{j}\ \mathrm{GOTO}\;\mathrm{L}\bar{\imath }\)
     </li>
     <li class='enumerate' id='x1-130003x115'><span class='cmti-10'>Cuando</span>  \(\mathcal{Q}\)  <span class='cmti-10'>termina  partiendo  de  un  estado  cualquiera  dado,  el  estado
     </span><span class='cmti-10'>alcansado es tal que las variables numericas tienen todas el valor</span> \(0\) <span class='cmti-10'>y las
     </span><span class='cmti-10'>alfabeticas tienen todas exepto</span> \(\mathrm{P}1\) <span class='cmti-10'>el valor</span> \(\varepsilon \)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 10563 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 10564 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea \(\mathcal{P}\) un programa que compute a \(f\). Sea \(r\in \mathbf{N}\) tal que \(r&gt;N(\mathcal{P}),n,m\). Sea \(\mathcal{\tilde{P}}\) el resultado de
reemplazar en \(\mathcal{P}\) cada instruccion de la forma \[ \alpha \mathrm{GOTO}\;\mathrm{L}\bar{\imath } \] con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{L}\bar{j}:j\in \mathbf{N}\}\) por \(\alpha \mathrm{IF\ N}\bar{r}\neq 0\ \mathrm{GOTO}\;\mathrm{L}\bar{\imath }\). Ahora sea \(\mathcal{Q}\) el siguiente
programa \[ \begin{array}{l} \mathrm{N}\bar{r}\leftarrow \mathrm{N}\bar{r}+1\\ \mathcal{\tilde{P}}\\ \mathrm{N}1\leftarrow 0\\ \vdots \\ \mathrm{N}\bar{r}\leftarrow 0\\ \mathrm{P}2\leftarrow \varepsilon \\ \vdots \\ \mathrm{P}\bar{r}\leftarrow \varepsilon \end{array} \] Es facil ver que \(\mathcal{Q}\) tiene las propiedades (1) y (2).                         □
</p>
   </div>
<!-- l. 10589 --><p class='indent'>   Por supuesto, hay un lema analogo para el caso en que \(f\) llega a \(\omega \) en lugar de llegar
a \(\Sigma ^{\ast }\). Ahora si, el anunciado teorema:
</p>
   <div class='newtheorem'>
<!-- l. 10592 --><p class='noindent'><span class='head'>
<a id='x1-130004r116'></a>
<span class='cmbx-10'>Teorema 116.</span>  </span><span class='cmti-10'>Si</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-computable, entonces</span> \(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-Turing computable.</span>

</p>
   </div>
<!-- l. 10597 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 10598 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(O=\Sigma ^{\ast }\). Por el Lema <a href='#x1-130001r115'>115<!-- tex4ht:ref: sinGOTO  --></a> existe \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) el cual computa \(f\) y tiene las
propiedades (1) y (2). Sea \(k=\max \{n,m,N(\mathcal{P})\}\) y sea \(M_{sim}\) la maquina de Turing con unit que simula a \(\mathcal{P}\)
respecto de \(k\). Como puede observarse, la maquina \(M_{sim}\), no necesariamente computara
a \(f\). Sea \(M_{1}\) la siguiente maquina:
</p><!-- l. 10604 --><p class='indent'>   @@figura:figure9.png@@
</p><!-- l. 10606 --><p class='noindent'>(Cuando \(n=0\) debemos interpretar que \(D_{0}=\left (\{q_{0},q_{f}\},\Gamma ,\Sigma ,\delta ,q_{0},B,\shortmid ,\{q_{f}\}\right )\), con \(\delta (q_{0},B)=\{(q_{f},B,K)\}\) y \(\delta =\emptyset \) en cualquier otro caso). Notese que
\(M_{1}\) cumple que para cada \((\vec{x},\vec{\alpha })\in \omega ^{n}\times \Sigma ^{\ast m}\), \[ \left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}B\right \rfloor \overset{\ast }{\vdash }\left \lfloor q_{f}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B^{k-n}B\alpha _{1}B...B\alpha _{m}B\right \rfloor \] Sea \(M_{2}\) la siguiente maquina
</p><!-- l. 10614 --><p class='indent'>   @@figura:figure10.png@@
</p><!-- l. 10616 --><p class='noindent'>Notese que \(M_{2}\) cumple que para cada \(\alpha \in \Sigma ^{\ast }\), \[ \left \lfloor q_{0}B^{k+1}\alpha \right \rfloor \overset{\ast }{\vdash }\left \lfloor q_{f}B\alpha \right \rfloor \] Sea \(M\) la siguiente maquina:
</p><!-- l. 10622 --><p class='indent'>   @@figura:figure11.png@@
</p><!-- l. 10624 --><p class='noindent'>A continuacion veremos que \(M\) computa a \(f\). Supongamos que \((\vec{x},\vec{\alpha })\in (\omega ^{n}\times \Sigma ^{\ast m})-D_{f}\). Deberemos ver que \(M\) no
termina partiendo de
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-130005x3.4.4'>\(\left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}B\right \rfloor \)</li></ol>
<!-- l. 10630 --><p class='noindent'>Primero notemos que, ya que \(\mathcal{P}\) computa a \(f\), tenemos que \(\mathcal{P}\) no termina partiendo de \(\left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \) por lo
cual \(\mathcal{P}\) no termina partiendo de \[ \left \Vert x_{1},...,x_{n},\overset{k-n}{\overbrace{0,...,0}},\alpha _{1},...,\alpha _{m},\overset{k-m}{\overbrace{\varepsilon ,...,\varepsilon }}\right \Vert \] lo cual implica (Lema <a href='#x1-129001r114'>114<!-- tex4ht:ref: simulacion  --></a>) que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-130006x3.4.4'>\(M_{sim}\) no termina partiendo de \(\left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B^{k-n}B\alpha _{1}B...B\alpha _{m}B\right \rfloor \)</li></ol>
<!-- l. 10640 --><p class='noindent'>Ahora notese que si hacemos funcionar a \(M\) desde la descripcion instantanea dada en (*),
llegaremos (via la copia de \(M_{1}\) dentro de \(M\)) indefectiblemente (ya que \(M\) es deterministica)
a la siguiente descripcion instantanea \[ \left \lfloor q_{2}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B^{k-n}B\alpha _{1}B...B\alpha _{m}B\right \rfloor \] Luego entonces (**) nos dice que al
seguir trabajando \(M\) (ahora via la copia de \(M_{sim}\) dentro de \(M\)), la maquina \(M\) nunca
terminara.
</p><!-- l. 10651 --><p class='indent'>   Para terminar de ver que \(M\) computa a \(f\), tomemos \((\vec{x},\vec{\alpha })\in D_{f}\) y veamos que \[ \left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}B\right \rfloor \overset{\ast }{\underset{M}{\vdash }}\left \lfloor q_{5}Bf(\vec{x},\vec{\alpha })\right \rfloor \] y que la maquina \(M\)
se detiene en \(\left \lfloor q_{5}Bf(\vec{x},\vec{\alpha })\right \rfloor \). La maquina \(M\) se detiene en \(\left \lfloor q_{5}Bf(\vec{x},\vec{\alpha })\right \rfloor \) ya que \(q_{5}\) es el estado final de una copia de \(M_{2}\) y
por lo tanto no sale ninguna flecha desde el. Ya que \(\mathcal{P}\) computa a \(f\) y tiene la propiedad
(2) del Lema <a href='#x1-130001r115'>115<!-- tex4ht:ref: sinGOTO  --></a>, tenemos que \(\mathcal{P}\) termina partiendo de \(\left \Vert x_{1},...,x_{n},\alpha _{1},...,\alpha _{m}\right \Vert \) y llega al estado \(\left \Vert f(\vec{x},\vec{\alpha })\right \Vert \), o lo que es lo
mismo, \(\mathcal{P}\) termina partiendo de \[ \left \Vert x_{1},...,x_{n},\overset{k-n}{\overbrace{0,...,0}},\alpha _{1},...,\alpha _{m},\overset{k-m}{\overbrace{\varepsilon ,...,\varepsilon }}\right \Vert \] y llega al estado \[ \left \Vert \overset{k}{\overbrace{0,...,0}},f(\vec{x},\vec{\alpha }),\overset{k-1}{\overbrace{\varepsilon ,...,\varepsilon }}\right \Vert \] Pero entonces el Lema <a href='#x1-129001r114'>114<!-- tex4ht:ref: simulacion  --></a> nos dice
que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-130007x3.4.4'>\(\left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B^{k-n}B\alpha _{1}B...B\alpha _{m}B\right \rfloor \overset{\ast }{\underset{M_{sim}}{\vdash }}\left \lfloor q_{f}B^{k+1}f(\vec{x},\vec{\alpha })\right \rfloor \)</li></ol>
<!-- l. 10675 --><p class='noindent'>Como ya lo vimos, si hacemos funcionar a \(M\) desde \(\left \lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}B\right \rfloor \), llegaremos (via la copia de \(M_{1}\) dentro de
\(M\)) indefectiblemente a la siguiente descripcion instantanea \[ \left \lfloor q_{2}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B^{k-n}B\alpha _{1}B...B\alpha _{m}B\right \rfloor \] Luego (***) nos dice que,

via la copia de \(M_{sim}\) dentro de \(M\), llegaremos a \(\left \lfloor q_{3}B^{k+1}f(\vec{x},\vec{\alpha })\right \rfloor \) e inmediatamente a \(\left \lfloor q_{4}B^{k+1}f(\vec{x},\vec{\alpha })\right \rfloor \). Finalmente, via la
copia de \(M_{2}\) dentro de \(M\), llegaremos a \(\left \lfloor q_{5}Bf(\vec{x},\vec{\alpha })\right \rfloor \), lo cual termina de demostrar que \(M\) computa a
\(f\)                                                                 □
</p>
   </div>
<!-- l. 10691 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.5   </span> <a id='x1-1310003.5'></a>Conclusiones: La tesis de Church</h4>
<!-- l. 10693 --><p class='noindent'>En virtud de los teoremas ya probados tenemos el siguiente teorema que asegura que
los tres paradigmas son equivalentes.
</p>
   <div class='newtheorem'>
<!-- l. 10695 --><p class='noindent'><span class='head'>
<a id='x1-131001r117'></a>
<span class='cmbx-10'>Teorema 117.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto finito. Dada una funcion</span> \(f\)<span class='cmti-10'>, las siguientes son
</span><span class='cmti-10'>equivalentes:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-131002x117'>\(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-Turing computable</span>
     </li>
     <li class='enumerate' id='x1-131003x117'>\(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva</span>
     </li>
     <li class='enumerate' id='x1-131004x117'>\(f\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-computable</span></li></ol>
   </div>
<!-- l. 10705 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 10706 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(1)\(\Rightarrow \)(2) es probado en el Teorema <a href='#x1-123008r113'>113<!-- tex4ht:ref: TuringComputableImplicaRecursiva  --></a>. (2)\(\Rightarrow \)(3) es probado en el Teorema
<a href='#x1-112001r90'>90<!-- tex4ht:ref: RimplicaComp  --></a>. (3)\(\Rightarrow \)(1) es probado en el Teorema <a href='#x1-130004r116'>116<!-- tex4ht:ref: ComputableImplicaTuringComputable  --></a>.                                                □
</p>
   </div>
<!-- l. 10712 --><p class='indent'>   Tambien los tres paradigmas son equivalentes con respecto a los dos tipos de
conjuntos estudiados, es decir:

</p>
   <div class='newtheorem'>
<!-- l. 10714 --><p class='noindent'><span class='head'>
<a id='x1-131005r118'></a>
<span class='cmbx-10'>Teorema 118.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto finito y sea</span> \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\)<span class='cmti-10'>. Las siguientes son equivalentes:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-131006x118'>\(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-Turing enumerable</span>
     </li>
     <li class='enumerate' id='x1-131007x118'>\(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursivamente enumerable</span>
     </li>
     <li class='enumerate' id='x1-131008x118'>\(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-enumerable</span></li></ol>
   </div>
<!-- l. 10724 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 10725 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Directo de las definiciones y el teorema anterior.                             □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 10727 --><p class='noindent'><span class='head'>
<a id='x1-131009r119'></a>
<span class='cmbx-10'>Teorema 119.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto finito y sea</span> \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\)<span class='cmti-10'>. Las siguientes son equivalentes:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-131010x119'>\(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-Turing computable</span>
     </li>
     <li class='enumerate' id='x1-131011x119'>\(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursivo</span>
     </li>
     <li class='enumerate' id='x1-131012x119'>\(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-computable</span></li></ol>

   </div>
<!-- l. 10737 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 10738 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Directo de las definiciones y el teorema anterior.                             □
</p>
   </div>
<!-- l. 10742 --><p class='indent'>   Otro modelo matematico de computabilidad efectiva es el llamado lamda calculus,
introducido por Church, el cual tambien resulta equivalente a los estudiados por
nosotros. El hecho de que tan distintos paradigmas computacionales hayan resultado
equivalentes hace pensar que en realidad los mismos han tenido exito en capturar la
totalidad de las funciones \(\Sigma \)-efectivamente computables. Esta aseveracion es conocida
como la
</p><!-- l. 10752 --><p class='indent'>   <span class='cmr-12x-x-120'>Tesis de Church: </span><span class='cmti-10'>Toda funcion</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable es</span> \(\Sigma \)<span class='cmti-10'>-recursiva.</span>
</p><!-- l. 10757 --><p class='noindent'>Si bien no se ha podido dar una prueba estrictamente matematica de la Tesis de
Church, es un sentimiento comun de los investigadores del area que la misma es
verdadera.
</p><!-- l. 10765 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.6   </span> <a id='x1-1320003.6'></a>Resultados basicos presentados en paradigma recursivo</h4>
<!-- l. 10767 --><p class='noindent'>En esta seccion presentaremos varios de los resultados basicos de computabilidad,
expresados en el paradigma recursivo, ya que es el mas habitual y comodo.
Varios de estos resultados ya han sido establecidos dentro del desarrollo de la
computabilidad efectiva en el Capitulo <a href='#x1-510002'>2<!-- tex4ht:ref: ParadigmaFilosofico  --></a>. A estos resultados los enunciaremos dentro
del paradigma de Godel y daremos pruebas rigurosas matematicas de ellos
usando la teoria desarrollada hasta ahora. Sin envargo, veremos que hay otros
resultados que son dependientes del desarrollo matematico hecho y aportan nueva
informacion al paradigma filosofico (la indecidibilidad del halting problem, por
ejemplo).

</p><!-- l. 10778 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.6.1   </span> <a id='x1-1330003.6.1'></a>Lema de division por casos para funciones \(\Sigma \)-recursivas</h5>
   <div class='newtheorem'>
<!-- l. 10779 --><p class='noindent'><span class='head'>
<a id='x1-133001r120'></a>
<span class='cmbx-10'>Lema 120.</span>  </span><span class='cmti-10'>Supongamos</span> \(f_{i}:D_{f_{i}}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\)<span class='cmti-10'>,</span> \(i=1,...,k\)<span class='cmti-10'>, son funciones</span> \(\Sigma \)<span class='cmti-10'>-recursivas tales que</span> \(D_{f_{i}}\cap D_{f_{j}}=\emptyset \) <span class='cmti-10'>para</span> \(i\neq j\)<span class='cmti-10'>. Entonces
</span><span class='cmti-10'>la funcion</span> \(f_{1}\cup ...\cup f_{k}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva.</span>
</p>
   </div>
<!-- l. 10786 --><p class='noindent'>
</p>
   <div class='proof'>
<!-- l. 10787 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Probaremos el caso \(k=2\) y \(O=\Sigma ^{\ast }\). Ademas supondremos que \(n=m=1\). Sean \(\mathcal{P}_{1}\) y \(\mathcal{P}_{2}\) programas que
computen las funciones \(f_{1}\) y \(f_{2}\), respectivamente. Para \(i=1,2\), definamos \[ H_{i}=\lambda tx_{1}\alpha _{1}\left [Halt^{1,1}(t,x_{1},\alpha _{1},\mathcal{P}_{i})\right ] \] Notar que \(D_{H_{i}}=\omega ^{2}\times \Sigma ^{\ast }\) y que \(H_{i}\) es
\(\Sigma \)-mixta. Ademas sabemos que la funcion \(Halt^{1,1}\) es \((\Sigma \cup \Sigma _{p})\)-p.r. por lo cual resulta facilmente que \(H_{i}\) es
\((\Sigma \cup \Sigma _{p})\)-p.r.. Por el Teorema de Independencia del Alfabeto tenemos que \(H_{i}\) es \(\Sigma \)-p.r.. Entonces \(H_{i}\)
es \(\Sigma \)-computable por lo cual tenemos que hay un macro: \[ \left [\mathrm{IF}\;H_{i}(\mathrm{V}1,\mathrm{V}2,\mathrm{W}1)\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Para hacer mas intuitivo el
uso de este macro lo escribiremos de la siguiente manera \[ \left [\mathrm{IF}\;Halt^{1,1}(\mathrm{V}1,\mathrm{V}2,\mathrm{W}1,\mathcal{P}_{i})\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Ya que cada \(f_{i}\) es
\(\Sigma \)-computable, hay macros </p><div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left [\mathrm{W}2\leftarrow f_{1}(\mathrm{V}1,\mathrm{W}1)\right ]\\ &amp; &amp; \left [\mathrm{W}2\leftarrow f_{2}(\mathrm{V}1,\mathrm{W}1)\right ] \end{eqnarray*}
</div>Sea \(\mathcal{P}\) el siguiente programa: \[ \begin{array}{l} \mathrm{L}1\ \mathrm{N}20\leftarrow \mathrm{N}20+1\\ \left [\mathrm{IF}\;Halt^{1,1}(\mathrm{N}20,\mathrm{N}1,\mathrm{P}1,\mathcal{P}_{1})\;\mathrm{GOTO}\;\mathrm{L}2\right ]\\ \left [\mathrm{IF}\;Halt^{1,1}(\mathrm{N}20,\mathrm{N}1,\mathrm{P}1,\mathcal{P}_{2})\;\mathrm{GOTO}\;\mathrm{L}3\right ]\\ \mathrm{GOTO}\;\mathrm{L}1\\ \mathrm{L}2\ \left [\mathrm{P}1\leftarrow f_{1}(\mathrm{N}1,\mathrm{P}1)\right ]\\ \mathrm{GOTO}\;\mathrm{L}4\\ \mathrm{L}3\ \left [\mathrm{P}1\leftarrow f_{2}(\mathrm{N}1,\mathrm{P}1)\right ]\\ \mathrm{L}4\ \mathrm{SKIP} \end{array} \] Notese que \(\mathcal{P}\) computa la funcion \(f_{1}\cup f_{2}\)                      □
   </div>
<!-- l. 10830 --><p class='noindent'>La prueba del lema anterior es de naturaleza imperativa ya que da explicitamente un
programa (de todas maneras usa el paradigma recursivo o Godeliano para justificar
la existencia de los macros). A continuacion daremos una prueba la cual es mas
recursiva (aunque aun usa el paradigma imperativo en la existencia de los programas
\(\mathcal{P}_{i}\)).
</p><!-- l. 10838 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 10839 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sean \(\mathcal{P}_{1}\) y \(\mathcal{P}_{2}\) programas que computen las funciones \(f_{1}\) y \(f_{2}\), respectivamente. Sean
</p><div class='eqnarray'>\begin{eqnarray*} P_{1} &amp; = &amp; \lambda t\vec{x}\vec{\alpha }\left [Halt^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}_{1})\right ]\\ P_{2} &amp; = &amp; \lambda t\vec{x}\vec{\alpha }\left [Halt^{n,m}(t,\vec{x},\vec{\alpha },\mathcal{P}_{2})\right ] \end{eqnarray*}
</div>Notese que \(D_{P_{1}}=D_{P_{2}}=\omega \times \omega ^{n}\times \Sigma ^{\ast m}\) y que \(P_{1}\) y \(P_{2}\) son \((\Sigma \cup \Sigma _{p})\)-p.r.. Ya que son \(\Sigma \)-mixtos, el Teorema <a href='#x1-97010r84'>84<!-- tex4ht:ref: independencia  --></a> nos dice que son
\(\Sigma \)-p.r.. Tambien notese que \(D_{M((P_{1}\vee P_{2}))}=D_{f_{1}}\cup D_{f_{2}}\). Definamos <div class='eqnarray'>\begin{eqnarray*} g_{1} &amp; = &amp; \lambda \vec{x}\vec{\alpha }\left [E_{\ast 1}^{n,m}(M\left ((P_{1}\vee P_{2})\right )(\vec{x},\vec{\alpha }),\vec{x},\vec{\alpha },\mathcal{P}_{1})^{P_{1}(M\left ((P_{1}\vee P_{2})\right )(\vec{x},\vec{\alpha }),\vec{x},\vec{\alpha })}\right ]\\ g_{2} &amp; = &amp; \lambda \vec{x}\vec{\alpha }\left [E_{\ast 1}^{n,m}(M\left ((P_{1}\vee P_{2})\right )(\vec{x},\vec{\alpha }),\vec{x},\vec{\alpha },\mathcal{P}_{2})^{P_{2}(M\left ((P_{1}\vee P_{2})\right )(\vec{x},\vec{\alpha }),\vec{x},\vec{\alpha })}\right ] \end{eqnarray*}

</div>Notese que \(g_{1}\) y \(g_{2}\) son \(\Sigma \)-recursivas y que \(D_{g_{1}}=D_{g_{2}}=D_{f_{1}}\cup D_{f_{2}}\), Ademas notese que \[ g_{1}(\vec{x},\vec{\alpha })=\left \{ \begin{array}{lll} f_{1}(\vec{x},\vec{\alpha }) &amp; &amp; \text{si }(\vec{x},\vec{\alpha })\in D_{f_{1}}\\ \varepsilon &amp; &amp; \text{caso contrario} \end{array}\right . \] \[ g_{2}(\vec{x},\vec{\alpha })=\left \{ \begin{array}{lll} f_{2}(\vec{x},\vec{\alpha }) &amp; &amp; \text{si }(\vec{x},\vec{\alpha })\in D_{f_{2}}\\ \varepsilon &amp; &amp; \text{caso contrario} \end{array}\right . \] O sea que \(f_{1}\cup f_{2}=\lambda \alpha \beta \left [\alpha \beta \right ]\circ \left [g_{1},g_{2}\right ]\) es
\(\Sigma \)-recursiva.                                                                                        □
   </div>
<!-- l. 10877 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.6.2   </span> <a id='x1-1340003.6.2'></a>Conjuntos \(\Sigma \)-recursivos y \(\Sigma \)-recursivamente enumerables</h5>
<!-- l. 10879 --><p class='noindent'>A continuacion probaremos los resultados basicos sobre conjuntos \(\Sigma \)-efectivamente
computables y \(\Sigma \)-efectivamente enumerables, dados en las Secciones <a href='#x1-570002.3'>2.3<!-- tex4ht:ref: conjuntos sigma-efectivamente enumerables  --></a> y <a href='#x1-560002.2'>2.2<!-- tex4ht:ref: conjuntos sigma-efectivamente computables  --></a>, pero
enunciados dentro del paradigma de Godel.
</p>
   <div class='newtheorem'>
<!-- l. 10883 --><p class='noindent'><span class='head'>
<a id='x1-134001r121'></a>
<span class='cmbx-10'>Lema 121.</span>  </span><span class='cmti-10'>Si</span> \(P:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>y</span> \(Q:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) <span class='cmti-10'>son predicados</span> \(\Sigma \)<span class='cmti-10'>-r., entonces</span> \((P\vee Q)\)<span class='cmti-10'>,</span> \((P\wedge Q)\) <span class='cmti-10'>y</span> \(\lnot P\) <span class='cmti-10'>lo son tambien.</span>
</p>
   </div>
<!-- l. 10890 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 10891 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Note que </p><div class='eqnarray'>\begin{eqnarray*} \lnot P &amp; = &amp; \lambda xy\left [x\dot{-}y\right ]\circ \left [C_{1}^{n,m},P\right ]\\ (P\wedge Q) &amp; = &amp; \lambda xy\left [x.y\right ]\circ [P,Q]\\ (P\vee Q) &amp; = &amp; \lnot (\lnot P\wedge \lnot Q). \end{eqnarray*}
</div>                                                                 □
   </div>
   <div class='newtheorem'>
<!-- l. 10898 --><p class='noindent'><span class='head'>
<a id='x1-134002r122'></a>
<span class='cmbx-10'>Lema 122.</span>  </span><span class='cmti-10'>Supongamos</span>  \(S_{1},S_{2}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\)  <span class='cmti-10'>son  conjuntos</span>  \(\Sigma \)<span class='cmti-10'>-recursivos.  Entonces</span>  \(S_{1}\cup S_{2}\)<span class='cmti-10'>,</span>  \(S_{1}\cap S_{2}\)  <span class='cmti-10'>y</span>  \(S_{1}-S_{2}\)  <span class='cmti-10'>son</span>
\(\Sigma \)<span class='cmti-10'>-recursivos</span>
</p>
   </div>
<!-- l. 10904 --><p class='indent'>
</p>
   <div class='proof'>

<!-- l. 10905 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es directa del lema anterior.                                                       □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 10907 --><p class='noindent'><span class='head'>
<a id='x1-134003r123'></a>
<span class='cmbx-10'>Lema 123.</span>  </span><span class='cmti-10'>Supongamos</span> \(S_{1},S_{2}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>son conjuntos</span> \(\Sigma \)<span class='cmti-10'>-r.e.. Entonces</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-134004x123'>\(S_{1}\cup S_{2}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r.e..</span>
     </li>
     <li class='enumerate' id='x1-134005x123'>\(S_{1}\cap S_{2}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r.e..</span></li></ol>
   </div>
<!-- l. 10916 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 10917 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Podemos  suponer  que  ni  \(S_{1}\)  ni  \(S_{2}\)  son  vacios  ya  que  de  lo  contrario  los
resultados son triviales. Ademas supondremos que \(n=2\) y \(m=1\).
</p><!-- l. 10921 --><p class='indent'>   (1). La idea de la prueba es la misma que la que usamos para probar que la
union de conjuntos \(\Sigma \)-efectivamente enumerables es \(\Sigma \)-efectivamente enumerable.
Daremos usando macros un programa que enumera a \(S_{1}\cup S_{2}\) y luego aplicaremos
la Proposicion <a href='#x1-108004r89'>89<!-- tex4ht:ref: P enumera a S  --></a>. Por hipotesis hay funciones \(F:\omega \rightarrow \omega \times \omega \times \Sigma ^{\ast }\) y \(G:\omega \rightarrow \omega \times \omega \times \Sigma ^{\ast }\) tales que \(F_{(1)}\), \(F_{(2)}\), \(F_{(3)}\), \(G_{(1)}\), \(G_{(2)}\) y \(G_{(3)}\) son
\(\Sigma \)-recursivas, \(\mathrm{Im}(F)=S_{1}\) y \(\mathrm{Im}(G)=S_{2}\). Ya que estas funciones tambien son \(\Sigma \)-computables, hay macros
</p><div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left [\mathrm{V}2\leftarrow F_{(1)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{V}2\leftarrow F_{(2)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{W}1\leftarrow F_{(3)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{V}2\leftarrow G_{(1)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{V}2\leftarrow G_{(2)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{W}1\leftarrow G_{(3)}(\mathrm{V}1)\right ] \end{eqnarray*}
</div>Ya que el predicado \(Par=\lambda x[x\) es par\(]\) es \(\Sigma \)-p.r., tenemos que \(Par\) es \(\Sigma \)-computable. Es decir que hay
un macro: \[ [\mathrm{IF\ }Par(\mathrm{V}1)\ \mathrm{GOTO\ A}1] \] el cual escribiremos de la siguiente manera mas intuitiva \[ [\mathrm{IF\ V}1\text{ es par }\mathrm{GOTO\ A}1] \] Ya que la
funcion \(D=\lambda x[\lfloor x/2\rfloor ]\) es \(\Sigma \)-p.r., tenemos que \(D\) es \(\Sigma \)-computable. Es decir que hay un macro: \[ [\mathrm{V}2\leftarrow D(\mathrm{V}1)] \] el cual
escribiremos de la siguiente manera mas intuitiva \[ [\mathrm{V}2\leftarrow \lfloor \mathrm{V}1/2\rfloor ] \] Sea \(\mathcal{P}\) el siguiente programa: \[ \begin{array}{ll} &amp; [\mathrm{IF\ N}1\text{ es par }\mathrm{GOTO\ L}1\\ &amp; \mathrm{N}1\leftarrow \mathrm{N}1\dot{-}1\\ &amp; [\mathrm{N}1111\leftarrow \lfloor \mathrm{N}1/2\rfloor ]\\ &amp; \left [\mathrm{N}1\leftarrow G_{(1)}(\mathrm{N}1111)\right ]\\ &amp; \left [\mathrm{N}2\leftarrow G_{(2)}(\mathrm{N}1111)\right ]\\ &amp; \left [\mathrm{P}1\leftarrow G_{(3)}(\mathrm{N}1111)\right ]\\ &amp; \mathrm{GOTO\ L}2\\ \mathrm{L}1 &amp; [\mathrm{N}1111\leftarrow \lfloor \mathrm{N}1/2\rfloor ]\\ &amp; \left [\mathrm{N}1\leftarrow F_{(1)}(\mathrm{N}1111)\right ]\\ &amp; \left [\mathrm{N}2\leftarrow F_{(2)}(\mathrm{N}1111)\right ]\\ &amp; \left [\mathrm{P}1\leftarrow F_{(3)}(\mathrm{N}1111)\right ]\\ \mathrm{L}2 &amp; \mathrm{SKIP} \end{array} \]
Es facil ver que \(\mathcal{P}\) cumple a y b de (3) de la Proposicion <a href='#x1-108004r89'>89<!-- tex4ht:ref: P enumera a S  --></a> por lo cual \(S_{1}\cup S_{2}\) es
\(\Sigma \)-enumerable.
<!-- l. 10976 --><p class='indent'>   (2). Es dejada al lector                                                                   □
</p>
   </div>

<!-- l. 10980 --><p class='indent'>   Tal como veremos mas adelante hay conjuntos \(\Sigma \)-recursivamente enumerables
los cuales no son \(\Sigma \)-recursivos. Sin envargo tenemos el siguiente interesante
resultado.
</p>
   <div class='newtheorem'>
<!-- l. 10983 --><p class='noindent'><span class='head'>
<a id='x1-134006r124'></a>
<span class='cmbx-10'>Teorema 124.</span>  </span><span class='cmti-10'>Sea</span> \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\)<span class='cmti-10'>. Son equivalentes</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-134007x124'>\(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursivo</span>
     </li>
     <li class='enumerate' id='x1-134008x124'>\(S\) <span class='cmti-10'>y</span> \((\omega ^{n}\times \Sigma ^{\ast m})-S\) <span class='cmti-10'>son</span> \(\Sigma \)<span class='cmti-10'>-recursivamente enumerables</span></li></ol>
   </div>
<!-- l. 10993 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 10994 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a)\(\Rightarrow \)(b). Si \(S=\emptyset \), por definicion \(S\) es \(\Sigma \)-recursivamente enumerable. Supongamos
entonces \(S\neq \emptyset \). Haremos el caso en el que \(n=m=1\) y \((0,\varepsilon )\in S\). Sea \(\leq \) un orden total sobre \(\Sigma \). Por hipotesis
tenemos que \(\chi _{S}^{\omega \times \Sigma ^{\ast }}\) es \(\Sigma \)-recursiva por lo cual es \(\Sigma \)-computable. O sea que tenemos un
macro \[ [\mathrm{IF\ }\chi _{S}^{\omega \times \Sigma ^{\ast }}(\mathrm{V}1,\mathrm{W}1)\ \mathrm{GOTO\ A}1] \] Ya que la funcion \(f=\lambda x[(x)_{1}]\) es \(\Sigma \)-p.r., ella es \(\Sigma \)-computable por lo cual hay un macro
\[ [\mathrm{V}2\leftarrow f(\mathrm{V}1)] \] el cual escribiremos de la siguiente manera: \[ [\mathrm{V}2\leftarrow (\mathrm{V}1)_{1}] \] Ya que la funcion \(g=\lambda x[\ast ^{\leq }((x)_{2})]\) es \(\Sigma \)-p.r., ella
es \(\Sigma \)-computable por lo cual hay un macro \[ [\mathrm{W}1\leftarrow g(\mathrm{V}1)] \] el cual escribiremos de la siguiente
manera: \[ [\mathrm{W}1\leftarrow \ast ^{\leq }((\mathrm{V}1)_{2})] \] (Dejamos al lector entender bien el funcionamiento de estos macros.)
Sea \(\mathcal{P}\) el siguiente programa: \[ \begin{array}{l} \mathrm{N}1\leftarrow \mathrm{N}1+1\\{} [\mathrm{N}2\leftarrow (\mathrm{N}1)_{1}]\\{} [\mathrm{P}2\leftarrow \ast ^{\leq }(\mathrm{N}1)_{2}]\\{} [\mathrm{IF\ }\chi _{S}^{\omega \times \Sigma ^{\ast }}(\mathrm{N}2,\mathrm{P}2)\ \mathrm{GOTO\ L}1\\ \mathrm{N}1\leftarrow 0\\ \mathrm{P}1\leftarrow \varepsilon \\ \mathrm{GOTO\ L}2\\ \mathrm{L}1\ [\mathrm{N}1\leftarrow \mathrm{N}2]\\ \left [\mathrm{P}1\leftarrow \mathrm{P}2)\right ]\\ \mathrm{L}2\ \mathrm{SKIP} \end{array} \] Notese que \(\mathrm{Dom}(\left [\Psi _{\mathcal{P}}^{1,0,\#},\Psi _{\mathcal{P}}^{1,0,\ast }\right ])=\omega \) y que \(\mathrm{Im}(\left [\Psi _{\mathcal{P}}^{1,0,\#},\Psi _{\mathcal{P}}^{1,0,\ast }\right ])=S\) por lo cual \(S\) es \(\Sigma \)-enumerable lo
que nos dice que \(S\) es \(\Sigma \)-recursivamente enumerable.
</p><!-- l. 11042 --><p class='indent'>   (b)\(\Rightarrow \)(a). Haremos el caso en que los conjuntos \(S\) y \((\omega ^{n}\times \Sigma ^{\ast m})-S\) son no vacios. Tambien
supondremos \(n=m=1\). Por hipotesis hay funciones \(F:\omega \rightarrow \omega \times \Sigma ^{\ast }\) y \(G:\omega \rightarrow \omega \times \Sigma ^{\ast }\) tales que \(F_{(1)}\), \(F_{(2)}\), \(G_{(1)}\) y \(G_{(2)}\) son \(\Sigma \)-recursivas, \(\mathrm{Im}(F)=S\) y \(\mathrm{Im}(G)=(\omega \times \Sigma ^{\ast })-S\). Ya
que estas funciones tambien son \(\Sigma \)-computables, hay macros </p><div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left [\mathrm{V}2\leftarrow F_{(1)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{W}1\leftarrow F_{(2)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{V}1\leftarrow G_{(1)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{W}1\leftarrow G_{(2)}(\mathrm{V}1)\right ] \end{eqnarray*}
</div>Ya que los predicados \(D=\lambda xy[x\neq y]\) y \(D^{\prime }=\lambda \alpha \beta [\alpha \neq \beta ]\) son \(\Sigma \)-computables, hay macros <div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left [\mathrm{IF}\;D(\mathrm{V}1,\mathrm{V}2)\;\mathrm{GOTO}\;\mathrm{A}1\right ]\\ &amp; &amp; \left [\mathrm{IF}\;D^{\prime }(\mathrm{W}1,\mathrm{W}2)\;\mathrm{GOTO}\;\mathrm{A}1\right ] \end{eqnarray*}
</div>los cuales para hacer mas amigable la lectura los escribieremos de la siguiente manera
<div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left [\mathrm{IF}\;\mathrm{V}1\neq \mathrm{V}2\;\mathrm{GOTO}\;\mathrm{A}1\right ]\\ &amp; &amp; \left [\mathrm{IF}\;\mathrm{W}1\neq \mathrm{W}2\;\mathrm{GOTO}\;\mathrm{A}1\right ] \end{eqnarray*}
</div>Tambien usaremos el macro \[ [\mathrm{V}1\leftarrow C_{1}^{0,0}(\Diamond )] \] (asociado a la funcion \(\Sigma \)-computable \(C_{1}^{0,0}\)), el cual
escribiremos de la siguiente manera \[ [\mathrm{V}1\leftarrow 1] \] Sea \(\mathcal{P}\) el siguiente programa: \[ \begin{array}{l} \mathrm{L}1\ [\mathrm{N}2\leftarrow F_{(1)}(\mathrm{N}20)]\\{} [\mathrm{P}2\leftarrow F_{(2)}(\mathrm{N}20)]\\ \left [\mathrm{IF}\;\mathrm{N}2\neq \mathrm{N}1\;\mathrm{GOTO}\;\mathrm{L}2\right ]\\ \left [\mathrm{IF}\;\mathrm{P}2\neq \mathrm{P}1\;\mathrm{GOTO}\;\mathrm{L}2\right ]\\{} [\mathrm{N}1\leftarrow 1]\\ \mathrm{GOTO}\;\mathrm{L}3\\ \mathrm{L}2\ [\mathrm{N}2\leftarrow G_{(1)}(\mathrm{N}20)]\\{} [\mathrm{P}2\leftarrow G_{(2)}(\mathrm{N}20)]\\ \left [\mathrm{IF}\;\mathrm{N}2\neq \mathrm{N}1\;\mathrm{GOTO}\;\mathrm{L}4\right ]\\ \left [\mathrm{IF}\;\mathrm{P}2\neq \mathrm{P}1\;\mathrm{GOTO}\;\mathrm{L}4\right ]\\ \mathrm{N}1\leftarrow 0\\ \mathrm{GOTO}\;\mathrm{L}3\\ \mathrm{L}4\ \mathrm{N}20\leftarrow \mathrm{N}20+1\\ \mathrm{GOTO}\;\mathrm{L}1\\ \mathrm{L}3\ \mathrm{SKIP} \end{array} \] Notese que \(\mathcal{P}\)
computa a la funcion \(\chi _{S}^{\omega \times \Sigma ^{\ast }}\) por lo cual \(\chi _{S}^{\omega \times \Sigma ^{\ast }}\) es \(\Sigma \)-computable lo que nos dice que es \(\Sigma \)-recursiva.
Esto por definicion nos dice que \(S\) es \(\Sigma \)-recursivo                                          □
   </div>

   <div class='newtheorem'>
<!-- l. 11105 --><p class='noindent'><span class='head'>
<a id='x1-134009r125'></a>
<span class='cmbx-10'>Lema 125.</span>  </span><span class='cmti-10'>Supongamos</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva y</span> \(S\subseteq D_{f}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r.e., entonces</span> \(f|_{S}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva.</span>
</p>
   </div>
<!-- l. 11111 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11112 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Si \(S=\emptyset \), entonces \(f|_{S}=\emptyset \) y por lo tanto \(f|_{S}\) es \(\Sigma \)-recursiva. Supongamos \(S\neq \emptyset \). Haremos el caso \(n=m=1\) y \(O=\Sigma ^{\ast }\).
Tenemos que hay una \(F:\omega \rightarrow \omega \times \Sigma ^{\ast }\) tal que \(\mathrm{Im}F=S\) y \(F_{(1)}\), \(F_{(2)}\) son \(\Sigma \)-recursivas. Ya que \(f\), \(F_{(1)}\) y \(F_{(2)}\) son \(\Sigma \)-computables,
hay macros </p><div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left [\mathrm{W}2\leftarrow f(\mathrm{V}1,\mathrm{W}1)\right ]\\ &amp; &amp; \left [\mathrm{V}2\leftarrow F_{(1)}(\mathrm{V}1)\right ]\\ &amp; &amp; \left [\mathrm{W}1\leftarrow F_{(2)}(\mathrm{V}1)\right ] \end{eqnarray*}
</div>Usaremos los macros <div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \left [\mathrm{IF}\;\mathrm{V}1\neq \mathrm{V}2\;\mathrm{GOTO}\;\mathrm{A}1\right ]\\ &amp; &amp; \left [\mathrm{IF}\;\mathrm{W}1\neq \mathrm{W}2\;\mathrm{GOTO}\;\mathrm{A}1\right ] \end{eqnarray*}
</div>Sea \(\mathcal{P}\) el siguiente programa \[ \begin{array}{ll} \mathrm{L}2 &amp; [\mathrm{N}2\leftarrow F_{(1)}(\mathrm{N}20)]\\ &amp; [\mathrm{P}2\leftarrow F_{(2)}(\mathrm{N}20)]\\ &amp; \left [\mathrm{IF}\;\mathrm{N}1\neq \mathrm{N}2\;\mathrm{GOTO}\;\mathrm{L}1\right ]\\ &amp; \left [\mathrm{IF}\;\mathrm{P}1\neq \mathrm{P}2\;\mathrm{GOTO}\;\mathrm{L}1\right ]\\ &amp; \left [\mathrm{P}1\leftarrow f(\mathrm{N}1,\mathrm{P}1)\right ]\\ &amp; \mathrm{GOTO}\;\mathrm{L}3\\ \mathrm{L}1 &amp; \mathrm{N}20\leftarrow \mathrm{N}20+1\\ &amp; \mathrm{GOTO}\;\mathrm{L}2\\ \mathrm{L}3 &amp; \mathrm{SKIP} \end{array} \] Es facil ver que \(\mathcal{P}\) computa a \(f|_{S}\)                            □
   </div>
<!-- l. 11148 --><p class='indent'>   Ahora probaremos el analogo recursivo del Teorema <a href='#x1-57016r31'>31<!-- tex4ht:ref: equivalencias de efectivamente enumerable  --></a>.
</p>
   <div class='newtheorem'>
<!-- l. 11149 --><p class='noindent'><span class='head'>
<a id='x1-134010r126'></a>
<span class='cmbx-10'>Teorema 126.</span>  </span><span class='cmti-10'>Dado</span> \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\)<span class='cmti-10'>, son equivalentes</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-134011x126'>\(S\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursivamente enumerable</span>
     </li>
     <li class='enumerate' id='x1-134012x126'>\(S=I_{F}\)<span class='cmti-10'>, para alguna</span> \(F:D_{F}\subseteq \omega ^{k}\times \Sigma ^{\ast l}\rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>tal que cada</span> \(F_{(i)}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva.</span>
     </li>
     <li class='enumerate' id='x1-134013x126'>\(S=D_{f}\)<span class='cmti-10'>, para alguna funcion</span> \(\Sigma \)<span class='cmti-10'>-recursiva</span> \(f\)
     </li>
     <li class='enumerate' id='x1-134014x126'>\(S=\emptyset \) <span class='cmti-10'>o</span> \(S=I_{F}\)<span class='cmti-10'>, para alguna</span> \(F:\omega \rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>tal que cada</span> \(F_{(i)}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-p.r.</span></li></ol>

   </div>
<!-- l. 11162 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11163 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>El caso \(n=m=0\) es facil y es dejado al lector. Supongamos entonces que \(n+m\geq 1\).
</p><!-- l. 11166 --><p class='indent'>   (2)\(\Rightarrow \)(3). Haremos el caso \(k=l=1\) y \(n=m=2\). El caso general es completamente analogo. Notese
que entonces tenemos que \(S\subseteq \omega ^{2}\times \Sigma ^{\ast 2}\) y \(F:D_{F}\subseteq \omega \times \Sigma ^{\ast }\rightarrow \omega ^{2}\times \Sigma ^{\ast 2}\) es tal que \(\mathrm{Im}F=S\) y \(F_{(1)}\), \(F_{(2)}\), \(F_{(3)}\), \(F_{(4)}\) son \(\Sigma \)-recursivas. Para cada \(i\in \{1,2,3,4\}\),
sea \(\mathcal{P}_{i}\) un programa el cual computa a \(F_{(i)}\). Sea \(\leq \) un orden total sobre \(\Sigma \). Definamos \[ H_{i}=\lambda tx_{1}\alpha _{1}\left [\lnot Halt^{1,1}(t,x_{1},\alpha _{1},\mathcal{P}_{i})\right ] \]
Notar que \(D_{H_{i}}=\omega ^{2}\times \Sigma ^{\ast }\) y que \(H_{i}\) es \(\Sigma \)-mixta. Ademas sabemos que la funcion \(Halt^{1,1}\) es \((\Sigma \cup \Sigma _{p})\)-p.r. por lo cual
resulta facilmente que \(H_{i}\) es \((\Sigma \cup \Sigma _{p})\)-p.r.. Por la Proposicion de Independencia del Alfabeto
tenemos que \(H_{i}\) es \(\Sigma \)-p.r.. Entonces \(H_{i}\) es \(\Sigma \)-computable por lo cual tenemos que hay
un macro: \[ \left [\mathrm{IF}\;H_{i}(\mathrm{V}2,\mathrm{V}1,\mathrm{W}1)\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Para hacer mas intuitivo el uso de este macro lo escribiremos de la
siguiente manera \[ \left [\mathrm{IF}\;\lnot Halt^{1,1}(\mathrm{V}2,\mathrm{V}1,\mathrm{W}1,\mathcal{P}_{i})\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Para \(i=1,2\), definamos \[ E_{i}=\lambda xtx_{1}\alpha _{1}\left [x\neq E_{\#1}^{1,1}(t,x_{1},\alpha _{1},\mathcal{P}_{i})\right ] \] Para \(i=3,4\), definamos \[ E_{i}=\lambda tx_{1}\alpha _{1}\alpha \left [\alpha \neq E_{\ast 1}^{1,1}(t,x_{1},\alpha _{1},\mathcal{P}_{i})\right ] \] Dejamos al lector probar
que las funciones \(E_{i}\) son \(\Sigma \)-p.r.. O sea que son \(\Sigma \)-computables por lo cual para cada \(i\in \{1,2\}\)
hay un macro \[ \left [\mathrm{IF}\;E_{i}(\mathrm{V}2,\mathrm{V}3,\mathrm{V}1,\mathrm{W}1)\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] y para cada \(i\in \{3,4\}\) hay un macro \[ \left [\mathrm{IF}\;E_{i}(\mathrm{V}2,\mathrm{V}1,\mathrm{W}1,\mathrm{W}2)\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Haremos mas intuitiva la forma de
escribir estos macros, por ejemplo para \(i=1\), lo escribiremos de la siguiente manera
\[ \left [\mathrm{IF}\;\mathrm{V}2\neq E_{\#1}^{1,1}(\mathrm{V}3,\mathrm{V}1,\mathrm{W}1,\mathcal{P}_{1})\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Ya que la funcion \(f=\lambda x[(x)_{1}]\) es \(\Sigma \)-p.r., ella es \(\Sigma \)-computable por lo cual hay un macro \[ [\mathrm{V}2\leftarrow f(\mathrm{V}1)] \] el
cual escribiremos de la siguiente manera: \[ [\mathrm{V}2\leftarrow (\mathrm{V}1)_{1}] \] Similarmente hay macros: \[ [\mathrm{W}1\leftarrow \ast ^{\leq }(\mathrm{V}1)_{3}] \] \[ [\mathrm{V}2\leftarrow (\mathrm{V}1)_{2}] \] (dejamos
al lector entender bien el funcionamiento de estos macros). Sea \(\mathcal{P}\) el siguiente
programa de \(\mathcal{S}^{\Sigma }\): \[ \begin{array}{l} \mathrm{L}1\ \mathrm{N}20\leftarrow \mathrm{N}20+1\\{} [\mathrm{N}10\leftarrow (\mathrm{N}20)_{1}]\\{} [\mathrm{N}3\leftarrow (\mathrm{N}20)_{2}]\\{} [\mathrm{P}3\leftarrow \ast ^{\leq }(\mathrm{N}20)_{3}]\\ \left [\mathrm{IF}\;\lnot Halt^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{1})\;\mathrm{GOTO}\;\mathrm{L}1\right ]\\ \left [\mathrm{IF}\;\lnot Halt^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{2})\;\mathrm{GOTO}\;\mathrm{L}1\right ]\\ \left [\mathrm{IF}\;\lnot Halt^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{3})\;\mathrm{GOTO}\;\mathrm{L}1\right ]\\ \left [\mathrm{IF}\;\lnot Halt^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{4})\;\mathrm{GOTO}\;\mathrm{L}1\right ]\\ \left [\mathrm{IF}\;\mathrm{N}1\neq E_{\#1}^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{1})\;\mathrm{GOTO}\;\mathrm{L}1\right ]\\ \left [\mathrm{IF}\;\mathrm{N}2\neq E_{\#1}^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{2})\;\mathrm{GOTO}\;\mathrm{L}1\right ]\\ \left [\mathrm{IF}\;\mathrm{P}1\neq E_{\ast 1}^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{3})\;\mathrm{GOTO}\;\mathrm{L}1\right ]\\ \left [\mathrm{IF}\;\mathrm{P}2\neq E_{\ast 1}^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{4})\;\mathrm{GOTO}\;\mathrm{L}1\right ] \end{array} \] Dejamos al lector la tarea de comprender el funcionamiento de
este programa y convenserse de que computa la funcion \(p_{1}^{2,2}|_{S}\). Pero entonces \(p_{1}^{2,2}|_{S}\) es
\(\Sigma \)-computable por lo cual es \(\Sigma \)-recursiva, lo cual prueba (3) ya que \(\mathrm{Dom}(p_{1}^{2,2}|_{S})=S\).
</p><!-- l. 11253 --><p class='indent'>   (3)\(\Rightarrow \)(4). Supongamos \(S\neq \emptyset \). Sea \((z_{1},...,z_{n},\gamma _{1},...,\gamma _{m})\in S\) fijo. Sea \(\mathcal{P}\) un programa el cual compute a \(f\) y Sea
\(\leq \) un orden total sobre \(\Sigma \). Sea \(P:\mathbf{N}\rightarrow \omega \) dado por \(P(x)=1\) sii \[ Halt^{n,m}\left ((x)_{n+m+1},(x)_{1},...,(x)_{n},\ast ^{\leq }((x)_{n+1}),...,\ast ^{\leq }((x)_{n+m})),\mathcal{P}\right )=1 \] Es facil ver que \(P\) es \((\Sigma \cup \Sigma _{p})\)-p.r. por lo cual
es \(\Sigma \)-p.r.. Sea \(\bar{P}=P\cup C_{0}^{1,0}|_{\{0\}}\). Para \(i=1,...,n\), definamos \(F_{i}:\omega \rightarrow \omega \) de la siguiente manera \[ F_{i}(x)=\left \{ \begin{array}{ccc} (x)_{i} &amp; \text{si} &amp; \bar{P}(x)=1\\ z_{i} &amp; \text{si} &amp; \bar{P}(x)\neq 1 \end{array}\right . \] Para \(i=n+1,...,n+m\), definamos \(F_{i}:\omega \rightarrow \Sigma ^{\ast }\) de la
siguiente manera \[ F_{i}(x)=\left \{ \begin{array}{lll} \ast ^{\leq }((x)_{i}) &amp; \text{si} &amp; \bar{P}(x)=1\\ \gamma _{i-n} &amp; \text{si} &amp; \bar{P}(x)\neq 1 \end{array}\right . \] Por el lema de division por casos, cada \(F_{i}\) es \(\Sigma \)-p.r.. Es facil ver
que \(F=[F_{1},...,F_{n+m}]\) cumple (4).                                                                                □
</p>
   </div>
<!-- l. 11283 --><p class='indent'>   La prueba de (2)\(\Rightarrow \)(3) del teorema anterior es de naturaleza imperativa ya que da
explicitamente un programa (de todas maneras usa el paradigma recursivo o
Godeliano para justificar la existencia de los macros). A continuacion daremos una
prueba de (2)\(\Rightarrow \)(3) la cual es mas recursiva (aunque aun usa el paradigma imperativo
en la existencia de los programas \(\mathcal{P}_{i}\)).
</p><!-- l. 11292 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11292 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>(2)</span>\(\Rightarrow \)<span class='cmti-10'>(3).</span> </span> Para \(i=1,...,n+m\), sea \(\mathcal{P}_{i}\) un programa el cual computa a \(F_{(i)}\) y Sea \(\leq \) un orden total sobre \(\Sigma \). Sea
\(P:\mathbf{N}\times \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) dado por \(P(t,\vec{x},\vec{\alpha })=1\) sii se cumplen las siguientes condiciones </p><div class='eqnarray'>\begin{eqnarray*} Halt^{k,l}(\left ((t)_{k+l+1},(t)_{1},...,(t)_{k},\ast ^{\leq }((t)_{k+1}),...,\ast ^{\leq }((t)_{k+l})),\mathcal{P}_{1}\right ) &amp; = &amp; 1\\ &amp; &amp; \vdots \\ Halt^{k,l}\left ((t)_{k+l+1},(t)_{1}...(t)_{k},\ast ^{\leq }((t)_{k+1})...\ast ^{\leq }((t)_{k+l})),\mathcal{P}_{n+m}\right ) &amp; = &amp; 1\\ E_{\#1}^{k,l}((t)_{k+l+1},(t)_{1},...,(t)_{k},\ast ^{\leq }((t)_{k+1}),...,\ast ^{\leq }((t)_{k+l})),\mathcal{P}_{1}) &amp; = &amp; x_{1}\\ &amp; &amp; \vdots \\ E_{\#1}^{k,l}((t)_{k+l+1},(t)_{1},...,(t)_{k},\ast ^{\leq }((t)_{k+1}),...,\ast ^{\leq }((t)_{k+l})),\mathcal{P}_{n}) &amp; = &amp; x_{n}\\ E_{\ast 1}^{k,l}((t)_{k+l+1},(t)_{1},...,(t)_{k},\ast ^{\leq }((t)_{k+1}),...,\ast ^{\leq }((t)_{k+l})),\mathcal{P}_{n+1}) &amp; = &amp; \alpha _{1}\\ &amp; &amp; \vdots \\ E_{\ast 1}^{k,l}((t)_{k+l+1},(t)_{1},...,(t)_{k},\ast ^{\leq }((t)_{k+1}),...,\ast ^{\leq }((t)_{k+l})),\mathcal{P}_{n+m}) &amp; = &amp; \alpha _{m} \end{eqnarray*}
</div>Note que \(P\) es \((\Sigma \cup \Sigma _{p})\)-p.r. y por lo tanto \(P\) es \(\Sigma \)-p.r.. Pero entonces \(M(P)\) es \(\Sigma \)-r. lo cual nos dice que se
cumple (3) ya que \(D_{M(P)}=I_{F}=S\).                                                                            □
   </div>
   <div class='newtheorem'>
<!-- l. 11312 --><p class='noindent'><span class='head'>
<a id='x1-134015r127'></a>
<span class='cmbx-10'>Corollary 127.</span>  </span><span class='cmti-10'>Supongamos</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva y</span> \(S\subseteq I_{f}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r.e., entonces</span> \(f^{-1}(S)=\{(\vec{x},\vec{\alpha }):f(\vec{x},\vec{\alpha })\in S\}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r.e..</span>
</p>
   </div>
<!-- l. 11319 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11320 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Por el teorema anterior \(S=D_{g}\), para alguna funcion \(\Sigma \)-recursiva \(g\). Note que \(f^{-1}(S)=D_{g\circ f}\), lo
cual nuevamente por el teorema anterior nos dice que \(f^{-1}(S)\) es \(\Sigma \)-r.e..                    □
</p>
   </div>
<!-- l. 11326 --><p class='indent'>   Dejamos como ejercicio dar una prueba imperativa del corolario anterior. Los
Lemas <a href='#x1-134009r125'>125<!-- tex4ht:ref: restriccion1  --></a> y <a href='#x1-134003r123'>123<!-- tex4ht:ref: union e interseccion de r.e.  --></a> pueden obtenerse facilmente como corolarios del teorema
anterior. Se gana en elegancia y simplicidad pero cabe destacar que se pierde en
intuicion
</p>
   <div class='newtheorem'>
<!-- l. 11330 --><p class='noindent'><span class='head'>
<a id='x1-134016r128'></a>
<span class='cmbx-10'>Corollary 128.</span>  </span><span class='cmti-10'>Supongamos</span> \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva y</span> \(S\subseteq D_{f}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r.e., entonces</span> \(f|_{S}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursiva.</span>
</p>
   </div>
<!-- l. 11336 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11337 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Supongamos \(O=\Sigma ^{\ast }\). Por el teorema anterior \(S=D_{g}\), para alguna funcion \(\Sigma \)-recursiva
\(g\). Notese que componiendo adecuadamente podemos suponer que \(I_{g}=\{\varepsilon \}.\) O sea que
tenemos \(f|_{S}=\lambda \alpha \beta \left [\alpha \beta \right ]\circ [f,g]\).                                                                                         □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 11344 --><p class='noindent'><span class='head'>
<a id='x1-134017r129'></a>
<span class='cmbx-10'>Corollary 129.</span>  </span><span class='cmti-10'>Supongamos</span> \(S_{1},S_{2}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>son conjuntos</span> \(\Sigma \)<span class='cmti-10'>-r.e.. Entonces</span> \(S_{1}\cap S_{2}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r.e..</span>
</p>
   </div>
<!-- l. 11349 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11350 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Por el teorema anterior \(S_{i}=D_{g_{i}}\), con \(g_{1},g_{2}\) funciones \(\Sigma \)-recursivas\(.\) Notese que podemos
suponer que \(I_{g_{1}},I_{g_{2}}\subseteq \omega \) por lo que \(S_{1}\cap S_{2}=D_{\lambda xy\left [xy\right ]\circ [g_{1},g_{2}]}\) es \(\Sigma \)-r.e.\(.\)                                                            □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 11357 --><p class='noindent'><span class='head'>
<a id='x1-134018r130'></a>
<span class='cmbx-10'>Corollary 130.</span>  </span><span class='cmti-10'>Supongamos</span> \(S_{1},S_{2}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) <span class='cmti-10'>son conjuntos</span> \(\Sigma \)<span class='cmti-10'>-r.e.. Entonces</span> \(S_{1}\cup S_{2}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r.e.</span>
</p>
   </div>
<!-- l. 11362 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11363 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(S_{1}\neq \emptyset \neq S_{2}.\) Sean \(F,G:\omega \rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) tales que \(I_{F}=S_{1}\), \(I_{G}=S_{2}\) y las funciones \(F_{(i)}{\acute{}}s\) y \(G_{(i)}{\acute{}}s\) son \(\Sigma \)-recursivas. Sean
\(f=\lambda x\left [Q(x,2)\right ]\) y \(g=\lambda x\left [Q(x\dot{-}1,2)\right ].\) Sea \(H:\omega \rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) dada por \[ H_{(i)}=(F_{(i)}\circ f)\mathrm{|}_{\{x:x\mathrm{\ es\ par}\}}\cup (G_{(i)}\circ g)\mathrm{|}_{\{x:x\mathrm{\ es\ impar}\}} \] Por el Lema <a href='#x1-134009r125'>125<!-- tex4ht:ref: restriccion1  --></a> y el Lema <a href='#x1-133001r120'>120<!-- tex4ht:ref: dpc1  --></a>, cada \(H_{i}\) es \(\Sigma \)-recursiva. Ya que
\(I_{H}=S_{1}\cup S_{2}\).tenemos que \(S_{1}\cup S_{2}\) es \(\Sigma \)-r.e.                                                                          □

</p>
   </div>
<!-- l. 11382 --><p class='indent'>   A continuacion dejamos un sketch de una prueba alternativa del Teorema <a href='#x1-134006r124'>124<!-- tex4ht:ref: carac recursivos  --></a>.
Dejamos al lector completar los detalles.
</p><!-- l. 11384 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11385 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a)\(\Rightarrow \)(b)\(.\) Note que \(S=D_{Pred\circ \chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}}.\)
</p><!-- l. 11387 --><p class='indent'>   (b)\(\Rightarrow \)(a). Note que \(\chi _{S}^{\omega ^{n}\times \Sigma ^{\ast m}}=C_{1}^{n,m}\)\(|\)\(_{S}\cup C_{0}^{n,m}\)\(|\)\(_{(\omega ^{n}\times \Sigma ^{\ast m})-S}\).                                                                          □
</p>
   </div>
<!-- l. 11391 --><p class='indent'>   Los dos siguientes teoremas, nos agregan una equivalencia mas al Teorema <a href='#x1-134010r126'>126<!-- tex4ht:ref: equivalencias-r.e.  --></a>,
para el caso \(n=0\), \(m=1\).
</p>
   <div class='newtheorem'>
<!-- l. 11393 --><p class='noindent'><span class='head'>
<a id='x1-134019r131'></a>
<span class='cmbx-10'>Teorema 131.</span>  </span><span class='cmti-10'>Si</span>  \(L\subseteq \Sigma ^{\ast }\)  <span class='cmti-10'>es</span>  \(\Sigma \)<span class='cmti-10'>-r.e.,  entonces</span>  \(L=L(M)=H(M)\)  <span class='cmti-10'>para   alguna  maquina  de  Turing
</span><span class='cmti-10'>deterministica</span> \(M\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 11398 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11399 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>La prueba es similar a la del Teorema <a href='#x1-130004r116'>116<!-- tex4ht:ref: ComputableImplicaTuringComputable  --></a> asique solo daremos un skech de
la misma. Por el Teorema <a href='#x1-134010r126'>126<!-- tex4ht:ref: equivalencias-r.e.  --></a> \(L=D_{f}\) para alguna funcion \(f\) la cual es \(\Sigma \)-recursiva. Notese
que podemos suponer que \(\mathrm{Im}f\subseteq \Sigma ^{\ast }\). Ya que \(f\) es \(\Sigma \)-recursiva, tambien es \(\Sigma \)-computable. Por
el Lema <a href='#x1-130001r115'>115<!-- tex4ht:ref: sinGOTO  --></a> existe \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) el cual computa \(f\) y tiene las propiedades (1) y (2). Sea \(k=N(\mathcal{P})\) y sea
\(M_{sim}\) la maquina de Turing con unit que simula a \(\mathcal{P}\) respecto de \(k\). Sea \(M_{1}\) una maquina de
Turing deterministica con un solo estado final \(q_{f}\) (del cual no salen flechas) y tal
que para todo \(\alpha \in \Sigma ^{\ast }\), \[ \left \lfloor q_{0}B\alpha \right \rfloor \overset{\ast }{\vdash }\left \lfloor q_{f}B^{k+1}\alpha \right \rfloor \] Note que la concatenacion de \(M_{1}\) con \(M\) produce una maquina de
Turing deterministica \(M_{2}\) tal que \(H(M_{2})=L(M_{2})=L\). Dejamos al lector los detalles de la construccion
de \(M_{2}.\)                                                                                                  □

</p>
   </div>
   <div class='newtheorem'>
<!-- l. 11419 --><p class='noindent'><span class='head'>
<a id='x1-134020r132'></a>
<span class='cmbx-10'>Teorema 132.</span>  </span><span class='cmti-10'>Sea</span> \(M=\left (Q,\Sigma ,\Gamma ,\delta ,q_{0},B,F\right )\) <span class='cmti-10'>una maquina de Turing. Entonces</span> \(L(M)\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-recursivamente
</span><span class='cmti-10'>enumerable.</span>
</p>
   </div>
<!-- l. 11424 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11425 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea \(P\) el siguiente predicado \((\Gamma \cup Q)\)-mixto \[ \lambda n\alpha \left [(\exists d\in Des)\;\left \lfloor q_{0}B\alpha \right \rfloor \underset{M}{\overset{n}{\vdash }}d\wedge St(d)\in F\right ] \] Notese que \(D_{P}=\omega \times \Gamma ^{\ast }\). Dejamos al lector probar
que \(P\) es \((\Gamma \cup Q)\)-p.r.. Sea \(P^{\prime }=P|_{\omega \times \Sigma ^{\ast }}\). Notese que \(P^{\prime }(n,\alpha )=1\) sii \(\alpha \in L(M)\) atestiguado por una computacion de longitud
\(n\). Ya que \(P^{\prime }\) es \((\Gamma \cup Q)\)-p.r. (por que?) y ademas es \(\Sigma \)-mixto, el Teorema <a href='#x1-97010r84'>84<!-- tex4ht:ref: independencia  --></a> nos dice que \(P^{\prime }\) es
\(\Sigma \)-p.r.. Ya que \(L(M)=D_{M(P^{\prime })}\), el Teorema <a href='#x1-134010r126'>126<!-- tex4ht:ref: equivalencias-r.e.  --></a> nos dice que \(L(M)\) es \(\Sigma \)-r.e..                                  □
</p>
   </div>
<!-- l. 11439 --><p class='indent'>   @@finpagina@@
</p><!-- l. 11444 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.6.3   </span> <a id='x1-1350003.6.3'></a>El halting problem y los conjuntos \(A\) y \(N\)</h5>
<!-- l. 11446 --><p class='noindent'>Cuando \(\Sigma \supseteq \Sigma _{p}\), podemos definir \[ AutoHalt^{\Sigma }=\lambda \mathcal{P}\left [(\exists t\in \omega )\;Halt^{0,1}(t,\mathcal{P},\mathcal{P})\right ]\text{.} \] Notar que el dominio de \(AutoHalt^{\Sigma }\) es \(\mathrm{Pro}^{\Sigma }\) y que para cada \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) tenemos
que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-135001x3.6.3'>\(AutoHalt(\mathcal{P})=1\) sii \(\mathcal{P}\) se detiene partiendo del estado \(\left \Vert \mathcal{P}\right \Vert \).</li></ol>
<div class='newtheorem'>
<!-- l. 11456 --><p class='noindent'><span class='head'>
<a id='x1-135002r133'></a>
<span class='cmbx-10'>Lema 133.</span>  </span><span class='cmti-10'>Supongamos</span> \(\Sigma \supseteq \Sigma _{p}\)<span class='cmti-10'>. Entonces</span> \(AutoHalt^{\Sigma }\) <span class='cmti-10'>no es</span> \(\Sigma \)<span class='cmti-10'>-recursivo.</span>

</p>
</div>
<!-- l. 11461 --><p class='noindent'>
</p>
   <div class='proof'>
<!-- l. 11462 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(AutoHalt^{\Sigma }\) es \(\Sigma \)-recursivo y por lo tanto \(\Sigma \)-computable. Por la proposicion de
existencia de macros tenemos que hay un macro \[ \left [\mathrm{IF}\;AutoHalt^{\Sigma }(\mathrm{W}1)\;\mathrm{GOTO}\;\mathrm{A}1\right ] \] Sea \(\mathcal{P}_{0}\) el siguiente programa de \(\mathcal{S}^{\Sigma }\) \[ \mathrm{L}1\;\left [\mathrm{IF}\;AutoHalt^{\Sigma }(\mathrm{P}1)\;\mathrm{GOTO}\;\mathrm{L}1\right ] \] Note
que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-135003x3.6.3'>\(\mathcal{P}_{0}\) termina partiendo desde \(\left \Vert \mathcal{P}_{0}\right \Vert \) sii \(AutoHalt^{\Sigma }(\mathcal{P}_{0})=0\),</li></ol>
<!-- l. 11477 --><p class='noindent'>lo cual produce una contradiccion si tomamos en (*) \(\mathcal{P}=\mathcal{P}_{0}\).                                    □
</p>
   </div>
<!-- l. 11481 --><p class='noindent'>Usando el lema anterior y la Tesis de Church podemos probar el siguiente impactante
resultado.
</p>
   <div class='newtheorem'>
<!-- l. 11483 --><p class='noindent'><span class='head'>
<a id='x1-135004r134'></a>
<span class='cmbx-10'>Teorema 134.</span>  </span><span class='cmti-10'>Supongamos</span> \(\Sigma \supseteq \Sigma _{p}\)<span class='cmti-10'>. Entonces</span> \(AutoHalt^{\Sigma }\) <span class='cmti-10'>no es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable. Es
</span><span class='cmti-10'>decir  no  hay  ningun  procedimiento  efectivo  que  decida  si  un  programa  de</span>  \(\mathcal{S}^{\Sigma }\)
<span class='cmti-10'>termina partiendo de si mismo.</span>
</p>
   </div>
<!-- l. 11490 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11491 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Si \(AutoHalt^{\Sigma }\) fuera \(\Sigma \)-efectivamente computable, la Tesis de Church nos diria que es
\(\Sigma \)-recursivo, contradiciendo el lema anterior.                                              □
</p>
   </div>

<!-- l. 11497 --><p class='indent'>   Notese que \(AutoHalt^{\Sigma }\) provee de un ejemplo natural en el cual la cuantificacion (no
acotada) de un predicado \(\Sigma \)-p.r. con dominio rectangular no es \(\Sigma \)-efectivamente
computable
</p><!-- l. 11501 --><p class='indent'>   Ahora estamos en condiciones de dar un ejemplo natural de un conjunto \(A\) que es
\(\Sigma \)-recursivamente enumerable pero el cual no es \(\Sigma \)-recursivo.
</p>
   <div class='newtheorem'>
<!-- l. 11504 --><p class='noindent'><span class='head'>
<a id='x1-135005r135'></a>
<span class='cmbx-10'>Lema 135.</span>  </span><span class='cmti-10'>Supongamos que</span> \(\Sigma \supseteq \Sigma _{p}.\) <span class='cmti-10'>Entonces </span>\[ A=\left \{ \mathcal{P}\in \mathrm{Pro}^{\Sigma }:AutoHalt^{\Sigma }(\mathcal{P})=1\right \} \] <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r.e. y no es</span> \(\Sigma \)<span class='cmti-10'>-recursivo. Mas aun el
</span><span class='cmti-10'>conjunto </span>\[ N=\left \{ \mathcal{P}\in \mathrm{Pro}^{\Sigma }:AutoHalt^{\Sigma }(\mathcal{P})=0\right \} \] <span class='cmti-10'>no es</span> \(\Sigma \)<span class='cmti-10'>-r.e.</span>
</p>
   </div>
<!-- l. 11517 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11518 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Para  ver  que  \(A\)  es  \(\Sigma \)-r.e.  se  lo  puede  hacer  imperativamente  dando  un
programa (usando macros) que enumere a \(A\). De esta forma probariamos que \(A\) es
\(\Sigma \)-enumerable y por lo tanto es \(\Sigma \)-r.e.. Daremos ahora una prueba no imperativa
de este hecho, es decir mas propia del paradigma funcional. Sea \(P=\lambda t\mathcal{P}\left [Halt^{0,1}(t,\mathcal{P},\mathcal{P})\right ]\). Note que \(P\) es
\(\Sigma \)-p.r. por lo que \(M(P)\) es \(\Sigma \)-r.. Ademas note que \(D_{M(P)}=A\), lo cual implica que \(A\) es \(\Sigma \)-r.e..
</p><!-- l. 11526 --><p class='indent'>   Supongamos ahora que \(N\) es \(\Sigma \)-r.e.. Entonces la funcion \(C_{0}^{0,1}|_{N}\) es \(\Sigma \)-recursiva ya que \(C_{0}^{0,1}\)
lo es. Ademas ya que \(A\) es \(\Sigma \)-r.e. tenemos que \(C_{1}^{0,1}|_{A}\) es \(\Sigma \)-recursiva. Ya que \[ AutoHalt^{\Sigma }=C_{1}^{0,1}|_{A}\cup C_{0}^{0,1}|_{N} \] el Lema <a href='#x1-133001r120'>120<!-- tex4ht:ref: dpc1  --></a>
nos dice que \(AutoHalt^{\Sigma }\) es \(\Sigma \)-recursivo, contradiciendo el Lema <a href='#x1-135002r133'>133<!-- tex4ht:ref: autohalt  --></a>. Esto prueba que \(N\) no es
\(\Sigma \)-r.e..
</p><!-- l. 11537 --><p class='indent'>   Finalmente supongamos \(A\) es \(\Sigma \)-recursivo. Entonces el conjunto \[ N=\left (\Sigma ^{\ast }-A\right )\cap \mathrm{Pro}^{\Sigma } \] deberia serlo,
lo cual es absurdo. Hemos probado entonces que \(A\) no es \(\Sigma \)-recursivo.               □
</p>
   </div>
<!-- l. 11546 --><p class='indent'>   Cabe destacar aqui que el dominio de una funcion \(\Sigma \)-recursiva no siempre sera un
conjunto \(\Sigma \)-recursivo. Por ejemplo si tomamos \(\Sigma \) tal que \(\Sigma \supseteq \Sigma _{p}\), entonces \(C_{1}^{0,1}|_{A}\) es una funcion
\(\Sigma \)-recursiva ya que es la restriccion de la funcion \(\Sigma \)-recursiva \(C_{1}^{0,1}\) al conjunto \(\Sigma \)-r.e. \(A\), pero \(\mathrm{Dom}(C_{1}^{0,1}|_{A})=A\) no
es \(\Sigma \)-recursivo.
</p><!-- l. 11555 --><p class='indent'>   Usando la Tesis de Church obtenemos el siguiente resultado.
</p>
   <div class='newtheorem'>
<!-- l. 11556 --><p class='noindent'><span class='head'>
<a id='x1-135006r136'></a>

<span class='cmbx-10'>Proposition 136.</span>  </span><span class='cmti-10'>Supongamos que</span> \(\Sigma \supseteq \Sigma _{p}.\) <span class='cmti-10'>Entonces</span> \(A\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente enumerable y
</span><span class='cmti-10'>no es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente computable. El conjunto</span> \(N\) <span class='cmti-10'>no es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente enumerable.
</span><span class='cmti-10'>Es  decir,</span>  \(A\)  <span class='cmti-10'>puede  ser  enumerado  por  un  procedimiento  efectivo  pero  no  hay
</span><span class='cmti-10'>ningun procedimiento efectivo que decida la pertenencia a</span> \(A\) <span class='cmti-10'>y no hay ningun
</span><span class='cmti-10'>procedimiento efectivo que enumere a</span> \(N\)<span class='cmti-10'>. Mas aun, si un procedimiento efectivo
</span><span class='cmti-10'>da como salida siempre elementos de</span> \(N\)<span class='cmti-10'>, entonces hay una cantidad infinita de
</span><span class='cmti-10'>elementos de</span> \(N\) <span class='cmti-10'>los cuales nunca da como salida</span>
</p>
   </div>
<!-- l. 11570 --><p class='indent'>   Con los resultados anteriores estamos en condiciones de dar un ejemplo de un
predicado \(\Sigma \)-recursivo, cuya minimizacion no es \(\Sigma \)-efectivamente computable (y por lo
tanto es no \(\Sigma \)-recursiva).
</p>
   <div class='newtheorem'>
<!-- l. 11576 --><p class='noindent'><span class='head'>
<a id='x1-135007r137'></a>
<span class='cmbx-10'>Proposition 137.</span>  </span><span class='cmti-10'>Supongamos que</span> \(\Sigma \supseteq \Sigma _{p}\)<span class='cmti-10'>. Sea</span> \(P=C_{1}^{0,1}|_{A}\circ \lambda t\alpha \left [\alpha ^{1\dot{-}t}\mathrm{SKIP}^{t}\right ]|_{\omega \times \mathrm{Pro}^{\Sigma }}\)<span class='cmti-10'>. La funcion</span> \(M(P)\) <span class='cmti-10'>no es</span> \(\Sigma \)<span class='cmti-10'>-efectivamente
</span><span class='cmti-10'>computable (y por lo tanto es no</span> \(\Sigma \)<span class='cmti-10'>-recursiva)</span>
</p>
   </div>
<!-- l. 11583 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11584 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que \(D_{M(P)}=\mathrm{Pro}^{\Sigma }\) y que para cada \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) se tiene que \[ M(P)(\mathcal{P})=0\text{ sii }\mathcal{P}\in A \] O sea que \(AutoHalt^{\Sigma }=\lambda x[x=0]\circ M(P)\) lo cual nos dice
que \(M(P)\) no es \(\Sigma \)-recursiva ya que si lo fuese lo seria tambien \(AutoHalt^{\Sigma }\). Por la Tesis de Church
\(M(P)\) tampoco es \(\Sigma \)-efectivamente computable                                                  □
</p>
   </div>
<!-- l. 11598 --><p class='indent'>   Supongamos \(\Sigma \supseteq \Sigma _{p}\). Sea \(f=\lambda \mathcal{P}\left [T^{0,1}(\mathcal{P},\mathcal{P})\right ]\). Note que \(D_{f}=A\) y \(f(\mathcal{P})\) es la cantidad de pasos en la que \(\mathcal{P}\) se detiene
partiendo de \(\left \Vert \mathcal{P}\right \Vert \).
</p>
   <div class='newtheorem'>
<!-- l. 11601 --><p class='noindent'><span class='head'>
<a id='x1-135008r138'></a>

<span class='cmbx-10'>Lema 138.</span>  </span><span class='cmti-10'>No hay ninguna funcion</span> \(F:\mathrm{Pro}^{\Sigma }\rightarrow \omega \) <span class='cmti-10'>la cual sea</span> \(\Sigma \)<span class='cmti-10'>-recursiva y extienda a</span> \(f\)
</p>
   </div>
<!-- l. 11606 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11607 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos hay una tal \(F\). Notese que \(AutoHalt^{\Sigma }=\lambda \mathcal{P}\left [Halt^{0,1}(F(\mathcal{P}),\mathcal{P},\mathcal{P})\right ]\) lo cual nos dice que \(AutoHalt^{\Sigma }\) es \(\Sigma \)-recursiva,
llegando a una contradiccion.                                                               □
</p>
   </div>
<!-- l. 11613 --><p class='indent'>   @@finpagina@@
</p><!-- l. 11615 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>4   </span> <a id='x1-1360004'></a>Estructuras algebraicas ordenadas</h3>
<!-- l. 11617 --><p class='noindent'>En esta seccion estudiaremos varios clases de estructuras algebraicas en las
cuales hay un orden parcial involucrado. Esto tendra una doble utilidad. Por
un lado algunos de los resultados probados sobre algebras de Boole (por
ejemplo el teorema de Rasiova y Sikorski) seran utilizados mas adelante
para la prueba del teorema de completitud de la logica de primer orden.
Tambien las diversas estructuras que veamos nos serviran como ejemplos de
estructuras de primer orden y muchas de las pruebas dadas en este capitulo seran
inspiradoras para definir el concepto de prueba formal en una teoria de primer
orden.
</p><!-- l. 11630 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>4.1   </span> <a id='x1-1370004.1'></a>Conjuntos parcialmente ordenados</h4>
<!-- l. 11632 --><p class='noindent'>Recordamos que tal como se lo definio en la Seccion <a href='#x1-200001.6.2'>1.6.2<!-- tex4ht:ref: ordenes parciales  --></a>, una relacion binaria \(\leq \) sobre
un conjunto \(P\) es llamada un <span class='cmti-10'>orden parcial sobre</span> \(P\)<span class='cmti-10'> </span>si se cumplen las siguientes
condiciones:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-137001x4.1'>\(\leq \) es reflexiva, i. e. para todo \(a\in P\), \(a\leq a\)

     </li>
     <li class='enumerate' id='x1-137002x4.1'>\(\leq \) es antisimetrica, i. e. para todo \(a,b\in P\), si \(a\leq b\) y \(b\leq a\), entonces \(a=b.\)
     </li>
     <li class='enumerate' id='x1-137003x4.1'>\(\leq \) es transitiva, i. e. para todo \(a,b,c\in P\), si \(a\leq b\) y \(b\leq c\), entonces \(a\leq c\).</li></ol>
<!-- l. 11643 --><p class='noindent'>(recomendamos antes de leer este tema, leer la Seccion <a href='#x1-200001.6.2'>1.6.2<!-- tex4ht:ref: ordenes parciales  --></a>, para familiarizarse con la
notacion y las propiedades basicas de los ordenes parciales).
</p><!-- l. 11647 --><p class='indent'>   Un <span class='cmti-10'>conjunto parcialmente ordenado o poset </span>es un par \((P,\leq )\) donde \(P\) es un conjunto no
vacio cualquiera y \(\leq \) es un orden parcial sobre \(P\). Dado un poset \((P,\leq )\), el conjunto \(P\) sera
llamado el <span class='cmti-10'>universo </span>de \((P,\leq )\). Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-137004x4.1'>\((\mathbf{R},\leq )\) es un poset, donde \(\leq \) es el orden usual de los numeros relales
     </li>
     <li class='enumerate' id='x1-137005x4.1'>\((\{1,2,3\},\{(1,2),(1,3),(1,1),(2,2),(3,3)\})\) es un poset
     </li>
     <li class='enumerate' id='x1-137006x4.1'>\((\mathcal{P}(\omega ),\leq )\) es un poset, donde \(\mathrm{\leq }=\{(S,T)\in \mathcal{P}(\omega )^{2}:S\subseteq T\}\)
     </li>
     <li class='enumerate' id='x1-137007x4.1'>\((\{1\},\{(1,1)\}\) es un poset
     </li>
     <li class='enumerate' id='x1-137008x4.1'>\((\mathbf{N},\leq )\) es un poset, donde \(\mathrm{\leq }=\{(n,m)\in \mathbf{N}^{2}:n\mid m\}\)</li></ol>
<!-- l. 11659 --><p class='noindent'>Usaremos la siguiente
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-137009x4.1'>Si hemos denotado con \(\leq \) a cierto orden parcial sobre un conjunto \(A\),
     entonces
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-137011x1'>Denotaremos con \(&lt;\) a la relacion binaria \(\{(a,b)\in A^{2}:a\leq b\) y \(a\neq b\}\). Es decir que \(\mathrm{&lt;}=\{(a,b)\in A^{2}:a\leq b\) y \(a\neq b\}\). Cuando
         se de \(a&lt;b\) diremos que \(a\) <span class='cmti-10'>es menor que</span> \(b\) o que \(b\) <span class='cmti-10'>es mayor que</span> \(a\) (<span class='cmti-10'>respecto de</span>
         \(\leq \))
         </li>
         <li class='enumerate' id='x1-137013x2'>Denotaremos con \(\prec \) a la relacion binaria \[ \{(a,b)\in A^{2}:a&lt;b\text{ y no existe }z\text{ tal que }a&lt;z&lt;b\} \] Cuando se de \(a\prec b\) diremos que \(a\)
         <span class='cmti-10'>es cubierto por</span> \(b\) o que \(b\) <span class='cmti-10'>cubre a</span> \(a\) (<span class='cmti-10'>respecto de</span> \(\leq \))</li></ol>
     </li></ol>
<!-- l. 11677 --><p class='noindent'>El mismo tipo de convencion notacional se hara cuando denotemos con \(\leq ^{\prime }\) (o \(\tilde{\leq }\), etc) a un
orden parcial sobre \(A\). Es decir tendremos dos relaciones binarias nuevas tacitamente
definidas, a saber: </p><div class='eqnarray'>\begin{eqnarray*} &amp; \mathrm{&lt;} &amp; ^{\prime }=\{(a,b)\in A^{2}:a\leq ^{\prime }b\text{ y }a\neq b\}\\ &amp; \mathrm{\prec } &amp; ^{\prime }=\{(a,b)\in A^{2}:a&lt;^{\prime }b\text{ y no existe }z\text{ tal que }a&lt;^{\prime }z&lt;^{\prime }b\} \end{eqnarray*}
</div>

<!-- l. 11687 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.1.1   </span> <a id='x1-1380004.1.1'></a>Diagramas de Hasse</h5>
<!-- l. 11689 --><p class='noindent'>Dado un poset \((P,\leq )\), con \(P\) un conjunto finito, podemos realizar un diagrama llamado
<span class='cmti-10'>diagrama de Hasse, </span>siguiendo las siguientes instrucciones:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-138001x4.1.1'>Asociar en forma inyectiva, a cada \(a\in \) \(P\) un punto \(p_{a}\) del plano
     </li>
     <li class='enumerate' id='x1-138002x4.1.1'>Trazar un segmento de recta uniendo los puntos \(p_{a}\) y \(p_{b}\), cada vez que \(a\prec b\)
     </li>
     <li class='enumerate' id='x1-138003x4.1.1'>Realizar lo indicado en los puntos (1) y (2) en tal forma que
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-138004x4.1.1'>Si \(a\prec b\), entonces \(p_{a}\) esta por debajo de \(p_{b}\)
         </li>
         <li class='enumerate' id='x1-138005x4.1.1'>Si un punto \(p_{a}\) ocurre en un segmento del diagrama entonces lo hace
         en alguno de sus extremos.</li></ol>
     </li></ol>
<!-- l. 11704 --><p class='noindent'>La relacion de orden \(\leq \) puede ser facilmente obtenida a partir del diagrama, a saber, \(a\leq b\)
sucedera si y solo si \(p_{a}=p_{b}\) o hay una sucesion de segmentos ascendentes desde \(p_{a}\) hasta
\(p_{b}\).
</p><!-- l. 11708 --><p class='indent'>   Algunos ejemplos:
</p><!-- l. 11713 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.1.2   </span> <a id='x1-1390004.1.2'></a>Elementos maximales, maximos, minimales y minimos</h5>
<!-- l. 11715 --><p class='noindent'>Sea \((P,\leq )\) un poset. Diremos que \(a\in P\) es un elemento <span class='cmti-10'>maximal de</span> \((P,\leq )\) si no existe un \(b\in P\) tal
que \(a&lt;b\). Diremos que \(a\in P\) es un elemento <span class='cmti-10'>maximo de</span> \((P,\leq )\) si \(b\leq a\), para todo \(b\in P\). En forma
analoga se definen los conceptos de elemento <span class='cmti-10'>minimal </span>y <span class='cmti-10'>minimo</span>. Algunos
ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-139001x4.1.2'>Sea \(\leq \) el orden usual de los numeros reales. El poset \((\mathbf{R},\leq )\) no tiene elemento
     maximo ni minimo. Tampoco tiene elementos maximales ni minimales.
     </li>
     <li class='enumerate' id='x1-139002x4.1.2'>El poset \(\mathbf{P}=(\{1,2,3\},\{(1,2),(1,3),(1,1),(2,2),(3,3)\})\) no tiene elemento maximo. \(1\) es un elemento minimo de \(\mathbf{P}\). El unico
     elemento minimal de \(\mathbf{P}\) es \(1\). Los elementos \(2\) y \(3\) son los unicos maximales de
     \(\mathbf{P}\).
     </li>
     <li class='enumerate' id='x1-139003x4.1.2'>\(1\) es un elemento maximo de del poset \((\{1\},\{(1,1)\})\). Tambien \(1\) es un elemento minimo
     de \((\{1\},\{(1,1)\})\).</li></ol>

<!-- l. 11731 --><p class='noindent'>Como lo muestra el ejemplo (E3), no siempre hay elementos maximales o maximos en
un poset. Ademas un poset tiene a lo sumo un maximo y un minimo (por
que?), los cuales en caso de existir algunas veces seran denotados con \(1\) y \(0\),
respectivamente. Tambien diremos que \((P,\leq )\) <span class='cmti-10'>tiene un</span> \(1\) (resp. \(0\)) para expresar que \((P,\leq )\) tiene
un elemento maximo (resp. minimo). Notese tambien que todo elemento
maximo (resp. minimo) de \((P,\leq )\) es un elemento maximal (resp. minimal) de \((P,\leq )\) (por
que?).
</p><!-- l. 11743 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.1.3   </span> <a id='x1-1400004.1.3'></a>Supremos</h5>
<!-- l. 11745 --><p class='noindent'>Sea \((P,\leq )\) un poset. Dado \(S\subseteq P\), diremos que un elemento \(a\in P\) es <span class='cmti-10'>cota superior de</span> \(S\) <span class='cmti-10'>en</span> \((P,\leq )\) cuando
\(b\leq a\), para todo \(b\in S\). Notese que todo elemento de \(P\) es cota superior de \(\emptyset \) en \((P,\leq )\). Un
elemento \(a\in P\) sera llamado <span class='cmti-10'>supremo de</span> \(S\) <span class='cmti-10'>en</span> \((P,\leq )\) cuando se den las siguientes dos
propiedades
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-140001x4.1.3'>\(a\) es a cota superior de \(S\) en \((P,\leq )\)
     </li>
     <li class='enumerate' id='x1-140002x4.1.3'>Para cada \(b\in P\), si \(b\) es una cota superior de \(S\) en \((P,\leq )\), entonces \(a\leq b\).</li></ol>
<!-- l. 11756 --><p class='noindent'>Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-140003x4.1.3'>Consideremos el poset \((\mathbf{R},\leq )\), donde \(\leq \) es el orden usual de los numeros reales. Notese
     que ningun elemento de \(\mathbf{R}\) es cota superior de \(\omega \) en \((\mathbf{R},\leq )\). O sea que ningun elemento de
     \(\mathbf{R}\) es supremo de \(\omega \) en \((\mathbf{R},\leq )\). Sea <div class='eqnarray'>\begin{eqnarray*} S &amp; = &amp; \{-1/n:n\in \mathbf{N}\}\\ &amp; = &amp; \{-1,-1/2,-1/3,...\} \end{eqnarray*}
     </div>Es facil ver que \(0\) es supremo de \(S\) en \((\mathbf{R},\leq )\).
     </li>
     <li class='enumerate' id='x1-140004x4.1.3'>Consideremos el poset \((\mathcal{P}(\omega ),\leq )\), donde \(\mathrm{\leq }=\{(A,B)\in \mathcal{P}(\omega )^{2}:A\subseteq B\}\). Sean \(A,B\in \mathcal{P}(\omega )\). Es facil ver que \(A\cup B\) es supremo de \(\{A,B\}\) en
     \((\mathcal{P}(\omega ),\leq )\).
     </li>
     <li class='enumerate' id='x1-140005x4.1.3'>Sea \(\mathrm{\leq }_{d}=\{(n,m)\in \mathbf{N}^{2}:n\mid m\}\). Veamos que en el poset \((\mathbf{N},\leq _{d})\) se tiene que \(\sup \{n,m\}=mcm(n,m)\). Es claro que \(mcm(n,m)\) es multiplo de \(n\) y \(m\) por
     lo cual es cota superior de \(\{n,m\}\) en \((\mathbf{N},\leq _{d})\). Para terminar de probar que \(mcm(n,m)=\sup \{n,m\}\) nos faltaria ver
     que si \(x\) es cota superior de \(\{n,m\}\) en \((\mathbf{N},\leq _{d})\), entonces \(mcm(n,m)\leq _{d}x\). Es decir debemos probar que si \(n\mid x\) y \(m\mid x\),
     entonces \(mcm(n,m)\mid x\), o dicho de otra forma que si \(x\) es multiplo de \(n\) y de \(m\), entonces \(mcm(n,m)\mid x\). Pero
     esta es una propiedad basica del minimo comun multiplo la cual aceptaremos
     sin demostracion. Pregunta: ¿No es mas simple decir que \(mcm(n,m)=\sup \{n,m\}\) ya que \(mcm(n,m)\) por
     definicion es el menor multiplo comun, es decir la menor cota superior de
     \(\{n,m\}\)?</li></ol>
<!-- l. 11785 --><p class='noindent'>Como lo muestra el ejemplo (E1) no siempre existe un supremo de \(S\) en \((P,\leq )\). Ademas
notese que en caso de existir es unico, es decir, si \(a\) es supremo de \(S\) en \((P,\leq )\) y \(a^{\prime }\) es

supremo de \(S\) en \((P,\leq )\), entonces \(a=a^{\prime }\) (por que?). Esto nos permite hablar de EL supremo
de \(S\) en \((P,\leq )\), cuando exista. Denotaremos con \(\sup (S)\) al supremo de \(S\) en \((P,\leq )\), en caso de
que exista. Notese que (E1) nos muestra que no siempre el supremo de un
conjunto pertenece al conjunto. Notese ademas que en caso de existir, \(\sup (\emptyset )\) en \((P,\leq )\) es un
elemento minimo de \((P,\leq )\). Esto es porque todo elemento de \(P\) es cota superior de \(\emptyset \) en
\((P,\leq )\).
</p><!-- l. 11797 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.1.4   </span> <a id='x1-1410004.1.4'></a>Infimos</h5>
<!-- l. 11799 --><p class='noindent'>Sea \((P,\leq )\) un poset. Dado \(S\subseteq P\), diremos que un elemento \(a\in P\) es <span class='cmti-10'>cota inferior de</span> \(S\) <span class='cmti-10'>en</span> \((P,\leq )\),
cuando \(a\leq b\), para cada \(b\in S\). Notese que todo elemento de \(P\) es cota inferior de \(\emptyset \) en \((P,\leq )\).
Un elemento \(a\in P\) sera llamado <span class='cmti-10'>infimo de</span> \(S\) <span class='cmti-10'>en</span> \((P,\leq )\) cuando se den las siguientes dos
propiedades
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-141001x4.1.4'>\(a\) es a cota inferior de \(S\) en \((P,\leq )\)
     </li>
     <li class='enumerate' id='x1-141002x4.1.4'>Para cada \(b\in P\), si \(b\) es una cota inferior de \(S\) en \((P,\leq )\), entonces \(b\leq a\).</li></ol>
<!-- l. 11810 --><p class='noindent'>Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-141003x4.1.4'>Consideremos el poset \((\mathbf{R},\leq )\), donde \(\leq \) es el orden usual de los numeros reales. Notese
     que ningun elemento de \(\mathbf{R}\) es cota inferior de \(\mathbf{Z}\) en \((\mathbf{R},\leq )\). O sea que ningun elemento de
     \(\mathbf{R}\) es infimo de \(\mathbf{Z}\) en \((\mathbf{R},\leq )\). Sea <div class='eqnarray'>\begin{eqnarray*} S &amp; = &amp; \{1/n:n\in \mathbf{N}\}\\ &amp; = &amp; \{1,1/2,1/3,...\} \end{eqnarray*}
     </div>Es facil ver que \(0\) es infimo de \(S\) en \((\mathbf{R},\leq )\). Notar que \(\inf S\notin S\).
     </li>
     <li class='enumerate' id='x1-141004x4.1.4'>Consideremos el poset \((\mathcal{P}(\omega ),\leq )\), donde \(\mathrm{\leq }=\{(A,B)\in \mathcal{P}(\omega )^{2}:A\subseteq B\}\). Sean \(A,B\in \mathcal{P}(\omega )\). Es facil ver que \(A\cap B\) es infimo de \(\{A,B\}\) en
     \((\mathcal{P}(\omega ),\leq )\).
     </li>
     <li class='enumerate' id='x1-141005x4.1.4'>Sea \(\mathrm{\leq }_{d}=\{(n,m)\in \mathbf{N}^{2}:n\mid m\}\). Veamos que en el poset \((\mathbf{N},\leq _{d})\) se tiene que \(\inf \{n,m\}=mcd(n,m)\). Es claro que \(mcd(n,m)\) divide a \(n\) y \(m\) por lo
     cual es cota inferior de \(\{n,m\}\) en \((\mathbf{N},\leq _{d})\). Para terminar de probar que \(mcd(n,m)=\inf \{n,m\}\) nos faltaria ver que si
     \(x\) es cota inferior de \(\{n,m\}\) en \((\mathbf{N},\leq _{d})\), entonces \(x\leq _{d}mcd(n,m)\). Es decir debemos probar que si \(x\mid n\) y \(x\mid m\), entonces
     \(x\mid mcd(n,m)\). Pero esta es una propiedad basica del maximo comun divisor la cual
     aceptaremos sin demostracion. Pregunta: ¿No es mas simple decir que \(mcd(n,m)=\inf \{n,m\}\) ya que \(mcd(n,m)\)
     por definicion es el maximo de los divisores comunes, es decir la mayor cota
     inferior de \(\{n,m\}\)?</li></ol>
<!-- l. 11839 --><p class='noindent'>Como lo muestra el ejemplo (E1) no siempre existe un infimo de \(S\) en \((P,\leq )\). Ademas notese que
en caso de existir es unico, es decir, si \(a\) es infimo de \(S\) en \((P,\leq )\) y \(a^{\prime }\) es infimo de \(S\) en \((P,\leq )\),
entonces \(a=a^{\prime }\) (por que?). Esto nos permite hablar de EL infimo de \(S\) en \((P,\leq )\), cuando
exista. Denotaremos con \(\inf (S)\) al infimo de \(S\) en \((P,\leq )\), en caso de que exista. Notese
que (E1) nos muestra que no siempre el infimo de un conjunto pertenece al

conjunto. Notese ademas que en caso de existir, \(\inf (\emptyset )\) en \((P,\leq )\) es un elemento maximo de
\((P,\leq )\).
</p><!-- l. 11853 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.1.5   </span> <a id='x1-1420004.1.5'></a>Homomorfismos de posets</h5>
<!-- l. 11855 --><p class='noindent'>Sean \((P,\leq )\) y \((P^{\prime },\leq ^{\prime })\) posets. Una funcion \(F:P\rightarrow P^{\prime }\) sera llamada un <span class='cmti-10'>homomorfismo de</span> \((P,\leq )\) <span class='cmti-10'>en</span> \((P^{\prime },\leq ^{\prime })\) si para todo \(x,y\in P\) se
cumple que \(x\leq y\) implica \(F(x)\leq ^{\prime }F(y)\). Escribiremos \(F:(P,\leq )\rightarrow (P^{\prime },\leq ^{\prime })\) para expresar que \(F\) es un homomorfismo de<span class='cmti-10'> </span>\((P,\leq )\) en \((P^{\prime },\leq ^{\prime })\).
Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-142001x4.1.5'>\(F:\mathbf{R}\rightarrow \mathbf{R}\) dada por \(F(r)=3.r\) es un homomorfismo de \((\mathbf{R},\leq )\) en \((\mathbf{R},\leq )\)
     </li>
     <li class='enumerate' id='x1-142002x4.1.5'>Sea  \(\mathrm{\leq }=\{(n,m)\in \omega :n=m\}\)  y  sea  \((P^{\prime },\leq ^{\prime })\)  un  poset  cualquiera.  Entonces  cualquier  funcion  \(F:\omega \rightarrow P^{\prime }\)  es  un
     homomorfismo de \((\omega ,\leq )\) en \((P^{\prime },\leq ^{\prime })\) (glup!)
     </li>
     <li class='enumerate' id='x1-142003x4.1.5'>Consideremos el poset \((\mathcal{P}(\omega ),\leq )\), donde \(\mathrm{\leq }=\{(A,B)\in \mathcal{P}(\omega )^{2}:A\subseteq B\}\) y el poset \((\mathcal{P}(\{1,2,3,4\}),\leq ^{\prime })\), donde \(\mathrm{\leq }^{\prime }=\{(A,B)\in \mathcal{P}(\{1,2,3,4\})^{2}:A\subseteq B\}\). Entonces \(F:\mathcal{P}(\omega )\rightarrow \mathcal{P}(1,2,3,4)\) dada por \(F(A)=A\cap \{1,2,3,4\}\)
     es un homomorfismo de \((\mathcal{P}(\omega ),\leq )\) en \((\mathcal{P}(\{1,2,3,4\}),\leq ^{\prime })\)</li></ol>
<!-- l. 11875 --><p class='noindent'>Una funcion \(F:P\rightarrow P^{\prime }\) sera llamada un <span class='cmti-10'>isomorfismo de</span> \((P,\leq )\) <span class='cmti-10'>en</span> \((P^{\prime },\leq ^{\prime })\) si \(F\) es biyectiva, \(F\) es un homomorfismo
de \((P,\leq )\) en \((P^{\prime },\leq ^{\prime })\) y \(F^{-1}\) es un homomorfismo de \((P^{\prime },\leq ^{\prime })\) en \((P,\leq )\). Escribiremos \((P,\leq )\cong (P^{\prime },\leq ^{\prime })\) cuando exista un isomorfismo
de \((P,\leq )\) en \((P^{\prime },\leq ^{\prime })\) y en tal caso diremos que \((P,\leq )\) y \((P^{\prime },\leq ^{\prime })\) son <span class='cmti-10'>isomorfos</span>. Cabe observar que un
homomorfismo biyectivo no necesariamente es un isomorfismo como lo muestra el
siguiente ejemplo.
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-142004x4.1.5'>Consideremos  los  posets  \(\mathbf{P}=(\{1,2\},\{(1,1),(2,2)\})\)  y  \(\mathbf{Q}=(\{1,2\},\{(1,1),(2,2),(1,2)\})\).  Es  facil  ver  que  \(F:\{1,2\}\rightarrow \{1,2\}\),  dada  por  \(F(1)=1\)  y  \(F(2)=2\)  es  un
     homomorfismo  de  \(\mathbf{P}\)  en  \(\mathbf{Q}\).  Dejamos  al  lector  chequear  que  \(F^{-1}\)  no  es  un
     homomorfismo de \(\mathbf{Q}\) en \(\mathbf{P}\).
     </li>
     <li class='enumerate' id='x1-142005x4.1.5'>Dada una funcion \(F:A\rightarrow B\) y \(S\subseteq A\), denotaremos con \(F(S)\) al conjunto \(\{F(a):a\in S\}\)</li></ol>
<!-- l. 11893 --><p class='noindent'>El siguiente lema aporta evidencia al hecho de que posets isomorfos tienen las mismas
propiedades matematicas.
</p>
   <div class='newtheorem'>
<!-- l. 11895 --><p class='noindent'><span class='head'>
<a id='x1-142006r139'></a>
<span class='cmbx-10'>Lema 139.</span>  </span><span class='cmti-10'>Sean</span> \((P,\leq )\) <span class='cmti-10'>y</span> \((P^{\prime },\leq ^{\prime })\)<span class='cmti-10'> posets. Supongamos</span> \(F\) <span class='cmti-10'>es un isomorfismo de</span> \((P,\leq )\) <span class='cmti-10'>en</span> \((P^{\prime },\leq ^{\prime })\)<span class='cmti-10'>.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-142007x139'><span class='cmti-10'>Para cada</span> \(S\subseteq P\) <span class='cmti-10'>y cada</span> \(a\in P\)<span class='cmti-10'>, se tiene que</span> \(a\) <span class='cmti-10'>es cota superior (resp. inferior) de</span> \(S\) <span class='cmti-10'>si y
     </span><span class='cmti-10'>solo si</span> \(F(a)\) <span class='cmti-10'>es cota superior (resp. inferior) de</span> \(F(S)\)<span class='cmti-10'>.</span>

     </li>
     <li class='enumerate' id='x1-142008x139'><span class='cmti-10'>Para cada</span> \(S\subseteq P\)<span class='cmti-10'>, se tiene que existe</span> \(\sup (S)\) <span class='cmti-10'>si y solo si existe</span> \(\sup (F(S))\) <span class='cmti-10'>y en el caso de que
     </span><span class='cmti-10'>existan tales elementos se tiene que</span> \(F(\sup (S))=\sup (F(S))\)<span class='cmti-10'>.</span>
     </li>
     <li class='enumerate' id='x1-142009x139'><span class='cmti-10'>Para cada</span> \(a\in P\)<span class='cmti-10'>,</span> \(a\) <span class='cmti-10'>es maximo (resp. minimo) si y solo si</span> \(F(a)\) <span class='cmti-10'>es maximo (resp.
     </span><span class='cmti-10'>minimo).</span>
     </li>
     <li class='enumerate' id='x1-142010x139'><span class='cmti-10'>Para cada</span> \(a\in P\)<span class='cmti-10'>,</span> \(a\) <span class='cmti-10'>es maximal (resp. minimal) si y solo si</span> \(F(a)\) <span class='cmti-10'>es maximal (resp.
     </span><span class='cmti-10'>minimal).</span>
     </li>
     <li class='enumerate' id='x1-142011x139'><span class='cmti-10'>Para</span> \(a,b\in P\)<span class='cmti-10'>, tenemos que</span> \(a\prec b\) <span class='cmti-10'>si y solo si</span> \(F(a)\prec ^{\prime }F(b)\)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 11913 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11914 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Supongamos que \(a\) es cota superior de \(S\). Veamos que entonces \(F(a)\) es cota
superior de \(F(S)\). Sea \(x\in F(S)\). Sea \(s\in S\) tal que \(x=F(s)\). Ya que \(s\leq a\), tenemos que \(x=F(s)\leq ^{\prime }F(a)\). Supongamos ahora que
\(F(a)\) es cota superior de \(F(S)\) y veamos que entonces \(a\) es cota superior de \(S\). Sea \(s\in S\). Ya que
\(F(s)\leq ^{\prime }F(a)\), tenemos que \(s=F^{-1}(F(s))\leq F^{-1}(F(a))=a\).
</p><!-- l. 11921 --><p class='indent'>   (b) Supongamos existe \(\sup (S)\). Veamos entonces que \(F(\sup (S))\) es el supremo de \(F(S)\). Por (a) \(F(\sup (S))\) es
cota superior de \(F(S)\). Supongamos \(b\) es cota superior de \(F(S)\). Entonces \(F^{-1}(b)\) es cota superior
de \(S\), por lo cual \(\sup (S)\leq F^{-1}(b)\), produciendo \(F(\sup (S))\leq ^{\prime }b\). En forma analoga se ve que si existe \(\sup (F(S))\), entonces \(F^{-1}(\sup (F(S)))\)
es el supremo de \(S\).
</p><!-- l. 11928 --><p class='indent'>   (c), (d) y (e) son dejados como ejercicio.                                            □
</p>
   </div>
<!-- l. 11932 --><p class='indent'>   Notese que (e) nos garantiza que si dos posets finitos son isomorfos, entonces
pueden representarse con el mismo diagrama de Hasse.
</p><!-- l. 11935 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.1.6   </span> <a id='x1-1430004.1.6'></a>Version geometrica del concepto de reticulado</h5>
<!-- l. 11937 --><p class='noindent'>El concepto de reticulado puede ser abordado en dos formas distintas, una
geometrica (via posets) y la otra algebraica (via estructuras algebraicas
definidas ecuacionalmente). Como veremos mas adelante ambas definiciones son
equivalentes.

</p><!-- l. 11942 --><p class='indent'>   Diremos que un poset \((P,\leq )\) es un <span class='cmti-10'>reticulado </span>si para todo \(a,b\in P\), existen \(\sup (\{a,b\})\) e \(\inf (\{a,b\})\). Recordemos que
dado un conjunto \(A\), por una <span class='cmti-10'>operacion binaria sobre</span> \(A\) entenderemos una funcion cuyo
dominio es \(A^{2}\) y cuya imagen esta contenida en \(A\). En un reticulado \((P,\leq )\) tenemos dos
operaciones binarias naturalmente definidas: \[ \begin{array}{rcl} \mathsf{s}:P^{2} &amp; \rightarrow &amp; P\\ (a,b) &amp; \rightarrow &amp; \sup (\{a,b\}) \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl} \mathsf{i}:P^{2} &amp; \rightarrow &amp; P\\ (a,b) &amp; \rightarrow &amp; \inf (\{a,b\}) \end{array} \] Escribiremos \(a\mathsf{\;s\;}b\) en lugar de \(\mathsf{s}(a,b)\) y \(a\mathsf{\;i\;}b\) en lugar
de \(\mathsf{i}(a,b)\).
</p>
   <div class='newtheorem'>
<!-- l. 11959 --><p class='noindent'><span class='head'>
<a id='x1-143001r140'></a>
<span class='cmbx-10'>Lema 140.</span>  </span><span class='cmti-10'>Dado un reticulado</span> \((L,\leq )\) <span class='cmti-10'>y elementos</span> \(x,y,z,w\in L\)<span class='cmti-10'>, se cumplen las siguientes.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-143002x140'>\(x\leq x\) \(\mathsf{s}\) \(y\)
     </li>
     <li class='enumerate' id='x1-143003x140'>\(x\;\mathsf{i\;}y\leq x\)
     </li>
     <li class='enumerate' id='x1-143004x140'>\(x\;\mathsf{s}\;x=x\mathsf{\;i\;}x=x\)
     </li>
     <li class='enumerate' id='x1-143005x140'>\(x\;\mathsf{s}\;y=y\;\mathsf{s}\;x\)
     </li>
     <li class='enumerate' id='x1-143006x140'>\(x\mathsf{\;i\;}y=y\mathsf{\;i\;}x\)</li></ol>
   </div>
<!-- l. 11971 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11972 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Trivial de las definiciones                                                           □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 11976 --><p class='noindent'><span class='head'>
<a id='x1-143007r141'></a>
<span class='cmbx-10'>Lema 141.</span>  </span><span class='cmti-10'>Dado un reticulado</span> \((L,\leq )\) <span class='cmti-10'>y elementos</span> \(x,y\in L\)<span class='cmti-10'>, son equivalentes:</span>

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-143008x141'>\(x\leq y\)
     </li>
     <li class='enumerate' id='x1-143009x141'>\(x\;\mathsf{s}\;y=y\)
     </li>
     <li class='enumerate' id='x1-143010x141'>\(x\mathsf{\;i\;}y=x\)</li></ol>
   </div>
<!-- l. 11986 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 11987 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ejercicio                                                                                 □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 11991 --><p class='noindent'><span class='head'>
<a id='x1-143011r142'></a>
<span class='cmbx-10'>Lema 142.</span>  </span><span class='cmti-10'>Dado un reticulado</span> \((L,\leq )\) <span class='cmti-10'>y elementos</span> \(x,y\in L\)<span class='cmti-10'>, se tiene que:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-143012x142'>\(x\;\mathsf{s}\;(x\mathsf{\;i\;}y)=x\)
     </li>
     <li class='enumerate' id='x1-143013x142'>\(x\mathsf{\;i\;}(x\;\mathsf{s}\;y)=x\)</li></ol>
   </div>
<!-- l. 12000 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12001 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que \(x\mathsf{\;i\;}y\leq x\), el lema anterior nos dice que \((x\mathsf{\;i\;}y)\;\mathsf{s}\;x=x\), por lo cual \(x\;\mathsf{s}\;(x\mathsf{\;i\;}y)=x\).                        □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 12006 --><p class='noindent'><span class='head'>
<a id='x1-143014r143'></a>

<span class='cmbx-10'>Lema 143.</span>  </span><span class='cmti-10'>Dado un reticulado</span> \((L,\leq )\) <span class='cmti-10'>y elementos</span> \(x,y,z\in L\)<span class='cmti-10'>, se tiene que:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-143015x143'>\((x\;\mathsf{s}\;y)\;\mathsf{s}\;z=x\;\mathsf{s}\;(y\;\mathsf{s}\;z)\)
     </li>
     <li class='enumerate' id='x1-143016x143'>\((x\mathsf{\;i\;}y)\mathsf{\;i\;}z=x\mathsf{\;i\;}(y\mathsf{\;i\;}z)\)</li></ol>
   </div>
<!-- l. 12015 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12016 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(1) Notese que \(x\;\mathsf{s}\;(y\;\mathsf{s}\;z)\) es cota superior de \(\{x,y,z\}\) ya que obviamente \(x\leq x\;\mathsf{s}\;(y\;\mathsf{s}\;z)\) y ademas
</p><div class='eqnarray'>\begin{eqnarray*} y &amp; \leq &amp; (y\;\mathsf{s}\;z)\leq x\;\mathsf{s}\;(y\;\mathsf{s}\;z)\\ z &amp; \leq &amp; (y\;\mathsf{s}\;z)\leq x\;\mathsf{s}\;(y\;\mathsf{s}\;z) \end{eqnarray*}
</div>Ya que \(x\;\mathsf{s}\;(y\;\mathsf{s}\;z)\) es cota superior de \(\{x,y\}\), tenemos que \(x\;\mathsf{s}\;y\leq x\;\mathsf{s}\ (y\;\mathsf{s}\;z)\), por lo cual \(x\;\mathsf{s}\;(y\;\mathsf{s}\;z)\) es cota superior del conjunto \(\{x\;\mathsf{s}\;y,z\}\),
lo cual dice que \((x\;\mathsf{s}\;y)\;\mathsf{s}\;z\leq x\;\mathsf{s}\;(y\;\mathsf{s}\;z)\). Analogamente se puede probar que \(x\;\mathsf{s}\;(y\;\mathsf{s}\;z)\leq (x\;\mathsf{s}\;y)\;\mathsf{s}\;z\).                               □
   </div>
   <div class='newtheorem'>
<!-- l. 12031 --><p class='noindent'><span class='head'>
<a id='x1-143017r144'></a>
<span class='cmbx-10'>Lema 144.</span>  </span><span class='cmti-10'>Dado un reticulado</span> \((L,\leq )\) <span class='cmti-10'>y elementos</span> \(x,y,z,w\in L\)<span class='cmti-10'>, se tiene que:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-143018x144'><span class='cmti-10'>Si</span> \(x\leq z\) <span class='cmti-10'>e</span> \(y\leq w\)<span class='cmti-10'>, entonces</span> \(x\;\mathsf{s}\ y\leq z\;\mathsf{s}\ w\) <span class='cmti-10'>y</span> \(x\mathsf{\;i\;}y\leq z\mathsf{\;i\;}w\)</li></ol>
   </div>
<!-- l. 12040 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12041 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que </p><div class='eqnarray'>\begin{eqnarray*} x &amp; \leq &amp; z\leq z\;\mathsf{s}\;w\\ y &amp; \leq &amp; w\leq z\;\mathsf{s}\;w \end{eqnarray*}
</div>tenemos que \(z\;\mathsf{s}\;w\) es cota superior de \(\{x,y\}\) lo cual dice que \(x\;\mathsf{s}\;y\leq z\;\mathsf{s}\;w\). La otra desigualdad es
analoga.                                                                                           □

   </div>
   <div class='newtheorem'>
<!-- l. 12052 --><p class='noindent'><span class='head'>
<a id='x1-143019r145'></a>
<span class='cmbx-10'>Lema 145.</span>  </span><span class='cmti-10'>Dado un reticulado</span> \((L,\leq )\) <span class='cmti-10'>y elementos</span> \(x,y,z\in L\)<span class='cmti-10'>, se tiene que:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-143020x145'>\((x\mathsf{\;i\;}y)\;\mathsf{s}\;(x\mathsf{\;i\;}z)\leq x\mathsf{\;i\;}(y\;\mathsf{s}\;z)\)</li></ol>
   </div>
<!-- l. 12060 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12061 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que </p><div class='eqnarray'>\begin{eqnarray*} (x\mathsf{\;i\;}y),(x\mathsf{\;i\;}z) &amp; \leq &amp; x\\ (x\mathsf{\;i\;}y),(x\mathsf{\;i\;}z) &amp; \leq &amp; y\;\mathsf{s}\;z \end{eqnarray*}
</div>tenemos que \((x\;\mathsf{i}\;y),(x\mathsf{\;i\;}z)\leq x\mathsf{\;i\;}(y\;\mathsf{s}\;z)\), por lo cual \((x\mathsf{\;i\;}y)\;\mathsf{s}\;(x\mathsf{\;i\;}z)\leq x\mathsf{\;i\;}(y\;\mathsf{s}\;z)\).                                                                   □
   </div>
   <div class='newtheorem'>
<!-- l. 12071 --><p class='noindent'><span class='head'>
<a id='x1-143021r146'></a>
<span class='cmbx-10'>Lema 146.</span>  </span><span class='cmti-10'>Sea</span> \((L,\leq )\) <span class='cmti-10'>un reticulado. Dados elementos</span> \(x_{1},...,x_{n}\in L\)<span class='cmti-10'>, con</span> \(n\geq 2\)<span class='cmti-10'>, se tiene</span> </p><div class='eqnarray'>\begin{eqnarray*} (...(x_{1}\;\mathsf{s\;}x_{2})\;\mathsf{s\;}...)\;\mathsf{s\;}x_{n} &amp; = &amp; \sup (\{x_{1},...,x_{n}\})\\ (...(x_{1}\mathsf{\;i\;}x_{2})\mathsf{\;i\;}...)\mathsf{\;i\;}x_{n} &amp; = &amp; \inf (\{x_{1},...,x_{n}\}) \end{eqnarray*}
</div>
   </div>
<!-- l. 12080 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12081 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Por induccion en \(n\). Claramente el resultado vale para \(n=2\). Supongamos vale para \(n\)
y veamos entonces que vale para \(n+1\). Sean \(x_{1},...,x_{n+1}\in L\). Por hipotesis inductiva tenemos
que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-143022x4.1.6'>\((...(x_{1}\;\mathsf{s}\;x_{2})\;\mathsf{s\;}...)\;\mathsf{s\;}x_{n}=\sup (\{x_{1},...,x_{n}\}).\)</li></ol>
<!-- l. 12087 --><p class='noindent'>Veamos entonces que

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-143023x4.1.6'>\(((...(x_{1}\;\mathsf{s\;}x_{2})\;\mathsf{s\;}...)\;\mathsf{s\;}x_{n})\;\mathsf{s\;}x_{n+1}=\sup (\{x_{1},...,x_{n+1}\}).\)</li></ol>
<!-- l. 12091 --><p class='noindent'>Es facil ver que \(((...(x_{1}\;\mathsf{s\;}x_{2})\;\mathsf{s\;}...)\;\mathsf{s\;}x_{n})\;\mathsf{s\;}x_{n+1}\) es cota superior de \(\{x_{1},...,x_{n+1}\}\). Supongamos que \(z\) es otra cota superior. Ya que \(z\) es
tambien cota superior del conjunto \(\{x_{1},...,x_{n}\}\), por (1) tenemos que \[ (...(x_{1}\;\mathsf{s\;}x_{2})\;\mathsf{s}\;...)\;\mathsf{s\;}x_{n}\leq z. \] Pero entonces ya que \(x_{n+1}\leq z\),
tenemos que \[ ((...(x_{1}\;\mathsf{s\;}x_{2})\;\mathsf{s\;}...)\;\mathsf{s\;}x_{n})\;\mathsf{s\;}x_{n+1}\leq z, \] con lo cual hemos probado (2).                                           □
</p>
   </div>
<!-- l. 12106 --><p class='indent'>   Dado que la distribucion de parentesis en una expresion de la forma \[ (...(x_{1}\;\mathsf{s\;}x_{2})\;\mathsf{s\;}...)\;\mathsf{s\;}x_{n} \] es irrelevante
(ya que\(\;\mathsf{s\;}\)es asociativa), en general suprimiremos los parentesis.
</p><!-- l. 12118 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>4.2   </span> <a id='x1-1440004.2'></a>Version algebraica del concepto de reticulado</h4>
<!-- l. 12120 --><p class='noindent'>De la diversas propiedades de las operaciones s e i de un reticulado \((L,\leq )\) distinguiremos
las siguientes:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-144001x4.2'>\(x\;\mathsf{s}\;x=x\mathsf{\;i\;}x=x\), cualesquiera sea \(x\in L\)
     </li>
     <li class='enumerate' id='x1-144002x4.2'>\(x\mathsf{\;s\;}y=y\;\mathsf{s}\;x\), cualesquiera sean \(x,y\in L\)
     </li>
     <li class='enumerate' id='x1-144003x4.2'>\(x\mathsf{\;i\;}y=y\mathsf{\;i\;}x\), cualesquiera sean \(x,y\in L\)
     </li>
     <li class='enumerate' id='x1-144004x4.2'>\((x\mathsf{\;s\;}y)\;\mathsf{s}\;z=x\;\mathsf{s}\;(y\;\mathsf{s}\;z)\), cualesquiera sean \(x,y,z\in L\)
     </li>
     <li class='enumerate' id='x1-144005x4.2'>\((x\mathsf{\;i\;}y)\mathsf{\;i\;}z=x\mathsf{\;i\;}(y\mathsf{\;i\;}z)\), cualesquiera sean \(x,y,z\in L\)
     </li>
     <li class='enumerate' id='x1-144006x4.2'>\(x\;\mathsf{s}\;(x\mathsf{\;i\;}y)=x\), cualesquiera sean \(x,y\in L\)
     </li>
     <li class='enumerate' id='x1-144007x4.2'>\(x\mathsf{\;i\;}(x\;\mathsf{s}\;y)=x\), cualesquiera sean \(x,y\in L\)</li></ol>
<!-- l. 12133 --><p class='noindent'>Podemos abstraernos y pensar que s e i son dos operaciones cualesquiera sobre un
conjunto \(L\) arbitrario y estudiar cuando se satisfacen y cuando no dichas propiedades.
Por ejemplo si tomamos \(L=\mathbf{R}\) y \[ \begin{array}{rcl} \mathsf{s}:\mathbf{R}^{2} &amp; \rightarrow &amp; \mathbf{R}\\ (a,b) &amp; \rightarrow &amp; a+b \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl} \mathsf{i}:\mathbf{R}^{2} &amp; \rightarrow &amp; \mathbf{R}\\ (a,b) &amp; \rightarrow &amp; a.b \end{array} \] entonces se cumplen (I2), (I3), (I4) e (I5), pero (I1), (I6)
e (I7) no se cumplen. Otro ejemplo, si tomamos \(L=\{1,2\}\) y \[ \begin{array}{rcl} \mathsf{s}:\{1,2\}^{2} &amp; \rightarrow &amp; \{1,2\}\\ (1,1) &amp; \rightarrow &amp; 1\\ (1,2) &amp; \rightarrow &amp; 2\\ (2,1) &amp; \rightarrow &amp; 1\\ (2,2) &amp; \rightarrow &amp; 2 \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl} \mathsf{i}:\{1,2\}^{2} &amp; \rightarrow &amp; \{1,2\}\\ (1,1) &amp; \rightarrow &amp; 1\\ (1,2) &amp; \rightarrow &amp; 1\\ (2,1) &amp; \rightarrow &amp; 1\\ (2,2) &amp; \rightarrow &amp; 1 \end{array} \] entonces se cumplen (I3), (I4) e
(I5), pero (I1), (I2), (I6) e (I7) no se cumplen. Otro ejemplo, si tomamos \(L=\mathbf{N}\) y \[ \begin{array}{rcl} \mathsf{s}:\mathbf{N}^{2} &amp; \rightarrow &amp; \mathbf{N}\\ (a,b) &amp; \rightarrow &amp; \max \{a,b\} \end{array}\ \ \ \ \ \ \begin{array}{rcl} \mathsf{i}:\mathbf{N}^{2} &amp; \rightarrow &amp; \mathbf{N}\\ (a,b) &amp; \rightarrow &amp; \text{maximo comun divisor de }a\text{ y }b \end{array} \] entonces
se cumplen (I1), (I2), (I3), (I4), (I5) e (I6), pero (I7) no se cumple. Por supuesto si s

e i son las operaciones supremo e infimo dadas por algun orden parcial \(\leq \)
sobre \(L\) el cual hace de \((L,\leq )\) un reticulado, entonces las propedades (I1),...,(I7) se
cumplen y esto es justamente lo probado en la ultima serie de lemas. El
ultimo ejemplo nos permite ver una sutileza. Notese que en este ejemplo
s es la operacion supremo del reticulado \((\mathbf{N},\leq )\), donde \(\leq \) es el orden usual de los
naturales, e i es la operacion infimo del reticulado \((\mathbf{N},|)\), donde \(|\) es el orden de la
divisibilidad de los naturales. Sin envargo la ultima propiedad falla y esto se
debe a que s e i son supremo e infimo pero respecto de distintos ordenes
parciales.
</p><!-- l. 12187 --><p class='indent'>   Lo anterior motiva la siguiente definicion: Una terna \((L,\mathsf{s},\mathsf{i})\), donde \(L\) es un conjunto
no vacio y \(\mathsf{s}\) e \(\mathsf{i}\) son dos operaciones binarias sobre \(L\) sera llamada <span class='cmti-10'>reticulado</span>
cuando cumpla (I1),...,(I7). Si \((L,\mathsf{s},\mathsf{i})\) es un reticulado, llamaremos a \(L\) el <span class='cmti-10'>universo </span>de
\(L\).
</p><!-- l. 12193 --><p class='indent'>   Tal como lo vimos recien, las ternas dadas por los tres ejemplos anteriores no son
reticulados y si tomamos un poset \((L,\leq )\) el cual sea un reticulado, entonces la terna \((L,\mathsf{s},\mathsf{i})\), con \(\mathsf{s}\)
e \(\mathsf{i}\) definidas como supremo e infimo, es un reticulado. El siguiente teorema muestra
que todo reticulado \((L,\mathsf{s},\mathsf{i})\) se obtiene de esta forma.
</p>
   <div class='newtheorem'>
<!-- l. 12199 --><p class='noindent'><span class='head'>
<a id='x1-144008r147'></a>
<span class='cmbx-10'>Teorema 147.</span>  </span><span class='cmti-10'>(Dedekind) Sea</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>un reticulado. La relacion binaria definida por: </span>\[ x\leq y\text{ si y solo si }x\;\mathsf{s}\;y=y \] <span class='cmti-10'>es
</span><span class='cmti-10'>un orden parcial sobre</span> \(L\) <span class='cmti-10'>para el cual se cumple que:</span> </p><div class='eqnarray'>\begin{eqnarray*} \sup (\{x,y\}) &amp; = &amp; x\;\mathsf{s}\;y\\ \inf (\{x,y\}) &amp; = &amp; x\mathsf{\;i\;}y \end{eqnarray*}
</div><span class='cmti-10'>cualesquiera sean</span> \(x,y\in L\)
   </div>
<!-- l. 12213 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12214 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Dejamos  como  ejercicio  para  el  lector  probar  que  \(\leq \)  es  reflexiva  y
antisimetrica. Veamos que \(\leq \) es transitiva. Supongamos que \(x\leq y\) e \(y\leq z\). Entonces \[ x\;\mathsf{s\;}z=x\;\mathsf{s\;}(y\;\mathsf{s\;}z)=(x\;\mathsf{s\;}y)\;\mathsf{s\;}z=y\;\mathsf{s\;}z=z, \] por
lo cual \(x\leq z\). Veamos ahora que \(\sup (\{x,y\})=x\;\mathsf{s\;}y\). Es claro que \(x\;\mathsf{s\;}y\) es una cota superior del conjunto \(\{x,y\}\).
Supongamos \(x,y\leq z\). Entonces \[ (x\;\mathsf{s\;}y)\;\mathsf{s\;}z=x\;\mathsf{s\;}(y\;\mathsf{s\;}z)=x\;\mathsf{s\;}z=z, \] por lo que \(x\;\mathsf{s\;}y\leq z\). Es decir que \(x\;\mathsf{s\;}y\) es la menor cota superior.
</p><!-- l. 12229 --><p class='indent'>   Para probar que \(\inf (\{x,y\})=x\mathsf{\;i\;}y\), probaremos que para todo \(u,v\in L\), \[ u\leq v\text{ si y solo si }u\mathsf{\;i\;}v=u, \] lo cual le permitira al lector
aplicar un razonamiento similar al usado en el caso de la operacion \(\mathsf{s}\). Supongamos
que \(u\;\mathsf{s}\;v=v\). Entonces \(u\mathsf{\;i\;}v=u\mathsf{\;i\;}(u\;\mathsf{s}\;v)=u\). Reciprocamente si \(u\mathsf{\;i\;}v=u\), entonces \(u\;\mathsf{s}\;v=(u\mathsf{\;i\;}v)\;\mathsf{s}\;v=v\), por lo cual \(u\leq v\).                       □
</p>
   </div>
<!-- l. 12242 --><p class='indent'>

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-144009x4.2'>Use los resultados anteriores para definir una funcion \(\mathcal{F}\) de \(\{(L,\leq ):(L,\leq )\) es un reticulado\(\}\)
     en \(\{(L,\mathsf{s},\mathsf{i}):(L,\mathsf{s},\mathsf{i})\) es un reticulado\(\}\) la cual sea biyectiva</li></ol>
<!-- l. 12247 --><p class='noindent'>@@finpagina@@
</p><!-- l. 12249 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.2.1   </span> <a id='x1-1450004.2.1'></a>El orden asociado a un reticulado</h5>
<!-- l. 12251 --><p class='noindent'>Como vimos el teorema de Dedekind nos dice que un reticulado \((L,\mathsf{s},\mathsf{i})\) es un objeto
geometrico ya que si definimos \[ \mathrm{\leq }=\{(x,y):x\;\mathsf{s}\;y=y\} \] entonces \(\leq \) es un orden parcial sobre \(L\) y las operaciones \(\mathsf{s}\)
e \(\mathsf{i}\) resultan ser supremo e infimo. Llamaremos a \(\mathrm{\leq }=\{(x,y):x\;\mathsf{s}\;y=y\}\) el <span class='cmti-10'>orden parcial asociado a</span> \((L,\mathsf{s},\mathsf{i})\) y a \((L,\leq )\) el
<span class='cmti-10'>poset asociado a</span> \((L,\mathsf{s},\mathsf{i})\). Notese que tambien tenemos que \(\mathrm{\leq }=\{(x,y):x\;\mathsf{i}\;y=x\}\) (¿por que?). Muchos conceptos
definidos para posets ahora pueden aplicarse cuando tenemos un reticulado \((L,\mathsf{s},\mathsf{i})\). Por
ejemplo si decimos que \((L,\mathsf{s},\mathsf{i})\) tiene elemento maximo, esto significara que el poset \((L,\leq )\) tiene
elemento maximo.
</p><!-- l. 12270 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.2.2   </span> <a id='x1-1460004.2.2'></a>Notacion</h5>
<!-- l. 12272 --><p class='noindent'>Usaremos las siguientes practicas convenciones notacionales
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-146001x4.2.2'>Si \(L\) es un conjunto no vacio cuyos elementos son conjuntos y \(L\) cumple la
     siguiente condicion
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-146002x4.2.2'>Si \(A,B\in L\), entonces \(A\cup B,A\cap B\in L\)</li></ol>
     <!-- l. 12279 --><p class='noindent'>entonces ciertas veces usaremos \(\cup \) (resp. \(\cap \)) para denotar la operacion binaria
     sobre \(L\) dada por la union (resp. la interceccion). Es decir \(\cup \) e \(\cap \) denotaran las
     funciones \[ \begin{array}{rcl} L^{2} &amp; \rightarrow &amp; L\\ (A,B) &amp; \rightarrow &amp; A\cup B \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl} L^{2} &amp; \rightarrow &amp; L\\ (A,B) &amp; \rightarrow &amp; A\cap B \end{array} \]
     </p></li>
     <li class='enumerate' id='x1-146003x4.2.2'>Si \(L\) es un conjunto no vacio cuyos elementos son numeros reales entonces ciertas
     veces usaremos \(\max \) y \(\min \) para denotar las operaciones binarias sobre \(L\) dadas por
     \[ \begin{array}{rcl} L^{2} &amp; \rightarrow &amp; L\\ (a,b) &amp; \rightarrow &amp; \max (a,b) \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl} L^{2} &amp; \rightarrow &amp; L\\ (a,b) &amp; \rightarrow &amp; \min (a,b) \end{array} \]
     </li>
     <li class='enumerate' id='x1-146004x4.2.2'>Si \(L\) es un conjunto no vacio cuyos elementos son numeros naturales y \(L\) cumple la
     siguiente condicion
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-146005x4.2.2'>Si \(a,b\in L\), entonces \(mcm(a,b),mcd(a,b)\in L\)</li></ol>

     <!-- l. 12309 --><p class='noindent'>entonces ciertas veces usaremos \(mcm\) y \(mcd\) para denotar las operaciones binarias sobre \(L\)
     dadas por \[ \begin{array}{rcl} L^{2} &amp; \rightarrow &amp; L\\ (a,b) &amp; \rightarrow &amp; mcm(a,b) \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl} L^{2} &amp; \rightarrow &amp; L\\ (a,b) &amp; \rightarrow &amp; mcd(a,b) \end{array} \]
</p>
     </li></ol>
<!-- l. 12322 --><p class='noindent'>En virtud de las convenciones notacionales anteriores notese que por ejemplo
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-146007x1'>\((\mathbf{R,}\max ,\min )\)
     </li>
     <li class='enumerate' id='x1-146009x2'>\(([0,1]\mathbf{,}\max ,\min )\)
     </li>
     <li class='enumerate' id='x1-146011x3'>\((\mathcal{P}(\mathbf{N}),\cup ,\cap )\)
     </li>
     <li class='enumerate' id='x1-146013x4'>\((\{A\subseteq \mathbf{N}:A\) es finito\(\},\cup ,\cap )\)
     </li>
     <li class='enumerate' id='x1-146015x5'>\((\mathbf{N},mcm,mcd)\)
     </li>
     <li class='enumerate' id='x1-146017x6'>\((\{1,2,3,6,12\},mcm,mcd)\)</li></ol>
<!-- l. 12332 --><p class='noindent'>denotan reticulados pero deberia quedar claro que en los primeros dos ejemplos \(\max \) denota
dos distintas operaciones. Analogamente sucede con \(\min \), \(\cup \), \(\cap \), \(mcm\) y \(mcd\). Esta ambiguedad no nos
traera problemas si estamos atentos al contexto.
</p><!-- l. 12341 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.2.3   </span> <a id='x1-1470004.2.3'></a>Subreticulados</h5>
<!-- l. 12343 --><p class='noindent'>Dados reticulados \((L,\mathsf{s},\mathsf{i})\) y \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) diremos que \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>es un subreticulado de</span> \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) si se dan las siguientes
condiciones
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-147001x4.2.3'>\(L\subseteq L^{\prime }\)
     </li>
     <li class='enumerate' id='x1-147002x4.2.3'>\(\mathsf{s}=\mathsf{s}^{\prime }\)\(|\)\(_{L\times L}\) y \(\mathsf{i}=\mathsf{i}^{\prime }\)\(|\)\(_{L\times L}\)</li></ol>
<!-- l. 12351 --><p class='noindent'>Sea \((L,\mathsf{s},\mathsf{i})\) un reticulado. Un conjunto \(S\subseteq L\) es llamado <span class='cmti-10'>subuniverso </span>de \((L,\mathsf{s},\mathsf{i})\) si es no vacio y cerrado bajo
las operaciones \(\mathsf{s}\) e \(\mathsf{i}\) (i.e. \(x\mathsf{\;s\;}y\), \(x\;\mathsf{i}\ y\in S\), para todo \(x,y\in S)\). Es importante notar que si bien los conceptos
de subreticulado y subuniverso estan muy relacionados, se trata de objetos diferentes
ya que los subreticulados de un reticulado dado son reticulados, es decir ciertas
ternas y los subuniversos de un reticulado dado son ciertos subconjuntos por lo
cual no son ternas. Es facil notar que si \(S\) es un subuniverso de \((L,\mathsf{s},\mathsf{i})\), entonces
\((S,\mathsf{s}\)\(|\)\(_{S\times S},\mathsf{i}\)\(|\)\(_{S\times S})\) es un subreticulado de \((L,\mathsf{s},\mathsf{i})\) y que todo subreticulado de \((L,\mathsf{s},\mathsf{i})\) se obtiene en esta
forma.

</p><!-- l. 12364 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.2.4   </span> <a id='x1-1480004.2.4'></a>Homomorfismos de reticulados</h5>
<!-- l. 12366 --><p class='noindent'>Sean \((L,\mathsf{s},\mathsf{i})\) y \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) reticulados. Una funcion \(F:L\rightarrow L^{\prime }\) sera llamada un <span class='cmti-10'>homomorfismo de</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>en</span> \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) si para
todo \(x,y\in L\) se cumple que </p><div class='eqnarray'>\begin{eqnarray*} F(x\mathsf{\;s\;}y) &amp; = &amp; F(x)\;\mathsf{s}^{\prime }\ F(y)\\ F(x\mathsf{\;i\;}y) &amp; = &amp; F(x)\;\mathsf{i}^{\prime }\ F(y). \end{eqnarray*}
</div>Un homomorfismo de<p><span class='cmti-10'> </span></p>\((L,\mathsf{s},\mathsf{i})\) en \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) sera llamado <p><span class='cmti-10'>isomorfismo de</span></p> \((L,\mathsf{s},\mathsf{i})\) <p><span class='cmti-10'>en</span></p> \((L^{\prime },\mathsf{s}^{\prime }\), \(\mathsf{i}^{\prime }\) \()\) cuando sea biyectivo y
su inversa sea tambien un homomorfismo. Escribiremos \((L,\mathsf{s},\mathsf{i})\cong (L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) cuando exista un
isomorfismo de \((L,\mathsf{s},\mathsf{i})\) en \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\). Escribiremos \(F:(L,\mathsf{s},\mathsf{i})\rightarrow (L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) cuando \(F\) sea un homomorfismo de<p><span class='cmti-10'> </span></p>\((L,\mathsf{s},\mathsf{i})\) en
\((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\).
   <div class='newtheorem'>
<!-- l. 12384 --><p class='noindent'><span class='head'>
<a id='x1-148001r148'></a>
<span class='cmbx-10'>Lema 148.</span>  </span><span class='cmti-10'>Si</span> \(F:(L,\mathsf{s},\mathsf{i})\rightarrow (L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) <span class='cmti-10'>es un homomorfismo biyectivo, entonces</span> \(F\) <span class='cmti-10'>es un isomorfismo</span>
</p>
   </div>
<!-- l. 12389 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12390 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Solo falta ver que \(F^{-1}\) es un homomorfismo. Sean \(F(x),F(y)\) dos elementos cualesquiera
de \(L^{\prime }\). Tenemos que \[ F^{-1}(F(x)\;\mathsf{s}^{\prime }\ F(y))=F^{-1}(F(x\mathsf{\;s\;}y))=x\mathsf{\;s\;}y=F^{-1}(F(x))\;\mathsf{s}\ F^{-1}(F(y)) \]                                                                              □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 12398 --><p class='noindent'><span class='head'>
<a id='x1-148002r149'></a>
<span class='cmbx-10'>Lema 149.</span>  </span><span class='cmti-10'>Sean</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>y</span> \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) <span class='cmti-10'>reticulados y sea</span> \(F:(L,\mathsf{s},\mathsf{i})\rightarrow (L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) <span class='cmti-10'>un homomorfismo. Entonces</span> \(I_{F}\) <span class='cmti-10'>es un
</span><span class='cmti-10'>subuniverso de</span> \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\)<span class='cmti-10'>. Es decir que</span> \(F\) <span class='cmti-10'>es tambien un homomorfismo de</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>en</span> \((I_{F},\mathsf{s}^{\prime }\)\(|\)\(_{I_{F}\times I_{F}},\mathsf{i}^{\prime }\)\(|\)\(_{I_{F}\times I_{F}})\)
</p>
   </div>
<!-- l. 12406 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12407 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Ya que \(L\) es no vacio tenemos que \(I_{F}\) tambien es no vacio. Sean \(a,b\in I_{F}\). Sean \(x,y\in L\) tales que \(F(x)=a\)
y \(F(y)=b\). Se tiene que </p><div class='eqnarray'>\begin{eqnarray*} a\;\mathsf{s}^{\prime }\ b &amp; = &amp; F(x)\;\mathsf{s}^{\prime }\ F(y)=F(x\mathsf{\;s\;}y)\in I_{F}\\ a\;\mathsf{i}^{\prime }\ b &amp; = &amp; F(x)\;\mathsf{i}^{\prime }\ F(y)=F(x\mathsf{\;i\;}y)\in I_{F} \end{eqnarray*}
</div>por lo cual \(I_{F}\) es cerrada bajo \(\mathsf{s}^{\prime }\) e \(\mathsf{i}^{\prime }\).                                                             □
   </div>
   <div class='newtheorem'>
<!-- l. 12418 --><p class='noindent'><span class='head'>
<a id='x1-148003r150'></a>
<span class='cmbx-10'>Lema 150.</span>  </span><span class='cmti-10'>Sean</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>y</span> \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) <span class='cmti-10'>reticulados y sean</span> \((L\leq )\) <span class='cmti-10'>y</span> \((L^{\prime },\leq ^{\prime })\) <span class='cmti-10'>los posets asociados. Sea</span> \(F:L\rightarrow L^{\prime }\) <span class='cmti-10'>una
</span><span class='cmti-10'>funcion. Entonces</span> \(F\) <span class='cmti-10'>es un isomorfismo de</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>en</span> \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) <span class='cmti-10'>si y solo si</span> \(F\) <span class='cmti-10'>es un isomorfismo de</span>
\((L,\leq )\) <span class='cmti-10'>en</span> \((L^{\prime },\leq ^{\prime })\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 12426 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12427 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(F\) es un isomorfismo de \((L,\mathsf{s},\mathsf{i})\) en \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\). Sean \(x,y\in L\), tales que \(x\leq y\). Tenemos que
\(y=x\mathsf{\;s\;}y\) por lo cual \(F(y)=F(x\mathsf{\;s\;}y)=F(x)\mathsf{\;s^{\prime }\;}F(y)\), produciendo \(F(x)\leq ^{\prime }F(y)\). En forma similar se puede ver que \(F^{-1}\) es tambien un
homomorfismo de \((L^{\prime },\leq ^{\prime })\) en \((L,\leq )\). Si \(F\) es un isomorfismo de \((L,\leq )\) en \((L^{\prime },\leq ^{\prime })\), entonces el Lema <a href='#x1-142006r139'>139<!-- tex4ht:ref: isoposets  --></a> nos
dice que \(F\) y \(F^{-1}\) respetan las operaciones de supremo e infimo por lo cual \(F\) es un
isomorfismo de \((L,\mathsf{s},\mathsf{i})\) en \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\).                                                                            □
</p>
   </div>
<!-- l. 12440 --><p class='indent'>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-148004x4.2.4'>Encontrar dos reticulados, \((L,\mathsf{s},\mathsf{i})\) y \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\), tales que haya una función biyectiva de \(L\)
     en \(L^{\prime }\) que preserve orden pero no sea homomorfismo de reticulados.</li></ol>
<!-- l. 12448 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.2.5   </span> <a id='x1-1490004.2.5'></a>Congruencias de reticulados</h5>
<!-- l. 12450 --><p class='noindent'>Sea \((L,\mathsf{s},\mathsf{i})\) un reticulado. Una <span class='cmti-10'>congruencia sobre</span> \((L,\mathsf{s},\mathsf{i})\) sera una relacion de equivalencia \(\theta \) sobre \(L\)
la cual cumpla:

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-149001x4.2.5'>\(x\theta x^{\prime }\) y \(y\theta y^{\prime }\) implica \((x\mathsf{\;s\;}y)\theta (x^{\prime }\mathsf{\;s\;}y^{\prime })\) y \((x\mathsf{\;i\;}y)\theta (x^{\prime }\mathsf{\;i\;}y^{\prime })\)</li></ol>
<!-- l. 12457 --><p class='noindent'>Gracias a esta condicion podemos definir sobre \(L/\theta \) dos operaciones binarias \(\mathsf{\tilde{s}}\) e \(\mathsf{\tilde{\imath }}\), de la
siguiente manera: </p><div class='eqnarray'>\begin{eqnarray*} x/\theta \mathsf{\;\tilde{s}\;}y/\theta &amp; = &amp; (x\mathsf{\;s\;}y)/\theta \\ x/\theta \mathsf{\;\tilde{\imath }\;}y/\theta &amp; = &amp; (x\mathsf{\;i\;}y)/\theta  \end{eqnarray*}
</div>La terna \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }})\) es llamada el <p><span class='cmti-10'>cociente de</span></p> \((L,\mathsf{s},\mathsf{i})\) <p><span class='cmti-10'>sobre</span></p> \(\theta \) y la denotaremos con \((L,\mathsf{s},\mathsf{i})/\theta \).
   <div class='newtheorem'>
<!-- l. 12467 --><p class='noindent'><span class='head'>
<a id='x1-149002r151'></a>
<span class='cmbx-10'>Lema 151.</span>  </span>\((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }})\) <span class='cmti-10'>es  un  reticulado.  El  orden  parcial</span>  \(\tilde{\leq }\)  <span class='cmti-10'>asociado  a  este  reticulado
</span><span class='cmti-10'>cumple </span>\[ x/\theta \tilde{\leq }y/\theta \text{ sii }y\theta (x\mathsf{\;s\;}y) \]
</p>
   </div>
<!-- l. 12475 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12476 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Veamos que la estructura \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }})\) cumple (I4). Sean \(x/\theta \), \(y/\theta \), \(z/\theta \) elementos cualesquiera
de \(L/\theta \). Tenemos que \[ \begin{array}{ccl} (x/\theta \mathsf{\;\tilde{s}\;}y/\theta )\;\mathsf{\tilde{s}}\;z/\theta &amp; = &amp; (x\mathsf{\;s\;}y)/\theta \;\mathsf{\tilde{s}}\;z/\theta \\ &amp; = &amp; ((x\mathsf{\;s\;}y)\;\mathsf{s}\;z)/\theta \\ &amp; = &amp; (x\mathsf{\;s\;}(y\;\mathsf{s}\;z))/\theta \\ &amp; = &amp; x/\theta \;\mathsf{\tilde{s}}\;(y\;\mathsf{s}\;z)/\theta \\ &amp; = &amp; x/\theta \mathsf{\;\tilde{s}\;}(y/\theta \;\mathsf{\tilde{s}}\;z/\theta ) \end{array} \] En forma similar se puede ver que la estructura \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }})\) cumple el
resto de las identidades que definen reticulado.
</p><!-- l. 12491 --><p class='indent'>   Por definicion, \(x/\theta \tilde{\leq }y/\theta \) sii \(y/\theta =x/\theta \mathsf{\;\tilde{s}\;}y/\theta \), por lo cual \(x/\theta \tilde{\leq }y/\theta \) sii \(y/\theta =(x\mathsf{\;s\;}y)/\theta \).                                                  □
</p>
   </div>
<!-- l. 12496 --><p class='indent'>   El reticulado \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }})\) es llamado el <span class='cmti-10'>cociente de</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>sobre</span> \(\theta \).
</p>
   <div class='newtheorem'>
<!-- l. 12499 --><p class='noindent'><span class='head'>
<a id='x1-149003r152'></a>
<span class='cmbx-10'>Corollary 152.</span>  </span><span class='cmti-10'>Sea</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>un reticulado en el cual hay un elemento maximo</span> \(1\) <span class='cmti-10'>(resp.
</span><span class='cmti-10'>minimo</span> \(0\)<span class='cmti-10'>). Entonces si</span> \(\theta \) <span class='cmti-10'>es una congruencia sobre</span> \((L,\mathsf{s},\mathsf{i})\)<span class='cmti-10'>,</span> \(1/\theta \) <span class='cmti-10'>(resp.</span> \(0/\theta \)<span class='cmti-10'>) es un elemento
</span><span class='cmti-10'>maximo (resp. minimo) de</span> \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }})\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 12507 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12508 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Ya que \(1=x\mathsf{\;s\;}1\), para cada \(x\in L\), tenemos que \(1/\theta =(x\mathsf{\;s\;}1)/\theta \), para cada \(x\in L\), lo cual por el lema anterior
nos dice que \(x/\theta \tilde{\leq }1/\theta \), para cada \(x\in L\).                                                                    □
</p>
   </div>
<!-- l. 12514 --><p class='indent'>   El siguiente lema nos da una forma natural de encontrar congruencias
</p>
   <div class='newtheorem'>
<!-- l. 12515 --><p class='noindent'><span class='head'>
<a id='x1-149004r153'></a>
<span class='cmbx-10'>Lema 153.</span>  </span><span class='cmti-10'>Si</span> \(F:(L,\mathsf{s},\mathsf{i})\rightarrow (L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) <span class='cmti-10'>es un homomorfismo, entonces</span> \(\ker F\) <span class='cmti-10'>es una congruencia sobre</span> \((L,\mathsf{s},\mathsf{i})\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 12520 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12521 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Dejamos al lector ver que \(\ker F\) es una relacion de equivalencia. Supongamos
\(x\ker Fx^{\prime }\) y \(y\ker Fy^{\prime }\). Entonces \[ F(x\mathsf{\;s\;}y)=F(x)\mathsf{\;s^{\prime }\;}F(y)=F(x^{\prime })\mathsf{\;s^{\prime }\;}F(y^{\prime })=F(x^{\prime }\mathsf{\;s\;}y^{\prime }) \] lo cual nos dice que \((x\mathsf{\;s\;}y)\ker F(x^{\prime }\mathsf{\;s\;}y^{\prime })\). En forma similar tenemos que \((x\mathsf{\;i\;}y)\ker F(x^{\prime }\mathsf{\;i\;}y^{\prime })\).             □
</p>
   </div>
<!-- l. 12531 --><p class='indent'>   Ya vimos que el nucleo de un homomorfismo es una congruencia. El siguiente
lema muestra que toda congruencia es el nucleo de un homomorfismo.
</p>
   <div class='newtheorem'>
<!-- l. 12533 --><p class='noindent'><span class='head'>
<a id='x1-149005r154'></a>
<span class='cmbx-10'>Lema 154.</span>  </span><span class='cmti-10'>Sea</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>un reticulado y sea</span> \(\theta \) <span class='cmti-10'>una congruencia sobre</span> \((L,\mathsf{s},\mathsf{i})\)<span class='cmti-10'>. Entonces</span> \(\pi _{\theta }\) <span class='cmti-10'>es un
</span><span class='cmti-10'>homomorfismo de</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>en</span> \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }})\)<span class='cmti-10'>. Ademas</span> \(\ker \pi _{\theta }=\theta \)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 12541 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12542 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Sean \(x,y\in L\). Tenemos que \[ \pi _{\theta }(x\mathsf{\;s\;}y)=(x\mathsf{\;s\;}y)/\theta =x/\theta \mathsf{\;\tilde{s}\;}y/\theta =\pi _{\theta }(x)\mathsf{\;\tilde{s}\;}\pi _{\theta }(y) \] por lo cual \(\pi _{\theta }\) preserva la operacion supremo. Para la
operacion infimo es similar.                                                                  □
</p>
   </div>
<!-- l. 12553 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>4.3   </span> <a id='x1-1500004.3'></a>Reticulados acotados</h4>
<!-- l. 12555 --><p class='noindent'>Por un <span class='cmti-10'>reticulado acotado </span>entenderemos una \(5\)-upla \((L,\mathsf{s},\mathsf{i},0,1)\), tal que \((L,\mathsf{s},\mathsf{i})\) es un reticulado, \(0,1\in L\), y
ademas se cumplen las siguientes identidades
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-150001x4.3'>\(0\mathsf{\;s\;}x=x\), para cada \(x\in L\)
     </li>
     <li class='enumerate' id='x1-150002x4.3'>\(x\mathsf{\;s\;}1=1\), para cada \(x\in L\).</li></ol>
<!-- l. 12563 --><p class='noindent'>Notese que si \((L,\leq )\) es un poset el cual es un reticulado y en el cual hay un maximo \(1\) y un
minimo \(0\), entonces si tomamos: \[ \begin{array}{rcl} \mathsf{s}:L^{2} &amp; \rightarrow &amp; L\\ (a,b) &amp; \rightarrow &amp; \sup (\{a,b\}) \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl} \mathsf{i}:L^{2} &amp; \rightarrow &amp; L\\ (a,b) &amp; \rightarrow &amp; \inf (\{a,b\}) \end{array} \] tenemos que \((L,\mathsf{s},\mathsf{i},0,1)\) es un reticulado acotado.
Ademas en virtud del Teorema <a href='#x1-144008r147'>147<!-- tex4ht:ref: equivalencia  --></a> todo reticulado acotado se obtiene de esta
forma.
</p><!-- l. 12580 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.3.1   </span> <a id='x1-1510004.3.1'></a>Subreticulados acotados</h5>
<!-- l. 12582 --><p class='noindent'>Dados reticulados acotados \((L,\mathsf{s},\mathsf{i},0,1)\) y \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\) diremos que \((L,\mathsf{s},\mathsf{i},0,1)\) <span class='cmti-10'>es un subreticulado acotado de</span> \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\) si se dan
las siguientes condiciones
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-151001x4.3.1'>\(L\subseteq L^{\prime }\)
     </li>
     <li class='enumerate' id='x1-151002x4.3.1'>\(0=0^{\prime }\) y \(1=1^{\prime }\)
     </li>
     <li class='enumerate' id='x1-151003x4.3.1'>\(\mathsf{s}=\mathsf{s}^{\prime }\)\(|\)\(_{L\times L}\) y \(\mathsf{i}=\mathsf{i}^{\prime }\)\(|\)\(_{L\times L}\)</li></ol>
<!-- l. 12591 --><p class='noindent'>Sea \((L,\mathsf{s},\mathsf{i},0,1)\) un reticulado acotado. Un conjunto \(S\subseteq L\) es llamado <span class='cmti-10'>subuniverso </span>de \((L,\mathsf{s},\mathsf{i},0,1)\) si \(0,1\in S\) y \(S\) es cerrado
bajo las operaciones \(\mathsf{s}\) e \(\mathsf{i}\) (i.e. \(x\mathsf{\;s\;}y\), \(x\;\mathsf{i}\ y\in S\), para todo \(x,y\in S)\). Es importante notar que si bien los
conceptos de subreticulado acotado y subuniverso estan muy relacionados, se trata de
objetos diferentes. Es facil notar que si \(S\) es un subuniverso de \((L,\mathsf{s},\mathsf{i},0,1)\), entonces \((S,\mathsf{s}\)\(|\)\(_{S\times S},\mathsf{i}\)\(|\)\(_{S\times S},0,1)\) es un
subreticulado de \((L,\mathsf{s},\mathsf{i},0,1)\) y que todo subreticulado acotado de \((L,\mathsf{s},\mathsf{i},0,1)\) se obtiene en esta
forma.

</p><!-- l. 12603 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.3.2   </span> <a id='x1-1520004.3.2'></a>Homomorfismos de reticulados acotados</h5>
<!-- l. 12605 --><p class='noindent'>Sean \((L,\mathsf{s},\mathsf{i},0,1)\) y \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\) reticulados acotados. Una funcion \(F:L\rightarrow L^{\prime }\) sera llamada un <span class='cmti-10'>homomorfismo de</span> \((L,\mathsf{s},\mathsf{i},0,1)\) <span class='cmti-10'>en</span> \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\) si
para todo \(x,y\in L\) se cumple que </p><div class='eqnarray'>\begin{eqnarray*} F(x\mathsf{\;s\;}y) &amp; = &amp; F(x)\;\mathsf{s}^{\prime }\ F(y)\\ F(x\mathsf{\;i\;}y) &amp; = &amp; F(x)\;\mathsf{i}^{\prime }\ F(y)\\ F(0) &amp; = &amp; 0^{\prime }\\ F(1) &amp; = &amp; 1^{\prime } \end{eqnarray*}
</div>Un homomorfismo de<p><span class='cmti-10'> </span></p>\((L,\mathsf{s},\mathsf{i},0,1)\) en \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\) sera llamado <p><span class='cmti-10'>isomorfismo </span></p>cuando sea biyectivo y
su inversa sea tambien un homomorfismo. Escribiremos \((L,\mathsf{s},\mathsf{i},0,1)\cong (L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\) cuando exista un
isomorfismo de \((L,\mathsf{s},\mathsf{i},0,1)\) en \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\). Escribiremos \(F:(L,\mathsf{s},\mathsf{i},0,1)\rightarrow (L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\) cuando \(F\) sea un homomorfismo de<p><span class='cmti-10'> </span></p>\((L,\mathsf{s},\mathsf{i,}0,1)\) en
\((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\).
   <div class='newtheorem'>
<!-- l. 12625 --><p class='noindent'><span class='head'>
<a id='x1-152001r155'></a>
<span class='cmbx-10'>Lema 155.</span>  </span><span class='cmti-10'>Si</span> \(F:(L,\mathsf{s},\mathsf{i},0,1)\rightarrow (L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\) <span class='cmti-10'>un homomorfismo biyectivo, entonces</span> \(F\) <span class='cmti-10'>es un isomorfismo</span>
</p>
   </div>
<!-- l. 12630 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12631 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Similar a la prueba del Lemma <a href='#x1-148001r148'>148<!-- tex4ht:ref: hom biyect implica iso  --></a>.                                             □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 12633 --><p class='noindent'><span class='head'>
<a id='x1-152002r156'></a>
<span class='cmbx-10'>Lema 156.</span>  </span><span class='cmti-10'>Si</span> \(F:(L,\mathsf{s},\mathsf{i},0,1)\rightarrow (L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\) <span class='cmti-10'>es un homomorfismo, entonces</span> \(I_{F}\) <span class='cmti-10'>es un subuniverso de</span> \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\)<span class='cmti-10'>. Es decir
</span><span class='cmti-10'>que</span> \(F\) <span class='cmti-10'>es tambien un homomorfismo de</span> \((L,\mathsf{s},\mathsf{i},0,1)\) <span class='cmti-10'>en</span> \((I_{F},\mathsf{s}^{\prime }\)\(|\)\(_{I_{F}\times I_{F}},\mathsf{i}^{\prime }\)\(|\)\(_{I_{F}\times I_{F}},0^{\prime },1^{\prime })\)
</p>
   </div>
<!-- l. 12640 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12641 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que \(F\) es un homomorfismo de<span class='cmti-10'> </span>\((L,\mathsf{s},\mathsf{i})\) en \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) tenemos que \(I_{F}\) es subuniverso de \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) lo
cual ya que \(0^{\prime },1^{\prime }\in I_{F}\) implica que \(I_{F}\) es un subuniverso de \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\).                                       □

</p>
   </div>
<!-- l. 12648 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.3.3   </span> <a id='x1-1530004.3.3'></a>Congruencias de reticulados acotados</h5>
<!-- l. 12650 --><p class='noindent'>Sea \((L,\mathsf{s},\mathsf{i},0,1)\) un reticulado acotado. Una <span class='cmti-10'>congruencia sobre</span> \((L,\mathsf{s},\mathsf{i},0,1)\) sera una relacion de equivalencia \(\theta \)
la cual sea una congruencia sobre \((L,\mathsf{s},\mathsf{i})\). Tenemos definidas sobre \(L/\theta \) dos operaciones binarias
\(\mathsf{\tilde{s}}\) e \(\mathsf{\tilde{\imath }}\), de la siguiente manera: </p><div class='eqnarray'>\begin{eqnarray*} x/\theta \mathsf{\tilde{s}}y/\theta &amp; = &amp; (x\mathsf{\;s\;}y)/\theta \\ x/\theta \mathsf{\tilde{\imath }}y/\theta &amp; = &amp; (x\mathsf{\;i\;}y)/\theta  \end{eqnarray*}
</div>La \(5\)-upla \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }},0/\theta ,1/\theta )\) es llamada el <p><span class='cmti-10'>cociente de</span></p> \((L,\mathsf{s},\mathsf{i},0,1)\) <p><span class='cmti-10'>sobre</span></p> \(\theta \) y la denotaremos con \((L,\mathsf{s},\mathsf{i},0,1)/\theta \).
   <div class='newtheorem'>
<!-- l. 12662 --><p class='noindent'><span class='head'>
<a id='x1-153001r157'></a>
<span class='cmbx-10'>Lema 157.</span>  </span><span class='cmti-10'>Sea</span> \((L,\mathsf{s},\mathsf{i},0,1)\) <span class='cmti-10'>un reticulado acotado y</span> \(\theta \) <span class='cmti-10'>una congruencia sobre</span> \((L,\mathsf{s},\mathsf{i},0,1)\)<span class='cmti-10'>.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-153002x157'>\((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }},0/\theta ,1/\theta )\) <span class='cmti-10'>es un reticulado acotado.</span>
     </li>
     <li class='enumerate' id='x1-153003x157'>\(\pi _{\theta }\) <span class='cmti-10'>es un homomorfismo de</span> \((L,\mathsf{s},\mathsf{i},0,1)\) <span class='cmti-10'>en</span> \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }},0/\theta ,1/\theta )\) <span class='cmti-10'>cuyo nucleo es</span> \(\theta \)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 12674 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12675 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) (a) Es facil ver que \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }},0/\theta ,1/\theta )\) cumple (I1), (I2),...,(I9) dado que \((L,\mathsf{s},\mathsf{i},0,1)\) las cumple.
</p><!-- l. 12679 --><p class='indent'>   (b) Sigue directamente del Lema <a href='#x1-149005r154'>154<!-- tex4ht:ref: pi sub tita es homomorfismo  --></a>                                                 □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 12683 --><p class='noindent'><span class='head'>
<a id='x1-153004r158'></a>
<span class='cmbx-10'>Lema 158.</span>  </span><span class='cmti-10'>Si</span> \(F:(L,\mathsf{s},\mathsf{i},0,1)\rightarrow (L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\) <span class='cmti-10'>es un homomorfismo de reticulados acotados, entonces</span> \(\ker F\) <span class='cmti-10'>es una
</span><span class='cmti-10'>congruencia sobre</span> \((L,\mathsf{s},\mathsf{i},0,1)\)<span class='cmti-10'>.</span>

</p>
   </div>
<!-- l. 12689 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12690 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que \(F\) es un homomorfismo de \((L,\mathsf{s},\mathsf{i})\ \)en \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime })\) tenemos que por un lema anterior \(\ker F\)
es una congruencia sobre \((L,\mathsf{s},\mathsf{i})\) lo cual por definicion nos dice que \(\ker F\) es una congruencia
sobre \((L,\mathsf{s},\mathsf{i},0,1)\).                                                                                             □
</p>
   </div>
<!-- l. 12697 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>4.4   </span> <a id='x1-1540004.4'></a>Reticulados complementados</h4>
<!-- l. 12699 --><p class='noindent'>Sea \((L,\mathsf{s},\mathsf{i},0,1)\) un reticulado acotado. Dado \(a\in L\), diremos que \(a\) es <span class='cmti-10'>complementado </span>cuando exista un
elemento \(b\in L\) (llamado <span class='cmti-10'>complemento de a</span>) tal que: </p><div class='eqnarray'>\begin{eqnarray*} a\;\mathsf{s\;}b &amp; = &amp; 1\\ a\;\mathsf{i\;}b &amp; = &amp; 0 \end{eqnarray*}
</div>Notese que dicho elemento \(b\) puede no ser unico, es decir \(a\) puede tener varios
complementos. Recordemos que una operacion unaria sobre un conjunto \(L\) es por
definicion una funcion de \(L\) en \(L\). Muchas veces si \(s\) denota una operacion unaria,
entonces escribiremos \(x^{s}\) en lugar de \(s(x)\). Por un <p><span class='cmti-10'>reticulado complementado </span></p>entederemos
una \(6\)-upla \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) tal que \((L,\mathsf{s},\mathsf{i},0,1)\) es un reticulado acotado y \(^{c}\) es una operacion unaria sobre \(L\) tal
que
     <ol class='enumerate1'>
     <li class='enumerate' id='x1-154001x4.4'>\(x\mathsf{\;s\;}x^{c}=1\), para cada \(x\in L\)
     </li>
     <li class='enumerate' id='x1-154002x4.4'>\(x\mathsf{\;i\;}x^{c}=0\), para cada \(x\in L\)</li></ol>
<!-- l. 12719 --><p class='noindent'>Dado un reticulado acotado \((L,\mathsf{s},\mathsf{i},0,1)\) puede haber mas de una operacion unaria \(g\) tal que \((L,\mathsf{s},\mathsf{i},g,0,1)\) resulte
un reticulado complementado. Intente dar un ejemplo en el cual \(L\) tenga 5
elementos. Notese que si tenemos un poset \((L,\leq )\) el cual es un reticulado en el
cual hay un maximo \(1\) y un minimo \(0\) y ademas tenemos una funcion \(g:L\rightarrow L\) tal
que
</p>
   <div class='eqnarray'>\begin{eqnarray*} \sup \{x,g(x)\} &amp; = &amp; 1\\ \inf \{x,g(x)\} &amp; = &amp; 0 \end{eqnarray*}
</div>para cada \(x\in L\), entonces podemos definir \[ \begin{array}{rcl} \mathsf{s}:L^{2} &amp; \rightarrow &amp; L\\ (a,b) &amp; \rightarrow &amp; \sup (\{a,b\}) \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl} \mathsf{i}:L^{2} &amp; \rightarrow &amp; L\\ (a,b) &amp; \rightarrow &amp; \inf (\{a,b\}) \end{array} \] y se obtiene que \((L,\mathsf{s},\mathsf{i},g,0,1)\) es un reticulado
complementado. Ademas en virtud del Teorema <p><a href='#x1-144008r147'>147<!-- tex4ht:ref: equivalencia  --></a></p> todo reticulado complementado
se obtiene de esta forma.

<!-- l. 12744 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.4.1   </span> <a id='x1-1550004.4.1'></a>Subreticulados complementados</h5>
<!-- l. 12746 --><p class='noindent'>Dados reticulados complementados \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) y \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },^{c^{\prime }},0^{\prime },1^{\prime })\) diremos que \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) <span class='cmti-10'>es un subreticulado
</span><span class='cmti-10'>complementado de</span> \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },^{c^{\prime }},0^{\prime },1^{\prime })\) si se dan las siguientes condiciones
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-155001x4.4.1'>\(L\subseteq L^{\prime }\)
     </li>
     <li class='enumerate' id='x1-155002x4.4.1'>\(0=0^{\prime }\) y \(1=1^{\prime }\)
     </li>
     <li class='enumerate' id='x1-155003x4.4.1'>\(\mathsf{s}=\mathsf{s}^{\prime }\)\(|\)\(_{L\times L}\), \(\mathsf{i}=\mathsf{i}^{\prime }\)\(|\)\(_{L\times L}\) y \(^{c}=\ ^{c^{\prime }}\)\(|\)\(_{L}\)</li></ol>
<!-- l. 12757 --><p class='noindent'>Sea \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) un reticulado complementado. Un conjunto \(S\subseteq L\) es llamado <span class='cmti-10'>subuniverso </span>de \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) si \(0,1\in S\) y \(S\) es
cerrado bajo las operaciones \(\mathsf{s}\), \(\mathsf{i}\) y \(^{c}\) (i.e. \(x\mathsf{\;s\;}y\), \(x\;\mathsf{i}\ y\), \(x^{c}\in S\), para todo \(x,y\in S)\). Es importante notar que si bien
los conceptos de subreticulado complementado y subuniverso estan muy relacionados,
se trata de objetos diferentes. Es facil notar que si \(S\) es un subuniverso de \((L,\mathsf{s},\mathsf{i},^{c},0,1)\), entonces \((S,\mathsf{s}\)\(|\)\(_{S\times S},\mathsf{i}\)\(|\)\(_{S\times S},^{c}\)\(|\)\(_{S},0,1)\)
es un subreticulado complementado de \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) y que todo subreticulado complementado de \((L,\mathsf{s},\mathsf{i},^{c},0,1)\)
se obtiene en esta forma.
</p><!-- l. 12770 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.4.2   </span> <a id='x1-1560004.4.2'></a>Homomorfismos de reticulados complementados</h5>
<!-- l. 12772 --><p class='noindent'>Sean \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) y \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },^{c^{\prime }},0^{\prime },1^{\prime })\) reticulados complementados. Una funcion \(F:L\rightarrow L^{\prime }\) sera llamada un <span class='cmti-10'>homomorfismo
</span><span class='cmti-10'>de</span> \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) <span class='cmti-10'>en</span> \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },^{c^{\prime }},0^{\prime },1^{\prime })\) si para todo \(x,y\in L\) se cumple que </p><div class='eqnarray'>\begin{eqnarray*} F(x\mathsf{\;s\;}y) &amp; = &amp; F(x)\;\mathsf{s}^{\prime }\ F(y)\\ F(x\mathsf{\;i\;}y) &amp; = &amp; F(x)\;\mathsf{i}^{\prime }\ F(y)\\ F(x^{c}) &amp; = &amp; F(x)^{c^{\prime }}\\ F(0) &amp; = &amp; 0^{\prime }\\ F(1) &amp; = &amp; 1^{\prime } \end{eqnarray*}
</div>Un homomorfismo de<p><span class='cmti-10'> </span></p>\((L,\mathsf{s},\mathsf{i},^{c},0,1)\) en \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },^{c^{\prime }},0^{\prime },1^{\prime })\) sera llamado <p><span class='cmti-10'>isomorfismo </span></p>cuando sea biyectivo y su
inversa sea un homomorfismo. Como es usual usaremos el simbolo \(\cong \) para denotar la
relacion de isomorfismo. Escribiremos \(F:(L,\mathsf{s},\mathsf{i},^{c},0,1)\rightarrow (L^{\prime },\mathsf{s}^{\prime }\), \(\mathsf{i}^{\prime },^{c^{\prime }},0^{\prime },1^{\prime })\) cuando \(F\) sea un homomorfismo de<p><span class='cmti-10'> </span></p>\((L,\mathsf{s},\mathsf{i},^{c},0,1)\) en \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },^{c^{\prime }},0^{\prime },1^{\prime })\).
Dejamos al lector la prueba de los siguientes lemas.
   <div class='newtheorem'>
<!-- l. 12793 --><p class='noindent'><span class='head'>
<a id='x1-156001r159'></a>
<span class='cmbx-10'>Lema 159.</span>  </span><span class='cmti-10'>Si</span> \(F:(L,\mathsf{s},\mathsf{i},^{c},0,1)\rightarrow (L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },^{c^{\prime }},0^{\prime },1^{\prime })\) <span class='cmti-10'>un homomorfismo biyectivo, entonces</span> \(F\) <span class='cmti-10'>es un isomorfismo</span>
</p>
   </div>
<!-- l. 12798 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12799 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Es dejada al lector.                                                                   □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 12801 --><p class='noindent'><span class='head'>
<a id='x1-156002r160'></a>
<span class='cmbx-10'>Lema 160.</span>  </span><span class='cmti-10'>Si</span> \(F:(L,\mathsf{s},\mathsf{i},^{c},0,1)\rightarrow (L^{\prime },\mathsf{s}^{\prime }\)<span class='cmti-10'>,</span>\(\mathsf{i}^{\prime },^{c^{\prime }},0^{\prime },1^{\prime })\)<span class='cmti-10'> es un homomorfismo, entonces</span> \(I_{F}\) <span class='cmti-10'>es un subuniverso de</span> \((L^{\prime },\mathsf{s}^{\prime }\)<span class='cmti-10'>,</span>\(\mathsf{i}^{\prime },^{c^{\prime }},0^{\prime },1^{\prime })\)<span class='cmti-10'>. Es
</span><span class='cmti-10'>decir que</span> \(F\) <span class='cmti-10'>es tambien un homomorfismo de</span> \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) <span class='cmti-10'>en</span> \((I_{F},\mathsf{s}^{\prime }\)\(|\)\(_{I_{F}\times I_{F}},\mathsf{i}^{\prime }\)\(|\)\(_{I_{F}\times I_{F}},^{c^{\prime }},0^{\prime },1^{\prime })\)
</p>
   </div>
<!-- l. 12808 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12809 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es dejada al lector.                                                                   □
</p>
   </div>
<!-- l. 12812 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>4.4.3   </span> <a id='x1-1570004.4.3'></a>Congruencias de reticulados complementados</h5>
<!-- l. 12814 --><p class='noindent'>Sea \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) un reticulado complementado. Una <span class='cmti-10'>congruencia sobre</span> \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) sera una relacion de
equivalencia sobre \(L\) la cual cumpla:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-157001x4.4.3'>\(\theta \) es una congruencia sobre \((L,\mathsf{s},\mathsf{i},0,1)\)
     </li>
     <li class='enumerate' id='x1-157002x4.4.3'>\(x/\theta =y/\theta \) implica \(x^{c}/\theta =y^{c}/\theta \)</li></ol>
<!-- l. 12821 --><p class='noindent'>Las condiciones anteriores nos permiten definir sobre \(L/\theta \) dos operaciones binarias \(\mathsf{\tilde{s}}\) e \(\mathsf{\tilde{\imath }}\), y una
operacion unaria \(^{\tilde{c}}\) de la siguiente manera: </p><div class='eqnarray'>\begin{eqnarray*} x/\theta \mathsf{\;\tilde{s}\;}y/\theta &amp; = &amp; (x\mathsf{\;s\;}y)/\theta \\ x/\theta \mathsf{\;\tilde{\imath }\;}y/\theta &amp; = &amp; (x\mathsf{\;i\;}y)/\theta \\ (x/\theta )^{\tilde{c}} &amp; = &amp; x^{c}/\theta  \end{eqnarray*}
</div>La \(6\)-upla \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }},^{\tilde{c}},0/\theta ,1/\theta )\) es llamada el <p><span class='cmti-10'>cociente de</span></p> \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) <p><span class='cmti-10'>sobre</span></p> \(\theta \) y la denotaremos con \((L,\mathsf{s},\mathsf{i},^{c},0,1)/\theta \). Tal como era de
esperar tenemos entonces
   <div class='newtheorem'>
<!-- l. 12833 --><p class='noindent'><span class='head'>
<a id='x1-157003r161'></a>

<span class='cmbx-10'>Lema 161.</span>  </span><span class='cmti-10'>Sea</span> \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) <span class='cmti-10'>un reticulado complementado y sea</span> \(\theta \) <span class='cmti-10'>una congruencia sobre</span>
\((L,\mathsf{s},\mathsf{i},^{c},0,1)\)<span class='cmti-10'>.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-157004x161'>\((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }},^{\tilde{c}},0/\theta ,1/\theta )\) <span class='cmti-10'>es un reticulado complementado.</span>
     </li>
     <li class='enumerate' id='x1-157005x161'>\(\pi _{\theta }\) <span class='cmti-10'>es un homomorfismo de</span> \((L,\mathsf{s},\mathsf{i},^{c},0,1)\) <span class='cmti-10'>en</span> \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }},^{\tilde{c}},0/\theta ,1/\theta )\) <span class='cmti-10'>cuyo nucleo es</span> \(\theta \)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 12845 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12846 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Por un lema anterior ya sabemos que \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }},0/\theta ,1/\theta )\) es un reticulado acotado. Es
decir que solo nos falta ver que \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }},^{\tilde{c}},0/\theta ,1/\theta )\) sarisface las identidades (I10) y (I11). Veamos
por ejemplo que satisface la (I10). Sea \(x/\theta \) un elemento cualquiera de \(L/\theta \). Ya que \((L,\mathsf{s},\mathsf{i},^{c},0,1)\)
satisface la (I10), tenemos que \(x\mathsf{\;s\;}x^{c}=1\). O sea que \((x\mathsf{\;s\;}x^{c})/\theta =1/\theta \) y por lo tanto \(x/\theta \mathsf{\;\tilde{s}\;}x^{c}/\theta =1/\theta \). Pero por definicion
de \(^{\tilde{c}}\) tenemos que \((x/\theta )^{\tilde{c}}=x^{c}/\theta \), lo cual nos dice que \(x/\theta \mathsf{\;\tilde{s}\;}(x/\theta )^{\tilde{c}}=1/\theta \). Dejamos al lector ver que \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }},^{\tilde{c}},0/\theta ,1/\theta )\) sarisface la
identidad (I11)
</p><!-- l. 12858 --><p class='indent'>   (b) Por el Lema <a href='#x1-153001r157'>157<!-- tex4ht:ref: cociente de reticulados acotados  --></a> tenemos que \(\pi _{\theta }\) es un homomorfismo de \((L,\mathsf{s},\mathsf{i},0,1)\) en \((L/\theta ,\mathsf{\tilde{s}},\mathsf{\tilde{\imath }},0/\theta ,1/\theta )\) cuyo nucleo
es \(\theta \). Notese que por definicion de \(^{\tilde{c}}\) tenemos que \(x^{c}/\theta =(x/\theta )^{\tilde{c}}\), es decir \(\pi _{\theta }(x^{c})=(\pi _{\theta }(x))^{\tilde{c}}\), cualquiera sea \(x\in L\)      □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 12867 --><p class='noindent'><span class='head'>
<a id='x1-157006r162'></a>
<span class='cmbx-10'>Lema 162.</span>  </span><span class='cmti-10'>Si</span> \(F:(L,\mathsf{s},\mathsf{i},^{c},0,1)\rightarrow (L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },^{c^{\prime }},0^{\prime },1^{\prime })\) <span class='cmti-10'>es un homomorfismo de reticulados complementados, entonces</span> \(\ker F\) <span class='cmti-10'>es
</span><span class='cmti-10'>una congruencia sobre</span> \((L,\mathsf{s},\mathsf{i},^{c},0,1)\)
</p><!-- l. 12871 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12872 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que \(F\) es un homomorfismo de \((L,\mathsf{s},\mathsf{i},0,1)\) en \((L^{\prime },\mathsf{s}^{\prime },\mathsf{i}^{\prime },0^{\prime },1^{\prime })\) tenemos que por un lema anterior
\(\ker F\) es una congruencia sobre \((L,\mathsf{s},\mathsf{i},0,1)\). Es decir que solo falta probar que para todos \(x,y\in L\), se
tiene que \(x/\ker F=y/\ker F\) implica \(x^{c}/\ker F=y^{c}/\ker F\), lo cual es dejado al lector                                          □

</p>
   </div>
   </div>
<!-- l. 12884 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>4.5   </span> <a id='x1-1580004.5'></a>Algebras de Boole</h4>
<!-- l. 12886 --><p class='noindent'>Un reticulado \((L,\mathsf{s},\mathsf{i})\) se llamara <span class='cmti-10'>distributivo </span>cuando cumpla la siguiente identidad
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-158001x4.5'>\(x\mathsf{\;i\;}(y\;\mathsf{s}\;z)=(x\mathsf{\;i\;}y)\;\mathsf{s}\;(x\mathsf{\;i\;}z)\), cualesquiera sean \(x,y,z\in L\)</li></ol>
<!-- l. 12892 --><p class='noindent'>Diremos que un reticulado acotado \((L,\mathsf{s},\mathsf{i},0,1)\) (resp. complementado \((L,\mathsf{s},\mathsf{i},^{c},0,1)\)) es <span class='cmti-10'>distributivo </span>cuando \((L,\mathsf{s},\mathsf{i})\) lo
sea. Consideremos la distributividad dual a Dis\(_{1}\), es decir
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-158002x4.5'>\(x\;\mathsf{s}\;(y\mathsf{\;i\;}z)=(x\mathsf{\;s\;}y)\mathsf{\;i\;}(x\;\mathsf{s}\;z)\), cualesquiera sean \(x,y,z\in L\)</li></ol>
<div class='newtheorem'>
<!-- l. 12900 --><p class='noindent'><span class='head'>
<a id='x1-158003r163'></a>
<span class='cmbx-10'>Lema 163.</span>  </span><span class='cmti-10'>Sea</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>un reticulado. Entonces</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>satisface Dis</span>\(_{1}\) <span class='cmti-10'>sii</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>satisface Dis</span>\(_{2}\)
</p>
</div>
<!-- l. 12905 --><p class='noindent'>
</p>
   <div class='proof'>
<!-- l. 12906 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \((L,\mathsf{s},\mathsf{i})\) satisface Dis\(_{1}\). Notese que </p><div class='eqnarray'>\begin{eqnarray*} (x\mathsf{\;s\;}y)\mathsf{\;i\;}(x\;\mathsf{s}\;z) &amp; = &amp; ((x\mathsf{\;s\;}y)\mathsf{\;i\;}x)\;\mathsf{s}\;((x\mathsf{\;s\;}y)\mathsf{\;i\;}z)\\ &amp; = &amp; (x\;\mathsf{s}\;(z\mathsf{\;i\;}(x\mathsf{\;s\;}y))\\ &amp; = &amp; (x\;\mathsf{s}\;((z\;\mathsf{i\;}x)\mathsf{\;s\;}(z\;\mathsf{i\;}y))\\ &amp; = &amp; (x\;\mathsf{s}\;(z\;\mathsf{i\;}x))\mathsf{\;s\;}(z\;\mathsf{i\;}y)\\ &amp; = &amp; x\mathsf{\;s\;}(z\;\mathsf{i\;}y)\\ &amp; = &amp; x\mathsf{\ s\ }(y\ \mathsf{i\ }z) \end{eqnarray*}
</div>por lo cual \((L,\mathsf{s},\mathsf{i})\) satisface Dis\(_{2}\)                                                                      □
   </div>
<!-- l. 12920 --><p class='noindent'>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-158004x4.5'>Use la prueba del lema anterior para hacer un algoritmo el cual tome de
     entrada un reticulado acotado \((L,\mathsf{s},\mathsf{i},0,1)\) y elementos \(x,y,z\in L\) tales que \(y\neq z\) son complementos
     de \(x\), y de como salida elementos \(a,b,c\) tales que \(a\mathsf{\;i\;}(b\;\mathsf{s}\;c)\neq (a\mathsf{\;i\;}b)\;\mathsf{s}\;(a\mathsf{\;i\;}c)\)</li></ol>

<!-- l. 12930 --><p class='indent'>   Por un <span class='cmti-10'>Algebra de Boole </span>entenderemos un reticulado complementado que es
distributivo. Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-158005x4.5'>Dado un conjunto \(X\), la \(6\)-upla \((X,\cup ,\cap ,^{c},\emptyset ,X)\) es un algebra de Boole</li></ol>
<!-- l. 12940 --><p class='indent'>   Para probar algunas propiedades fundamentales de un algebra de Boole
necesitaremos el siguiente
</p>
   <div class='newtheorem'>
<!-- l. 12945 --><p class='noindent'><span class='head'>
<a id='x1-158006r164'></a>
<span class='cmbx-10'>Lema 164.</span>  </span><span class='cmti-10'>Si</span> \((L,\mathsf{s},\mathsf{i},0,1)\) <span class='cmti-10'>un reticulado acotado y distributivo, entonces todo elemento
</span><span class='cmti-10'>tiene a lo sumo un complemento.</span>
</p>
   </div>
<!-- l. 12950 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12951 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(x\in L\) tiene complementos \(y,z\). Se tiene \[ y=y\;\mathsf{i\;}1=y\;\mathsf{i\;}(x\;\mathsf{s\;}z)=(y\;\mathsf{i\;}x)\;\mathsf{s\;}(y\;\mathsf{i\;}z)=0\;\mathsf{s\;}(y\;\mathsf{i\;}z)=y\;\mathsf{i\;}z, \] por lo cual \(y\leq z\). En forma
analoga se muestra que \(z\leq y\).                                                                      □
</p>
   </div>
<!-- l. 12959 --><p class='indent'>   Una propiedad muy importante que se da en las algebras de Boole es
</p>
   <div class='newtheorem'>
<!-- l. 12960 --><p class='noindent'><span class='head'>
<a id='x1-158007r165'></a>
<span class='cmbx-10'>Lema 165.</span>  </span><span class='cmti-10'>Sea</span> \((B,\mathsf{s},\mathsf{i},^{\mathbf{c}},0,1)\) <span class='cmti-10'>un álgebra de Boole y sean</span> \(x,y\in B\)<span class='cmti-10'>. Se tiene que</span> \(y=(y\;\mathsf{i\;}x)\;\mathsf{s\;}(y\mathsf{\;i\mathsf{\;}}x^{c})\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 12965 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12966 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>\(y=y\;\mathsf{i\;}1=y\mathsf{\;i\mathsf{\;}}(x\mathsf{\;s\mathsf{\;}}x^{c})=(y\;\mathsf{i\;}x)\;\mathsf{s\;}(y\mathsf{\;i\mathsf{\;}}x^{c})\)                                                                                      □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 12970 --><p class='noindent'><span class='head'>
<a id='x1-158008r166'></a>
<span class='cmbx-10'>Teorema 166.</span>  </span><span class='cmti-10'>Sea</span> \((L,\mathsf{s},\mathsf{i},^{\mathbf{c}},0,1)\) <span class='cmti-10'>un álgebra de Boole.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-158009x166'>\((x\,\mathsf{i\,}y)^{c}=x^{c}\,\mathsf{s\,}y^{c}\)
     </li>
     <li class='enumerate' id='x1-158010x166'>\((x\,\mathsf{s\,}y)^{c}=x^{c}\,\mathsf{i\,}y^{c}\)
     </li>
     <li class='enumerate' id='x1-158011x166'>\(x^{cc}=x\)
     </li>
     <li class='enumerate' id='x1-158012x166'>\(x\,\mathsf{i\,}y=0\) <span class='cmti-10'>si y solo si</span> \(y\leq x^{c}\)
     </li>
     <li class='enumerate' id='x1-158013x166'>\(x\leq y\) <span class='cmti-10'>si y solo si</span> \(y^{c}\leq x^{c}\)</li></ol>
   </div>
<!-- l. 12981 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 12982 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(1) Es facil ver que \(x^{c}\,\mathsf{s\,}y^{c}\) es un complemento de \(x\,\mathsf{i\,}y\). Pero ya que \((L,\mathsf{s},\mathsf{i},^{\mathbf{c}},0,1)\) es un reticulado
complementado, tenemos que \((x\,\mathsf{i\,}y)^{c}\) es un complemento de \(x\,\mathsf{i\,}y\). El lema anterior nos dice
que \((x\,\mathsf{i\,}y)^{c}\) y \(x^{c}\,\mathsf{s\,}y^{c}\) deben ser iguales.
</p><!-- l. 12989 --><p class='indent'>   (2) y (3) se prueban en forma similar.
</p><!-- l. 12991 --><p class='indent'>   (4) Supongamos \(x\,\mathsf{i\,}y=0\). Se tiene </p><div class='eqnarray'>\begin{eqnarray*} y &amp; = &amp; (y\;\mathsf{i\;}x)\;\mathsf{s\;}(y\mathsf{\;i\mathsf{\;}}x^{c})\mathsf{\,}\\ &amp; = &amp; (x\;\mathsf{i\;}y)\;\mathsf{s\;}(y\mathsf{\;i\mathsf{\;}}x^{c})\\ &amp; = &amp; 0\;\mathsf{s\;}(y\mathsf{\;i\mathsf{\;}}x^{c})\\ &amp; = &amp; (y\mathsf{\;i\mathsf{\;}}x^{c}) \end{eqnarray*}
</div>lo cual dice que \(y\leq x^{c}\). Supongamos \(y\leq x^{c}\). Entonces \(x\,\mathsf{i\,}y\leq x\,\mathsf{i\,}x^{c}=0\) por lo cual \(x\,\mathsf{i\,}y=0\).
<!-- l. 13001 --><p class='indent'>   (5) Supongamos \(x\leq y\). Entonces \(x\,\mathsf{i\,}y=x\), lo cual por (1) nos dice que \(x^{c}\,\mathsf{s\,}y^{c}=x^{c}\) obteniendo que \(y^{c}\leq x^{c}\). La
resiproca es dejada al lector (hint: use (3)                                               □
</p>
   </div>
<!-- l. 13010 --><p class='indent'>   @@finpagina@@

</p><!-- l. 13014 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>4.6   </span> <a id='x1-1590004.6'></a>Teoremas del filtro primo y de Rasiowa Sikorski</h4>
<!-- l. 13018 --><p class='noindent'>Un <span class='cmti-10'>filtro </span>de un reticulado \((L,\mathsf{s},\mathsf{i})\) sera un subconjunto \(F\subseteq L\) tal que:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-159001x4.6'>\(F\neq \emptyset \)
     </li>
     <li class='enumerate' id='x1-159002x4.6'>\(x,y\in F\Rightarrow x\;\mathsf{i\;}y\in F\)
     </li>
     <li class='enumerate' id='x1-159003x4.6'>\(x\in F\) y \(x\leq y\Rightarrow y\in F\)</li></ol>
<!-- l. 13025 --><p class='noindent'>El nombre ”filtro” es inspirado por la propiedad (3) ya que si un filtro o colador atrapa a
cierto objeto \(x\), entonces claramente atrapara a todos los objetos mas grandes que
\(x\).
</p><!-- l. 13029 --><p class='indent'>   Dado un conjunto \(S\subseteq L\), denotemos con \([S)\) el siguiente conjunto \[ \{y\in L:y\geq s_{1}\;\mathsf{i\;}...\;\mathsf{i\;}s_{n}\text{, para algunos }s_{1},...,s_{n}\in S\text{, }n\geq 1\} \]
</p>
   <div class='newtheorem'>
<!-- l. 13035 --><p class='noindent'><span class='head'>
<a id='x1-159004r167'></a>
<span class='cmbx-10'>Lema 167.</span>  </span><span class='cmti-10'>Supongamos</span> \(S\) <span class='cmti-10'>es no vacio. Entonces</span> \([S)\) <span class='cmti-10'>es un filtro. Mas aun si</span> \(F\) <span class='cmti-10'>es
</span><span class='cmti-10'>un filtro y</span> \(F\supseteq S\)<span class='cmti-10'>, entonces</span> \(F\supseteq [S)\)<span class='cmti-10'>. Es decir,</span> \([S)\) <span class='cmti-10'>es el menor filtro que contiene a</span> \(S\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 13041 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 13042 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que \(S\subseteq [S)\), tenemos que \([S)\neq \emptyset \). Claramente \([S)\) cumple la propiedad (3). Veamos
cumple la (2). Si \(y\geq s_{1}\;\mathsf{i\;}s_{2}\;\mathsf{i\;}...\;\mathsf{i\;}s_{n}\) y \(z\geq t_{1}\;\mathsf{i\;}t_{2}\;\mathsf{i\;}\)...\(\;\mathsf{i\;}t_{m}\), con \(s_{1},s_{2},...,s_{n}\), \(t_{1},t_{2},...,t_{m}\in S\), entonces \[ y\;\mathsf{i\;}z\geq s_{1}\;\mathsf{i\;}s_{2}\;\mathsf{i\;}...\;\mathsf{i\;}s_{n}\;\mathsf{i\;}t_{1}\;\mathsf{i\;}t_{2}\;\mathsf{i\;}...\;\mathsf{i\;}t_{m} \] lo cual prueba (2).                         □
</p>
   </div>
<!-- l. 13057 --><p class='indent'>   Llamaremos a \([S)\) el <span class='cmti-10'>filtro generado por</span> \(S\). Cuando \(S\) es finito, ya que existe \(\inf S\), es claro
que \([S)=\{y\in L:y\geq \inf S\}\). Cuando \(S\) es infinito y existe \(\inf S\), en muchos casos se dara que \([S)=\{y\in L:y\geq \inf S\}\) o que \([S)=\{y\in L:y&gt;\inf S\}\), pero no
necesariamente esto sucedera siempre. Por ejemplo:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-159005x4.6'>Sea \(\mathbf{L}=(\mathcal{P}(\mathbf{N}),\cup ,\cap )\) y sea \(S=\{\mathbf{N}-\{n\}:n\in \mathbf{N}\}\). Es facil ver que \(\inf S=\emptyset \) y que \([S)=\{A\in \mathcal{P}(\mathbf{N}):\mathbf{N}-A\) es finito\(\}\) por lo cual no se da que \([S)=\{y\in L:y\geq \inf S\}\) o
     que \([S)=\{y\in L:y&gt;\inf S\}\)</li></ol>

<!-- l. 13070 --><p class='indent'>   En general, si \((L,\mathsf{s},\mathsf{i},0,1)\) es un reticulado acotado, diremos que \(F\) es un <span class='cmti-10'>filtro </span>de \((L,\mathsf{s},\mathsf{i},0,1)\) cuando \(F\) sea
un filtro de \((L,\mathsf{s},\mathsf{i})\). Lo mismo sucedera con el concepto de filtro de un reticulado
complementado \((L,\mathsf{s},\mathsf{i},^{c},0,1)\)
</p><!-- l. 13076 --><p class='indent'>   Sea \((P,\leq )\) un poset. Un subconjunto \(C\subseteq P\) sera llamado una <span class='cmti-10'>cadena </span>si para cada \(x,y\in C\), se tiene
que \(x\leq y\) o \(y\leq x\). Por ejemplo
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-159006x4.6'>\(\{1,10,40,600\}\) y \(\{2^{n}:n\in \mathbf{N}\}\) son cadenas del poset \((\mathbf{N},|)\)
     </li>
     <li class='enumerate' id='x1-159007x4.6'>\(\{-3,5,2\}\) y el intervalo \([2,3]\) son cadenas del poset \((\mathbf{R},\leq )\). De hecho todo subconjunto de \(\mathbf{R}\) es
     una cadena de \((\mathbf{R},\leq )\)</li></ol>
<!-- l. 13085 --><p class='noindent'>Es importante notar que las cadenas pueden ser infinitas y que dada una cadena infinita \(C\)
puede no existir una infinitupla \((c_{1},c_{2},...)\) tal que \(C=\{c_{n}:n\in \mathbf{N}\}\) (por que?). El siguiente resultado es una
herramienta fundamental en el algebra moderna.
</p>
   <div class='newtheorem'>
<!-- l. 13091 --><p class='noindent'><span class='head'>
<a id='x1-159008r168'></a>
<span class='cmbx-10'>Lema 168.</span>  </span><span class='cmti-10'>(Zorn) Sea</span> \((P,\leq )\) <span class='cmti-10'>un poset y supongamos cada cadena de</span> \((P,\leq )\) <span class='cmti-10'>tiene una cota
</span><span class='cmti-10'>superior. Entonces hay un elemento maximal en</span> \((P,\leq )\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 13098 --><p class='indent'>   Un filtro \(F\) de un reticulado \((L,\mathsf{s},\mathsf{i})\) sera llamado <span class='cmti-10'>primo </span>cuando se cumplan:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-159009x4.6'>\(F\neq L\)
     </li>
     <li class='enumerate' id='x1-159010x4.6'>\(x\;\mathsf{s\;}y\in F\Rightarrow x\in F\) o \(y\in F\).</li></ol>
<!-- l. 13106 --><p class='indent'>   Algunos ejemplos:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-159011x4.6'>Todo filtro de \((\mathbf{R},\max ,\min )\), distinto de \(\mathbf{R}\), es primo (justificar)
     </li>
     <li class='enumerate' id='x1-159012x4.6'>Sea \(B=\{X\subseteq \omega :X\) es finito o \(\omega -X\) es finito\(\}\). Como vimos anteriormente \(B\) es cerrado bajo las
     operaciones \(\cup \) y \(\cap \). Sea \(P=\{X\subseteq \omega :\omega -X\) es finito\(\}\). Entonces \(P\) es un filtro primo de \((B,\cup ,\cap )\).</li></ol>
   <div class='newtheorem'>
<!-- l. 13117 --><p class='noindent'><span class='head'>
<a id='x1-159013r169'></a>

<span class='cmbx-10'>Teorema 169 </span>(Teorema del Filtro Primo)<span class='cmbx-10'>.</span>  </span><span class='cmti-10'>Sea</span> \((L,\mathsf{s},\mathsf{i})\) <span class='cmti-10'>un reticulado distributivo y</span> \(F\)
<span class='cmti-10'>un filtro. Supongamos</span> \(x_{0}\in L-F\)<span class='cmti-10'>. Entonces hay un filtro primo</span> \(P\) <span class='cmti-10'>tal que</span> \(x_{0}\notin P\) <span class='cmti-10'>y</span> \(F\subseteq P\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 13123 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 13124 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea \[ \mathcal{F}=\{F_{1}:F_{1}\text{ es un filtro, }x_{0}\notin F_{1}\text{ y }F\subseteq F_{1}\}. \] Notese que \(\mathcal{F}\neq \emptyset \), por lo cual \((\mathcal{F},\subseteq )\) es un poset. Veamos que cada cadena en \((\mathcal{F},\subseteq )\) tiene
una cota superior. Sea \(C\) una cadena. Si \(C=\emptyset \), entonces cualquier elemento de \(\mathcal{F}\) es cota de
\(C\). Supongamos entonces \(C\neq \emptyset \). Sea \[ G=\{x\in L:x\in F_{1}\text{, para algun }F_{1}\in C\}. \] Veamos que \(G\) es un filtro. Es claro que \(G\) es
no vacio. Supongamos que \(x,y\in G\). Sean \(F_{1},F_{2}\in \mathcal{F}\) tales que \(x\in F_{1}\) y \(y\in F_{2}\). Si \(F_{1}\subseteq F_{2}\), entonces ya que \(F_{2}\) es
un filtro tenemos que \(x\;\mathsf{i\;}y\in F_{2}\subseteq G\). Si \(F_{2}\subseteq F_{1}\), entonces tenemos que \(x\;\mathsf{i\;}y\in F_{1}\subseteq G\). Ya que \(C\) es una cadena,
tenemos que siempre \(x\;\mathsf{i\;}y\in G\). En forma analoga se prueba la propiedad restante
por lo cual tenemos que \(G\) es un filtro. Ademas \(x_{0}\notin G\), por lo que \(G\in \mathcal{F}\) es cota superior
de \(C\). Por el lema de Zorn, \((\mathcal{F},\subseteq )\) tiene un elemento maximal \(P\). Veamos que \(P\) es
un filtro primo. Supongamos \(x\;\mathsf{s\;}y\in P\) y \(x,y\notin P\). Notese que \([P\cup \{x\})\) es un filtro el cual contiene
propiamente a \(P\). Entonces ya que \(P\) es un elemento maximal de \((\mathcal{F},\subseteq )\), tenemos
que \(x_{0}\in [P\cup \{x\})\). Analogamente tenemos que \(x_{0}\in [P\cup \{y\})\). Ya que \(x_{0}\in [P\cup \{x\})\), tenemos que hay elementos \(p_{1},...,p_{n}\in P\),
tales que \[ x_{0}\geq p_{1}\;\mathsf{i\;}...\;\mathsf{i\;}p_{n}\;\mathsf{i\;}x \] (se deja como ejercicio justificar esto). Ya que \(x_{0}\in [P\cup \{y\})\), tenemos que hay
elementos \(q_{1},...,q_{m}\in P\), tales que \[ x_{0}\geq q_{1}\;\mathsf{i\;}...\;\mathsf{i\;}q_{m}\;\mathsf{i\;}y \] Si llamamos \(p\) al siguiente elemento de \(P\) \[ p_{1}\;\mathsf{i\;}...\;\mathsf{i\;}p_{n}\;\mathsf{i\;}q_{1}\;\mathsf{i\;}...\;\mathsf{i\;}q_{m} \] tenemos que
</p><div class='eqnarray'>\begin{eqnarray*} x_{0} &amp; \geq &amp; p\;\mathsf{i\;}x\\ x_{0} &amp; \geq &amp; p\;\mathsf{i\;}y \end{eqnarray*}
</div>Se tiene entonces que \(x_{0}\geq (p\;\mathsf{i\;}x)\;\mathsf{s\;}(p\;\mathsf{i\;}y)=p\;\mathsf{i\;}(x\;\mathsf{s\;}y)\in P\), lo cual es absurdo ya que \(x_{0}\notin P\).                                    □
   </div>
   <div class='newtheorem'>
<!-- l. 13172 --><p class='noindent'><span class='head'>
<a id='x1-159014r170'></a>
<span class='cmbx-10'>Corollary 170.</span>  </span><span class='cmti-10'>Sea</span> \((L,\mathsf{s},\mathsf{i},0,1)\) <span class='cmti-10'>un reticulado acotado distributivo. Si</span> \(\emptyset \neq S\subseteq L\) <span class='cmti-10'>es tal que</span> \(s_{1}\;\mathsf{i\;}s_{2}\;\mathsf{i\;}...\;\mathsf{i\;}s_{n}\neq 0\)<span class='cmti-10'>, para
</span><span class='cmti-10'>cada</span> \(s_{1},...,s_{n}\in S\)<span class='cmti-10'>, entonces hay un filtro primo que contiene a</span> \(S\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 13179 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 13180 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que \([S)\neq L\) por lo cual se puede aplicar el Teorema del filtro primo.   □

</p>
   </div>
   <div class='newtheorem'>
<!-- l. 13185 --><p class='noindent'><span class='head'>
<a id='x1-159015r171'></a>
<span class='cmbx-10'>Lema 171.</span>  </span><span class='cmti-10'>Sea</span> \((B,\mathsf{s},\mathsf{i},^{c},0,1)\) <span class='cmti-10'>un algebra de Boole. Entonces para un filtro</span> \(F\subsetneq B\) <span class='cmti-10'>las siguientes son
</span><span class='cmti-10'>equivalentes:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-159016x171'>\(F\) <span class='cmti-10'>es primo</span>
     </li>
     <li class='enumerate' id='x1-159017x171'>\(x\in F\) <span class='cmti-10'>o</span> \(x^{c}\in F\)<span class='cmti-10'>, para cada</span> \(x\in B\)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 13194 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 13195 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(1)\(\Rightarrow \)(2). Ya que \(x\;\mathsf{s\;}x^{c}=1\in F\), (2) se cumple si \(F\) es primo.
</p><!-- l. 13198 --><p class='indent'>   (2)\(\Rightarrow \)(1). Ya sabemos por hipotesis que \(F\) es un filtro y que \(F\neq B\). Supongamos que \(x\;\mathsf{s\;}y\in F\)
y que \(x\not \in F\). Entonces por (2), \(x^{c}\in F\) y por lo tanto tenemos que \[ y\geq x^{c}\;\mathsf{i\;}y=(x^{c}\;\mathsf{i\;}x)\;\mathsf{s\;}(x^{c}\;\mathsf{i\;}y)=x^{c}\;\mathsf{i\;}(x\;\mathsf{s\;}y)\in F, \] lo cual dice que \(y\in F\).       □
</p>
   </div>
<!-- l. 13208 --><p class='indent'>   Necesitaremos el siguiente lema.
</p>
   <div class='newtheorem'>
<!-- l. 13209 --><p class='noindent'><span class='head'>
<a id='x1-159018r172'></a>
<span class='cmbx-10'>Lema 172.</span>  </span><span class='cmti-10'>Sea</span> \((B,\mathsf{s},\mathsf{i},^{c},0,1)\) <span class='cmti-10'>un algebra de Boole. Supongamos que</span> \(b\neq 0\) <span class='cmti-10'>y</span> \(a=\inf A\)<span class='cmti-10'>, con</span> \(A\subseteq B\)<span class='cmti-10'>. Entonces si</span> \(b\;\mathsf{i\;}a=0\)<span class='cmti-10'>,
</span><span class='cmti-10'>existe un</span> \(e\in A\) <span class='cmti-10'>tal que</span> \(b\;\mathsf{i\;}e^{c}\neq 0\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 13215 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 13216 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Supongamos que para cada \(e\in A\), tengamos que \(b\;\mathsf{i\;}e^{c}=0\). Entonces tenemos que para
cada \(e\in A\), \[ b=b\;\mathsf{i\;}(e\;\mathsf{s\;}e^{c})=(b\;\mathsf{i\;}e)\;\mathsf{s\;}(b\;\mathsf{i\;}e^{c})=b\;\mathsf{i\;}e, \] lo cual nos dice que \(b\) es cota inferior de \(A\). Pero entonces \(b\leq a\), por lo cual \(b=b\;\mathsf{i\;}a=0\),
contradiciendo la hipotesis.                                                                  □
</p>
   </div>
<!-- l. 13227 --><p class='indent'>   Es claro que si \(P\) es un filtro primo de un algebra de Boole \((B,\mathsf{s},\mathsf{i},^{c},0,1)\), entonces cualquiera sea
el conjunto finito \(S\) contenido en \(P\), se tiene que \(\inf S\in P\). Cuando tomamos un subconjunto \(S\subseteq P\) el
cual es infinito, la cosa cambia sustancialmente. Primero cabe destacar que puede
suceder que \(S\) no tenga infimo en \((B,\mathsf{s},\mathsf{i},^{c},0,1)\). Pero tambien puede pasar que \(S\) tenga infimo pero
que \(\inf S\) no pertenesca a \(P\). Por ejemplo, si tomamos el algebra de Boole \((B,\cup ,\cap ,^{c},\emptyset ,\omega )\), donde \[ B=\{X\subseteq \omega :X\text{ es finito o }\omega -X\text{ es finito}\} \] podemos
observar que \[ P=\{X\subseteq \omega :\omega -X\text{ es finito}\} \] es un filtro primo y que \[ S=\{\omega -\{n\}:n\in \omega \} \] esta contenido en \(P\) pero \(\inf S=\emptyset \) no pertenece a
\(P\).
</p><!-- l. 13252 --><p class='indent'>   El siguiente teorema sera clave en nuestra prueba del teorema de completitud de
la logica de primer orden.
</p>
   <div class='newtheorem'>
<!-- l. 13254 --><p class='noindent'><span class='head'>
<a id='x1-159019r173'></a>
<span class='cmbx-10'>Teorema 173.</span>  </span><span class='cmti-10'>(Rasiova y Sikorski) Sea</span> \((B,\mathsf{s},\mathsf{i},^{c},0,1)\) <span class='cmti-10'>un algebra de Boole. Sea</span> \(x\in B\)<span class='cmti-10'>,</span> \(x\neq 0\)<span class='cmti-10'>. Supongamos
</span><span class='cmti-10'>que</span> \((A_{1},A_{2},...)\) <span class='cmti-10'>es una infinitupla de subconjuntos de</span> \(B\) <span class='cmti-10'>tal que existe</span> \(\inf (A_{j})\)<span class='cmti-10'>, para cada</span> \(j=1,2....\) <span class='cmti-10'>Entonces hay
</span><span class='cmti-10'>un filtro primo</span> \(P\) <span class='cmti-10'>el cual cumple:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-159020x173'>\(x\in P\)
     </li>
     <li class='enumerate' id='x1-159021x173'>\(P\supseteq A_{j}\Rightarrow P\ni \inf (A_{j})\)<span class='cmti-10'>, para cada</span> \(j=1,2,....\)</li></ol>
   </div>
<!-- l. 13265 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 13266 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sean \(a_{j}=\inf (A_{j})\), \(j=1,2,...\). Construiremos inductivamente una infinitupla \((b_{0},b_{1},...)\) de elementos de \(B\) tal
que:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-159022x4.6'>\(b_{0}=x\)

     </li>
     <li class='enumerate' id='x1-159023x4.6'>\(b_{0}\;\mathsf{i\;}\)...\(\;\mathsf{i\;}b_{n}\neq 0\), para cada \(n\geq 0\)
     </li>
     <li class='enumerate' id='x1-159024x4.6'>\(b_{j}=a_{j}\) o \(b_{j}^{c}\in A_{j}\), para cada \(j\geq 1\).</li></ol>
<!-- l. 13273 --><p class='noindent'>Definamos \(b_{0}=x\). Supongamos ya definimos \(b_{0},...,b_{n}\), veamos como definir \(b_{n+1}\). Si \((b_{0}\;\mathsf{i\;}...\;\mathsf{i\;}b_{n})\;\mathsf{i\;}a_{n+1}\neq 0\), entonces definamos \(b_{n+1}=a_{n+1}\).
Si \((b_{0}\;\mathsf{i\;}...\;\mathsf{i\;}b_{n})\;\mathsf{i\;}a_{n+1}=0\), entonces por el lema anterior, tenemos que hay un \(e\in A_{n+1}\) tal que \((b_{0}\;\mathsf{i\;}...\;\mathsf{i\;}b_{n})\;\mathsf{i\;}e^{c}\neq 0\), lo cual nos permite
definir \(b_{n+1}=e^{c}\).
</p><!-- l. 13280 --><p class='indent'>   Usando (2) se puede probar que el conjunto \(S=\{b_{0},b_{1},...\}\) satisface la hipotesis del primer
corolario del Teorema del filtro primo, por lo cual hay un filtro primo \(P\) tal que
\(\{b_{0},b_{1},...\}\subseteq P\). Es claro que \(x\in P\) y es facil chequear usando (3) que \(P\) satisface la propiedad
(b).                                                                                                 □
</p>
   </div>
<!-- l. 13291 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>5   </span> <a id='x1-1600005'></a>Sintaxis de la logica de primer orden</h3>
<!-- l. 13293 --><p class='noindent'>En esta seccion desarrolaremos en forma rigurosa como parte del universo de los
objetos matematicos ciertos conjuntos de palabras que seran utilizados luego para
modelizar matematicamente la actividad matematica misma.
</p><!-- l. 13301 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>5.1   </span> <a id='x1-1610005.1'></a>Variables</h4>
<!-- l. 13303 --><p class='noindent'>Sea \(Var\) el siguiente conjunto de palabras del alfabeto \(\{\mathsf{X},\mathit{0},\mathit{1},...,\mathit{9},\mathbf{0},\mathbf{1},...,\mathbf{9}\}\): \[ Var=\{\mathsf{X}\mathbf{1},...,\mathsf{X}\mathbf{9},\mathsf{X}\mathit{1}\mathbf{0},\mathsf{X}\mathit{1}\mathbf{1},...,\mathsf{X}\mathit{1}\mathbf{9},\mathsf{X}\mathit{2}\mathbf{0},\mathsf{X}\mathit{2}\mathbf{1},...\} \] Es decir el elemento \(n\)-esimo de \(Var\)
es la palabra de la forma \(\mathsf{X}\alpha \) donde \(\alpha \) es el resultado de reemplazar en la palabra que
denota \(n\) en notacion decimal, el ultimo numeral por su correspondiente numeral
bold y los otros por sus correspondientes italicos. A los elementos de \(Var\) los
llamaremos <span class='cmti-10'>variables. </span>Denotaremos con \(x_{i}\) al \(i\)-esimo elemento de \(Var\), para cada
\(i\in \mathbf{N}\).
</p><!-- l. 13318 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>5.2   </span> <a id='x1-1620005.2'></a>Tipos</h4>
<!-- l. 13320 --><p class='noindent'>Recordemos que \(\alpha \) <span class='cmti-10'>es subpalabra (propia) de</span> \(\beta \) cuando (\(\alpha \notin \{\varepsilon ,\beta \}\) y) existan palabras \(\delta ,\gamma \) tales que
\(\beta =\delta \alpha \gamma \).
</p><!-- l. 13324 --><p class='indent'>   Por un <span class='cmti-10'>tipo </span>(<span class='cmti-10'>de primer orden</span>) entenderemos una 4-upla \(\tau =(\mathcal{C},\mathcal{F},\mathcal{R},a)\) tal que:

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-162001x5.2'>Hay alfabetos finitos \(\Sigma _{1}\), \(\Sigma _{2}\) y \(\Sigma _{3}\) tales:
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-162003x1'>\(\mathcal{C}\subseteq \Sigma _{1}^{+}\), \(\mathcal{F}\subseteq \Sigma _{2}^{+}\) y \(\mathcal{R}\subseteq \Sigma _{3}^{+}\)
         </li>
         <li class='enumerate' id='x1-162005x2'>\(\Sigma _{1}\), \(\Sigma _{2}\) y \(\Sigma _{3}\) son disjuntos de a pares.
         </li>
         <li class='enumerate' id='x1-162007x3'>\(\Sigma _{1}\cup \Sigma _{2}\cup \Sigma _{3}\) no contiene ningun simbolo de la lista
         <!-- l. 13336 --><p class='noindent'>\(\forall \ \exists \;\lnot \;\vee \;\wedge \;\rightarrow \;\leftrightarrow \;(\;)\;,\;\equiv \mathsf{X\;}\mathit{0}\;\mathit{1\;}...\;\mathit{9}\;\mathbf{0}\;\mathbf{1}\ ...\;\mathbf{9}\)</p></li></ol>
     </li>
     <li class='enumerate' id='x1-162008x5.2'>\(a:\mathcal{F}\cup \mathcal{R}\rightarrow \mathbf{N}\) es una funcion que a cada \(p\in \mathcal{F}\cup \mathcal{R}\) le asocia un numero natural \(a(p)\), llamado la <span class='cmti-10'>aridad </span>de
     \(p\).
     </li>
     <li class='enumerate' id='x1-162009x5.2'>Ninguna palabra de \(\mathcal{C}\) (resp. \(\mathcal{F}\), \(\mathcal{R}\)) es subpalabra propia de otra palabra de \(\mathcal{C}\) (resp. \(\mathcal{F}\),
     \(\mathcal{R}\)).</li></ol>
<!-- l. 13345 --><p class='noindent'>A los elementos de \(\mathcal{C}\) (resp. \(\mathcal{F}\), \(\mathcal{R}\)) los llamaremos <span class='cmti-10'>nombres de constante </span>(resp. <span class='cmti-10'>nombres de
</span><span class='cmti-10'>funcion, nombres de relacion</span>) <span class='cmti-10'>de tipo</span> \(\tau \).
</p><!-- l. 13350 --><p class='indent'>   Dado \(n\geq 1\), definamos </p><div class='eqnarray'>\begin{eqnarray*} \mathcal{F}_{n} &amp; = &amp; \{f\in \mathcal{F}:a(f)=n\}\\ \mathcal{R}_{n} &amp; = &amp; \{r\in \mathcal{R}:a(r)=n\} \end{eqnarray*}
</div>
<!-- l. 13357 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>5.3   </span> <a id='x1-1630005.3'></a>Terminos</h4>
<!-- l. 13359 --><p class='noindent'>Dado un tipo \(\tau \), definamos recursivamente los conjuntos de palabras \(T_{k}^{\tau }\), con \(k\geq 0\), de la
siguiente manera: </p><div class='eqnarray'>\begin{eqnarray*} T_{0}^{\tau } &amp; = &amp; Var\cup \mathcal{C}\\ T_{k+1}^{\tau } &amp; = &amp; T_{k}^{\tau }\cup \{f(t_{1},...,t_{n}):f\in \mathcal{F}_{n},n\geq 1,t_{1},...,t_{n}\in T_{k}^{\tau }\}. \end{eqnarray*}
</div>Sea \[ T^{\tau }=\bigcup _{k\geq 0}T_{k}^{\tau } \] Los elementos de \(T^{\tau }\) seran llamados <p><span class='cmti-10'>terminos de tipo</span></p> \(\tau \). Un termino \(t\) es llamado
<p><span class='cmti-10'>cerrado </span></p>si \(x_{i}\) no es subpalabra de \(t\), para cada \(i\in \mathbf{N}\). Definamos \[ T_{c}^{\tau }=\{t\in T^{\tau }:t\text{ es cerrado}\} \]
<!-- l. 13376 --><p class='indent'>   El siguiente lema es la herramienta basica para probar propiedades de los
terminos.
</p>
   <div class='newtheorem'>
<!-- l. 13381 --><p class='noindent'><span class='head'>
<a id='x1-163001r174'></a>
<span class='cmbx-10'>Lema 174.</span>  </span><span class='cmti-10'>Supongamos</span> \(t\in T_{k}^{\tau }\)<span class='cmti-10'>, con</span> \(k\geq 1\)<span class='cmti-10'>. Entonces ya sea</span> \(t\in Var\cup \mathcal{C}\) <span class='cmti-10'>o</span> \(t=f(t_{1},...,t_{n})\)<span class='cmti-10'>, con</span> \(f\in \mathcal{F}_{n}\)<span class='cmti-10'>,</span> \(n\geq 1,\;t_{1},...,t_{n}\in T_{k-1}^{\tau }\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 13387 --><p class='indent'>
</p>

   <div class='proof'>
<!-- l. 13388 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Por induccion en \(k\).
</p><!-- l. 13390 --><p class='indent'>   CASO \(k=1\): Es directo ya que por definicion \[ T_{1}^{\tau }=Var\cup \mathcal{C}\cup \{f(t_{1},...,t_{n}):f\in \mathcal{F}_{n},n\geq 1,t_{1},...,t_{n}\in T_{0}^{\tau }\}. \]
</p><!-- l. 13395 --><p class='indent'>   CASO \(k\Rightarrow k+1\): Sea \(t\in T_{k+1}^{\tau }\). Por definicion de \(T_{k+1}^{\tau }\) tenemos que \(t\in T_{k}^{\tau }\) o \(t=f(t_{1},...,t_{n})\) con \(f\in \mathcal{F}_{n}\), \(n\geq 1\) y \(t_{1},...,t_{n}\in T_{k}^{\tau }\). Si se da que
\(t\in T_{k}^{\tau }\), entonces podemos aplicar hipotesis inductiva y usar que \(T_{k-1}^{\tau }\subseteq T_{k}^{\tau }\). Esto completa el
caso.                                                                                                □
</p>
   </div>
<!-- l. 13404 --><p class='indent'>   Algunos ejemplos de propiedades de los terminos las cuales se pueden probar
facilmente usando el lema anterior son
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-163002x5.3'>Si \(t\in T^{\tau }\) es tal que en \(t\) ocurre el simbolo \()\), entonces \(t=f(t_{1},...,t_{n})\) con \(f\in \mathcal{F}_{n}\), \(n\geq 1\) y \(t_{1},...,t_{n}\in T^{\tau }\).
     </li>
     <li class='enumerate' id='x1-163003x5.3'>Ningun termino comienza con un simbolo del alfabeto \(\{\mathit{0},\mathit{1},...,\mathit{9}\}\)
     </li>
     <li class='enumerate' id='x1-163004x5.3'>Si \(t\in T^{\tau }\) comienza con \(\mathsf{X}\) entonces \(t\in Var\)
     </li>
     <li class='enumerate' id='x1-163005x5.3'>Si \(t\in T^{\tau }\) y \(\left [t\right ]_{i}=)\), con \(i&lt;\left \vert t\right \vert \), entonces \(\left [t\right ]_{i+1}=\) \(,\) o \(\left [t\right ]_{i+1}=\) \()\)</li></ol>
<!-- l. 13418 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>5.3.1   </span> <a id='x1-1640005.3.1'></a>Unicidad de la lectura de terminos</h5>
<!-- l. 13420 --><p class='noindent'>Definamos conjuntos \(Bal_{k}\), con \(k\geq 1\) de la siguiente manera: </p><div class='eqnarray'>\begin{eqnarray*} Bal_{1} &amp; = &amp; \{()\}\\ Bal_{k+1} &amp; = &amp; Bal_{k}\cup \{(b_{1}...b_{n}):b_{1},...,b_{n}\in Bal_{k},n\geq 1\}. \end{eqnarray*}
</div>Sea \[ Bal=\bigcup _{k\geq 1}Bal_{k} \] Recordemos que \(\beta \) es un <p><span class='cmti-10'>tramo inicial (propio) </span></p>de \(\alpha \) si hay una palabra \(\gamma \) tal que \(\alpha =\beta \gamma \) (y
\(\beta \notin \{\varepsilon ,\alpha \}\)). En forma similar se define <p><span class='cmti-10'>tramo final (propio).</span></p>
   <div class='newtheorem'>
<!-- l. 13432 --><p class='noindent'><span class='head'>
<a id='x1-164001r175'></a>
<span class='cmbx-10'>Lema 175.</span>  </span><span class='cmti-10'>Sea</span> \(b\in Bal\)<span class='cmti-10'>. Se tiene:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-164002x175'>\(\left \vert b\right \vert _{(}-\left \vert b\right \vert _{)}=0\)
     </li>
     <li class='enumerate' id='x1-164003x175'><span class='cmti-10'>Si</span> \(x\) <span class='cmti-10'>es tramo inicial propio de</span> \(b\)<span class='cmti-10'>, entonces</span> \(\left \vert x\right \vert _{(}-\left \vert x\right \vert _{)}&gt;0\)

     </li>
     <li class='enumerate' id='x1-164004x175'><span class='cmti-10'>Si</span> \(x\) <span class='cmti-10'>es tramo final propio de</span> \(b\)<span class='cmti-10'>, entonces</span> \(\left \vert x\right \vert _{(}-\left \vert x\right \vert _{)}&lt;0\)</li></ol>
   </div>
<!-- l. 13441 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 13442 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Probaremos por induccion en \(k\), que valen (1), (2) y (3) para cada \(b\in Bal_{k}\). El caso
\(k=1\) es trivial. Supongamos \(b\in Bal_{k+1}\). Si \(b\in Bal_{k}\), se aplica directamente HI. Supongamos entonces
que \(b=(b_{1}...b_{n})\), con \(b_{1},...,b_{n}\in Bal_{k}\), \(n\geq 1\). Por HI, \(b_{1},...,b_{n}\) cumplen (1) por lo cual \(b\) cumple (1). Veamos que \(b\) cumple
(2). Sea \(x\) un tramo inicial propio de \(b\). Notese que \(x\) es de la forma \(x=(b_{1}...b_{i}x_{1}\) con \(0\leq i\leq n-1\) y \(x_{1}\) un
tramo inicial de \(b_{i+1}\) (en el caso \(i=0\) interpretamos \(b_{1}...b_{i}=\varepsilon )\). Pero entonces ya que \[ \left \vert x\right \vert _{(}-\left \vert x\right \vert _{)}=1+\left (\sum _{j=1}^{i}\left \vert b_{j}\right \vert _{(}-\left \vert b_{j}\right \vert _{)}\right )+\left \vert x_{1}\right \vert _{(}-\left \vert x_{1}\right \vert _{)} \] tenemos que
por HI, se da que \(\left \vert x\right \vert _{(}-\left \vert x\right \vert _{)}&gt;0\). En forma analoga se puede ver que \(b\) cumple (3).             □
</p>
   </div>
<!-- l. 13459 --><p class='indent'>   @@finpagina@@
</p><!-- l. 13461 --><p class='indent'>   Dado un alfabeto \(\Sigma \) tal que \((\) y \()\) pertenecen a \(\Sigma \), definamos \(del:\Sigma ^{\ast }\rightarrow \Sigma ^{\ast }\), de la siguiente manera
</p><div class='eqnarray'>\begin{eqnarray*} del(\varepsilon ) &amp; = &amp; \varepsilon \\ del(\alpha a) &amp; = &amp; del(\alpha )a\text{, si }a\in \{(,)\}\\ del(\alpha a) &amp; = &amp; del(\alpha )\text{, si }a\in \Sigma -\{(,)\} \end{eqnarray*}
</div>
   <div class='newtheorem'>
<!-- l. 13470 --><p class='noindent'><span class='head'>
<a id='x1-164005r176'></a>
<span class='cmbx-10'>Lema 176.</span>  </span>\(del(xy)=del(x)del(y)\)<span class='cmti-10'>, para todo</span> \(x,y\in \Sigma ^{\ast }\)
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 13474 --><p class='noindent'><span class='head'>
<a id='x1-164006r177'></a>
<span class='cmbx-10'>Lema 177.</span>  </span><span class='cmti-10'>Supongamos que</span> \(\Sigma \) <span class='cmti-10'>es tal que</span> \(T^{\tau }\subseteq \Sigma ^{\ast }\)<span class='cmti-10'>. Entonces</span> \(del(t)\in Bal\)<span class='cmti-10'>, para cada</span> \(t\in T^{\tau }-(Var\cup \mathcal{C})\)
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 13479 --><p class='noindent'><span class='head'>
<a id='x1-164007r178'></a>

<span class='cmbx-10'>Lema 178.</span>  </span><span class='cmti-10'>Sean</span> \(s,t\in T^{\tau }\) <span class='cmti-10'>y supongamos que hay palabras</span> \(x,y,z\)<span class='cmti-10'>, con</span> \(y\neq \varepsilon \) <span class='cmti-10'>tales que</span> \(s=xy\) <span class='cmti-10'>y</span> \(t=yz\) <span class='cmti-10'>. Entonces</span> \(x=z=\varepsilon \)
<span class='cmti-10'>o</span> \(s,t\in \mathcal{C}\)<span class='cmti-10'>. En particular si un termino es tramo inicial o final de otro termino, entonces
</span><span class='cmti-10'>dichos terminos son iguales.</span>
</p>
   </div>
<!-- l. 13487 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 13488 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(s\in \mathcal{C}\). Ya que \(y\neq \varepsilon \) tenemos que \(t\) debe comenzar con un simbolo que ocurre
en un nombre de cte, lo cual dice que \(t\) no puede ser ni una variable ni de la
forma \(g(t_{1},...,t_{m})\), es decir \(t\in \mathcal{C}\). Supongamos \(s\in Var\). Si \(x\neq \varepsilon \) tenemos que \(t\) debe comenzar con alguno
de los siguientes simbolos \[ \mathit{0}\;\mathit{1\;}...\;\mathit{9}\;\mathbf{0}\;\mathbf{1}\ ...\;\mathbf{9} \] lo cual es absurdo. O sea que \(x=\varepsilon \) y por lo tanto \(t\)
debe comenzar con \(\mathsf{X}\). Pero esto dice que \(t\in Var\) de lo que sigue facilmente que \(z=\varepsilon \).
Supongamos entonces que \(s\) es de la forma \(f(s_{1},...,s_{n})\). Ya que \()\) debe ocurrir en \(t\), tenemos que \(t\)
es de la forma \(g(t_{1},...,t_{m})\). O sea que \(del(s),del(t)\in Bal\). Ya que \()\) ocurre en \(y\), \(del(y)\neq \varepsilon \). Tenemos tambien que
</p><div class='eqnarray'>\begin{eqnarray*} del(s) &amp; = &amp; del(x)del(y)\\ del(t) &amp; = &amp; del(y)del(z) \end{eqnarray*}
</div>La primera igualdad, por (1) y (3) del Lema <a href='#x1-164001r175'>175<!-- tex4ht:ref: basicas de balanceadas  --></a>, nos dice que \[ \left \vert del(y)\right \vert _{(}-\left \vert del(y)\right \vert _{)}\leq 0, \] y la segunda que \[ \left \vert del(y)\right \vert _{(}-\left \vert del(y)\right \vert _{)}\geq 0, \] por
lo cual \[ \left \vert del(y)\right \vert _{(}-\left \vert del(y)\right \vert _{)}=0 \] Pero entonces (3) del Lema <a href='#x1-164001r175'>175<!-- tex4ht:ref: basicas de balanceadas  --></a> nos dice que \(del(y)\) no puede ser tramo final propio
de \(del(s)\), por lo cual debe suceder que \(del(y)=del(s)\), ya que \(del(y)\neq \varepsilon \). Claramente entonces obtenemos que \(del(x)=\varepsilon \).
Similarmente se puede ver que \(del(z)=\varepsilon \). Ya que que \(t\) termina con \()\) tenemos que \(z=\varepsilon \). O sea que \(f(s_{1},...,s_{n})=xg(t_{1},...,t_{m})\)
con \(del(x)=\varepsilon \), de lo que se saca que \(f=xg\) ya que \((\) no ocurre en \(x\). De la definicion de tipo se
desprende que \(x=\varepsilon \).                                                                                 □
   </div>
   <div class='newtheorem'>
<!-- l. 13532 --><p class='noindent'><span class='head'>
<a id='x1-164008r179'></a>
<span class='cmbx-10'>Teorema 179.</span>  </span><span class='cmti-10'>(Lectura unica de terminos). Dado</span> \(t\in T^{\tau }\)<span class='cmti-10'> se da una de las siguientes:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-164009x179'>\(t\in Var\cup \mathcal{C}\)
     </li>
     <li class='enumerate' id='x1-164010x179'><span class='cmti-10'>Hay unicos</span> \(n\geq 1,\;f\in \mathcal{F}_{n},\;t_{1},...,t_{n}\in T^{\tau }\)<span class='cmti-10'> tales que</span> \(t=f(t_{1},...,t_{n})\)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 13542 --><p class='indent'>
</p>
   <div class='proof'>

<!-- l. 13543 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>En virtud del Lema <a href='#x1-163001r174'>174<!-- tex4ht:ref: basic0  --></a> solo nos falta probar la unicidad en el punto (2).
Supongamos que \[ t=f(t_{1},...,t_{n})=g(s_{1},...,s_{m}) \] con \(n,m\geq 1,\;f\in \mathcal{F}_{n}\), \(g\in \mathcal{F}_{m}\), \(t_{1},...,t_{n},s_{1},...,s_{m}\in T^{\tau }\). Notese que \(f=g\). O sea que \(n=m=a(f)\). Notese que \(t_{1}\) es tramo inicial
de \(s_{1}\) o \(s_{1}\) es tramo inicial de \(t_{1}\), lo cual por el lema anterior nos dice que \(t_{1}=s_{1}\). Con el
mismo razonamiento podemos probar que debera suceder \(t_{2}=s_{2},...,t_{n}=s_{n}\).                         □
</p>
   </div>
<!-- l. 13555 --><p class='indent'>    
</p><!-- l. 13557 --><p class='indent'>   El teorema anterior es importante ya que nos permite definir recursivamente
funciones con dominio contenido en \(T^{\tau }\). Por ejemplo podemos definir una funcion \(F:T^{\tau }\rightarrow T^{\tau }\), de la
siguiente manera:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-164011x5.3.1'>\(F(c)=c\), para cada \(c\in \mathcal{C}\)
     </li>
     <li class='enumerate' id='x1-164012x5.3.1'>\(F(v)=v\), para cada \(v\in Var\)
     </li>
     <li class='enumerate' id='x1-164013x5.3.1'>\(F(f(t_{1},...,t_{n}))=f(F(t_{1}),...,F(t_{n}))\), si \(f\in \mathcal{F}_{n}\), con \(n\neq 2\)
     </li>
     <li class='enumerate' id='x1-164014x5.3.1'>\(F(f(t_{1},t_{2}))=f(t_{2},t_{1})\), si \(f\in \mathcal{F}_{2}.\)</li></ol>
<!-- l. 13568 --><p class='noindent'>Notese que si la unicidad de la lectura no fuera cierta, entonces las ecuaciones anterires
no estarian definiendo en forma correcta una funcion ya que el valor de la imagen
de un termino \(t\) estaria dependiendo de cual descomposicion tomemos para
\(t\).
</p><!-- l. 13576 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>5.3.2   </span> <a id='x1-1650005.3.2'></a>Subterminos</h5>
<!-- l. 13578 --><p class='noindent'>Sean \(s,t\in T^{\tau }\). Diremos que \(s\) es <span class='cmti-10'>subtermino </span>(<span class='cmti-10'>propio</span>)<span class='cmti-10'> </span>de \(t\) si (no es igual a \(t\) y) \(s\) es subpalabra de
\(t\). A continuacion veremos de que manera ocurren los subterminos de un termino.
Para esto recordemos un poco el concepto de ocurrencia.
</p><!-- l. 13583 --><p class='indent'>   Dadas palabras \(\alpha ,\beta \in \Sigma ^{\ast }\), con \(\left \vert \alpha \right \vert ,\left \vert \beta \right \vert \geq 1\), y un natural \(i\in \{1,...,\left \vert \beta \right \vert \}\), se dice que \(\alpha \) <span class='cmti-10'>ocurre a partir de</span> \(i\) <span class='cmti-10'>en</span> \(\beta \) cuando
se de que existan palabras \(\delta ,\gamma \) tales que \(\beta =\delta \alpha \gamma \) y \(\left \vert \delta \right \vert =i-1\).
</p><!-- l. 13589 --><p class='indent'>   Notese que una palabra \(\alpha \) puede ocurrir en \(\beta \), a partir de \(i\), y tambien a partir de \(j\),
con \(i\neq j\). En virtud de esto, hablaremos de las distintas ocurrencias de \(\alpha \) en \(\beta \). Por ejemplo
hay dos ocurrencias de la palabra \(aba\) en la palabra \[ cccccccabaccccabaccccc \] y tambien hay dos ocurrencias de la
palabra \(aba\) en la palabra \[ cccccccababacccccccccc \] En el primer caso diremos que dichas ocurrencias de \(aba\) son

<span class='cmti-10'>disjuntas</span>, en cambio en el segundo caso puede apreciarse que las dos ocurrencias se
superponen en una posicion. No definiremos en forma matematica precisa
el concepto de ocurrencia pero lo describiremos con ejemplos de manera
que el lector no tendra problemas en comprenderlo y manejarlo en forma
correcta.
</p><!-- l. 13607 --><p class='indent'>   A veces diremos que una ocurrencia esta <span class='cmti-10'>contenida </span>o <span class='cmti-10'>sucede </span>dentro de otra. Por
ejemplo la segunda ocurrencia de \(ab\) en \(babbbfabcccfabccc\) esta contenida en la primer ocurrencia de \(fabc\) en \(babbbfabcccfabccc\).
Tambien haremos <span class='cmti-10'>reemplazos </span>de ocurrencias por palabras. Por ejemplo el resultado
de reemplazar la primer ocurrencia de \(abb\) en \(ccabbgfgabbgg\) por \(oolala\) es la palabra \(ccoolalagfgabbgg\). El resultado de
reemplazar todas las ocurrencias de \(aba\) en \(ccabagfgabaggaba\) por \(\$\$\) es la palabra \(cc\$\$gfg\$\$gg\$\$\). En algunos casos
deberemos especificar que los reemplazos se hagan <span class='cmti-10'>simultaneamente</span>. Por ejemplo
hablaremos del resultado de reemplazar en \(\gamma \), simultaneamente, todas las ocurrencias
de \(\alpha _{1}\) por \(\beta _{1}\) y todas las de \(\alpha _{2}\) por \(\beta _{2}\). Aqui la aclaracion de simultaneidad es importante ya
que si primero reemplazaramos las ocurrencias de \(\alpha _{1}\) por \(\beta _{1}\) y despues las de \(\alpha _{2}\) por \(\beta _{2}\), el
resultado puede cambiar porque en \(\beta _{1}\) puede haber ocurrencias de \(\alpha _{2}\). Dejamos al lector
dar un ejemplo en el cual el reemplazo secuencial y el simultaneo dan distintos
resultados.
</p>
   <div class='newtheorem'>
<!-- l. 13627 --><p class='noindent'><span class='head'>
<a id='x1-165001r180'></a>
<span class='cmbx-10'>Lema 180.</span>  </span><span class='cmti-10'>Sean</span> \(r,s,t\in T^{\tau }\)<span class='cmti-10'>.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-165002x180'><span class='cmti-10'>Si</span> \(s\neq t=f(t_{1},...,t_{n})\) <span class='cmti-10'>y</span> \(s\) <span class='cmti-10'>ocurre en</span> \(t\)<span class='cmti-10'>, entonces dicha ocurrencia sucede dentro de algun</span> \(t_{j}\)<span class='cmti-10'>,</span> \(j=1,...,n\)<span class='cmti-10'>.</span>
     </li>
     <li class='enumerate' id='x1-165003x180'><span class='cmti-10'>Si</span> \(r,s\)<span class='cmti-10'> ocurren en</span> \(t\)<span class='cmti-10'>, entonces dichas ocurrencias son disjuntas o una ocurre
     </span><span class='cmti-10'>dentro  de  otra.  En  particular,  las  distintas  ocurrencias  de</span>  \(r\)  <span class='cmti-10'>en</span>  \(t\)  <span class='cmti-10'>son
     </span><span class='cmti-10'>disjuntas.</span>
     </li>
     <li class='enumerate' id='x1-165004x180'><span class='cmti-10'>Si</span> \(t^{\prime }\)<span class='cmti-10'> es el resultado de reemplazar una ocurrencia de</span> \(s\)<span class='cmti-10'> en</span> \(t\)<span class='cmti-10'> por</span> \(r\)<span class='cmti-10'>, entonces</span> \(t^{\prime }\in T^{\tau }\)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 13640 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 13641 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) Supongamos la ocurrencia de \(s\) comienza en algun \(t_{j}\). Entonces el Lema
<a href='#x1-164007r178'>178<!-- tex4ht:ref: superposicion  --></a> nos conduce a que dicha ocurrencia debera estar contenida en \(t_{j}\). Veamos que

la ocurrencia de \(s\) no puede ser a partir de un \(i\in \{1,...,\left \vert f\right \vert \}\). Supongamos lo contrario. Tenemos
entonces que \(s\) debe ser de la forma \(g(s_{1},...,s_{m})\) ya que no puede estar en \(Var\cup \mathcal{C}\). Notese que \(i\neq 1\) ya
que en caso contrario \(s\) seria un tramo inicial propio de \(t\). Pero entonces \(g\) debe ser
un tramo final propio de \(f\), lo cual es absurdo. Ya que \(s\) no puede comenzar con
parentesis o coma, hemos contemplado todos los posibles casos de comienzo de
la ocurrencia de \(s\) en \(t\).
</p><!-- l. 13653 --><p class='indent'>   (b) y (c) pueden probarse por induccion, usando (a).                            □
</p>
   </div>
<!-- l. 13658 --><p class='indent'>   <span class='cmbx-10'>Nota: </span>Es importante notar que si bien no hemos definido en forma presisa el
concepto de ocurrencia o de reemplazo de ocurrencias, la prueba del lema
anterior es rigurosa en el sentido de que solo usa propiedades del concepto de
ocurrencia y reemplazo de ocurrencias las cuales deberan ser comunes a
cualquier definicion o formulacion matematica que se hiciera de aquellos
conceptos. En este caso, es posible dar una defincion presisa y satisfactoria de
dichos conceptos aunque para otros conceptos tales como los de pruebas
absolutas de consistencia, aun no se ha encontrado una formulacion matematica
adecuada.
</p><!-- l. 13671 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>5.4   </span> <a id='x1-1660005.4'></a>Formulas</h4>
<!-- l. 13673 --><p class='noindent'>Sea \(\tau \) un tipo. Las palabras de alguna de las siguientes dos formas \[ \begin{array}{l} (t\equiv s),\;\text{con }t,s\in T^{\tau }\\ r(t_{1},...,t_{n})\text{, con }r\in \mathcal{R}_{n}\text{,}\ n\geq 1\text{ y }t_{1},...,t_{n}\in T^{\tau } \end{array} \] seran llamadas
<span class='cmti-10'>formulas atomicas de tipo</span> \(\tau \)<span class='cmti-10'>.</span>
</p><!-- l. 13683 --><p class='indent'>   Dado un tipo \(\tau \), definamos recursivamente los conjuntos de palabras \(F_{k}^{\tau }\), con \(k\geq 0\), de la
siguiente manera: \[ \begin{array}{ccl} F_{0}^{\tau } &amp; = &amp; \{\text{formulas atomicas}\}\\ F_{k+1}^{\tau } &amp; = &amp; F_{k}^{\tau }\cup \{\lnot \varphi :\varphi \in F_{k}^{\tau }\}\cup \{(\varphi \vee \psi ):\varphi ,\psi \in F_{k}^{\tau }\}\cup \\ &amp; &amp; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{(\varphi \wedge \psi ):\varphi ,\psi \in F_{k}^{\tau }\}\cup \{(\varphi \rightarrow \psi ):\varphi ,\psi \in F_{k}^{\tau }\}\cup \\ &amp; &amp; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{(\varphi \leftrightarrow \psi ):\varphi ,\psi \in F_{k}^{\tau }\}\cup \{\forall v\varphi :\varphi \in F_{k}^{\tau },v\in Var\}\cup \\ &amp; &amp; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\exists v\varphi :\varphi \in F_{k}^{\tau },v\in Var\} \end{array} \] Sea \[ F^{\tau }=\bigcup _{k\geq 0}F_{k}^{\tau } \] Los elementos de \(F^{\tau }\) seran llamados <span class='cmti-10'>formulas de tipo</span> \(\tau \). El
siguiente lema es la herramienta basica que usaremos para probar propiedades acerca
de los elementos de \(F^{\tau }\).
</p>
   <div class='newtheorem'>
<!-- l. 13701 --><p class='noindent'><span class='head'>
<a id='x1-166001r181'></a>
<span class='cmbx-10'>Lema 181.</span>  </span><span class='cmti-10'>Supongamos</span> \(\varphi \in F_{k}^{\tau }\)<span class='cmti-10'>, con</span> \(k\geq 1\)<span class='cmti-10'>. Entonces</span> \(\varphi \) <span class='cmti-10'>es de alguna de las siguientes formas</span>
</p><!-- l. 13705 --><p class='indent'>   \(\varphi =(t\equiv s),\) <span class='cmti-10'>con</span> \(t,s\in T^{\tau }\)<span class='cmti-10'>.</span>
</p><!-- l. 13707 --><p class='indent'>   \(\varphi =r(t_{1},...,t_{n}),\) <span class='cmti-10'>con</span> \(r\in \mathcal{R}_{n}\)<span class='cmti-10'>,</span> \(t_{1},...,t_{n}\in T^{\tau }\)<span class='cmti-10'> </span>
</p><!-- l. 13709 --><p class='indent'>   \(\varphi =(\varphi _{1}\eta \varphi _{2}),\) <span class='cmti-10'>con</span> \(\eta \in \{\wedge ,\vee ,\rightarrow ,\leftrightarrow \},\;\varphi _{1},\varphi _{2}\in F_{k-1}^{\tau }\)
</p><!-- l. 13711 --><p class='indent'>   \(\varphi =\lnot \varphi _{1},\) <span class='cmti-10'>con</span> \(\varphi _{1}\in F_{k-1}^{\tau }\)
</p><!-- l. 13713 --><p class='indent'>   \(\varphi =Qv\varphi _{1},\) <span class='cmti-10'>con</span> \(Q\in \{\forall ,\exists \},\;v\in Var\) <span class='cmti-10'>y</span> \(\varphi _{1}\in F_{k-1}^{\tau }.\)
</p>
   </div>

<!-- l. 13717 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 13718 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Induccion en \(k\).                                                                          □
</p>
   </div>
<!-- l. 13727 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>5.4.1   </span> <a id='x1-1670005.4.1'></a>Unicidad de la lectura de formulas</h5>
   <div class='newtheorem'>
<!-- l. 13728 --><p class='noindent'><span class='head'>
<a id='x1-167001r182'></a>
<span class='cmbx-10'>Lema 182.</span>  </span><span class='cmti-10'>Sea</span> \(\tau \) <span class='cmti-10'>un tipo.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-167002x182'><span class='cmti-10'>Supongamos que</span> \(\Sigma \) <span class='cmti-10'>es tal que</span> \(F^{\tau }\subseteq \Sigma ^{\ast }\)<span class='cmti-10'>. Entonces</span> \(del(\varphi )\in Bal\)<span class='cmti-10'>, para cada</span> \(\varphi \in F^{\tau }\)<span class='cmti-10'>.</span>
     </li>
     <li class='enumerate' id='x1-167003x182'><span class='cmti-10'>Sea</span> \(\varphi \in F_{k}^{\tau }\)<span class='cmti-10'>, con</span> \(k\geq 0\)<span class='cmti-10'>. Existen</span> \(x\in (\{\lnot \}\cup \{Qv:Q\in \{\forall ,\exists \}\) <span class='cmti-10'>y</span> \(v\in Var\})^{\ast }\) <span class='cmti-10'>y</span> \(\varphi _{1}\in F^{\tau }\) <span class='cmti-10'>tales que</span> \(\varphi =x\varphi _{1}\) <span class='cmti-10'>y</span> \(\varphi _{1}\) <span class='cmti-10'>es de la forma</span> \((\psi _{1}\eta \psi _{2})\) <span class='cmti-10'>o atomica. En
     </span><span class='cmti-10'>particular toda formula termina con el simbolo</span> \()\)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 13740 --><p class='noindent'>
</p>
   <div class='proof'>
<!-- l. 13741 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(b) Induccion en \(k\). El caso \(k=0\) es trivial. Supongamos (b) vale para cada \(\varphi \in F_{k}^{\tau }\) y
sea \(\varphi \in F_{k+1}^{\tau }\). Hay varios casos de los cuales haremos solo dos
</p><!-- l. 13745 --><p class='indent'>   CASO \(\varphi =(\psi _{1}\eta \psi _{2})\), con \(\psi _{1},\psi _{2}\in F_{k}^{\tau }\) y \(\eta \in \{\vee ,\wedge ,\rightarrow ,\leftrightarrow \}\).
</p><!-- l. 13748 --><p class='noindent'>Podemos tomar \(x=\varepsilon \) y \(\varphi _{1}=\varphi \).
</p><!-- l. 13750 --><p class='indent'>   CASO \(\varphi =Qx_{i}\psi \), con \(\psi \in F_{k}^{\tau }\), \(i\geq 1\) y \(Q\in \{\forall ,\exists \}\).
</p><!-- l. 13753 --><p class='noindent'>Por HI hay \(\bar{x}\in (\{\lnot \}\cup \{Qv:Q\in \{\forall ,\exists \}\) y \(v\in Var\})^{\ast }\) y \(\psi _{1}\in F^{\tau }\) tales que \(\psi =\bar{x}\psi _{1}\) y \(\psi _{1}\) es de la forma \((\gamma _{1}\eta \gamma _{2})\) o atomica. Entonces es claro que
\(x=Qx_{i}\bar{x}\) y \(\varphi _{1}=\psi _{1}\) cumplen (b).                                                                                □

</p>
   </div>
   <div class='newtheorem'>
<!-- l. 13761 --><p class='noindent'><span class='head'>
<a id='x1-167004r183'></a>
<span class='cmbx-10'>Lema 183.</span>  </span><span class='cmti-10'>Ninguna formula es tramo final propio de una formula atomica, es
</span><span class='cmti-10'>decir, si</span> \(\varphi =x\psi \)<span class='cmti-10'>, con</span> \(\varphi \in F_{0}^{\tau }\) <span class='cmti-10'>y</span> \(,\psi \in F^{\tau }\)<span class='cmti-10'>, entonces</span> \(x=\varepsilon \)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 13767 --><p class='noindent'>
</p>
   <div class='proof'>
<!-- l. 13768 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Si \(\varphi \) es de la forma \((t\equiv s)\), entonces \(\left \vert del(y)\right \vert _{(}-\left \vert del(y)\right \vert _{)}&lt;0\) para cada tramo final propio \(y\) de \(\varphi \), lo cual
termina el caso ya que \(del(\psi )\) es balanceada. Supongamos entonces \(\varphi =r(t_{1},...,t_{n})\). Notese que \(\psi \) no
puede ser tramo final de \(t_{1},...,t_{n})\) ya que \(del(\psi )\) es balanceada y \(\left \vert del(y)\right \vert _{(}-\left \vert del(y)\right \vert _{)}&lt;0\) para cada tramo final \(y\) de \(t_{1},...,t_{n})\).
Es decir que \(\psi =y(t_{1},...,t_{n})\), para algun tramo final \(y\) de \(r\). Ya que en \(\psi \) no ocurren cuantificadores
ni nexos ni el simbolo \(\equiv \) el Lema <a href='#x1-166001r181'>181<!-- tex4ht:ref: basic2  --></a> nos dice \(\psi =\tilde{r}(s_{1},...,s_{m})\), con \(\tilde{r}\in \mathcal{R}_{m}\)<span class='cmti-10'>,</span> \(m\geq 1\) y \(s_{1},...,s_{m}\in T^{\tau }\). Ahora es facil usando
un argumento paresido al usado en la prueba del Teorema <a href='#x1-164008r179'>179<!-- tex4ht:ref: le-un-de-te  --></a> concluir que \(m=n\), \(s_{i}=t_{i}\), \(i=1,...,n\)
y \(\tilde{r}\) es tramo final de \(r\). Por (3) de la definicion de tipo tenemos que \(\tilde{r}=r\) lo cual nos
dice que \(\varphi =\psi \) y \(x=\varepsilon \)                                                                                       □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 13785 --><p class='noindent'><span class='head'>
<a id='x1-167005r184'></a>
<span class='cmbx-10'>Lema 184.</span>  </span><span class='cmti-10'>Si</span> \(\varphi =x\psi \)<span class='cmti-10'>, con</span> \(\varphi ,\psi \in F^{\tau }\) <span class='cmti-10'>y</span> \(x\) <span class='cmti-10'>sin parentesis, entonces</span> \(x\in (\{\lnot \}\cup \{Qv:Q\in \{\forall ,\exists \}\) <span class='cmti-10'>y</span> \(v\in Var\})^{\ast }\)
</p>
   </div>
<!-- l. 13790 --><p class='noindent'>
</p>
   <div class='proof'>
<!-- l. 13791 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Por induccion en el \(k\) tal que \(\varphi \in F_{k}^{\tau }\). El caso \(k=0\) es probado en el lema anterior.
Asumamos que el resultado vale cuando \(\varphi \in F_{k}^{\tau }\) y veamos que vale cuando \(\varphi \in F_{k+1}^{\tau }\). Mas aun
supongamos \(\varphi \in F_{k+1}^{\tau }-F_{k}^{\tau }\). Primero haremos el caso en que \(\varphi =Qv\varphi _{1},\) con \(Q\in \{\forall ,\exists \},\;v\in Var\) y \(\varphi _{1}\in F_{k}^{\tau }\). Supongamos \(x\neq \varepsilon \). Ya que \(\psi \)
no comienza con simbolos de \(v\), tenemos que \(\psi \) debe ser tramo final de \(\varphi _{1}\) lo cual nos
dice que hay una palabra \(x_{1}\) tal que \(x=Qvx_{1}\) y \(\varphi _{1}=x_{1}\psi \). Por HI tenemos que \(x_{1}\in (\{\lnot \}\cup \{Qv:Q\in \{\forall ,\exists \}\) y \(v\in Var\})^{\ast }\) con lo cual \(x\in (\{\lnot \}\cup \{Qv:Q\in \{\forall ,\exists \}\) y \(v\in Var\})^{\ast }\).
El caso en el que \(\varphi =\lnot \varphi _{1}\) con \(\varphi _{1}\in F_{k}^{\tau }\), es similar. Note que no hay mas casos posibles ya que \(\varphi \)
no puede comenzar con \((\) porque en \(x\) no ocurren parentesis por hipotesis        □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 13809 --><p class='noindent'><span class='head'>
<a id='x1-167006r185'></a>
<span class='cmbx-10'>Proposition 185.</span>  </span><span class='cmti-10'>Si</span> \(\varphi ,\psi \in F^{\tau }\)<span class='cmti-10'> y</span> \(x,y,z\)<span class='cmti-10'> son tales que</span> \(\varphi =xy,\)<span class='cmti-10'> </span>\(\psi =yz\)<span class='cmti-10'> y</span> \(y\neq \varepsilon ,\)<span class='cmti-10'> entonces</span> \(z=\varepsilon \)<span class='cmti-10'> y</span> \(x\in (\{\lnot \}\cup \{Qv:Q\in \{\forall ,\exists \}\) <span class='cmti-10'>y</span> \(v\in Var\})^{\ast }\)<span class='cmti-10'>. En particular
</span><span class='cmti-10'>ningun tramo inicial propio de una formula es una formula.</span>
</p>
   </div>
<!-- l. 13817 --><p class='noindent'>
</p>
   <div class='proof'>
<!-- l. 13818 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que \(\varphi \) termina con \()\) tenemos que \(del(y)\neq \varepsilon .\) Por un lema anterior tenemos que \(del(\varphi ),del(\psi )\in Bal\).
Ademas </p><div class='eqnarray'>\begin{eqnarray*} del(\varphi ) &amp; = &amp; del(x)del(y)\\ del(\psi ) &amp; = &amp; del(y)del(z) \end{eqnarray*}
</div>La primera igualdad, por (1) y (3) del Lema <a href='#x1-164001r175'>175<!-- tex4ht:ref: basicas de balanceadas  --></a>, nos dice que \[ \left \vert del(y)\right \vert _{(}-\left \vert del(y)\right \vert _{)}\leq 0, \] y la segunda que
\[ \left \vert del(y)\right \vert _{(}-\left \vert del(y)\right \vert _{)}\geq 0, \] por lo cual \[ \left \vert del(y)\right \vert _{(}-\left \vert del(y)\right \vert _{)}=0 \] Pero entonces (3) del Lema <a href='#x1-164001r175'>175<!-- tex4ht:ref: basicas de balanceadas  --></a> nos dice que \(del(y)\) no puede ser
tramo final propio de \(del(\varphi )\), por lo cual debe suceder que \(del(y)=del(\varphi )\), ya que \(del(y)\neq \varepsilon \). Claramente
entonces obtenemos que \(del(x)=\varepsilon \). Similarmente se puede ver que \(del(z)=\varepsilon \). Pero \(\psi \) termina con \()\)
lo cual nos dice que \(z=\varepsilon \). Es decir que \(\varphi =x\psi \). Por el lema anterior tenemos que \(x\in (\{\lnot \}\cup \{Qv:Q\in \{\forall ,\exists \}\) y
\(v\in Var\})^{\ast }\)                                                                 □
   </div>
   <div class='newtheorem'>
<!-- l. 13849 --><p class='noindent'><span class='head'>
<a id='x1-167007r186'></a>
<span class='cmbx-10'>Teorema 186.</span>  </span><span class='cmti-10'>(Lectura unica de formulas) Dada</span> \(\varphi \in F^{\tau }\)<span class='cmti-10'> se da una y solo una de las
</span><span class='cmti-10'>siguientes:</span>

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-167008x186'>\(\varphi =(t\equiv s),\) <span class='cmti-10'>con</span> \(t,s\in T^{\tau }\)
     </li>
     <li class='enumerate' id='x1-167009x186'>\(\varphi =r(t_{1},...,t_{n}),\) <span class='cmti-10'>con</span> \(r\in \mathcal{R}_{n}\)<span class='cmti-10'>,</span> \(t_{1},...,t_{n}\in T^{\tau }\)
     </li>
     <li class='enumerate' id='x1-167010x186'>\(\varphi =(\varphi _{1}\eta \varphi _{2}),\) <span class='cmti-10'>con</span> \(\eta \in \{\wedge ,\vee ,\rightarrow ,\leftrightarrow \},\;\varphi _{1},\varphi _{2}\in F^{\tau }\)
     </li>
     <li class='enumerate' id='x1-167011x186'>\(\varphi =\lnot \varphi _{1},\) <span class='cmti-10'>con</span> \(\varphi _{1}\in F^{\tau }\)
     </li>
     <li class='enumerate' id='x1-167012x186'>\(\varphi =Qv\varphi _{1},\) <span class='cmti-10'>con</span> \(Q\in \{\forall ,\exists \},\;\varphi _{1}\in F^{\tau }\) <span class='cmti-10'>y</span> \(v\in Var.\)</li></ol>
<!-- l. 13860 --><p class='noindent'><span class='cmti-10'>Mas aun, en los puntos (1), (2), (3), (4) y (5) tales descomposiciones son unicas.</span>
</p>
   </div>
<!-- l. 13864 --><p class='noindent'>
</p>
   <div class='proof'>
<!-- l. 13865 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Si una formula \(\varphi \) satisface (1), entonces \(\varphi \) no puede contener simbolos del
alfabeto \(\{\wedge ,\vee ,\rightarrow ,\leftrightarrow \}\) lo cual garantiza que \(\varphi \) no puede satisfacer (3). Ademas \(\varphi \) no puede
satisfacer (2) o (4) o (5) ya que \(\varphi \) comienza con \((\). En forma analoga se puede
terminar de ver que las propiedades (1),...,(5) son excluyentes.
</p><!-- l. 13872 --><p class='indent'>   La unicidad en las descomposiciones de (4) y (5) es obvia. La de (3) se
desprende facilmente del lema anterior y la de los puntos (1) y (2) del lema
analogo para terminos.                                                                        □
</p>
   </div>
<!-- l. 13881 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>5.4.2   </span> <a id='x1-1680005.4.2'></a>Subformulas</h5>
<!-- l. 13883 --><p class='noindent'>Una formula \(\varphi \) sera llamada una <span class='cmti-10'>subformula </span>(<span class='cmti-10'>propia</span>)<span class='cmti-10'> </span>de una formula \(\psi \), cuando \(\varphi \) (sea
no igual a \(\psi \) y) tenga alguna ocurrencia en \(\psi .\)
</p>
   <div class='newtheorem'>
<!-- l. 13886 --><p class='noindent'><span class='head'>
<a id='x1-168001r187'></a>

<span class='cmbx-10'>Lema 187.</span>  </span><span class='cmti-10'>Sea</span> \(\tau \) <span class='cmti-10'>un tipo.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-168002x187'><span class='cmti-10'>Las formulas atomicas no tienen subformulas propias.</span>
     </li>
     <li class='enumerate' id='x1-168003x187'><span class='cmti-10'>Si</span> \(\varphi \)<span class='cmti-10'> ocurre propiamente en</span> \((\psi \eta \gamma ),\)<span class='cmti-10'> entonces tal ocurrencia es en</span> \(\psi \)<span class='cmti-10'> o en</span> \(\gamma .\)
     </li>
     <li class='enumerate' id='x1-168004x187'><span class='cmti-10'>Si</span> \(\varphi \)<span class='cmti-10'> ocurre propiamente en</span> \(\lnot \psi \)<span class='cmti-10'>, entonces tal ocurrencia es en</span> \(\psi .\)
     </li>
     <li class='enumerate' id='x1-168005x187'><span class='cmti-10'>Si</span> \(\varphi \)<span class='cmti-10'> ocurre propiamente en</span> \(Qx_{k}\psi ,\)<span class='cmti-10'> entonces tal ocurrencia es en</span> \(\psi .\)
     </li>
     <li class='enumerate' id='x1-168006x187'><span class='cmti-10'>Si</span> \(\varphi _{1},\varphi _{2}\)<span class='cmti-10'> ocurren en</span> \(\varphi ,\)<span class='cmti-10'> entonces dichas ocurrencias son disjuntas o una contiene
     </span><span class='cmti-10'>a la otra.</span>
     </li>
     <li class='enumerate' id='x1-168007x187'><span class='cmti-10'>Si</span> \(\lambda ^{\prime }\)<span class='cmti-10'> es el resultado de reemplazar alguna ocurrencia de</span> \(\varphi \)<span class='cmti-10'> en</span> \(\lambda \)<span class='cmti-10'> por</span> \(\psi \)<span class='cmti-10'>, entonces</span>
     \(\lambda ^{\prime }\in F^{\tau }\)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 13903 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 13904 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ejercicio.                                                                                □
</p>
   </div>
<!-- l. 13916 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>5.5   </span> <a id='x1-1690005.5'></a>Variables libres</h4>
<!-- l. 13918 --><p class='noindent'>Definamos recursivamente la relacion \("v\mathit{\ ocurre\ libremente\ en\ }\varphi \mathit{\ a\ partir\ de\ }i"\), donde \(v\in Var\), \(\varphi \in F^{\tau }\) y \(i\in \{1,...,\left \vert \varphi \right \vert \}\), de la siguiente manera:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-169001x5.5'>Si \(\varphi \) es atomica, entonces \(v\) ocurre libremente en \(\varphi \) a partir de \(i\) sii \(v\) ocurre en \(\varphi \)
     a partir de \(i\)
     </li>
     <li class='enumerate' id='x1-169002x5.5'>Si \(\varphi =(\varphi _{1}\eta \varphi _{2})\), entonces \(v\) ocurre libremente en \(\varphi \) a partir de \(i\) sii se da alguna de las
     siguientes

         <ol class='enumerate2'>
         <li class='enumerate' id='x1-169003x5.5'>\(v\) ocurre libremente en \(\varphi _{1}\) a partir de \(i-1\)
         </li>
         <li class='enumerate' id='x1-169004x5.5'>\(v\) ocurre libremente en \(\varphi _{2}\) a partir de \(i-\left \vert (\varphi _{1}\eta \right \vert \)</li></ol>
     </li>
     <li class='enumerate' id='x1-169005x5.5'>Si \(\varphi =\lnot \varphi _{1}\), entonces \(v\) ocurre libremente en \(\varphi \) a partir de \(i\) sii \(v\) ocurre libremente en \(\varphi _{1}\) a
     partir de \(i-1\)
     </li>
     <li class='enumerate' id='x1-169006x5.5'>Si \(\varphi =Qw\varphi _{1}\), entonces \(v\) ocurre libremente en \(\varphi \) a partir de \(i\) sii \(v\neq w\) y \(v\) ocurre libremente en \(\varphi _{1}\) a
     partir de \(i-\left \vert Qw\right \vert \)</li></ol>
<!-- l. 13938 --><p class='noindent'>Dados \(v\in Var\), \(\varphi \in F^{\tau }\) y \(i\in \{1,...,\left \vert \varphi \right \vert \}\), diremos que \("v\) <span class='cmti-10'>ocurre acotadamente en</span> \(\varphi \) <span class='cmti-10'>a partir de</span> \(i"\) cuando \(v\) ocurre en \(\varphi \) a
partir de \(i\) y \(v\) no ocurre libremente en \(\varphi \) a partir de \(i\).
</p><!-- l. 13943 --><p class='indent'>   Dada una formula \(\varphi \), sea
</p><!-- l. 13947 --><p class='indent'>   \[ Li(\varphi )=\{v\in Var:\text{hay un }i\text{ tal que }v\text{ ocurre libremente en }\varphi \text{ a partir de }i\}\text{.} \] Los elementos de \(Li(\varphi )\) seran llamados <span class='cmti-10'>variables libres de</span> \(\varphi \). Una <span class='cmti-10'>sentencia </span>sera una
formula \(\varphi \) tal que \(Li(\varphi )=\emptyset \). Usaremos \(S^{\tau }\) para denotar el conjunto de las sentencias de tipo
\(\tau \).
</p><!-- l. 13955 --><p class='indent'>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-169007x5.5'>\(Li((t\equiv s))=\{v\in Var:v\) ocurre en \(t\) o \(v\) ocurre en \(s\}.\)
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-169008x5.5'>\(Li(r(t_{1},...,t_{n}))=\{v\in Var:v\) ocurre en algun \(t_{i}\}.\)
         </li>
         <li class='enumerate' id='x1-169009x5.5'>\(Li(\lnot \varphi )=Li(\varphi )\)
         </li>
         <li class='enumerate' id='x1-169010x5.5'>\(Li((\varphi \eta \psi ))=Li(\varphi )\cup Li(\psi ).\)
         </li>
         <li class='enumerate' id='x1-169011x5.5'>\(Li(Qx_{j}\varphi )=Li(\varphi )-\{x_{j}\}.\)</li></ol>
     </li></ol>
<!-- l. 13964 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 13965 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a) y (b) son triviales de las definiciones y dejadas al lector
</p><!-- l. 13967 --><p class='indent'>   (d) Supongamos \(v\in Li((\varphi \eta \psi ))\), entonces hay un \(i\) tal que \(v\) ocurre libremente en \((\varphi \eta \psi )\) a partir
de \(i\). Por definicion tenemos que ya sea \(v\) ocurre libremente en \(\varphi \) a partir de \(i-1\) o \(v\)
ocurre libremente en \(\psi \) a partir de \(i-\left \vert (\varphi \eta \right \vert \), con lo cual \(v\in Li(\varphi )\cup Li(\psi )\)

</p><!-- l. 13974 --><p class='indent'>   Supongamos ahora que \(v\in Li(\varphi )\cup Li(\psi )\). S.p.d.g. supongamos \(v\in Li(\psi )\). Por definicion tenemos que
hay un \(i\) tal que \(v\) ocurre libremente en \(\psi \) a partir de \(i\). Pero notese que esto nos
dice por definicion que \(v\) ocurre libremente en \((\varphi \eta \psi )\) a partir de \(i+\left \vert (\varphi \eta \right \vert \) con lo cual \(v\in Li((\varphi \eta \psi ))\).
</p><!-- l. 13980 --><p class='indent'>   (c) es similar a (d)
</p><!-- l. 13982 --><p class='indent'>   (e) Supongamos \(v\in Li(Qx_{j}\varphi )\), entonces hay un \(i\) tal que \(v\) ocurre libremente en \(Qx_{j}\varphi \) a partir
de \(i\). Por definicion tenemos que \(v\neq x_{j}\) y \(v\) ocurre libremente en \(\varphi \) a partir de \(i-\left \vert Qx_{j}\right \vert \), con lo
cual \(v\in Li(\varphi )-\{x_{j}\}\)
</p><!-- l. 13988 --><p class='indent'>   Supongamos ahora que \(v\in Li(\varphi )-\{x_{j}\}\). Por definicion tenemos que hay un \(i\) tal que \(v\) ocurre
libremente en \(\varphi \) a partir de \(i\). Ya que \(v\neq x_{j}\) esto nos dice por definicion que \(v\) ocurre
libremente en \(Qx_{j}\varphi \) a partir de \(i+\left \vert Qx_{j}\right \vert \), con lo cual \(v\in Li(Qx_{j}\varphi )\).                                                 □
</p>
   </div>
<!-- l. 13996 --><p class='noindent'>@@finpagina@@
</p><!-- l. 13998 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>6   </span> <a id='x1-1700006'></a>Semantica de la logica de primer orden</h3>
<!-- l. 14000 --><p class='noindent'>A continuación introduciremos de manera intuitiva el valor de verdad de una
fórmula. Para poder darle sentido a una fórmula debemos tener un conjunto \(A\),
llamado universo, sobre el cual tomarán posibles valores las variables. De esta forma
interpretaremos que un cuantificador \(\forall x_{i}\) se está refiriendo a que la propiedad que
sigue se cumple para todos los posibles valores de \(x_{i}\) en \(A\). Y un cuantificador
\(\exists x_{i}\) se estará refiriendo a que al menos para un valor de \(x_{i}\) en \(A\) la propiedad
que sigue a dicho cuantificador vale. En lo que se refiere a las variables que
ocurren libremente en la fórmula, notese que para que la fórmula sea
verdadera o falsa deberemos haber asignado valores concretos del conjunto \(A\) a
cada una de las variables libres. Por otra parte también para darle sentido
a una fórmula deberemos tener asociado a cada nombre de función de \(\mathcal{F}_{n}\)
una operacion \(n\)-aria sobre \(A\), a cada nombre de relación \(r\in \mathcal{R}_{n}\) una relación \(n\)-aria
sobre \(A\) y a cada nombre de constante un elemento concreto del conjunto
\(A\).
</p><!-- l. 14017 --><p class='indent'>   Por ejemplo consideremos el tipo \(\tau _{1}=(\{0,1\},\{+,.\},\emptyset ,\{(+,2),(.,2)\})\) y fijemos como universo el conjunto \(\omega \). Además
interpretemos el nombre de función \(+\) como la función suma sobre \(\omega \), interpretemos el
nombre de función . cómo la funcion producto sobre \(\omega \) y a los nombres de
constante 0 y 1 como los números 0 y 1 respectivamente. Entonces la formula \(\exists x_{5}((x_{2}\equiv \mathrm{.}(x_{5},x_{3}))\)
sera verdadera si el valor asignado a \(x_{2}\) es divisible por el valor asignado a
\(x_{3}\).
</p><!-- l. 14026 --><p class='indent'>   En esta seccion definiremos en forma matematica como interpretar las
formulas y terminos de un tipo dado. Si bien las nociones que daremos se
corresponderan con la idea intuitiva antes descripta, cabe destacar que nuestras
definiciones seran rigurosas y precisas como las de cualquier tema clasico de la
matematica.

</p><!-- l. 14035 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>6.1   </span> <a id='x1-1710006.1'></a>Estructuras de tipo \(\tau \)</h4>
<!-- l. 14037 --><p class='noindent'>Sea \(A\) un conjunto y sea \(n\in \mathbf{N}\). Por una <span class='cmti-10'>operacion</span> \(n\)<span class='cmti-10'>-aria sobre</span> \(A\) entenderemos una funcion
cuyo dominio es \(A^{n}\) y cuya imagen esta contenida en \(A.\) Por una <span class='cmti-10'>relacion</span> \(n\)<span class='cmti-10'>-aria sobre</span> \(A\)
entenderemos un subconjunto de \(A^{n}\).
</p><!-- l. 14042 --><p class='indent'>   Sea \(\tau \) un tipo. Una <span class='cmti-10'>estructura o modelo de tipo</span> \(\tau \) sera un par \(\mathbf{A}=(A,i)\) tal que:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-171001x6.1'>\(A\) es un conjunto no vacio llamado el <span class='cmti-10'>universo </span>de \(\mathbf{A}\).
     </li>
     <li class='enumerate' id='x1-171002x6.1'>\(i\) es una funcion con dominio \(\mathcal{C}\cup \mathcal{F}\cup \mathcal{R},\) tal que:
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-171003x6.1'>para cada \(c\in \mathcal{C}\), \(i(c)\) es un elemento de \(A\)
         </li>
         <li class='enumerate' id='x1-171004x6.1'>para cada \(f\in \mathcal{F}\), \(i(f)\) es una operacion \(n\)-aria sobre \(A\)
         </li>
         <li class='enumerate' id='x1-171005x6.1'>para cada \(r\in \mathcal{R}_{n}\), \(i(r)\) es una relacion \(n\)-aria sobre \(A.\)</li></ol>
     </li></ol>
<!-- l. 14059 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>6.1.1   </span> <a id='x1-1720006.1.1'></a>El valor de un termino en una estructura</h5>
<!-- l. 14061 --><p class='noindent'>Sea \(\mathbf{A}=(A,i)\) una estructura de tipo \(\tau \). Una <span class='cmti-10'>asignacion de</span> \(\mathbf{A}\)<span class='cmti-10'> </span>sera un elemento de \(A^{\mathbf{N}}=\{\)infinituplas de
elementos de \(A\}\). Si \(\vec{a}=(a_{1},a_{2},...)\) es una asignacion, entonces diremos que \(a_{j}\) <span class='cmti-10'>es el valor que</span> \(\vec{a}\)<span class='cmti-10'> le asigna
</span><span class='cmti-10'>a la variable</span> \(x_{j}\).
</p><!-- l. 14067 --><p class='indent'>   Dada una estructura \(\mathbf{A}\) de tipo \(\tau \), un termino \(t\in T^{\tau }\) y una asignacion \(\vec{a}=(a_{1},a_{2},...)\in A^{\mathbf{N}}\) definamos
recursivamente \(t^{\mathbf{A}}[\vec{a}]\) de la siguiente manera
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-172001x6.1.1'>Si \(t=x_{i}\in Var\), entonces \(t^{\mathbf{A}}[\vec{a}]=a_{i}\)
     </li>
     <li class='enumerate' id='x1-172002x6.1.1'>Si \(t=c\in \mathcal{C}\), entonces \(t^{\mathbf{A}}[\vec{a}]=i(c)\)
     </li>
     <li class='enumerate' id='x1-172003x6.1.1'>Si \(t=f(t_{1},...,t_{n})\), con \(f\in \mathcal{F}_{n},\;n\geq 1\) y \(t_{1},...,t_{n}\in T^{\tau }\), entonces \(t^{\mathbf{A}}[\vec{a}]=i(f)(t_{1}^{\mathbf{A}}[\vec{a}],...,t_{n}^{\mathbf{A}}[\vec{a}])\)</li></ol>

<!-- l. 14076 --><p class='noindent'>El elemento \(t^{\mathbf{A}}[\vec{a}]\) sera llamado el <span class='cmti-10'>valor de</span> \(t\)<span class='cmti-10'> en la estructura</span> \(\mathbf{A}\)<span class='cmti-10'> para la asignacion</span>
\(\vec{a}\).
</p>
   <div class='newtheorem'>
<!-- l. 14082 --><p class='noindent'><span class='head'>
<a id='x1-172004r188'></a>
<span class='cmbx-10'>Lema 188.</span>  </span><span class='cmti-10'>Sea</span>  \(\mathbf{A}\)  <span class='cmti-10'>una  estructura  de  tipo</span>  \(\tau \)  <span class='cmti-10'>y  sea</span>  \(t\in T^{\tau }\)<span class='cmti-10'>.  Supongamos  que</span>  \(\vec{a},\vec{b}\)  <span class='cmti-10'>son
</span><span class='cmti-10'>asignaciones tales que</span> \(a_{i}=b_{i},\) <span class='cmti-10'>cada vez que</span> \(x_{i}\) <span class='cmti-10'>ocurra en</span> \(t\)<span class='cmti-10'>. Entonces</span> \(t^{\mathbf{A}}[\vec{a}]=t^{\mathbf{A}}[\vec{b}]\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 14089 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14090 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-172005x6.1.1'>Teo\(_{k}\): El lema vale para \(t\in T_{k}^{\tau }\).</li></ol>
<!-- l. 14094 --><p class='noindent'>Teo\(_{0}\) es facil de probar. Veamos Teo\(_{k}\Rightarrow \)Teo\(_{k+1}\). Supongamos \(t\in T_{k+1}^{\tau }-T_{k}^{\tau }\) y sean \(\vec{a},\vec{b}\) asignaciones tales que \(a_{i}=b_{i}\),
cada vez que \(x_{i}\) ocurra en \(t\). Notese que \(t=f(t_{1},...,t_{n})\), con \(f\in \mathcal{F}_{n}\),\(\;n\geq 1\) y \(t_{1},...,t_{n}\in T_{k}^{\tau }\). Notese que para cada \(j=1,...,n\), tenemos que \(a_{i}=b_{i},\)
cada vez que \(x_{i}\) ocurra en \(t_{j}\), lo cual por Teo\(_{k}\) nos dice que \[ t_{j}^{\mathbf{A}}[\vec{a}]=t_{j}^{\mathbf{A}}[\vec{b}]\text{, }j=1,...,n \] Se tiene entonces que \[ \begin{array}{ccl} t^{\mathbf{A}}[\vec{a}] &amp; = &amp; i(f)(t_{1}^{\mathbf{A}}[\vec{a}],...,t_{n}^{\mathbf{A}}[\vec{a}])\text{ (por def de }t^{\mathbf{A}}[\vec{a}]\text{)}\\ &amp; = &amp; i(f)(t_{1}^{\mathbf{A}}[\vec{b}],...,t_{n}^{\mathbf{A}}[\vec{b}])\\ &amp; = &amp; t^{\mathbf{A}}[\vec{b}]\text{ (por def de }t^{\mathbf{A}}[\vec{b}]\text{)} \end{array} \]
                                                                                                     □
</p>
   </div>
<!-- l. 14121 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>6.1.2   </span> <a id='x1-1730006.1.2'></a>El valor de verdad de una formula en una estructura</h5>
<!-- l. 14123 --><p class='noindent'>Dada una asignacion \(\vec{a}\in A^{\mathbf{N}}\) y \(a\in A\), con \(\downarrow _{i}^{a}(\vec{a})\) denotaremos la asignacion que resulta de reemplazar
en \(\vec{a}\) el \(i\)-esimo elemento por \(a\). A continuacion definiremos recursivamente la relacion \(\mathbf{A}\models \varphi [\vec{a}]\),
donde \(\mathbf{A}\) es una estructura de tipo \(\tau \), \(\vec{a}\) es una asignacion y \(\varphi \in F^{\tau }\). Escribiremos \(\mathbf{A}\not \models \varphi [\vec{a}]\) para expresar
que no se da \(\mathbf{A}\models \varphi [\vec{a}]\).
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-173001x6.1.2'>Si \(\varphi =(t\equiv s),\) entonces

         <ol class='enumerate2'>
         <li class='enumerate' id='x1-173002x6.1.2'>\(\mathbf{A}\models \varphi [\vec{a}]\) si y solo si \(t^{A}[\vec{a}]=s^{A}[\vec{a}]\)</li></ol>
     </li>
     <li class='enumerate' id='x1-173003x6.1.2'>Si \(\varphi =r(t_{1},...,t_{m})\), entonces
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-173004x6.1.2'>\(\mathbf{A}\models \varphi [\vec{a}]\) si y solo si \((t_{1}^{A}[\vec{a}],...,t_{m}^{A}[\vec{a}])\in i(r)\)</li></ol>
     </li>
     <li class='enumerate' id='x1-173005x6.1.2'>Si \(\varphi =(\varphi _{1}\wedge \varphi _{2})\), entonces
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-173006x6.1.2'>\(\mathbf{A}\models \varphi [\vec{a}]\) si y solo si \(\mathbf{A}\models \varphi _{1}[\vec{a}]\) y \(\mathbf{A}\models \varphi _{2}[\vec{a}]\)</li></ol>
     </li>
     <li class='enumerate' id='x1-173007x6.1.2'>Si \(\varphi =(\varphi _{1}\vee \varphi _{2})\), entonces
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-173008x6.1.2'>\(\mathbf{A}\models \varphi [\vec{a}]\) si y solo si \(\mathbf{A}\models \varphi _{1}[\vec{a}]\) o \(\mathbf{A}\models \varphi _{2}[\vec{a}]\)</li></ol>
     </li>
     <li class='enumerate' id='x1-173009x6.1.2'>Si \(\varphi =(\varphi _{1}\rightarrow \varphi _{2})\), entonces
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-173010x6.1.2'>\(\mathbf{A}\models \varphi [\vec{a}]\) si y solo si \(\mathbf{A}\models \varphi _{2}[\vec{a}]\) o \(\mathbf{A}\not \models \varphi _{1}[\vec{a}]\)</li></ol>
     </li>
     <li class='enumerate' id='x1-173011x6.1.2'>Si \(\varphi =(\varphi _{1}\leftrightarrow \varphi _{2})\), entonces
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-173012x6.1.2'>\(\mathbf{A}\models \varphi [\vec{a}]\) si y solo si ya sea se dan \(\mathbf{A}\models \varphi _{1}[\vec{a}]\) y \(\mathbf{A}\models \varphi _{2}[\vec{a}]\) o se dan \(\mathbf{A}\not \models \varphi _{1}[\vec{a}]\) y \(\mathbf{A}\not \models \varphi _{2}[\vec{a}]\)</li></ol>
     </li>
     <li class='enumerate' id='x1-173013x6.1.2'>Si \(\varphi =\lnot \varphi _{1},\) entonces
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-173014x6.1.2'>\(\mathbf{A}\models \varphi [\vec{a}]\) si y solo si \(\mathbf{A}\not \models \varphi _{1}[\vec{a}]\)</li></ol>
     </li>
     <li class='enumerate' id='x1-173015x6.1.2'>Si \(\varphi =\forall x_{i}\varphi _{1}\), entonces
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-173016x6.1.2'>\(\mathbf{A}\models \varphi [\vec{a}]\) si y solo si para cada \(a\in A\), se da que \(\mathbf{A}\models \varphi _{1}[\downarrow _{i}^{a}(\vec{a})]\)</li></ol>
     </li>
     <li class='enumerate' id='x1-173017x6.1.2'>Si \(\varphi =\exists x_{i}\varphi _{1}\), entonces
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-173018x6.1.2'>\(\mathbf{A}\models \varphi [\vec{a}]\) si y solo si hay un \(a\in A\) tal que \(\mathbf{A}\models \varphi _{1}[\downarrow _{i}^{a}(\vec{a})]\)</li></ol>
     </li></ol>

<!-- l. 14175 --><p class='noindent'>Cuando se de \(\mathbf{A}\models \varphi [\vec{a}]\) diremos que <span class='cmti-10'>la estructura</span> \(\mathbf{A}\)<span class='cmti-10'> satisface</span> \(\varphi \) <span class='cmti-10'>en la asignacion</span> \(\vec{a}\) y en tal
caso diremos que \(\varphi \) <span class='cmti-10'>es verdadera en</span> \(\mathbf{A}\)<span class='cmti-10'> para la asignacion</span> \(\vec{a}\). Cuando no se de \(\mathbf{A}\models \varphi [\vec{a}]\)
diremos que <span class='cmti-10'>la estructura</span> \(\mathbf{A}\)<span class='cmti-10'> no satisface</span> \(\varphi \) <span class='cmti-10'>en la asignacion</span> \(\vec{a}\) y en tal caso
diremos que \(\varphi \) <span class='cmti-10'>es falsa en</span> \(\mathbf{A}\)<span class='cmti-10'> para la asignacion</span> \(\vec{a}\). Tambien hablaremos del <span class='cmti-10'>valor de
</span><span class='cmti-10'>verdad de</span> \(\varphi \)<span class='cmti-10'> en</span> \(\mathbf{A}\)<span class='cmti-10'> para la asignacion</span> \(\vec{a}\) el cual sera igual a \(1\) si se da \(\mathbf{A}\models \varphi [\vec{a}]\) y \(0\) en caso
contrario.
</p>
   <div class='newtheorem'>
<!-- l. 14190 --><p class='noindent'><span class='head'>
<a id='x1-173019r189'></a>
<span class='cmbx-10'>Lema 189.</span>  </span><span class='cmti-10'>Supongamos que</span> \(\vec{a},\vec{b}\) <span class='cmti-10'>son asignaciones tales que si</span> \(x_{i}\in Li(\varphi ),\) <span class='cmti-10'>entonces</span> \(a_{i}=b_{i}.\) <span class='cmti-10'>Entonces</span>
\(\mathbf{A}\models \varphi [\vec{a}]\) <span class='cmti-10'>sii</span> \(\mathbf{A}\models \varphi [\vec{b}]\)
</p>
   </div>
<!-- l. 14196 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14197 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Probaremos por induccion en \(k\) que el lema vale para cada \(\varphi \in F_{k}^{\tau }\). El caso \(k=0\) se
desprende del Lema <a href='#x1-172004r188'>188<!-- tex4ht:ref: independencia del valor  --></a>. Veamos que Teo\(_{k}\) implica Teo\(_{k+1}.\) Sea \(\varphi \in F_{k+1}^{\tau }-F_{k}^{\tau }.\) Hay varios casos:
</p><!-- l. 14202 --><p class='indent'>   CASO \(\varphi =(\varphi _{1}\wedge \varphi _{2})\).
</p><!-- l. 14204 --><p class='noindent'>Ya que \(Li(\varphi _{i})\subseteq Li(\varphi )\), \(i=1,2\), Teo\(_{k}\) nos dice que \(\mathbf{A}\models \varphi _{i}[\vec{a}]\) sii \(\mathbf{A}\models \varphi _{i}[\vec{b}]\), para \(i=1,2\). Se tiene entonces que \[ \begin{array}{l} \mathbf{A}\models \varphi [\vec{a}]\\ \ \ \Updownarrow \text{ (por (3) en la def de }\mathbf{A}\models \varphi [\vec{a}]\text{)}\\ \mathbf{A}\models \varphi _{1}[\vec{a}]\text{ y }\mathbf{A}\models \varphi _{2}[\vec{a}]\\ \ \ \Updownarrow \text{ (por Teo}_{k}\text{)}\\ \mathbf{A}\models \varphi _{1}[\vec{b}]\text{ y }\mathbf{A}\models \varphi _{2}[\vec{b}]\\ \ \ \Updownarrow \text{(por (3) en la def de }\mathbf{A}\models \varphi [\vec{a}]\text{)}\\ \mathbf{A}\models \varphi [\vec{b}] \end{array} \]
</p><!-- l. 14220 --><p class='indent'>   CASO \(\varphi =(\varphi _{1}\vee \varphi _{2})\).
</p><!-- l. 14222 --><p class='noindent'>Es completamente similar al anterior.
</p><!-- l. 14224 --><p class='indent'>   CASO \(\varphi =(\varphi _{1}\rightarrow \varphi _{2})\).
</p><!-- l. 14226 --><p class='noindent'>Es completamente similar al anterior.
</p><!-- l. 14228 --><p class='indent'>   CASO \(\varphi =(\varphi _{1}\leftrightarrow \varphi _{2})\).
</p><!-- l. 14230 --><p class='noindent'>Es completamente similar al anterior.
</p><!-- l. 14232 --><p class='indent'>   CASO \(\varphi =\lnot \varphi _{1}.\)
</p><!-- l. 14234 --><p class='noindent'>Es completamente similar al anterior.
</p><!-- l. 14236 --><p class='indent'>   CASO \(\varphi =\forall x_{j}\varphi _{1}.\)
</p><!-- l. 14238 --><p class='noindent'>Supongamos \(\mathbf{A}\models \varphi [\vec{a}]\). Entonces por (8) en la def de \(\mathbf{A}\models \varphi [\vec{a}]\) se tiene que \(\mathbf{A}\models \varphi _{1}[\downarrow _{j}^{a}(\vec{a})]\), para todo \(a\in A\). Notese
que \(\downarrow _{j}^{a}(\vec{a})\) y \(\downarrow _{j}^{a}(\vec{b})\) coinciden en toda \(x_{i}\) de \(x_{i}\in Li(\varphi _{1})\subseteq Li(\varphi _{1})\cup \{x_{j}\}\), con lo cual por Teo\(_{k}\) se tiene que \(\mathbf{A}\models \varphi _{1}[\downarrow _{j}^{a}(\vec{b})]\), para todo \(a\in A\),
lo cual por (8) en la def de \(\mathbf{A}\models \varphi [\vec{a}]\) nos dice que \(\mathbf{A}\models \varphi [\vec{b}]\). La prueba de que \(\mathbf{A}\models \varphi [\vec{b}]\) implica que \(\mathbf{A}\models \varphi [\vec{a}]\) es
similar.
</p><!-- l. 14249 --><p class='indent'>   CASO \(\varphi =\exists x_{j}\varphi _{1}\).
</p><!-- l. 14251 --><p class='noindent'>Es similar al anterior.                                                                         □
</p>
   </div>

   <div class='newtheorem'>
<!-- l. 14253 --><p class='noindent'><span class='head'>
<a id='x1-173020r190'></a>
<span class='cmbx-10'>Corollary 190.</span>  </span><span class='cmti-10'>Si</span> \(\varphi \) <span class='cmti-10'>es una sentencia, entonces</span> \(\mathbf{A}\models \varphi [\vec{a}]\) <span class='cmti-10'>sii</span> \(\mathbf{A}\models \varphi [\vec{b}]\)<span class='cmti-10'>, cualesquiera sean las
</span><span class='cmti-10'>asignaciones</span> \(\vec{a},\vec{b}\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 14263 --><p class='indent'>   En virtud del corolario anterior tenemos que el valor de verdad de una sentencia \(\varphi \)
en una estructura dada \(\mathbf{A}\) para una asignacion \(\vec{a}\) no depende de \(\vec{a}\), es decir este valor es ya
sea \(1\) para todas las asignaciones o \(0\) para todas las asignaciones. En el primer caso
diremos que \(\varphi \) <span class='cmti-10'>es verdadera en</span> \(\mathbf{A}\) (y escribiremos \(\mathbf{A}\models \varphi \)) y en el segundo caso diremos que \(\varphi \) <span class='cmti-10'>es
</span><span class='cmti-10'>falsa en</span> \(\mathbf{A}\) (y escribiremos \(\mathbf{A}\not \models \varphi \))
</p><!-- l. 14272 --><p class='indent'>   Una sentencia de tipo \(\tau \) sera llamada <span class='cmti-10'>universalmente valida </span>si es verdadera en cada
modelo de tipo \(\tau \).
</p><!-- l. 14275 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>6.2   </span> <a id='x1-1740006.2'></a>Equivalencia de formulas</h4>
<!-- l. 14277 --><p class='noindent'>Dadas \(\varphi ,\psi \in F^{\tau }\) diremos que \(\varphi \) y \(\psi \) son <span class='cmti-10'>equivalentes </span>cuando se de la siguiente condicion
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-174001x6.2'>\(\mathbf{A}\models \varphi [\vec{a}]\) si y solo si \(\mathbf{A}\models \psi [\vec{a}]\), para cada modelo de tipo \(\tau \), \(\mathbf{A}\) y cada \(\vec{a}\in A^{\mathbf{N}}\)</li></ol>
<!-- l. 14283 --><p class='noindent'>Escribiremos \(\varphi \thicksim \psi \) cuando \(\varphi \) y \(\psi \) sean equivalentes. Notese que \(\thicksim \) es una relacion de equivalencia.
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-174003x1'>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-174004x0'>Si \(Li(\gamma )\cup Li(\psi )\subseteq \{x_{i_{1}},...,x_{i_{n}}\},\) entonces \(\gamma \thicksim \psi \) si y solo si la sentencia \(\forall x_{i_{1}}...\forall x_{i_{n}}(\gamma \leftrightarrow \psi )\) es universalmente valida.
         </li>
         <li class='enumerate' id='x1-174005x0'>Si \(\gamma _{i}\thicksim \psi _{i},\) \(i=1,2,\) entonces \(\lnot \gamma _{1}\thicksim \lnot \psi _{1},\) \((\gamma _{1}\eta \gamma _{2})\thicksim (\psi _{1}\eta \psi _{2})\) y \(Qv\gamma _{1}\thicksim Qv\psi _{1}.\)
         </li>
         <li class='enumerate' id='x1-174006x0'>Si  \(\gamma \thicksim \psi \)  y  \(\alpha ^{\prime }\)  es  el  resultado  de  reemplazar  en  una  formula  \(\alpha \)  algunas
         (posiblemente \(0\)) ocurrencias de \(\gamma \) por \(\psi \), entonces \(\alpha \thicksim \alpha ^{\prime }.\)</li></ol>
     </li></ol>
<!-- l. 14299 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14300 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>(a) Tenemos que \[ \begin{array}{l} \gamma \thicksim \psi \\ \ \ \Updownarrow \text{ (por (6) de la def de}\models \text{)}\\ \mathbf{A}\models (\gamma \leftrightarrow \psi )[\vec{a}]\text{, para todo }\mathbf{A}\text{ y toda }\vec{a}\in A^{\mathbf{N}}\\ \ \ \Updownarrow \\ \mathbf{A}\models (\gamma \leftrightarrow \psi )[\downarrow _{i_{n}}^{a}(\vec{a})]\text{, para todo }\mathbf{A}\text{, }a\in A\text{ y toda }\vec{a}\in A^{\mathbf{N}}\\ \ \ \Updownarrow (\text{por (8) de la def de}\models )\\ \mathbf{A}\models \forall x_{i_{n}}(\gamma \leftrightarrow \psi )[\vec{a}]\text{, para todo }\mathbf{A}\text{ y toda }\vec{a}\in A^{\mathbf{N}}\\ \ \ \Updownarrow \\ \mathbf{A}\models \forall x_{i_{n}}(\gamma \leftrightarrow \psi )[\downarrow _{i_{n-1}}^{a}(\vec{a})]\text{, para todo }\mathbf{A}\text{, }a\in A\text{ y toda }\vec{a}\in A^{\mathbf{N}}\\ \ \ \Updownarrow \text{ (por (8) de la def de}\models \text{)}\\ \mathbf{A}\models \forall x_{i_{n-1}}\forall x_{i_{n}}(\gamma \leftrightarrow \psi )[\vec{a}]\text{, para todo }\mathbf{A}\text{ y toda }\vec{a}\in A^{\mathbf{N}}\\ \ \ \Updownarrow \\ \ \ \ \ \vdots \\ \ \ \Updownarrow \\ \mathbf{A}\models \forall x_{i_{1}}...\forall x_{i_{n}}(\gamma \leftrightarrow \psi )[\vec{a}]\text{, para todo }\mathbf{A}\text{ y toda }\vec{a}\in A^{\mathbf{N}}\\ \ \ \Updownarrow \\ \forall x_{i_{1}}...\forall x_{i_{n}}(\gamma \leftrightarrow \psi )\text{ es universalmente valida} \end{array} \]
</p><!-- l. 14323 --><p class='indent'>   (b) Es dejado al lector.
</p><!-- l. 14325 --><p class='indent'>   (c) Por induccion en el \(k\) tal que \(\alpha \in F_{k}^{\tau }\).                                                       □
</p>
   </div>
<!-- l. 14327 --><p class='noindent'>@@finpagina@@
</p><!-- l. 14331 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>6.3   </span> <a id='x1-1750006.3'></a>Homomorfismos</h4>
<!-- l. 14333 --><p class='noindent'>Dado un modelo de tipo \(\tau \), \(\mathbf{A}=(A,i)\), para cada \(s\in \mathcal{C}\cup \mathcal{F}\cup \mathcal{R}\), usaremos \(s^{\mathbf{A}}\) para denotar a \(i(s)\). Sean \(\mathbf{A}\) y \(\mathbf{B}\) modelos
de tipo \(\tau \). Una funcion \(F:A\rightarrow B\) sera un <span class='cmti-10'>homomorfismo de</span> \(\mathbf{A}\) <span class='cmti-10'>en</span> \(\mathbf{B}\) si se cumplen las
siguientes
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-175001x6.3'>\(F(c^{\mathbf{A}})=c^{\mathbf{B}}\), para todo \(c\in \mathcal{C}\),
     </li>
     <li class='enumerate' id='x1-175002x6.3'>\(F(f^{\mathbf{A}}(a_{1},...,a_{n}))=f^{\mathbf{B}}(F(a_{1}),...,F(a_{n}))\), para cada \(f\in \mathcal{F}_{n}\), \(a_{1},...,a_{n}\in A\).
     </li>
     <li class='enumerate' id='x1-175003x6.3'>\((a_{1},...,a_{n})\in r^{\mathbf{A}}\) implica \((F(a_{1}),...,F(a_{n}))\in r^{\mathbf{B}}\), para todo \(r\in \mathcal{R}_{n}\), \(a_{1},...,a_{n}\in A\).</li></ol>
<!-- l. 14345 --><p class='noindent'>Un <span class='cmti-10'>isomorfismo de</span> \(\mathbf{A}\) <span class='cmti-10'>en</span> \(\mathbf{B}\) sera un un homomorfismo de \(\mathbf{A}\) en \(\mathbf{B}\) el cual sea biyectivo y cuya
inversa sea un homomorfismo de \(\mathbf{B}\) en \(\mathbf{A}\). Diremos que los modelos \(\mathbf{A}\) y \(\mathbf{B}\) son <span class='cmti-10'>isomorfos</span>
(en simbolos: \(\mathbf{A}\cong \mathbf{B}\)), cuando haya un isomorfismo \(F\) de \(\mathbf{A}\) en \(\mathbf{B}\). Diremos que \(F:\mathbf{A}\rightarrow \mathbf{B}\) <span class='cmti-10'>es un
</span><span class='cmti-10'>homomorfismo </span>para expresar que \(F\) es un homomorfismo de \(\mathbf{A}\) en \(\mathbf{B}\). Analogamente
diremos que \(F:\mathbf{A}\rightarrow \mathbf{B}\) <span class='cmti-10'>es un isomorfismo </span>para expresar que \(F\) es un isomorfismo de \(\mathbf{A}\) en
\(\mathbf{B}\).
</p><!-- l. 14359 --><p class='indent'>   <span class='cmbx-10'>Ejercicio: </span>Pruebe que la relacion \(\cong \) es reflexiva, transitiva y simetrica.
</p>
   <div class='newtheorem'>
<!-- l. 14361 --><p class='noindent'><span class='head'>
<a id='x1-175004r191'></a>
<span class='cmbx-10'>Lema 191.</span>  </span><span class='cmti-10'>Sea</span> \(F:\mathbf{A}\rightarrow \mathbf{B}\) <span class='cmti-10'>un homomorfismo. Entonces </span>\[ F(t^{\mathbf{A}}[(a_{1},a_{2},...)]=t^{\mathbf{B}}[(F(a_{1}),F(a_{2}),...)] \] <span class='cmti-10'>para cada</span> \(t\in T^{\tau }\)<span class='cmti-10'>,</span> \((a_{1},a_{2},...)\in A^{\mathbf{N}}\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 14370 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14371 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Sea
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-175005x6.3'>Teo\(_{k}\): Si \(F:\mathbf{A}\rightarrow \mathbf{B}\) es un homomorfismo, entonces \[ F(t^{\mathbf{A}}[(a_{1},a_{2},...)]=t^{\mathbf{B}}[(F(a_{1}),F(a_{2}),...)] \] para cada \(t\in T_{k}^{\tau }\), \((a_{1},a_{2},...)\in A^{\mathbf{N}}\).</li></ol>
<!-- l. 14380 --><p class='noindent'>Teo\(_{0}\) es trivial. Veamos que Teo\(_{k}\) implica Teo\(_{k+1}\). Supongamos que vale Teo\(_{k}\) y supongamos \(F:\mathbf{A}\rightarrow \mathbf{B}\) es
un homomorfismo, \(t\in T_{k+1}^{\tau }-T_{k}^{\tau }\) y \(\vec{a}=(a_{1},a_{2},...)\in A^{\mathbf{N}}\). Denotemos \((F(a_{1}),F(a_{2}),...)\) con \(F(\vec{a})\). Por Lema <a href='#x1-163001r174'>174<!-- tex4ht:ref: basic0  --></a>, \(t=f(t_{1},...,t_{n})\), con \(n\geq 1\),\(\;f\in \mathcal{F}_{n}\) y \(t_{1},...,t_{n}\in T_{k}^{\tau }\). Tenemos entonces
\[ \begin{array}{ccl} F(t^{\mathbf{A}}[\vec{a}]) &amp; = &amp; F(f(t_{1},...,t_{n})^{\mathbf{A}}[\vec{a}])\\ &amp; = &amp; F(f^{\mathbf{A}}(t_{1}^{\mathbf{A}}[\vec{a}],...,t_{n}^{\mathbf{A}}[\vec{a}]))\\ &amp; = &amp; f^{\mathbf{B}}(F(t_{1}^{\mathbf{A}}[\vec{a}]),...,F(t_{n}^{\mathbf{A}}[\vec{a}]))\\ &amp; = &amp; f^{\mathbf{B}}(t_{1}^{\mathbf{B}}[F(\vec{a})],...,t_{n}^{\mathbf{B}}[F(\vec{a})]))\\ &amp; = &amp; f(t_{1},...,t_{n})^{\mathbf{B}}[F(\vec{a})]\\ &amp; = &amp; t^{\mathbf{B}}[F(\vec{a})] \end{array} \]                                                                 □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 14397 --><p class='noindent'><span class='head'>
<a id='x1-175006r192'></a>
<span class='cmbx-10'>Lema 192.</span>  </span><span class='cmti-10'>Supongamos que</span> \(F:\mathbf{A}\rightarrow \mathbf{B}\) <span class='cmti-10'>es un isomorfismo</span>\(.\) <span class='cmti-10'>Sea</span> \(\varphi \in F^{\tau }.\) <span class='cmti-10'>Entonces </span>\[ \mathbf{A}\models \varphi [(a_{1},a_{2},...)]\text{ sii }\mathbf{B}\models \varphi [(F(a_{1}),F(a_{2}),...)] \] <span class='cmti-10'>para cada</span> \((a_{1},a_{2},...)\in A^{\mathbf{N}}\)<span class='cmti-10'>. En
</span><span class='cmti-10'>particular</span> \(\mathbf{A}\) <span class='cmti-10'>y</span> \(\mathbf{B}\) <span class='cmti-10'>satisfacen las mismas sentencias de tipo</span> \(\tau \)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 14407 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14408 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-175007x6.3'>Teo\(_{k}\): Supongamos que \(F:\mathbf{A}\rightarrow \mathbf{B}\) es un isomorfismo\(.\) Sea \(\varphi \in F_{k}^{\tau }\). Entonces \[ \mathbf{A}\models \varphi [(a_{1},a_{2},...)]\text{ sii }\mathbf{B}\models \varphi [(F(a_{1}),F(a_{2}),...)] \] para cada \((a_{1},a_{2},...)\in A^{\mathbf{N}}\)</li></ol>
                                                                 □
   </div>
<!-- l. 14421 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>6.4   </span> <a id='x1-1760006.4'></a>Algebras</h4>
<!-- l. 14423 --><p class='noindent'>Un tipo \(\tau \) sera llamado <span class='cmti-10'>algebraico </span>si no contiene nombres de relacion. Un modelo de un
tipo algebraico \(\tau \) sera llamado una \(\tau \)-<span class='cmti-10'>algebra</span>. Ejemplos clasicos de \(\tau \)-algebras son los
grupos (\(\tau =(\{e\},\{.^{2}\},\emptyset ,a)\)), los reticulados, los reticulados acotados, las algebras de Boole,
etc.
</p><!-- l. 14429 --><p class='indent'>   Una propiedad particular de los homomorfismos de \(\tau \)-algebras es la siguiente
</p>

   <div class='newtheorem'>
<!-- l. 14431 --><p class='noindent'><span class='head'>
<a id='x1-176001r193'></a>
<span class='cmbx-10'>Lema 193.</span>  </span><span class='cmti-10'>Supongamos</span> \(\tau \) <span class='cmti-10'>es algebraico. Si</span> \(F:\mathbf{A}\rightarrow \mathbf{B}\) <span class='cmti-10'>es un homomorfismo biyectivo,
</span><span class='cmti-10'>entonces</span> \(F\) <span class='cmti-10'>es un isomorfismo.</span>
</p>
   </div>
<!-- l. 14436 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14437 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Solo falta probar que \(F^{-1}\) es un homomorfismo. Supongamos que \(c\in \mathcal{C}\). Ya que
\(F(c^{\mathbf{A}})=c^{\mathbf{B}}\), tenemos que \(F^{-1}(c^{\mathbf{B}})=c^{\mathbf{A}}\), por lo cual \(F^{-1}\) cumple (1) de la definicion de homomorfismo.
Supongamos ahora que \(f\in \mathcal{F}_{n}\) y sean \(b_{1},...,b_{n}\in B\). Sean \(a_{1},...,a_{n}\in A\) tales que \(F(a_{i})=b_{i}\), \(i=1,...,n\). Tenemos que \[ \begin{array}{ccl} F^{-1}(f^{\mathbf{B}}(b_{1},...,b_{n})) &amp; = &amp; F^{-1}(f^{\mathbf{B}}(F(a_{1}),...,F(a_{n})))\\ &amp; = &amp; F^{-1}(F(f^{\mathbf{A}}(a_{1},...,a_{n})))\\ &amp; = &amp; f^{\mathbf{A}}(a_{1},...,a_{n})\\ &amp; = &amp; f^{\mathbf{A}}(F^{-1}(b_{1}),...,F^{-1}(b_{n})) \end{array} \] por lo cual \(F^{-1}\)
satisface (2) de la definicion de homomorfismo                                         □
</p>
   </div>
<!-- l. 14459 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>6.4.1   </span> <a id='x1-1770006.4.1'></a>Subalgebras</h5>
<!-- l. 14461 --><p class='noindent'>Dadas \(\tau \)-algebras \(\mathbf{A}\) y \(\mathbf{B}\), diremos que \(\mathbf{A}\) es una <span class='cmti-10'>subalgebra de</span> \(\mathbf{B}\) cuando se den las siguientes
condiciones
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-177001x6.4.1'>\(A\subseteq B\)
     </li>
     <li class='enumerate' id='x1-177002x6.4.1'>\(c^{\mathbf{A}}=c^{\mathbf{B}}\), para cada \(c\in \mathcal{C}\)
     </li>
     <li class='enumerate' id='x1-177003x6.4.1'>\(f^{\mathbf{A}}=f^{\mathbf{B}}|_{A^{n}}\), para cada \(f\in \mathcal{F}_{n}\), \(n\geq 1\)</li></ol>
<!-- l. 14472 --><p class='indent'>   Por ejemplo sea \(\tau =(\)
</p><!-- l. 14476 --><p class='indent'>   Si \(\mathbf{B}\) es una \(\tau \)-algebra, entonces un <span class='cmti-10'>subuniverso de</span> \(\mathbf{B}\) es un conjunto \(A\) el cual cumple las
siguientes condiciones:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-177004x6.4.1'>\(\emptyset \neq A\subseteq B\)

     </li>
     <li class='enumerate' id='x1-177005x6.4.1'>\(c^{\mathbf{B}}\in A,\) para cada \(c\in \mathcal{C}\)
     </li>
     <li class='enumerate' id='x1-177006x6.4.1'>\(f^{\mathbf{B}}(a_{1},...,a_{n})\in A\), para cada \((a_{1},...,a_{n})\in A^{n},\) \(f\in \mathcal{F}_{n}\)</li></ol>
<!-- l. 14487 --><p class='indent'>   Es importante notar que si bien los conceptos de subalgebra y subuniverso estan
muy relacionados, se trata de objetos diferentes ya que las subalgebras de un algebra
dada son estructuras de tipo \(\tau \) y por lo tanto son pares ordenados y los subuniversos
de un algebra dada son ciertos subconjuntos por lo cual no son pares ordenados. A
continuacion presisaremos la relacion que hay entre estos dos conceptos. Notese que
dado un subuniverso \(A\) de una \(\tau \)-algebra \(\mathbf{B}\) podemos definir en forma natural una \(\tau \)-algebra
\(\mathbf{A}\) de la siguiente manera:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-177007x6.4.1'>Universo de \(\mathbf{A}=A\)
     </li>
     <li class='enumerate' id='x1-177008x6.4.1'>\(c^{\mathbf{A}}=c^{\mathbf{B}},\) para cada \(c\in \mathcal{C}\)
     </li>
     <li class='enumerate' id='x1-177009x6.4.1'>\(f^{\mathbf{A}}=f^{\mathbf{B}}|_{A^{n}},\) para cada \(f\in \mathcal{F}_{n}\).</li></ol>
<!-- l. 14501 --><p class='noindent'>Es facil chequear que el algebra \(\mathbf{A}\) asi definida es una subalgebra de \(\mathbf{B}\). Lo anterior nos
muestra que los subuniversos de un algebra dada son precisamente los universos de
las distintas subalgebras de dicha algebra.
</p>
   <div class='newtheorem'>
<!-- l. 14508 --><p class='noindent'><span class='head'>
<a id='x1-177010r194'></a>
<span class='cmbx-10'>Lema 194.</span>  </span><span class='cmti-10'>Supongamos</span> \(\tau \) <span class='cmti-10'>es algebraico. Si</span> \(F:\mathbf{A}\rightarrow \mathbf{B}\) <span class='cmti-10'>es un homomorfismo, entonces</span> \(I_{F}\) <span class='cmti-10'>es
</span><span class='cmti-10'>un subuniverso de</span> \(\mathbf{B}\)
</p>
   </div>
<!-- l. 14513 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14514 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que \(A\neq \emptyset ,\) tenemos que \(I_{F}\neq \emptyset .\) Es claro que \(c^{\mathbf{B}}=F(c^{\mathbf{A}})\in I_{F},\) para cada \(c\in \mathcal{C}\). Sea \(f\in \mathcal{F}_{n}\) y sean \(b_{1},...,b_{n}\in I_{F}\) Sean \(a_{1},...,a_{n}\) tales
que \(F(a_{i})=b_{i},\) \(i=1,...,n\). Tenemos que \[ f^{\mathbf{B}}(b_{1},...,b_{n})=f^{\mathbf{B}}(F(a_{1}),...,F(a_{n}))=F(f^{\mathbf{A}}(a_{1},...,a_{n}))\in I_{F} \] por lo cual \(I_{F}\) es cerrada bajo \(f^{\mathbf{B}}\).                                     □
</p>
   </div>

<!-- l. 14525 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>6.4.2   </span> <a id='x1-1780006.4.2'></a>Congruencias</h5>
<!-- l. 14527 --><p class='noindent'>Sea \(\mathbf{A}\) una \(\tau \)-algebra. Una <span class='cmti-10'>congruencia sobre</span> \(\mathbf{A}\) es una relacion de equivalencia \(\theta \) sobre \(A\) la
cual cumple que
</p><!-- l. 14533 --><p class='indent'>   \[ a_{1}\theta b_{1},...,a_{n}\theta b_{n}\text{ implica }f^{\mathbf{A}}(a_{1},...,a_{n})\theta f^{\mathbf{A}}(b_{1},...,b_{n}) \] cualesquiera sean \(a_{1},...,a_{n},b_{1},...,b_{n}\in A\) y\(\;f\in \mathcal{F}_{n}\).
</p><!-- l. 14536 --><p class='indent'>   Dada una congruencia \(\theta \) sobre \(\mathbf{A}\) se puede formar una nueva algebra \(\mathbf{A}/\theta \) de la siguiente
manera:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-178001x6.4.2'>Universo de \(\mathbf{A}/\theta =A/\theta =\{a/\theta :a\in A\}=\{\)clases de equivalencia de \(\theta \}\)
     </li>
     <li class='enumerate' id='x1-178002x6.4.2'>\(f^{\mathbf{A}/\theta }(a_{1}/\theta ,...,a_{n}/\theta )=f^{\mathbf{A}}(a_{1},...,a_{n})/\theta ,\) para cada \(f\in \mathcal{F}_{n}.\)
     </li>
     <li class='enumerate' id='x1-178003x6.4.2'>\(c^{\mathbf{A}/\theta }=c^{\mathbf{A}}/\theta ,\) para cada \(c\in \mathcal{C}\)</li></ol>
<!-- l. 14545 --><p class='noindent'>\(\mathbf{A}/\theta \)sera llamada el <span class='cmti-10'>algebra cociente de</span> \(\mathbf{A}\) <span class='cmti-10'>por</span> \(\theta \).
</p>
   <div class='newtheorem'>
<!-- l. 14550 --><p class='noindent'><span class='head'>
<a id='x1-178004r195'></a>
<span class='cmbx-10'>Lema 195.</span>  </span><span class='cmti-10'>Supongamos</span> \(\tau \) <span class='cmti-10'>es algebraico. Si</span> \(F:\mathbf{A}\rightarrow \mathbf{B}\) <span class='cmti-10'>es un homomorfismo, entonces</span> \(\ker F\) <span class='cmti-10'>es
</span><span class='cmti-10'>una congruencia sobre</span> \(\mathbf{A}\)
</p>
   </div>
<!-- l. 14555 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14556 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea \(f\in \mathcal{F}_{n}\). Supongamos que \(a_{1},...,a_{n},b_{1},...,b_{n}\in A\) son tales que \(a_{1}\ker Fb_{1},...,a_{n}\ker Fb_{n}\). Tenemos entonces que \[ \begin{array}{ccl} F(f^{\mathbf{A}}(a_{1},...,a_{n})) &amp; = &amp; f^{\mathbf{B}}(F(a_{1}),...,F(a_{n}))\\ &amp; = &amp; f^{\mathbf{B}}(F(b_{1}),...,F(b_{n}))\\ &amp; = &amp; F(f^{\mathbf{A}}(b_{1},...,b_{n})) \end{array} \] lo cual nos
dice que \(f^{\mathbf{A}}(a_{1},...,a_{n})\ker Ff^{\mathbf{A}}(b_{1},...,b_{n})\)                                                                                          □
</p>
   </div>
<!-- l. 14572 --><p class='indent'>   Al mapeo \[ \begin{array}{lll} A &amp; \rightarrow &amp; A/\theta \\ a &amp; \rightarrow &amp; a/\theta \end{array} \] lo llamaremos la <span class='cmti-10'>proyeccion canonica </span>y lo denotaremos con
\(\pi _{\theta }\).
</p>
   <div class='newtheorem'>

<!-- l. 14581 --><p class='noindent'><span class='head'>
<a id='x1-178005r196'></a>
<span class='cmbx-10'>Lema 196.</span>  </span>\(\pi _{\theta }:\mathbf{A}\rightarrow \mathbf{A}/\theta \) <span class='cmti-10'>es un homomorfismo cuyo nucleo es</span> \(\theta \)
</p>
   </div>
<!-- l. 14586 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14587 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea \(c\in \mathcal{C}\). Tenemos que \[ \pi _{\theta }(c^{\mathbf{A}})=c^{\mathbf{A}}/\theta =c^{\mathbf{A}/\theta } \] Sea \(f\in \mathcal{F}_{n}\), con \(n\geq 1\) y sean \(a_{1},...,a_{n}\in A\). Tenemos que \[ \begin{array}{ccl} \pi _{\theta }(f^{\mathbf{A}}(a_{1},...,a_{n})) &amp; = &amp; f^{\mathbf{A}}(a_{1},...,a_{n})/\theta \\ &amp; = &amp; f^{\mathbf{A}/\theta }(a_{1}/\theta ,...,a_{n}/\theta )\\ &amp; = &amp; f^{\mathbf{A}/\theta }(\pi _{\theta }(a_{1}),...,\pi _{\theta }(a_{n})) \end{array} \] con lo cual \(\pi _{\theta }\) es un
homomorfismo. Es trivial que \(\ker \pi _{\theta }=\theta \)                                                              □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 14602 --><p class='noindent'><span class='head'>
<a id='x1-178006r197'></a>
<span class='cmbx-10'>Corollary 197.</span>  </span><span class='cmti-10'>Para cada</span> \(t\in T^{\tau }\)<span class='cmti-10'>,</span> \(\vec{a}\in A^{\mathbf{N}},\) <span class='cmti-10'>se tiene que</span> \(t^{\mathbf{A}/\theta }[(a_{1}/\theta ,a_{2}/\theta ,...)]=t^{\mathbf{A}}[(a_{1},a_{2},...)]/\theta .\)
</p>
   </div>
<!-- l. 14607 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14608 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que \(\pi _{\theta }\) es un homomorfismo, se puede aplicar el Lema <a href='#x1-175004r191'>191<!-- tex4ht:ref: F-respeta-term  --></a>.              □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 14613 --><p class='noindent'><span class='head'>
<a id='x1-178007r198'></a>
<span class='cmbx-10'>Teorema 198.</span>  </span><span class='cmti-10'>Sea</span>  \(F:\mathbf{A}\rightarrow \mathbf{B}\)  <span class='cmti-10'>un  homomorfismo  sobreyectivo.  Entonces  </span>\[ \begin{array}{lll} A/\ker F &amp; \rightarrow &amp; B\\ a/\ker F &amp; \rightarrow &amp; F(a) \end{array} \]  <span class='cmti-10'>define  sin
</span><span class='cmti-10'>ambiguedad una funcion</span> \(\bar{F}\) <span class='cmti-10'>la cual es un isomorfismo de</span> \(\mathbf{A}/\ker F\) <span class='cmti-10'>en</span> \(\mathbf{B}\)

</p>
   </div>
<!-- l. 14626 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14627 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que la definicion de \(\bar{F}\) es inambigua ya que si \(a/\ker F=a^{\prime }/\ker F\), entonces \(F(a)=F(a^{\prime }).\) Ya que
\(F\) es sobre, tenemos que \(\bar{F}\) lo es. Supongamos que \(\bar{F}(a/\ker F)=\bar{F}(a^{\prime }/\ker F).\) Claramente entonces tenemos
que \(F(a)=F(a^{\prime })\), lo cual nos dice que \(a/\ker F=a^{\prime }/\ker F\). Esto prueba que \(\bar{F}\) es inyectiva. Para ver que \(\bar{F}\) es un
isomorfismo, por el Lema <a href='#x1-176001r193'>193<!-- tex4ht:ref: homobiyectivo  --></a>, basta con ver que \(\bar{F}\) es un homomorfismo. Sea \(c\in \mathcal{C}\).
Tenemos que \[ \bar{F}(c^{\mathbf{A}/\ker F})=\bar{F}(c^{\mathbf{A}}/\ker F)=F(c^{\mathbf{A}})=c^{\mathbf{B}} \] Sea \(f\in \mathcal{F}_{n}\). Sean \(a_{1},...,a_{n}\in A\). Tenemos que \[ \begin{array}{ccl} \bar{F}(f^{\mathbf{A}/\ker F}(a_{1}/\ker F,...,a_{n}/\ker F)) &amp; = &amp; \bar{F}(f^{\mathbf{A}}(a_{1},...,a_{n})/\ker F)\\ &amp; = &amp; F(f^{\mathbf{A}}(a_{1},...,a_{n}))\\ &amp; = &amp; f^{\mathbf{B}}(F(a_{1}),...,F(a_{n}))\\ &amp; = &amp; f^{\mathbf{B}}(\bar{F}(a_{1}/\ker F),...,\bar{F}(a_{n}/\ker F)) \end{array} \] con lo cual \(\bar{F}\) cunple (2) de la definicion
de homomorfismo                                                                               □
</p>
   </div>
<!-- l. 14652 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>6.4.3   </span> <a id='x1-1790006.4.3'></a>Producto directo de algebras</h5>
<!-- l. 14654 --><p class='noindent'>Dadas \(\tau \)-algebras \(\mathbf{A},\mathbf{B},\) definamos una nueva \(\tau \)-algebra \(\mathbf{A}\times \mathbf{B},\) de la siguiente manera
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-179001x6.4.3'>Universo de \(\mathbf{A}\times \mathbf{B}=A\times B\)
     </li>
     <li class='enumerate' id='x1-179002x6.4.3'>\(c^{\mathbf{A}\times \mathbf{B}}=(c^{\mathbf{A}},c^{\mathbf{B}})\), para cada \(c\in \mathcal{C}\)
     </li>
     <li class='enumerate' id='x1-179003x6.4.3'>\(f^{\mathbf{A}\times \mathbf{B}}((a_{1},b_{1}),...,(a_{n},b_{n}))=(f^{\mathbf{A}}(a_{1},...,a_{n}),f^{\mathbf{B}}(b_{1},...,b_{n}))\), para cada \(f\in \mathcal{F}_{n}\)</li></ol>
<!-- l. 14663 --><p class='noindent'>Llamaremos a \(\mathbf{A}\times \mathbf{B}\) el <span class='cmti-10'>producto directo </span>de \(\mathbf{A}\) y \(\mathbf{B}.\)
</p><!-- l. 14666 --><p class='indent'>   Los mapeos \[ \begin{array}{lll} \pi _{1}:A\times B &amp; \rightarrow &amp; A\\ \;\;\;\;\;(a,b) &amp; \rightarrow &amp; a \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{lll} \pi _{2}:A\times B &amp; \rightarrow &amp; B\\ \;\;\;\;\;(a,b) &amp; \rightarrow &amp; b \end{array} \] seran llamados las <span class='cmti-10'>proyecciones canonicas </span>asociadas al producto
\(A\times B\)
</p>
   <div class='newtheorem'>
<!-- l. 14678 --><p class='noindent'><span class='head'>
<a id='x1-179004r199'></a>
<span class='cmbx-10'>Lema 199.</span>  </span><span class='cmti-10'>Los mapeos</span> \(\pi _{1}:\mathbf{A}\times \mathbf{B}\rightarrow \mathbf{A}\) <span class='cmti-10'>y</span> \(\pi _{2}:\mathbf{A}\times \mathbf{B}\rightarrow \mathbf{B}\) <span class='cmti-10'>son homomorfismos</span>
</p>
   </div>
<!-- l. 14683 --><p class='indent'>

</p>
   <div class='proof'>
<!-- l. 14684 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Veamos que \(\pi _{1}\) es un homomorfismo. Primero notese que si \(c\in \mathcal{C}\), entonces \[ \pi _{1}(c^{\mathbf{A}\times \mathbf{B}})=\pi _{1}((c^{\mathbf{A}},c^{\mathbf{B}}))=c^{\mathbf{A}} \] Sea
\(f\in \mathcal{F}_{n}\), con \(n\geq 1\) y sean \((a_{1},b_{1}),...,(a_{n},b_{n})\in A\times B\). Tenemos que \[ \begin{array}{ccl} \pi _{1}(f^{\mathbf{A}\times \mathbf{B}}((a_{1},b_{1}),...,(a_{n},b_{n})) &amp; = &amp; \pi _{1}((f^{\mathbf{A}}(a_{1},...,a_{n}),f^{\mathbf{B}}(b_{1},...,b_{n}))\\ &amp; = &amp; f^{\mathbf{A}}(a_{1},...,a_{n})\\ &amp; = &amp; f^{\mathbf{A}}(\pi _{1}(a_{1},b_{1}),...,\pi _{1}(a_{n},b_{n})) \end{array} \] con lo cual hemos probado que \(\pi _{1}\) cumple (2) de la
definicion de homomorfismo                                                                 □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 14701 --><p class='noindent'><span class='head'>
<a id='x1-179005r200'></a>
<span class='cmbx-10'>Lema 200.</span>  </span><span class='cmti-10'>Para cada</span> \(t\in T^{\tau },\) \(((a_{1},b_{1}),(a_{2},b_{2}),...)\in (A\times B)^{\mathbf{N}},\) <span class='cmti-10'>se tiene que</span> \(t^{\mathbf{A}\times \mathbf{B}}[((a_{1},b_{1}),(a_{2},b_{2}),...)]=(t^{\mathbf{A}}[(a_{1},a_{2},...)],t^{\mathbf{B}}[(b_{1},b_{2},...)])\)
</p>
   </div>
<!-- l. 14709 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>7   </span> <a id='x1-1800007'></a>Dos teoremas de reemplazo</h3>
<!-- l. 14711 --><p class='noindent'>Probaremos dos teoremas muy importantes que en algun sentido nos dicen que el
reemplazo sintactico se lleva bien con la semantica.
</p><!-- l. 14714 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>7.1   </span> <a id='x1-1810007.1'></a>Notacion declaratoria para terminos</h4>
<!-- l. 14716 --><p class='noindent'>Si \(t\) es un termino de tipo \(\tau \), entonces escribiremos \(t=_{d}t(v_{1},...,v_{n})\) para declarar que \(v_{1},...,v_{n}\) son variables
distintas tales que toda variable que ocurre en \(t\) pertenece a \(\{v_{1},...,v_{n}\}\) (no necesariamente toda \(v_{j}\)
debe ocurrir en \(t\)). El uso de declaraciones de la forma \(t=_{d}t(v_{1},...,v_{n})\) sera muy util cuando
se lo combina con ciertas convenciones notacionales que describiremos a
continuacion.
     </p><dl class='description'><dt class='description'>
<span class='cmbx-10'>Convencion Notacional 1:</span> </dt><dd class='description'>Cuando hayamos hecho la declaracion \(t=_{d}t(v_{1},...,v_{n})\), si \(P_{1},...,P_{n}\) son
     palabras cualesquiera (no necesariamente terminos), entonces \(t(P_{1},...,P_{n})\) denotara la
     palabra que resulta de reemplazar (simultaneamente) cada ocurrencia de
     \(v_{1}\) en \(t\), por \(P_{1}\), cada ocurrencia de \(v_{2}\) en \(t\), por \(P_{2}\), etc.</dd></dl>

<!-- l. 14731 --><p class='noindent'>Notese que cuando las palabras \(P_{i}^{\prime }s\) son terminos, \(t(P_{1},...,P_{n})\) es un termino (Lema <a href='#x1-165001r180'>180<!-- tex4ht:ref: reemp-ter-en-ter  --></a>). Ademas
notese que en esta convencion notacional, el orden de las variables \(v_{1},...,v_{n}\) es clave. Por
ejemplo si \(\tau =(\emptyset ,\{\mathrm{FU}\},\emptyset ,\{(\mathrm{FU},2)\})\) y \(t=\mathrm{FU}(\mathrm{FU}(x_{2},x_{16}),x_{3})\) y declaramos \(t=_{d}t(x_{3},x_{2},x_{16})\), entonces \(t(\#\#,\blacktriangle \#\blacktriangle ,@@)\) denotara la palabra \(\mathrm{FU}(\mathrm{FU}(\blacktriangle \#\blacktriangle ,@@),\#\#)\). Pero si declaramos \(t=_{d}t(x_{16},x_{3},x_{2})\),
entonces \(t(\#\#,\blacktriangle \#\blacktriangle ,@@)\) denotara la palabra \(\mathrm{FU}(\mathrm{FU}(@@,\#\#),\blacktriangle \#\blacktriangle )\).
     </p><dl class='description'><dt class='description'>
<span class='cmbx-10'>Convencion Notacional 2:</span> </dt><dd class='description'>Cuando hayamos declarado \(t=_{d}t(v_{1},...,v_{n})\), si \(\mathbf{A}\) es un modelo de
     tipo \(\tau \) y \(a_{1},...,a_{n}\in A\), entonces con \(t^{\mathbf{A}}[a_{1}...,a_{n}]\) denotaremos al elemento \(t^{\mathbf{A}}[\vec{b}]\), donde \(\vec{b}\) es una asignacion
     tal que a cada \(v_{i}\) le asigna el valor \(a_{i}\). (Notese que esta notacion es inhambigua
     gracias al Lema <a href='#x1-172004r188'>188<!-- tex4ht:ref: independencia del valor  --></a>.)</dd></dl>
<!-- l. 14748 --><p class='noindent'>Nuevamente cabe destacar que en esta convencion notacional, el orden de las
variables \(v_{1},...,v_{n}\) es clave. Por ejemplo si \(\tau \) y \(t\) son los dados en el ejemplo anterior y \(\mathbf{A}\) es
dado por \(A=\{1,2,3\}\) y \(\mathrm{FU}^{\mathbf{A}}(i,j)=j\), para cada \(i,j\in A\), tenemos que \(t^{\mathbf{A}}[2,1,3]=2\) si declaramos \(t=_{d}t(x_{3},x_{2},x_{16})\), pero \(t^{\mathbf{A}}[2,1,3]=1\) si declaramos
\(t=_{d}t(x_{16},x_{3},x_{2})\).
</p><!-- l. 14756 --><p class='indent'>   Para establecer nuestra Convencion Notacional 3, debemos antes enunciar un
lema clave el cual el lector no tendra inconvenientes en probar.
</p>
   <div class='newtheorem'>
<!-- l. 14758 --><p class='noindent'><span class='head'>
<a id='x1-181001r201'></a>
<span class='cmbx-10'>Lema 201.</span>  </span><span class='cmti-10'>Sea</span> \(\tau \) <span class='cmti-10'>un tipo cualquiera y supongamos</span> \(t\in T^{\tau }\)<span class='cmti-10'>. Si</span> \(t=_{d}t(v_{1},...,v_{n})\)<span class='cmti-10'>, entonces se da alguna de las
</span><span class='cmti-10'>siguientes</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-181002x201'>\(t=c,\) <span class='cmti-10'>para algun</span> \(c\in \mathcal{C}\)
     </li>
     <li class='enumerate' id='x1-181003x201'>\(t=v_{j},\) <span class='cmti-10'>para algun</span> \(j\)
     </li>
     <li class='enumerate' id='x1-181004x201'>\(t=f(t_{1},...,t_{m})\)<span class='cmti-10'>, con</span> \(f\in \mathcal{F}_{m}\) <span class='cmti-10'>y</span> \(t_{1},...,t_{m}\in T^{\tau }\) <span class='cmti-10'>tales que las variables que ocurren en cada uno de ellos estan en</span>
     \(\{v_{1},...,v_{n}\}\)</li></ol>
   </div>
<!-- l. 14771 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14772 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Rutina                                                                                   □
</p>
   </div>
<!-- l. 14776 --><p class='indent'>

     </p><dl class='description'><dt class='description'>
<span class='cmbx-10'>Convencion Notacional 3:</span> </dt><dd class='description'>Cuando  hayamos  declarado  \(t=_{d}t(v_{1},...,v_{n})\)  y  se  el  caso  (3)
     del  Lema  <a href='#x1-181001r201'>201<!-- tex4ht:ref: si t =00003D00003D00003D00003D00003D t(v1,...,vn) ...  --></a>  supondremos  tacitamente  que  tambien  hemos  hecho  las
     declaraciones \(t_{1}=_{d}t_{1}(v_{1},...,v_{n}),...,t_{m}=_{d}t_{m}(v_{1},...,v_{n})\).</dd></dl>
<!-- l. 14782 --><p class='noindent'>Cabe destacar que esta ultima convencion notacional junto con la Convencion Notacional
1, nos dice que cuando se de el caso (3) del Lema <a href='#x1-181001r201'>201<!-- tex4ht:ref: si t =00003D00003D00003D00003D00003D t(v1,...,vn) ...  --></a>, si \(P_{1},...,P_{n}\) son palabras cualesquiera,
entonces \(t(P_{1},...,P_{n})=f(t_{1}(P_{1},...,P_{n}),...,t_{m}(P_{1},...,P_{n}))\).
</p><!-- l. 14786 --><p class='indent'>   El siguiente lema se basa en la Convencion Notacional 3 y nos permite darle
caracter recursivo a la notacion \(t^{\mathbf{A}}[a_{1},....,a_{n}]\).
</p>
   <div class='newtheorem'>
<!-- l. 14788 --><p class='noindent'><span class='head'>
<a id='x1-181005r202'></a>
<span class='cmbx-10'>Lema 202.</span>  </span><span class='cmti-10'>Sea</span> \(\tau \) <span class='cmti-10'>un tipo cualquiera y</span> \(t\in T^{\tau }\)<span class='cmti-10'>. Supongamos</span> \(t=_{d}t(v_{1},...,v_{n})\)<span class='cmti-10'>. Sea</span> \(\mathbf{A}\) <span class='cmti-10'>un modelo de tipo</span> \(\tau \)<span class='cmti-10'>. Sean</span> \(a_{1},...,a_{n}\in A\)<span class='cmti-10'>.
</span><span class='cmti-10'>Se tiene que:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-181006x202'><span class='cmti-10'>Si</span> \(t=c,\) <span class='cmti-10'>entonces</span> \(t^{\mathbf{A}}[a_{1},....,a_{n}]=c^{\mathbf{A}}\)
     </li>
     <li class='enumerate' id='x1-181007x202'><span class='cmti-10'>Si</span> \(t=v_{j},\) <span class='cmti-10'>entonces</span> \(t^{\mathbf{A}}[a_{1},....,a_{n}]=a_{j}\)
     </li>
     <li class='enumerate' id='x1-181008x202'><span class='cmti-10'>Si</span> \(t=f(t_{1},...,t_{m})\)<span class='cmti-10'>, con</span> \(f\in \mathcal{F}_{m}\) <span class='cmti-10'>y</span> \(t_{1},...,t_{m}\in T^{\tau }\)<span class='cmti-10'>, entonces </span>\[ t^{\mathbf{A}}[a_{1},....,a_{n}]=f^{\mathbf{A}}(t_{1}^{\mathbf{A}}[a_{1},....,a_{n}],...,t_{m}^{\mathbf{A}}[a_{1},....,a_{n}]) \]</li></ol>
   </div>
<!-- l. 14803 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14804 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(1) y (2) son triviales.
</p><!-- l. 14806 --><p class='indent'>   (3) Sea \(\vec{b}\) una asignacion tal que a cada \(v_{i}\) le asigna el valor \(a_{i}\). Tenemos que
</p><div class='eqnarray'>\begin{eqnarray*} t^{\mathbf{A}}[a_{1},....,a_{n}] &amp; = &amp; t^{\mathbf{A}}[\vec{b}]\text{ (por def. de }t^{\mathbf{A}}[a_{1},....,a_{n}]\text{)}\\ &amp; = &amp; f^{\mathbf{A}}(t_{1}^{\mathbf{A}}[\vec{b}],...,t_{m}^{\mathbf{A}}[\vec{b}])\text{ (por def. de }t^{\mathbf{A}}[\vec{b}]\text{)}\\ &amp; = &amp; f^{\mathbf{A}}(t_{1}^{\mathbf{A}}[a_{1},....,a_{n}],...,t_{m}^{\mathbf{A}}[a_{1},....,a_{n}])\text{ (por def. de cada }t_{i}^{\mathbf{A}}[a_{1},....,a_{n}]\text{)} \end{eqnarray*}
</div>                                                                 □
   </div>

<!-- l. 14817 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>7.2   </span> <a id='x1-1820007.2'></a>Teorema de reemplazo para terminos</h4>
<!-- l. 14819 --><p class='noindent'>Ahora si podemos enunciar y probar el primero de nuestros teoremas de
reemplazo
</p>
   <div class='newtheorem'>
<!-- l. 14821 --><p class='noindent'><span class='head'>
<a id='x1-182001r203'></a>
<span class='cmbx-10'>Teorema 203.</span>   </span><span class='cmti-10'>Supongamos</span> \(t=_{d}t(w_{1},...,w_{k}),\) \(s_{1}=_{d}s_{1}(v_{1},...,v_{n}),...,s_{k}=_{d}s_{k}(v_{1},...,v_{n})\)<span class='cmti-10'>. Todas las variables de</span> \(t(s_{1},...,s_{k})\) <span class='cmti-10'>estan en</span> \(\{v_{1},...,v_{n}\}\) <span class='cmti-10'>y si declaramos</span>
\(t(s_{1},...,s_{k})=_{d}t(s_{1},...,s_{k})(v_{1},...,v_{n})\)<span class='cmti-10'>, entonces para cada estructura</span> \(\mathbf{A}\) <span class='cmti-10'>y</span> \(a_{1},....,a_{n}\in A,\) <span class='cmti-10'>se tiene que </span>\[ t(s_{1},...,s_{k})^{\mathbf{A}}[a_{1},....,a_{n}]=t^{\mathbf{A}}[s_{1}^{\mathbf{A}}[a_{1},....,a_{n}],...,s_{k}^{\mathbf{A}}[a_{1},....,a_{n}]]. \]
</p>
   </div>
<!-- l. 14832 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14833 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Por induccion en el \(l\) tal que \(t\in T_{l}^{\tau }\). El caso \(l=0\) es dejado al lector. Supongamos
entonces que el teorema vale siempre que \(t\in T_{l}^{\tau }\) y veamos que entonces vale cuando \(t\in T_{l+1}^{\tau }-T_{l}^{\tau }\).
Por el Lema <a href='#x1-181001r201'>201<!-- tex4ht:ref: si t =00003D00003D00003D00003D00003D t(v1,...,vn) ...  --></a> hay \(f\in \mathcal{F}_{m}\) y \(t_{1},...,t_{m}\) terminos tales \(t=f(t_{1},...,t_{m})\) y las variables que ocurren en cada \(t_{i}\) estan
en \(\{w_{1},...,w_{k}\}\). Por la unicidad de la lectura de terminos tenemos que \(t_{1},...,t_{m}\in T_{l}^{\tau }\) (por que?). Notese
que por nuestra Convencion Notacional 3 asumimos ya hechas las declaraciones
\[ t_{1}=_{d}t_{1}(w_{1},...,w_{k}),...,t_{m}=_{d}t_{m}(w_{1},...,w_{k}) \] Por HI tenemos que las variables de cada \(t_{i}(s_{1},...,s_{k})\) estan en \(\{v_{1},...,v_{n}\}\), lo cual nos permite hacer
las siguientes declaraciones: \[ t_{i}(s_{1},...,s_{k})=_{d}t_{i}(s_{1},...,s_{k})(v_{1},...,v_{n}),\text{ }i=1,...,m \] Por HI tenemos entonces que \[ t_{i}(s_{1},...,s_{k})^{\mathbf{A}}[\vec{a}]=t_{i}^{\mathbf{A}}[s_{1}^{\mathbf{A}}[\vec{a}],...,s_{k}^{\mathbf{A}}[\vec{a}]],\text{ }i=1,...,m \] Ya que las variables
de cada \(t_{i}(s_{1},...,s_{k})\) estan en \(\{v_{1},...,v_{n}\}\), tenemos que las variables de \(t(s_{1},...,s_{k})=f(t_{1}(s_{1},...,s_{k}),...,t_{m}(s_{1},...,s_{k}))\) estan en \(\{v_{1},...,v_{n}\}\). Declaremos entonces
\(t(s_{1},...,s_{k})=_{d}t(s_{1},...,s_{k})(v_{1},...,v_{n})\). Solo nos falta probar que \[ t(s_{1},...,s_{k})^{\mathbf{A}}[a_{1},....,a_{n}]=t^{\mathbf{A}}[s_{1}^{\mathbf{A}}[a_{1},....,a_{n}],...,s_{k}^{\mathbf{A}}[a_{1},....,a_{n}]]. \] lo cual se detalla a continuacion \[ \begin{array}{ccl} t(s_{1},...,s_{k})^{\mathbf{A}}[\vec{a}] &amp; = &amp; f(t_{1}(s_{1},...,s_{k}),...,t_{m}(s_{1},...,s_{k}))^{\mathbf{A}}[\vec{a}]\\ &amp; = &amp; f^{\mathbf{A}}(t_{1}(s_{1},...,s_{k})^{\mathbf{A}}[\vec{a}],...,t_{m}(s_{1},...,s_{k})^{\mathbf{A}}[\vec{a}])\\ &amp; = &amp; f^{\mathbf{A}}(t_{1}^{\mathbf{A}}[s_{1}^{\mathbf{A}}[\vec{a}],...,s_{k}^{\mathbf{A}}[\vec{a}]],...,t_{m}^{\mathbf{A}}[s_{1}^{\mathbf{A}}[\vec{a}],...,s_{k}^{\mathbf{A}}[\vec{a}]])\\ &amp; = &amp; t^{\mathbf{A}}[s_{1}^{\mathbf{A}}[\vec{a}],...,s_{k}^{\mathbf{A}}[\vec{a}]] \end{array} \]                      □
</p>
   </div>
<!-- l. 14872 --><p class='indent'>   @@finpagina@@ 
</p><!-- l. 14879 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>7.3   </span> <a id='x1-1830007.3'></a>Notacion declaratoria para formulas</h4>
<!-- l. 14881 --><p class='noindent'>Si \(\varphi \) es una formula de tipo \(\tau \), entonces escribiremos \(\varphi =_{d}\varphi (v_{1},...,v_{n})\) para declarar que \(v_{1},...,v_{n}\) son variables
distintas tales que \(Li(\varphi )\subseteq \{v_{1},...,v_{n}\}\). Tal como para el caso de terminos, el uso de declaraciones de la
forma \(\varphi =_{d}\varphi (v_{1},...,v_{n})\) sera muy util cuando se convina con ciertas convenciones notacionales que
describiremos a continuacion.

     </p><dl class='description'><dt class='description'>
<span class='cmbx-10'>Convencion Notacional 4:</span> </dt><dd class='description'>Cuando hayamos hecho la declaracion \(\varphi =_{d}\varphi (v_{1},...,v_{n})\), si \(P_{1},...,P_{n}\) son
     palabras  cualesquiera,  entonces  \(\varphi (P_{1},...,P_{n})\)  denotara  la  palabra  que  resulta  de
     reemplazar (simultaneamente) cada ocurrencia libre de \(v_{1}\) en \(\varphi \), por \(P_{1}\), cada
     ocurrencia libre de \(v_{2}\) en \(\varphi \), por \(P_{2}\), etc.</dd></dl>
<!-- l. 14895 --><p class='noindent'>Notese que cuando las palabras \(P_{i}^{\prime }s\) son terminos, \(\varphi (P_{1},...,P_{n})\) es una formula. Ademas notese
que tal como para el caso de terminos, en esta convencion notacional, el
orden de las variables \(v_{1},...,v_{n}\) es clave. Es facil dar el ejemplo analogo al dado para
terminos.
     </p><dl class='description'><dt class='description'>
<span class='cmbx-10'>Convencion Notacional 5:</span> </dt><dd class='description'>Cuando hayamos declarado \(\varphi =_{d}\varphi (v_{1},...,v_{n})\), si \(\mathbf{A}\) es un modelo de
     tipo \(\tau \) y \(a_{1},...,a_{n}\in A\), entonces \(\mathbf{A}\models \varphi [a_{1}...,a_{n}]\) significara que \(\mathbf{A}\models \varphi [\vec{b}],\) donde \(\vec{b}\) es una asignacion tal que a cada
     \(v_{i}\) le asigna el valor \(a_{i}\). (Notese que esta definicion es inambigua gracias al
     Lema <a href='#x1-173019r189'>189<!-- tex4ht:ref: independencia1  --></a>). En gral \(\mathbf{A}\not \models \varphi [a_{1},....,a_{n}]\) significara que no sucede \(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\)</dd></dl>
<!-- l. 14909 --><p class='noindent'>Nuevamente cabe destacar que en esta convencion notacional, el orden de las
variables \(v_{1},...,v_{n}\) es clave y dejamos al lector encontrar un ejemplo donde esto se
vea claramente. Para establecer nuestra Convencion Notacional 6, debemos
antes enunciar un lema clave el cual el lector no tendra inconvenientes en
probar.
</p>
   <div class='newtheorem'>
<!-- l. 14914 --><p class='noindent'><span class='head'>
<a id='x1-183001r204'></a>
<span class='cmbx-10'>Lema 204.</span>  </span><span class='cmti-10'>Sea</span> \(\tau \) <span class='cmti-10'>un tipo cualquiera y</span> \(\varphi \in F^{\tau }\)<span class='cmti-10'>. Supongamos</span> \(\varphi =_{d}\varphi (v_{1},...,v_{n})\)<span class='cmti-10'>. Entonces se una y solo una de
</span><span class='cmti-10'>las siguientes:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-183002x204'>\(\varphi =(t\equiv s)\)<span class='cmti-10'>, con</span> \(t,s\in T^{\tau }\)<span class='cmti-10'>, unicos y tales que las variables que ocurren en</span> \(t\) <span class='cmti-10'>o en</span> \(s\) <span class='cmti-10'>estan todas
     </span><span class='cmti-10'>en</span> \(\{v_{1},...,v_{n}\}\)
     </li>
     <li class='enumerate' id='x1-183003x204'>\(\varphi =r(t_{1},...,t_{m})\)<span class='cmti-10'>, con</span> \(r\in \mathcal{R}_{m}\)<span class='cmti-10'> y</span> \(t_{1},...,t_{m}\in T^{\tau }\)<span class='cmti-10'>, unicos y tales que las variables que ocurren en cada</span> \(t_{i}\) <span class='cmti-10'>estan todas
     </span><span class='cmti-10'>en</span> \(\{v_{1},...,v_{n}\}\)
     </li>
     <li class='enumerate' id='x1-183004x204'>\(\varphi =(\varphi _{1}\wedge \varphi _{2})\)<span class='cmti-10'>, con</span> \(\varphi _{1},\varphi _{2}\in F^{\tau }\)<span class='cmti-10'>, unicas y tales que</span> \(Li(\varphi _{1})\cup Li(\varphi _{2})\subseteq \{v_{1},...,v_{n}\}\)
     </li>
     <li class='enumerate' id='x1-183005x204'>\(\varphi =(\varphi _{1}\vee \varphi _{2})\)<span class='cmti-10'>, con</span> \(\varphi _{1},\varphi _{2}\in F^{\tau }\)<span class='cmti-10'>, unicas y tales que</span> \(Li(\varphi _{1})\cup Li(\varphi _{2})\subseteq \{v_{1},...,v_{n}\}\)
     </li>
     <li class='enumerate' id='x1-183006x204'>\(\varphi =(\varphi _{1}\rightarrow \varphi _{2})\)<span class='cmti-10'>, con</span> \(\varphi _{1},\varphi _{2}\in F^{\tau }\)<span class='cmti-10'>, unicas y tales que</span> \(Li(\varphi _{1})\cup Li(\varphi _{2})\subseteq \{v_{1},...,v_{n}\}\)
     </li>
     <li class='enumerate' id='x1-183007x204'>\(\varphi =(\varphi _{1}\leftrightarrow \varphi _{2})\)<span class='cmti-10'>, con</span> \(\varphi _{1},\varphi _{2}\in F^{\tau }\)<span class='cmti-10'>, unicas y tales que</span> \(Li(\varphi _{1})\cup Li(\varphi _{2})\subseteq \{v_{1},...,v_{n}\}\)

     </li>
     <li class='enumerate' id='x1-183008x204'>\(\varphi =\lnot \varphi _{1}\)<span class='cmti-10'>, con</span> \(\varphi _{1}\in F^{\tau }\)<span class='cmti-10'>, unica y tal que</span> \(Li(\varphi _{1})\subseteq \{v_{1},...,v_{n}\}\)
     </li>
     <li class='enumerate' id='x1-183009x204'>\(\varphi =\forall v_{j}\varphi _{1}\)<span class='cmti-10'>, con</span> \(v_{j}\in \{v_{1},...,v_{n}\}\) <span class='cmti-10'>y</span> \(\varphi _{1}\in F^{\tau }\)<span class='cmti-10'>, unicas y tales que</span> \(Li(\varphi _{1})\subseteq \{v_{1},...,v_{n}\}\)
     </li>
     <li class='enumerate' id='x1-183010x204'>\(\varphi =\forall v\varphi _{1}\)<span class='cmti-10'>, con</span> \(v\in Var-\{v_{1},...,v_{n}\}\) <span class='cmti-10'>y</span> \(\varphi _{1}\in F^{\tau }\)<span class='cmti-10'>, unicas y tales que</span> \(Li(\varphi _{1})\subseteq \{v_{1},...,v_{n},v\}\)
     </li>
     <li class='enumerate' id='x1-183011x204'>\(\varphi =\exists v_{j}\varphi _{1}\)<span class='cmti-10'>, con</span> \(v_{j}\in \{v_{1},...,v_{n}\}\) <span class='cmti-10'>y</span> \(\varphi _{1}\in F^{\tau }\)<span class='cmti-10'>, unicas y tales que</span> \(Li(\varphi _{1})\subseteq \{v_{1},...,v_{n}\}\)
     </li>
     <li class='enumerate' id='x1-183012x204'>\(\varphi =\exists v\varphi _{1}\)<span class='cmti-10'>, con</span> \(v\in Var-\{v_{1},...,v_{n}\}\) <span class='cmti-10'>y</span> \(\varphi _{1}\in F^{\tau }\)<span class='cmti-10'>, unicas y tales que</span> \(Li(\varphi _{1})\subseteq \{v_{1},...,v_{n},v\}\)</li></ol>
   </div>
<!-- l. 14945 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 14946 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Induccion en el \(k\) tal que \(\varphi \in F_{k}^{\tau }\)                                                             □
</p>
   </div>
<!-- l. 14950 --><p class='indent'>
     </p><dl class='description'><dt class='description'>
<span class='cmbx-10'>Convencion Notacional 6:</span> </dt><dd class='description'>Cuando hayamos declarado \(\varphi =_{d}\varphi (v_{1},...,v_{n})\), entonces:
     </dd><dt class='description'>
<span class='cmbx-10'>-</span> </dt><dd class='description'>si se da el caso (1) del Lema <a href='#x1-183001r204'>204<!-- tex4ht:ref: si fi =00003D00003D00003D00003D00003D fi(v1,...,vn)  --></a>, supondremos tacitamente que tambien hemos
     hecho las declaraciones \(t=_{d}t(v_{1},...,v_{n})\) y \(s=_{d}s(v_{1},...,v_{n})\).
     </dd><dt class='description'>
<span class='cmbx-10'>-</span> </dt><dd class='description'>si se da el caso (2) del Lema <a href='#x1-183001r204'>204<!-- tex4ht:ref: si fi =00003D00003D00003D00003D00003D fi(v1,...,vn)  --></a>, supondremos tacitamente que tambien hemos
     hecho las declaraciones \(t_{1}=_{d}t_{1}(v_{1},...,v_{n}),...,t_{m}=_{d}t_{m}(v_{1},...,v_{n})\).
     </dd><dt class='description'>
<span class='cmbx-10'>-</span> </dt><dd class='description'>si se da cualquiera de los casos (3), (4), (5) o (6) del Lema <a href='#x1-183001r204'>204<!-- tex4ht:ref: si fi =00003D00003D00003D00003D00003D fi(v1,...,vn)  --></a>, supondremos
     tacitamente que tambien hemos hecho las declaraciones \(\varphi _{1}=_{d}\varphi _{1}(v_{1},...,v_{n})\) y \(\varphi _{2}=_{d}\varphi _{2}(v_{1},...,v_{n})\).
     </dd><dt class='description'>
<span class='cmbx-10'>-</span> </dt><dd class='description'>si se da cualquiera de los casos (7), (8) o (10) del Lema <a href='#x1-183001r204'>204<!-- tex4ht:ref: si fi =00003D00003D00003D00003D00003D fi(v1,...,vn)  --></a>, supondremos
     tacitamente que tambien hemos hecho la declaracion \(\varphi _{1}=_{d}\varphi _{1}(v_{1},...,v_{n})\).

     </dd><dt class='description'>
<span class='cmbx-10'>-</span> </dt><dd class='description'>si se da el caso (9) o el caso (11) del Lema <a href='#x1-183001r204'>204<!-- tex4ht:ref: si fi =00003D00003D00003D00003D00003D fi(v1,...,vn)  --></a>, supondremos tacitamente que
     tambien hemos hecho la declaracion \(\varphi _{1}=_{d}\varphi _{1}(v_{1},...,v_{n},v)\).</dd></dl>
<!-- l. 14970 --><p class='indent'>   El siguiente lema se basa en la Convencion Notacional 6 y nos permite darle
caracter recursivo a la notacion \(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\).
</p>
   <div class='newtheorem'>
<!-- l. 14972 --><p class='noindent'><span class='head'>
<a id='x1-183013r205'></a>
<span class='cmbx-10'>Lema 205.</span>  </span><span class='cmti-10'>Supongamos</span> \(\varphi =_{d}\varphi (v_{1},...,v_{n})\)<span class='cmti-10'>. Sea</span> \(\mathbf{A}=(A,i)\) <span class='cmti-10'>un modelo de tipo</span> \(\tau \) <span class='cmti-10'>y sean</span> \(a_{1},...,a_{n}\in A\)<span class='cmti-10'>. Entonces</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-183014x205'><span class='cmti-10'>Si</span> \(\varphi =(t\equiv s)\)<span class='cmti-10'>, entonces</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-183015x205'>\(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\) <span class='cmti-10'>si y solo si</span> \(t^{\mathbf{A}}[a_{1},...,a_{n}]=s^{\mathbf{A}}[a_{1},...,a_{n}]\)</li></ol>
     </li>
     <li class='enumerate' id='x1-183016x205'><span class='cmti-10'>Si</span> \(\varphi =r(t_{1},...,t_{m})\)<span class='cmti-10'>, entonces</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-183017x205'>\(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\) <span class='cmti-10'>si y solo si</span> \((t_{1}^{\mathbf{A}}[a_{1},...,a_{n}],...,t_{m}^{\mathbf{A}}[a_{1},...,a_{n}])\in r^{\mathbf{A}}\)</li></ol>
     </li>
     <li class='enumerate' id='x1-183018x205'><span class='cmti-10'>Si</span> \(\varphi =(\varphi _{1}\wedge \varphi _{2}),\) <span class='cmti-10'>entonces</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-183019x205'>\(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\) <span class='cmti-10'>si y solo si</span> \(\mathbf{A}\models \varphi _{1}[a_{1},....,a_{n}]\) <span class='cmti-10'>y</span> \(\mathbf{A}\models \varphi _{2}[a_{1},....,a_{n}]\)</li></ol>
     </li>
     <li class='enumerate' id='x1-183020x205'><span class='cmti-10'>Si</span> \(\varphi =(\varphi _{1}\vee \varphi _{2}),\) <span class='cmti-10'>entonces</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-183021x205'>\(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\) <span class='cmti-10'>si y solo si</span> \(\mathbf{A}\models \varphi _{1}[a_{1},....,a_{n}]\) <span class='cmti-10'>o</span> \(\mathbf{A}\models \varphi _{2}[a_{1},....,a_{n}]\)</li></ol>
     </li>
     <li class='enumerate' id='x1-183022x205'><span class='cmti-10'>Si</span> \(\varphi =(\varphi _{1}\rightarrow \varphi _{2}),\) <span class='cmti-10'>entonces</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-183023x205'>\(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\) <span class='cmti-10'>si y solo si</span> \(\mathbf{A}\models \varphi _{2}[a_{1},....,a_{n}]\) <span class='cmti-10'>o</span> \(\mathbf{A}\not \models \varphi _{1}[a_{1},....,a_{n}]\)</li></ol>
     </li>
     <li class='enumerate' id='x1-183024x205'><span class='cmti-10'>Si</span> \(\varphi =(\varphi _{1}\leftrightarrow \varphi _{2}),\) <span class='cmti-10'>entonces</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-183025x205'>\(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\) <span class='cmti-10'>si y solo si ya sea</span> \(\mathbf{A}\models \varphi _{1}[a_{1},....,a_{n}]\) <span class='cmti-10'>y</span> \(\mathbf{A}\models \varphi _{2}[a_{1},....,a_{n}]\) <span class='cmti-10'>o</span> \(\mathbf{A}\not \models \varphi _{1}[a_{1},....,a_{n}]\) <span class='cmti-10'>y</span> \(\mathbf{A}\not \models \varphi _{2}[a_{1},....,a_{n}]\)</li></ol>

     </li>
     <li class='enumerate' id='x1-183026x205'><span class='cmti-10'>Si</span> \(\varphi =\lnot \varphi _{1},\) <span class='cmti-10'>entonces</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-183027x205'>\(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\) <span class='cmti-10'>si y solo si</span> \(\mathbf{A}\not \models \varphi _{1}[a_{1},....,a_{n}]\)</li></ol>
     </li>
     <li class='enumerate' id='x1-183028x205'><span class='cmti-10'>Si</span> \(\varphi =\forall v_{j}\varphi _{1},\) <span class='cmti-10'>entonces</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-183029x205'>\(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\) <span class='cmti-10'>si y solo si</span> \(\mathbf{A}\models \varphi _{1}[a_{1},....,a,...,a_{n}],\) <span class='cmti-10'>para todo</span> \(a\in A.\)</li></ol>
     </li>
     <li class='enumerate' id='x1-183030x205'><span class='cmti-10'>Si</span> \(\varphi =\forall v\varphi _{1},\) <span class='cmti-10'>con</span> \(v\not \in \{v_{1},...,v_{n}\}\) <span class='cmti-10'>y</span> \(\varphi _{1}=_{d}\varphi _{1}(v_{1},...,v_{n},v)\)<span class='cmti-10'>, entonces</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-183031x205'>\(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\) <span class='cmti-10'>si y solo si</span> \(\mathbf{A}\models \varphi _{1}[a_{1},....,a_{n},a]\)<span class='cmti-10'>, para todo</span> \(a\in A.\)</li></ol>
     </li>
     <li class='enumerate' id='x1-183032x205'><span class='cmti-10'>Si</span> \(\varphi =\exists v_{j}\varphi _{1}\)<span class='cmti-10'>, entonces</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-183033x205'>\(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\) <span class='cmti-10'>si y solo si</span> \(\mathbf{A}\models \varphi _{1}[a_{1},....,a,...,a_{n}]\)<span class='cmti-10'>, para algun</span> \(a\in A.\)</li></ol>
     </li>
     <li class='enumerate' id='x1-183034x205'><span class='cmti-10'>Si</span> \(\varphi =\exists v\varphi _{1}\)<span class='cmti-10'>, con</span> \(v\not \in \{v_{1},...,v_{n}\}\) <span class='cmti-10'>y</span> \(\varphi _{1}=_{d}\varphi _{1}(v_{1},...,v_{n},v)\)<span class='cmti-10'>, entonces</span>
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-183035x205'>\(\mathbf{A}\models \varphi [a_{1},....,a_{n}]\) <span class='cmti-10'>si y solo si</span> \(\mathbf{A}\models \varphi _{1}[a_{1},....,a_{n},a]\)<span class='cmti-10'>, para algun</span> \(a\in A.\)</li></ol>
     </li></ol>
   </div>
<!-- l. 15034 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 15035 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Rutina.                                                                                   □
</p>
   </div>

<!-- l. 15040 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>7.4   </span> <a id='x1-1840007.4'></a>Alcance de la ocurrencia de un cuantificador en una formula</h4>
   <div class='newtheorem'>
<!-- l. 15041 --><p class='noindent'><span class='head'>
<a id='x1-184001r206'></a>
<span class='cmbx-10'>Lema 206.</span>  </span><span class='cmti-10'>Si</span> \(Qv\) <span class='cmti-10'>ocurre en</span> \(\varphi \) <span class='cmti-10'>a partir de</span> \(i\)<span class='cmti-10'>, entonces hay una unica formula</span> \(\psi \) <span class='cmti-10'>tal
</span><span class='cmti-10'>que</span> \(Qv\psi \) <span class='cmti-10'>ocurre en</span> \(\varphi \) <span class='cmti-10'>a partir de</span> \(i\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 15047 --><p class='noindent'>
</p>
   <div class='proof'>
<!-- l. 15048 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Por induccion en el \(k\) tal que \(\varphi \in F^{\tau }\).                                                      □
</p>
   </div>
<!-- l. 15052 --><p class='noindent'>Dada una ocurrencia de \(Qv\) en una formula \(\varphi \), la formula \(\psi \) del lema anterior sera llamada
el <span class='cmti-10'>alcance </span>de dicha ocurrencia en \(\varphi \). Notese que dos ocurrencias distintas de \(Qv\) en \(\varphi \)
pueden tener alcances distintos.
</p><!-- l. 15059 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>7.5   </span> <a id='x1-1850007.5'></a>Sustitucion de variables libres</h4>
<!-- l. 15061 --><p class='noindent'>Diremos que \(v\) <span class='cmti-10'>es sustituible por</span> \(w\)<span class='cmti-10'> en</span> \(\varphi \) cuando ninguna ocurrencia libre de \(v\) en \(\varphi \) sucede
dentro de una ocurrencia de una subformula de la forma \(Qw\psi \) en \(\varphi \). En otras palabras \(v\) no
sera sustituible por \(w\) en \(\varphi \) cuando alguna ocurrencia libre de \(v\) en \(\varphi \) suceda dentro de
una ocurrencia en \(\varphi \) de una formula de la forma \(Qw\psi \). Notese que puede suceder
que \(v\) sea sustituible por \(w\) en \(\varphi \) y que sin envargo haya una subformula de la
forma \(Qw\psi \) para la cual \(v\in Li(Qw\psi )\). Dejamos como ejercicio encontrar un ejemplo de esta
situacion.
</p><!-- l. 15072 --><p class='indent'>   Usando lemas anteriores podemos ver que se dan las siguientes propiedades
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-185001x7.5'>Si \(\varphi \) es atomica, entonces \(v\) es sustituible por \(w\) en \(\varphi \)
     </li>
     <li class='enumerate' id='x1-185002x7.5'>Si \(\varphi =(\varphi _{1}\eta \varphi _{2})\), entonces \(v\) es sustituible por \(w\) en \(\varphi \) sii \(v\) es substituible por \(w\) en \(\varphi _{1}\) y \(v\) es
     <!-- l. 15080 --><p class='noindent'>substituible por \(w\) en \(\varphi _{2}\)

     </p></li>
     <li class='enumerate' id='x1-185003x7.5'>Si \(\varphi =\lnot \varphi _{1}\), entonces \(v\) es sustituible por \(w\) en \(\varphi \) sii \(v\) es substituible por \(w\) en \(\varphi _{1}\)
     </li>
     <li class='enumerate' id='x1-185004x7.5'>Si \(\varphi =Qv\varphi _{1}\), entonces \(v\) es sustituible por \(w\) en \(\varphi \)
     </li>
     <li class='enumerate' id='x1-185005x7.5'>Si \(\varphi =Qw\varphi _{1}\) y \(v\in Li(\varphi _{1})\), entonces \(v\) no es sustituible por \(w\) en \(\varphi \)
     </li>
     <li class='enumerate' id='x1-185006x7.5'>Si \(\varphi =Qw\varphi _{1}\) y \(v\not \in Li(\varphi _{1})\), entonces \(v\) es sustituible por \(w\) en \(\varphi \)
     </li>
     <li class='enumerate' id='x1-185007x7.5'>Si \(\varphi =Qu\varphi _{1}\), con \(u\neq v,w\), entonces \(v\) es sustituible por \(w\) en \(\varphi \) sii \(v\) es sustituible por \(w\) en \(\varphi _{1}\)</li></ol>
<!-- l. 15094 --><p class='indent'>   Notese que las propiedades (1),...,(7) pueden usarse para dar una definicion
recursiva de la relacion \("v\) \(\mathit{es\ sustituible\ por\ }w\mathit{\ en}\) \(\varphi "\).
</p><!-- l. 15098 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>7.6   </span> <a id='x1-1860007.6'></a>Teorema de reemplazo para formulas</h4>
<!-- l. 15100 --><p class='noindent'>Ahora si podemos enunciar y probar el primero de nuestros teoremas de
reemplazo. Antes una definicion. Dado un termino \(t\), diremos que una variable \(v\) <span class='cmti-10'>es
</span><span class='cmti-10'>sustituible por</span> \(t\) <span class='cmti-10'>en</span> \(\varphi \) cuando \(v\) sea sustituible en \(\varphi \) por cada variable que ocurre en
\(t\).
</p>
   <div class='newtheorem'>
<!-- l. 15105 --><p class='noindent'><span class='head'>
<a id='x1-186001r207'></a>
<span class='cmbx-10'>Teorema 207.</span>  </span><span class='cmti-10'>Supongamos</span> \(\varphi =_{d}\varphi (w_{1},...,w_{k})\)<span class='cmti-10'>,</span> \(t_{1}=_{d}t_{1}(v_{1},...,v_{n}),...,t_{k}=_{d}t_{k}(v_{1},...,v_{n})\) <span class='cmti-10'>y supongamos ademas que cada</span> \(w_{j}\) <span class='cmti-10'>es sustituible por</span> \(t_{j}\) <span class='cmti-10'>en</span>
\(\varphi .\) <span class='cmti-10'>Entonces</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-186002x207'>\(Li(\varphi (t_{1},...,t_{k}))\subseteq \{v_{1},...,v_{n}\}\)
     </li>
     <li class='enumerate' id='x1-186003x207'><span class='cmti-10'>Si declaramos</span> \(\varphi (t_{1},...,t_{k})=_{d}\varphi (t_{1},...,t_{k})(v_{1},...,v_{n})\)<span class='cmti-10'>, entonces para cada estructura</span> \(\mathbf{A}\) <span class='cmti-10'>y</span> \(\vec{a}\in A^{n}\) <span class='cmti-10'>se tiene </span>\[ \mathbf{A}\models \varphi (t_{1},...,t_{k})[\vec{a}]\text{ si y solo si }\mathbf{A}\models \varphi [t_{1}^{\mathbf{A}}[\vec{a}],...,t_{k}^{\mathbf{A}}[\vec{a}]] \]</li></ol>
   </div>
<!-- l. 15121 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 15122 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Probaremos que se dan (a) y (b), por induccion en el \(l\) tal que \(\varphi \in F_{l}^{\tau }.\) El caso \(l=0\)
es una consecuencia directa del Teorema <a href='#x1-182001r203'>203<!-- tex4ht:ref: reemp-term  --></a>. Supongamos (a) y (b) valen para
cada \(\varphi \in F_{l}^{\tau }\) y sea \(\varphi \in F_{l+1}^{\tau }-F_{l}^{\tau }.\) Notese que se puede suponer que cada \(v_{i}\) ocurre en algun \(t_{i}\), y que cada
\(w_{i}\in Li(\varphi )\), ya que para cada \(\varphi \), el caso general se desprende del caso con estas restricciones.
Hay varios casos
</p><!-- l. 15131 --><p class='indent'>   CASO \(\varphi =\forall w\varphi _{1}\), con \(w\not \in \{w_{1},...,w_{k}\}\).
</p><!-- l. 15133 --><p class='noindent'>Notese que cada \(w_{j}\in Li(\varphi _{1})\). Ademas notese que \(w\not \in \{v_{1},...,v_{n}\}\) ya que de lo contrario \(w\) ocurriria en
algun \(t_{j}\), y entonces \(w_{j}\) no seria sustituible por \(t_{j}\) en \(\varphi \). Sean \[ \begin{array}{ccc} \tilde{t}_{1} &amp; = &amp; t_{1}\\ &amp; \vdots \\ \tilde{t}_{k} &amp; = &amp; t_{k}\\ \tilde{t}_{k+1} &amp; = &amp; w \end{array} \] Declaremos \[ \tilde{t}_{j}=_{d}\tilde{t}_{j}(v_{1},...,v_{n},w) \] Notese que
nuestra Convencion Notacional 6 nos dice que tenemos implicitamente hecha la
declaracion \(\varphi _{1}=_{d}\varphi _{1}(w_{1},...,w_{k},w)\). Por (a) de la hipotesis inductiva tenemos que \[ Li(\varphi _{1}(t_{1},...,t_{k},w))=Li(\varphi _{1}(\tilde{t}_{1},...,\tilde{t}_{k},\tilde{t}_{k+1}))\subseteq \{v_{1},...,v_{n},w\} \] y por lo tanto \[ Li(\varphi (t_{1},...,t_{k}))\subseteq \{v_{1},...,v_{n}\} \] lo
cual prueba (a). Finalmente para probar (b) declaremos \(\varphi (t_{1},...,t_{k})=_{d}\varphi (t_{1},...,t_{k})(v_{1},...,v_{n})\). Se tiene que \[ \begin{array}{c} \mathbf{A}\models \varphi (t_{1},...,t_{k})\mathbf{[}\vec{a}]\\ \Updownarrow \\ \mathbf{A}\models \varphi _{1}(\tilde{t}_{1},...,\tilde{t}_{k},\tilde{t}_{k+1})[\vec{a},a]\text{, para todo }a\in A\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \Updownarrow \ \text{(por HI)}\\ \mathbf{A}\models \varphi _{1}[\tilde{t}_{1}^{\mathbf{A}}[\vec{a},a],...,\tilde{t}_{k}^{\mathbf{A}}[\vec{a},a],\tilde{t}_{k+1}^{\mathbf{A}}[\vec{a},a]]\text{, para todo }a\in A\\ \Updownarrow \\ \mathbf{A}\models \varphi _{1}[t_{1}^{\mathbf{A}}[\vec{a}],...,t_{k}^{\mathbf{A}}[\vec{a}],a]\text{, para todo }a\in A\\ \Updownarrow \\ \mathbf{A}\models \varphi [t_{1}^{\mathbf{A}}[\vec{a}],...,t_{k}^{\mathbf{A}}[\vec{a}]] \end{array} \] lo cual
pueba (b). Dejamos al lector los casos restantes.                                       □
</p>
   </div>
<!-- l. 15178 --><p class='indent'>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-186004x7.6'>Sea \(\tau =(\emptyset ,\{f\},\emptyset ,\{(f,1)\})\). Sean \(\varphi =\exists v_{1}(f(v_{1})\equiv w_{1})\) y \(t=v_{1}\), donde \(v_{1}\) y \(w_{1}\) son variables distintas. Declaremos \(\varphi =_{d}\varphi (w_{1})\) y \(t=_{d}t(v_{1})\). Notese que \(w_{1}\) no
     es sustituible en \(\varphi \) por \(t\), por lo cual el teorema anterior no se puede aplicar. De
     hecho la conclusion del teorema no se da en este caso ya que puede verse
     facilmente que, cualesquiera sea la estructura de tipo \(\tau \), \(\mathbf{A}\) y \(a_{1}\in A\), tenemos
     que:
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-186006x1'>\(\mathbf{A}\models \varphi (t)[a_{1}]\) si y solo si \(f^{\mathbf{A}}\) tiene un pto fijo, es decir, \(f^{\mathbf{A}}(a)=a\), para algun \(a\in A\)
         </li>
         <li class='enumerate' id='x1-186008x2'>\(\mathbf{A}\models \varphi [t^{\mathbf{A}}[a_{1}]]\) si y solo si \(a_{1}\) esta en la imagen de \(f^{\mathbf{A}}\)</li></ol>
     <!-- l. 15192 --><p class='noindent'>las cuales son condiciones claramente no equivalentes.</p></li></ol>
<!-- l. 15198 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>8   </span> <a id='x1-1870008'></a>Teorias de primer orden</h3>
<!-- l. 15200 --><p class='noindent'>Una <span class='cmti-10'>teoria de primer orden </span>sera un par \((\Sigma ,\tau )\), donde \(\tau \) es un tipo y \(\Sigma \) es un conjunto de
sentencias de tipo \(\tau \). Los elementos de \(\Sigma \) seran llamados <span class='cmti-10'>axiomas propios </span>de \((\Sigma ,\tau )\). Un <span class='cmti-10'>modelo
</span><span class='cmti-10'>de</span> \((\Sigma ,\tau )\) sera una estructura de tipo \(\tau \) la cual satisfaga todos los axiomas propios de \((\Sigma ,\tau )\). Hay
ejemplos muy naturales de teorias de primer orden, a continuacion damos
algunos.
</p><!-- l. 15210 --><p class='indent'>   <span class='cmbx-10'>Posets. </span>Sea \[ Po=(\{\mathrm{A}_{\leq R},\mathrm{A}_{\leq T},\mathrm{A}_{\leq A}\},\tau _{Po}) \] donde \(\tau _{Po}=(\emptyset ,\emptyset ,\{\leq \},\{(\leq ,2)\})\) y </p><div class='eqnarray'>\begin{eqnarray*} \mathrm{A}_{\leq R} &amp; = &amp; \forall x_{1}\;x_{1}\leq x_{1}\\ \mathrm{A}_{\leq T} &amp; = &amp; \forall x_{1}\forall x_{2}\forall x_{3}\;((x_{1}\leq x_{2}\wedge x_{2}\leq x_{3})\rightarrow x_{1}\leq x_{3})\\ \mathrm{A}_{\leq A} &amp; = &amp; \forall x_{1}\forall x_{2}\;((x_{1}\leq x_{2}\wedge x_{2}\leq x_{1})\rightarrow x_{1}\equiv x_{2}) \end{eqnarray*}
</div>Notese que una estructura \(\mathbf{A}\) de tipo \(\tau _{Po}\) es un modelo de \(Po\) si y solo si \(\leq ^{\mathbf{A}}\) es un orden parcial
sobre \(A\). Estrictamente hablando un modelo de \(Po\) no es un poset ya que es un par \((A,i)\) donde

\(A\) es un cojunto no vacio e \(i\) es una funcion con dominio \(\{\leq \}\) tal que \(i(\leq )\) es un orden
parcial sobre \(A\). Es decir, un modelo de \(Po\) es un par \((A,\{(\leq ,R)\})\) donde \(A\) es un conjunto
no vacio y \(R\) es un orden parcial sobre \(A\). De todas maneras deberia quedar
claro que en esencia un poset y un modelo de \(Po\) son la misma cosa por lo
cual llamaremos a \(Po\) la <p><span class='cmti-10'>teoria de los posets </span></p>y muchas veces nos referiremos
a los modelos de \(Po\) como si fueran posets. Dejamos al lector el ejercicio de
encontrar una biyeccion natural entre la clase de los modelos de \(Po\) y la clase de los
posets.
<!-- l. 15236 --><p class='indent'>   <span class='cmbx-10'>Reticulados. </span>Ahora consideraremos una nueva teoria de primer orden que
llamaremos \(Ret\). Sea \(\tau _{Ret}=(\emptyset ,\{\mathsf{s}^{2},\mathsf{i}^{2}\},\{\leq ^{2}\},a)\) y sea \(\Sigma _{Ret}\) el siguiente conjunto de sentencias: </p><div class='eqnarray'>\begin{eqnarray*} \mathrm{A}_{\leq R} &amp; = &amp; \forall x\;x\leq x\\ \mathrm{A}_{\leq A} &amp; = &amp; \forall x\forall y\;\left (\left (x\leq y\wedge y\leq x\right )\rightarrow x\equiv y\right )\\ \mathrm{A}_{\leq T} &amp; = &amp; \forall x\forall y\forall z\;\left ((x\leq y\wedge y\leq z)\rightarrow x\leq z\right )\\ \mathrm{A}_{\mathsf{s}esC} &amp; = &amp; \forall x\forall y\;(x\leq x\;\mathsf{s}\;y\wedge y\leq x\;\mathsf{s}\;y)\\ \mathrm{A}_{\mathsf{s}\leq C} &amp; = &amp; \forall x\forall y\forall z\;\left ((x\leq z\wedge y\leq z)\rightarrow x\;\text{\ensuremath{\mathsf{s\;}}}y\leq z\right )\\ \mathrm{A}_{\mathsf{i}esC} &amp; = &amp; \forall x\forall y\;(x\;\mathsf{i}\;y\leq x\wedge x\;\mathsf{i}\;y\leq y)\\ \mathrm{A}_{\mathsf{i}\geq C} &amp; = &amp; \forall x\forall y\forall z\;\left ((z\leq x\wedge z\leq y)\rightarrow z\leq x\;\mathsf{i}\;y\right ) \end{eqnarray*}
</div>Definamos \(Ret=(\Sigma _{Ret},\tau _{Ret})\). Comenzaremos estudiando un poco qué significan los axiomas de
\(Ret\).
     <ol class='enumerate1'>
     <li class='enumerate' id='x1-187001x8'>Una estructura \(\mathbf{A}\) de tipo \(\tau _{Ret}\) satisface los 3 primeros axiomas de \(Ret\) si y solo si
     el par \((A,\leq ^{\mathbf{A}})\) es un poset. Aqui es muy importante notar que una estructura \(\mathbf{A}\)
     de tipo \(\tau _{Ret}\) puede satisfacer los 3 axiomas mencionados antes pero esto no
     implica que las operaciones \(\mathsf{s}^{\mathbf{A}}\) e \(\mathsf{i}^{\mathbf{A}}\) deban ser las operaciones infimo y supremo
     respecto al orden \(\leq ^{\mathbf{A}}\). De hecho el poset \((A,\leq ^{\mathbf{A}})\) podria no tener supremo para algun
     subconjunto \(\{a,b\}\).
     </li>
     <li class='enumerate' id='x1-187002x8'>Una estructura \(\mathbf{A}\) que satisfaga los 3 primeros axiomas satisfacera el axioma
     \(\mathrm{A}_{\mathsf{s}esC}\) si y solo si cualesquiera sean los elementos \(a,b\in A\), se tiene que \(a\;\mathsf{s}^{\mathbf{A}}\;b\) es cota superior
     del conjunto \(\{a,b\}\) en el poset \((A,\leq ^{\mathbf{A}})\). Por supuesto esto no garaniza que \(a\;\mathsf{s}^{\mathbf{A}}\;b\) sea el
     supremo de \(\{a,b\}\) en \((A,\leq ^{\mathbf{A}})\), solo nos dice que debe ser una cota superior
     </li>
     <li class='enumerate' id='x1-187003x8'>Una estructura \(\mathbf{A}\) que satisfaga los 3 primeros axiomas cumplirá \(\mathrm{A}_{\mathsf{s}\leq C}\) si y solo
     si cualesquiera sean los elementos \(a,b\in A\), se tiene que \(a\;\mathsf{s}^{\mathbf{A}}\;b\) es menor o igual que toda
     cota superior de \(\{a,b\}\) en \((A,\leq ^{\mathbf{A}})\).</li></ol>
<!-- l. 15271 --><p class='noindent'>De las observaciones anteriores el lector ya se habra dado cuenta que dada una
estructura \(\mathbf{A}\) de tipo \(\tau _{Ret}\) son equivalentes
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-187005x1'>\(\mathbf{A}\) es modelo de \(Ret\)
     </li>
     <li class='enumerate' id='x1-187007x2'>\((A,\leq ^{\mathbf{A}})\) es un poset y cualesquiera sean \(a,b\in A\)
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-187009x1'>\(a\;\mathsf{s}^{\mathbf{A}}\;b=\) supremo de \(\{a,b\}\) en \((A,\leq ^{\mathbf{A}})\)
         </li>
         <li class='enumerate' id='x1-187011x2'>\(a\;\mathsf{i}^{\mathbf{A}}\;b=\) infimo de \(\{a,b\}\) en \((A,\leq ^{\mathbf{A}})\)</li></ol>
     </li></ol>

<!-- l. 15284 --><p class='indent'>   <span class='cmbx-10'>Grafos. </span>Sea \(\tau _{Gr}=(\emptyset ,\emptyset ,\{r\},\{(r,2)\})\) y
</p><!-- l. 15294 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>8.1   </span> <a id='x1-1880008.1'></a>Definicion del concepto de prueba formal</h4>
<!-- l. 15296 --><p class='noindent'>Ahora consideremos la siguiente sentencia de tipo \(\tau _{Po}\) \[ \mu =\forall x_{1}\forall x_{2}\left ((\forall x_{3}\ x_{3}\leq x_{1}\wedge \forall x_{3}\ x_{3}\leq x_{2})\rightarrow x_{1}\equiv x_{2})\right ) \] Notese que si \(\mathbf{A}\) es un modelo de \(Po\)
(i.e. ”un poset”), entonces la formula \(\forall x_{3}\ x_{3}\leq x_{1}\) ”dice en \(\mathbf{A}\)” que ”\(x_{1}\) es un maximo”. Es decir que
la sentencia \(\mu \) dice en \(\mathbf{A}\) que si \(x_{1}\) y \(x_{2}\) son maximos entonces son iguales. Sabemos que \(\mu \) es
verdadera en todo modelo de \(Po\) ya que esto lo probamos elementalmente en la seccion
de posets. A continuacion escribiremos la prueba mas formalmente de la mano de la
sintaxis de primer orden:
</p><!-- l. 15311 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 15311 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Prueba de</span> \(\mu \)<span class='cmti-10'>.</span> </span> Denotemos con \(a\) y \(b\) un par de elementos de \(A\), fijos. Supongamos \[ (\forall x_{3}\ x_{3}\leq a\wedge \forall x_{3}\ x_{3}\leq b) \]
En particular \(\forall x_{3}\ x_{3}\leq b\) nos dice que \(a\leq b\) y \(\forall x_{3}\ x_{3}\leq a\) nos dice que \(b\leq a\), por lo cual tenemos que \[ a\leq b\wedge b\leq a \] Pero el
axioma \[ \varphi _{A}=\forall x_{1}\forall x_{2}\;((x_{1}\leq x_{2}\wedge x_{2}\leq x_{1})\rightarrow x_{1}\equiv x_{2}) \] nos dice que \[ (a\leq b\wedge b\leq a)\rightarrow a\equiv b \] obteniendo de esta forma que \(a\equiv b\). O sea que hemos probado
que \[ (\forall x_{3}\ x_{3}\leq a\wedge \forall x_{3}\ x_{3}\leq b)\rightarrow a\equiv b \] Como \(a\) y \(b\) eran elementos cualesquiera, obtenemos que vale \(\mu \)                 □
</p>
   </div>
<!-- l. 15339 --><p class='indent'>   Como puede notarse, sacando las aclaraciones en castellano, la prueba anterior
solo usa sentencias del tipo \((\{a,b\},\emptyset ,\{\leq \},\{(\leq ,2)\})\), es decir \(\tau _{Po}\) con dos nombres de constante agregados.
Ademas la argumentacion es completamente elemental y solida, es decir se basa solo
en los axiomas de \(Po\) y cada paso es obvio e incuestionable.
</p><!-- l. 15345 --><p class='indent'>   Consideremos ahora \(Ret\). Hay muchas propiedades que valen en todos los modelos de \(Ret\)
las cuales pueden ser probadas con el caracter elemental de la prueba recien dada
para \(Po\). Por ejemplo, sea \[ \psi =\forall x\forall y\forall z\forall w\;\left ((x\leq z\wedge y\leq w)\rightarrow x\;\mathsf{s}\;y\leq z\;\mathsf{s}\;w\right ) \] Daremos aqui una prueba de \(\psi \) con dicha consigna de hacerla
con sentencias de \(\tau _{Ret}\) mas simbolos de constante auxiliares y con argumentos solidos y
elementales. Por supuesto dicha prueba solo podra usar como hipotesis los axiomas
de \(Ret\).
</p><!-- l. 15358 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 15358 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Prueba de</span> \(\psi \)<span class='cmti-10'>.</span> </span> Denotemos con \(a,b,c,d\) elementos de \(A\), fijos. Supongamos
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188001x8.1'>\(a\leq c\wedge b\leq d\)</li></ol>
<!-- l. 15363 --><p class='noindent'>Por el axioma \(\mathrm{A}_{\mathsf{s}esC}\) tenemos que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188002x8.1'>\(c\leq c\;\mathsf{s}\;d\)</li></ol>
<!-- l. 15367 --><p class='noindent'>O sea que tenemos
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188003x8.1'>\(a\leq c\wedge c\leq c\;\mathsf{s}\;d\)</li></ol>
<!-- l. 15371 --><p class='noindent'>Pero \(\mathrm{A}_{\leq T}\) nos dice que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188004x8.1'>\((a\leq c\wedge c\leq c\;\mathsf{s}\;d)\rightarrow a\leq c\;\mathsf{s}\;d\)</li></ol>
<!-- l. 15375 --><p class='noindent'>lo cual nos dice que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188005x8.1'>\(a\leq c\;\mathsf{s}\;d\)</li></ol>
<!-- l. 15379 --><p class='noindent'>Por el axioma \(\mathrm{A}_{\mathsf{s}esC}\) tenemos que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188006x8.1'>\(d\leq c\;\mathsf{s}\;d\)</li></ol>
<!-- l. 15383 --><p class='noindent'>O sea que por (1) y (6) tenemos
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188007x8.1'>\(b\leq d\wedge d\leq c\;\mathsf{s}\;d\)</li></ol>
<!-- l. 15387 --><p class='noindent'>Pero \(\mathrm{A}_{\leq T}\) nos dice que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188008x8.1'>\((b\leq d\wedge d\leq c\;\mathsf{s}\;d)\rightarrow b\leq c\;\mathsf{s}\;d\)</li></ol>
<!-- l. 15391 --><p class='noindent'>lo cual nos dice que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188009x8.1'>\(b\leq c\;\mathsf{s}\;d\)</li></ol>
<!-- l. 15395 --><p class='noindent'>De (5) y (9) tenemos que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188010x8.1'>\(a\leq c\;\mathsf{s}\;d\wedge b\leq c\;\mathsf{s}\;d\)</li></ol>
<!-- l. 15399 --><p class='noindent'>Pero \(\mathrm{A}_{\mathsf{s}\leq C}\) nos dice que

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188011x8.1'>\((a\leq c\;\mathsf{s}\;d\wedge b\leq c\;\mathsf{s}\;d)\rightarrow a\;\mathsf{s\;}b\leq c\;\mathsf{s}\;d\)</li></ol>
<!-- l. 15403 --><p class='noindent'>De donde sacamos
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188012x8.1'>\(a\;\mathsf{s\;}b\leq c\;\mathsf{s}\;d\)</li></ol>
<!-- l. 15407 --><p class='noindent'>Ya que habiamos asumido que \(a\leq c\wedge b\leq d\), lo que hemos probado es
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188013x8.1'>\((a\leq c\wedge b\leq d)\rightarrow a\;\mathsf{s\;}b\leq c\;\mathsf{s}\;d\)</li></ol>
<!-- l. 15412 --><p class='noindent'>Ya que \(a,b,c,d\) eran elementos cualesquiera tenemos que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-188014x8.1'>\(\forall x\forall y\forall z\forall w\;\left ((x\leq z\wedge y\leq w)\rightarrow x\;\mathsf{s}\;y\leq z\;\mathsf{s}\;w\right )\)</li></ol>
                                                                 □
   </div>
<!-- l. 15419 --><p class='indent'>   Como hemos visto en los ejemplos anteriores, dada una teoria \((\Sigma ,\tau )\) hay teoremas
acerca de los modelos de dicha teoria cuyos enunciados y pruebas se pueden expresar
usando solamente sentencias del tipo \(\tau \) extendido por nombres de constantes y en
dichas demostraciones ademas cada paso es solido simple e incuestionable. Otro razgo
caracteristico de estas demostraciones es que el matematico que las realiza solo tiene,
a manera de hipotesis o punto de partida, una estructura \(\mathbf{A}\) de tipo \(\tau \) de la cual solo
sabe que satisface las sentencias de \(\Sigma \) y esta es la unica informacion que podra usar en
la prueba. A este tipo de pruebas las llamaremos <span class='cmti-10'>elementales</span>. Por supuesto el
concepto de prueba elemental por el momento no es un concepto precisamente
definido sino mas bien una idea basada en ciertos ejemplos de la vida real de los
matematicos.
</p><!-- l. 15433 --><p class='indent'>   En esta seccion daremos una modelizacion matematica del concepto de prueba
elemental. A estos objetos matematicos que modelizaran a las pruebas elementales los
llamaremos <span class='cmti-10'>pruebas formales</span>
</p><!-- l. 15437 --><p class='indent'>   Tal como lo vimos en los ejemplos anteriores e informalmente hablando, una
prueba formal sera una sucecion de sentencias junto con una sucesion de
”justificaciones” las cuales van explicando o justificando por que es licito que cada
una de dichas sentencias aparezca en la sucesion. Por supuesto nuestra definicion sera
precisa y matematica por lo que deberemos trabajar bastante para poder escribirla
correctamente. Como objeto matematico una prueba formal resultara ser un par
ordenado de palabras cuya primera coordenada codificara en forma natural la
sucesion de sentencias y su segunda coordenada codificara la sucesion de
justificaciones.
</p><!-- l. 15448 --><p class='indent'>   La formalizacion matematica del concepto de prueba elemental es uno de los
grandes logros de la ciencia moderna y este hecho se debe fundamentalmente a que si
elejimos bien la teoria, las pruebas elementales no son ni mas ni menos que las
pruebas de la matematica misma por lo cual se tiene una definicion matematica de la
deduccion matematica misma!

</p><!-- l. 15457 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>8.1.1   </span> <a id='x1-1890008.1.1'></a>Reglas</h5>
<!-- l. 15459 --><p class='noindent'>Definiremos una serie de conjuntos los cuales poseen informacion deductiva basica, es
decir representan las reglas usuales con las que los matematicos dan pasos dentro de
una demostracion.
</p><!-- l. 15463 --><p class='indent'>   Recordemos que si \(\tau \) es un tipo cualquiera, un termino \(t\in T^{\tau }\) es llamado <span class='cmti-10'>cerrado</span> si
ninguna variable es subtermino de \(t\). Con \(T_{c}^{\tau }\) denotamos el conjunto formado por todos
los terminos cerrados.
</p><!-- l. 15468 --><p class='indent'>   Sean </p><div class='eqnarray'>\begin{eqnarray*} Partic^{\tau } &amp; = &amp; \{(\forall v\varphi (v),\varphi (t)):\varphi =_{d}\varphi (v)\in F^{\tau }\ \mathrm{y\ }t\in T_{c}^{\tau }\}\\ Exist^{\tau } &amp; = &amp; \{(\varphi (t),\exists v\varphi (v)):\varphi =_{d}\varphi (v)\in F^{\tau }\ \mathrm{y\ }t\in T_{c}^{\tau }\}\\ Evoc^{\tau } &amp; = &amp; \{(\varphi ,\varphi ):\varphi \in S^{\tau }\}\\ Absur^{\tau } &amp; = &amp; \{((\lnot \varphi \rightarrow (\psi \wedge \lnot \psi )),\varphi ):\varphi ,\psi \in S^{\tau }\}\cup \{((\varphi \rightarrow (\psi \wedge \lnot \psi )),\lnot \varphi ):\varphi ,\psi \in S^{\tau }\}\\ ConjElim^{\tau } &amp; = &amp; \{((\varphi \wedge \psi ),\varphi ):\varphi ,\psi \in S^{\tau }\}\cup \{((\varphi \wedge \psi ),\psi ):\varphi ,\psi \in S^{\tau }\}\\ EquivElim^{\tau } &amp; = &amp; \{((\varphi \leftrightarrow \psi ),(\varphi \rightarrow \psi )):\varphi ,\psi \in S^{\tau }\}\cup \{((\varphi \leftrightarrow \psi ),(\psi \rightarrow \varphi )):\varphi ,\psi \in S^{\tau }\}\\ DisjInt^{\tau } &amp; = &amp; \{(\varphi ,(\varphi \vee \psi )):\varphi ,\psi \in S^{\tau }\}\cup \{(\psi ,(\varphi \vee \psi )):\varphi ,\psi \in S^{\tau }\} \end{eqnarray*}
</div>Diremos que \(\varphi \) <p><span class='cmti-10'>se deduce de</span></p> \(\psi \) <p><span class='cmti-10'>por la regla de particularizacion </span></p>(resp. <p><span class='cmti-10'>existencia,</span></p>
<p><span class='cmti-10'>evocacion, absurdo, conjuncion-eliminacion, equivalencia-eliminacion,</span></p>
<p><span class='cmti-10'>disjuncion-introduccion</span></p>), <p><span class='cmti-10'>con respecto a</span></p> \(\tau \) para expresar que \((\psi ,\varphi )\in Partic^{\tau }\) (resp. \((\psi ,\varphi )\in Exist^{\tau }\), \((\psi ,\varphi )\in Evoc^{\tau }\), \((\psi ,\varphi )\in Absur^{\tau }\), \((\psi ,\varphi )\in ConjElim^{\tau }\), \((\psi ,\varphi )\in EquivElim^{\tau }\),
\((\psi ,\varphi )\in DisjInt^{\tau }\)).
<!-- l. 15486 --><p class='indent'>   Sea \[ Commut^{\tau }=Commut1^{\tau }\cup Commut2^{\tau } \] donde </p><div class='eqnarray'>\begin{eqnarray*} Commut1^{\tau } &amp; = &amp; \{((t\equiv s),(s\equiv t)):s,t\in T_{c}^{\tau }\}\\ Commut2^{\tau } &amp; = &amp; \{((\varphi \leftrightarrow \psi ),(\psi \leftrightarrow \varphi )):\varphi ,\psi \in S^{\tau }\} \end{eqnarray*}
</div>Diremos que \(\varphi \) <p><span class='cmti-10'>se deduce de</span></p> \(\psi \) <p><span class='cmti-10'>por la regla de commutatividad</span></p>, <p><span class='cmti-10'>con respecto a</span></p> \(\tau \) para
expresar que \((\psi ,\varphi )\in Commut^{\tau }\).
<!-- l. 15499 --><p class='indent'>   Sean </p><div class='eqnarray'>\begin{eqnarray*} ModPon^{\tau } &amp; = &amp; \{(\varphi ,(\varphi \rightarrow \psi ),\psi ):\varphi ,\psi \in S^{\tau }\}\\ ConjInt^{\tau } &amp; = &amp; \{(\varphi ,\psi ,(\varphi \wedge \psi )):\varphi ,\psi \in S^{\tau }\}\\ EquivInt^{\tau } &amp; = &amp; \{((\varphi \rightarrow \psi ),(\psi \rightarrow \varphi ),(\varphi \leftrightarrow \psi )):\varphi ,\psi \in S^{\tau }\}\\ DisjElim^{\tau } &amp; = &amp; \{(\lnot \varphi ,(\varphi \vee \psi ),\psi ):\varphi ,\psi \in S^{\tau }\}\cup \{(\lnot \psi ,(\varphi \vee \psi ),\varphi ):\varphi ,\psi \in S^{\tau }\} \end{eqnarray*}
</div>Diremos que \(\varphi \) <p><span class='cmti-10'>se deduce de</span></p> \(\psi _{1}\) y \(\psi _{2}\) <p><span class='cmti-10'>por la regla de Modus Ponens </span></p>(resp.
<p><span class='cmti-10'>conjuncion-introduccion, equivalencia-introduccion, disjuncion-eliminacion</span></p>), <p><span class='cmti-10'>con</span></p>
<p><span class='cmti-10'>respecto a</span></p> \(\tau \) para expresar que \((\psi _{1},\psi _{2},\varphi )\in ModPon^{\tau }\) (resp. \((\psi _{1},\psi _{2},\varphi )\in ConjInt^{\tau }\), \((\psi _{1},\psi _{2},\varphi )\in EquivInt^{\tau }\), \((\psi _{1},\psi _{2},\varphi )\in DisjElim^{\tau }\)). Sea \[ DivPorCas^{\tau }=\{((\varphi _{1}\vee \varphi _{2}),(\varphi _{1}\rightarrow \psi ),(\varphi _{2}\rightarrow \psi ),\psi ):\varphi _{1},\varphi _{2},\psi \in S^{\tau }\} \] Diremos que \(\varphi \) <p><span class='cmti-10'>se deduce de</span></p> \(\psi _{1}\), \(\psi _{2}\) y \(\psi _{3}\)
<p><span class='cmti-10'>por la regla de division por casos, con respecto a</span></p> \(\tau \) para expresar que \((\psi _{1},\psi _{2},\psi _{3},\varphi )\in DivPorCas^{\tau }\). Sea \[ Reemp^{\tau }=Reemp1^{\tau }\cup Reemp2^{\tau } \]
donde
<!-- l. 15524 --><p class='indent'>   \(Reemp1^{\tau }=\{((t\equiv s),\gamma ,\tilde{\gamma }):s,t\in T_{c}^{\tau },\)
</p><!-- l. 15526 --><p class='indent'>   \(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \gamma \in S^{\tau }\ \mathrm{y\ }\tilde{\gamma }=\mathrm{resultado\ de\ reemplazar\ en\ }\gamma \ \mathrm{una\ ocurrencia\ de\ }t\ \mathrm{por\ }s\}\)
</p><!-- l. 15528 --><p class='indent'>   \(Reemp2^{\tau }=\{(\forall v_{1}...\forall v_{n}(\varphi \leftrightarrow \psi ),\gamma ,\tilde{\gamma }):\varphi ,\psi \in F^{\tau }\), \(Li(\varphi )=Li(\psi )=\{v_{1},...,v_{n}\}\),
</p><!-- l. 15531 --><p class='indent'>   \(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ n\geq 0,\) \(\gamma \in S^{\tau }\ \mathrm{y\ }\tilde{\gamma }=\mathrm{resultado\ de\ reemplazar\ en\ }\gamma \ \mathrm{una\ ocurrencia\ de\ }\varphi \ \mathrm{por\ }\psi \}\)
</p><!-- l. 15534 --><p class='noindent'>Diremos que \(\varphi \) <span class='cmti-10'>se deduce de</span> \(\psi _{1}\)y \(\psi _{2}\) <span class='cmti-10'>por la regla de reemplazo, con respecto a</span> \(\tau \), para expresar
que \((\psi _{1},\psi _{2},\varphi )\in Reemp^{\tau }\). Sea \[ Trans^{\tau }=Trans1^{\tau }\cup Trans2^{\tau }\cup Trans3^{\tau } \] donde </p><div class='eqnarray'>\begin{eqnarray*} Trans1^{\tau } &amp; = &amp; \{((t\equiv s),(s\equiv u),(t\equiv u)):t,s,u\in T_{c}^{\tau }\}\\ Trans2^{\tau } &amp; = &amp; \{((\varphi \rightarrow \psi ),(\psi \rightarrow \Phi ),(\varphi \rightarrow \Phi )):\varphi ,\psi ,\Phi \in S^{\tau }\}\\ Trans3^{\tau } &amp; = &amp; \{((\varphi \leftrightarrow \psi ),(\psi \leftrightarrow \Phi ),(\varphi \leftrightarrow \Phi )):\varphi ,\psi ,\Phi \in S^{\tau }\} \end{eqnarray*}
</div>Diremos que \(\varphi \) <p><span class='cmti-10'>se deduce de</span></p> \(\psi _{1}\)y \(\psi _{2}\) <p><span class='cmti-10'>por la regla de transitividad, con respecto a</span></p> \(\tau \) para
expresar que \((\psi _{1},\psi _{2},\varphi )\in Trans^{\tau }\). Sea \[ \begin{array}{c} Generaliz^{\tau }=\{(\psi ,\forall v\tilde{\psi }):\psi \in S^{\tau }\text{,}\ v\ \mathrm{no\ ocurre\ en\ }\psi \ \mathrm{y\ existe}\\ \mathrm{\ }c\in \mathcal{C}\ \mathrm{tal\ que\ }c\ \mathrm{ocurre\ en\ }\psi \ \mathrm{y}\ \tilde{\psi }=\mathrm{resultado\ de}\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mathrm{\ reemplazar}\ \mathrm{en\ }\psi \ \mathrm{cada\ ocurrencia\ de\ }c\ \mathrm{por\ }v\} \end{array} \] Es importante el siguiente
   <div class='newtheorem'>
<!-- l. 15559 --><p class='noindent'><span class='head'>
<a id='x1-189001r208'></a>
<span class='cmbx-10'>Lema 208.</span>  </span><span class='cmti-10'>Si</span> \((\varphi _{1},\varphi _{2})\in Generaliz^{\tau }\)<span class='cmti-10'>, entonces el nombre de constante</span> \(c\) <span class='cmti-10'>del cual habla la definicion
</span><span class='cmti-10'>de</span> \(Generaliz^{\tau }\) <span class='cmti-10'>esta univocamente determinado por el par</span> \((\varphi _{1},\varphi _{2})\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 15565 --><p class='indent'>
</p>
   <div class='proof'>

<!-- l. 15566 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que \(c\) es el unico nombre de constante que ocurre en \(\varphi _{1}\) y no ocurre
en \(\varphi _{2}\)                                                                                                  □
</p>
   </div>
<!-- l. 15571 --><p class='indent'>   Escribiremos \((\varphi _{1},\varphi _{2})\in Generaliz^{\tau }\) <span class='cmti-10'>via</span> \(c\) para expresar que \((\varphi _{1},\varphi _{2})\in Generaliz^{\tau }\) y que \(c\) es el unico nombre de constante
que ocurre en \(\varphi _{1}\) y no ocurre en \(\varphi _{2}\). Diremos que \(\varphi _{2}\) <span class='cmti-10'>se deduce de</span> \(\varphi _{1}\) <span class='cmti-10'>por la regla de
</span><span class='cmti-10'>generalizacion con nombre de constante</span> \(c\), <span class='cmti-10'>con respecto a</span> \(\tau \), para expresar que \((\varphi _{1},\varphi _{2})\in Generaliz^{\tau }\) <span class='cmti-10'>via</span>
\(c\)
</p><!-- l. 15580 --><p class='indent'>   @@finpagina@@
</p><!-- l. 15582 --><p class='indent'>   Sea \[ Elec^{\tau }=\{(\exists v\varphi (v),\varphi (e)):\varphi =_{d}\varphi (v)\in F^{\tau },\ Li(\varphi )=\{v\}\ \mathrm{y\ }e\in \mathcal{C}\ \mathrm{no\ ocurre\ en}\ \varphi \} \] Es importante el siguiente
</p>
   <div class='newtheorem'>
<!-- l. 15587 --><p class='noindent'><span class='head'>
<a id='x1-189002r209'></a>
<span class='cmbx-10'>Lema 209.</span>  </span><span class='cmti-10'>Si</span> \((\varphi _{1},\varphi _{2})\in Elec^{\tau }\)<span class='cmti-10'>, entonces el nombre de constante</span> \(e\) <span class='cmti-10'>del cual habla la definicion
</span><span class='cmti-10'>de</span> \(Elec^{\tau }\) <span class='cmti-10'>esta univocamente determinado por el par</span> \((\varphi _{1},\varphi _{2})\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 15593 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 15594 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que \(e\) es el unico nombre de constante que ocurre en \(\varphi _{2}\) y no ocurre
en \(\varphi _{1}\).                                                                                                 □
</p>
   </div>
<!-- l. 15597 --><p class='indent'>   \(\bigskip \)
</p><!-- l. 15599 --><p class='indent'>   Escribiremos \((\varphi _{1},\varphi _{2})\in Elec^{\tau }\) <span class='cmti-10'>via</span> \(e\) para expresar que \((\varphi _{1},\varphi _{2})\in Elec^{\tau }\) y que \(e\) es el unico nombre de constante
que ocurre en \(\varphi _{2}\) y no ocurre en \(\varphi _{1}\). Diremos que \(\varphi _{2}\) <span class='cmti-10'>se deduce de</span> \(\varphi _{1}\) <span class='cmti-10'>por la regla de
</span><span class='cmti-10'>eleccion con nombre de constante</span> \(e\), <span class='cmti-10'>con respecto a</span> \(\tau \) para expresar que \((\varphi _{1},\varphi _{2})\in Elec^{\tau }\) <span class='cmti-10'>via</span>
\(e\).
</p>
   <div class='newtheorem'>
<!-- l. 15606 --><p class='noindent'><span class='head'>
<a id='x1-189003r210'></a>

<span class='cmbx-10'>Lema 210.</span>  </span><span class='cmti-10'>Sea</span>  \(\tau \)  <span class='cmti-10'>un  tipo.  Todas  las  reglas  exepto  las  reglas  de  eleccion  y
</span><span class='cmti-10'>generalizacion son universales en el sentido que si</span> \(\varphi \) <span class='cmti-10'>se deduce de</span> \(\psi _{1},...,\psi _{k}\) <span class='cmti-10'>por alguna de
</span><span class='cmti-10'>estas reglas, entonces</span> \(\left ((\psi _{1}\wedge ...\wedge \psi _{k})\rightarrow \varphi \right )\) <span class='cmti-10'>es una sentencia universalmente valida.</span>
</p>
   </div>
<!-- l. 15614 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 15615 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Veamos que la regla de existencia es universal. Por definicion, un par de
\(Exist^{\tau }\) es siempre de la forma \((\varphi (t),\exists v\varphi (v))\), con \(\varphi =_{d}\varphi (v)\) y \(t\in T_{c}^{\tau }\). Sea \(\mathbf{A}\) una estructura de tipo \(\tau \) tal que \(\mathbf{A}\models \varphi (t)\). Sea \(t^{\mathbf{A}}\) el
valor que toma \(t\) en \(\mathbf{A}\). Por el Lema <a href='#x1-186001r207'>207<!-- tex4ht:ref: reemp-term1  --></a> tenemos que \(\mathbf{A}\models \varphi \left [t^{\mathbf{A}}\right ]\), por lo cual tenemos que \(\mathbf{A}\models \exists v\varphi (v)\).
</p><!-- l. 15623 --><p class='indent'>   Veamos que la regla de reemplazo es universal. Debemos probar que si \((\psi _{1},\psi _{2},\varphi )\in Reemp^{\tau }=Reemp1^{\tau }\cup Reemp2^{\tau }\),
entonces \(\left ((\psi _{1}\wedge \psi _{2})\rightarrow \varphi \right )\) es una sentencia universalmente valida. El caso en el que \((\psi _{1},\psi _{2},\varphi )\in Reemp1^{\tau }\) es facil y lo
dejaremos al lector. Para el caso en el que \((\psi _{1},\psi _{2},\varphi )\in Reemp2^{\tau }\) nos hara falta un resultado un
poco mas general. Veamos por induccion en \(k\) que si se dan las siguientes
condiciones
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-189004x8.1.1'>\(\alpha \in F_{k}^{\tau }\) y \(\varphi ,\psi \in F^{\tau }\)
     </li>
     <li class='enumerate' id='x1-189005x8.1.1'>\(\mathbf{A}\) es una estructura de tipo \(\tau \)
     </li>
     <li class='enumerate' id='x1-189006x8.1.1'>\(\overline{\alpha }=\) resultado de reemplazar en \(\alpha \) una ocurrencia de \(\varphi \) por \(\psi \),
     </li>
     <li class='enumerate' id='x1-189007x8.1.1'>\(\mathbf{A}\models \varphi \left [\vec{a}\right ]\) si y solo si \(\mathbf{A}\models \psi \left [\vec{a}\right ]\), para cada \(\vec{a}\in A^{\mathbf{N}}\)</li></ol>
<!-- l. 15638 --><p class='noindent'>entonces se da que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-189008x8.1.1'>\(\mathbf{A}\models \alpha \left [\vec{a}\right ]\) si y solo si \(\mathbf{A}\models \overline{\alpha }\left [\vec{a}\right ]\), para cada \(\vec{a}\in A^{\mathbf{N}}\).</li></ol>
<!-- l. 15643 --><p class='noindent'>CASO \(k=0.\)
</p><!-- l. 15645 --><p class='noindent'>Entonces \(\alpha \) es atomica y por lo tanto ya que \(\alpha \) es la unica subformula de \(\alpha \), la situacion es
facil de probar.
</p><!-- l. 15648 --><p class='indent'>   CASO \(\alpha =\forall x_{i}\alpha _{1}.\)
</p><!-- l. 15650 --><p class='noindent'>Si \(\varphi =\alpha \), entonces la situacion es facil de probar. Si \(\varphi \neq \alpha \), entonces la ocurrencia de \(\varphi \) a
reemplazar sucede en \(\alpha _{1}\) y por lo tanto \(\overline{\alpha }=\forall x_{i}\overline{\alpha _{1}}.\) Se tiene entonces que para un \(\vec{a}\) dado, \[ \begin{array}{c} \mathbf{A}\models \alpha \left [\vec{a}\right ]\\ \Updownarrow \\ \mathbf{A}\models \alpha _{1}\left [\downarrow _{i}^{a}\vec{a}\right ],\text{ para cada }a\in A\\ \Updownarrow \\ \mathbf{A}\models \overline{\alpha _{1}}\left [\downarrow _{i}^{a}\vec{a}\right ],\text{ para cada }a\in A\\ \Updownarrow \\ \mathbf{A}\models \overline{\alpha }\left [\vec{a}\right ] \end{array} \] CASO
\(\alpha =(\alpha _{1}\vee \alpha _{2})\).
</p><!-- l. 15667 --><p class='noindent'>Si \(\varphi =\alpha \), entonces la situacion es facil de probar. Supongamos \(\varphi \neq \alpha \) y supongamos que la
ocurrencia de \(\varphi \) a reemplazar sucede en \(\alpha _{1}\). Entonces \(\overline{\alpha }=(\overline{\alpha _{1}}\vee \alpha _{2})\) y tenemos que \[ \begin{array}{c} \mathbf{A}\models \alpha \left [\vec{a}\right ]\\ \Updownarrow \\ \mathbf{A}\models \alpha _{1}\left [\vec{a}\right ]\text{ o }\mathbf{A}\models \alpha _{2}\left [\vec{a}\right ]\\ \Updownarrow \\ \mathbf{A}\models \overline{\alpha _{1}}\left [\vec{a}\right ]\text{ o }\mathbf{A}\models \alpha _{2}\left [\vec{a}\right ]\\ \Updownarrow \\ \mathbf{A}\models \overline{\alpha }\left [\vec{a}\right ] \end{array} \] Los demas casos
son dejados al lector.

</p><!-- l. 15684 --><p class='indent'>   Dejamos al lector el chequeo de la universalidad del resto de las reglas.    □
</p>
   </div>
<!-- l. 15690 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>8.1.2   </span> <a id='x1-1900008.1.2'></a>Axiomas logicos</h5>
<!-- l. 15692 --><p class='noindent'>Recordemos que dada una teoria \((\Sigma ,\tau )\), los elementos de \(\Sigma \) son llamados axiomas propios y
en general no son sentencias universalmente validas. En las pruebas elementales sera
necesario usar ciertas verdades universales y obvias las cuales llamaremos <span class='cmti-10'>axiomas
</span><span class='cmti-10'>logicos</span>.
</p><!-- l. 15698 --><p class='indent'>   Mas concretamente, llamaremos <span class='cmti-10'>axiomas logicos de tipo</span> \(\tau \) a todas las sentencias de
alguna de las siguientes formas.
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-190002x1'>\((\varphi \leftrightarrow \varphi )\)
     </li>
     <li class='enumerate' id='x1-190004x2'>\((t\equiv t)\)
     </li>
     <li class='enumerate' id='x1-190006x3'>\((\varphi \vee \lnot \varphi )\)
     </li>
     <li class='enumerate' id='x1-190008x4'>\((\varphi \leftrightarrow \lnot \lnot \varphi )\)
     </li>
     <li class='enumerate' id='x1-190010x5'>\((\lnot \forall v\psi \leftrightarrow \exists v\lnot \psi )\)
     </li>
     <li class='enumerate' id='x1-190012x6'>\((\lnot \exists v\psi \leftrightarrow \forall v\lnot \psi )\)</li></ol>
<!-- l. 15708 --><p class='noindent'>donde \(t\in T_{c}^{\tau }\), \(\varphi \in S^{\tau }\), \(\psi \in F^{\tau }\), \(v\in Var\) y \(Li(\psi )\subseteq \{v\}\). Con \(AxLog^{\tau }\) denotaremos el conjunto \[ \{\varphi \in S^{\tau }:\varphi \ \mathrm{es\ un\ axioma\ logico\ de\ tipo\ }\tau \} \] Notese que hay infinitos axiomas logicos de
tipo \(\tau \), es decir el conjunto \(AxLog^{\tau }\) es un conjunto infinito de palabras. Por ejemplo,
el formato dado en 1. produce una cantidad infinita de axiomas logicos, a
saber todas las sentencias de la forma \((\varphi \leftrightarrow \varphi )\), donde \(\varphi \) es cualquier sentencia de tipo
\(\tau \).
</p><!-- l. 15722 --><p class='indent'>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-190013x8.1.2'>Pruebe que cada sentencia de \(AxLog^{\tau }\) es universalmente valida</li></ol>

<!-- l. 15729 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>8.1.3   </span> <a id='x1-1910008.1.3'></a>Justificaciones</h5>
<!-- l. 15731 --><p class='noindent'>Remitimos a la Seccion <a href='#x1-990003.3.1'>3.3.1<!-- tex4ht:ref: SintaxisDeSsigma  --></a> por la definicion del alfabeto \(Num\) y la funcion \(\overline{\ \ \ \;}:\omega \rightarrow Num^{\ast }\)  Sea \(Nombres_{1}\) el
conjunto formado por las siguientes palabras
</p>
   <div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \text{EXISTENCIA}\\ &amp; &amp; \text{COMMUTATIVIDAD}\\ &amp; &amp; \text{PARTICULARIZACION}\\ &amp; &amp; \text{ABSURDO}\\ &amp; &amp; \text{EVOCACION}\\ &amp; &amp; \text{CONJUNCIONELIMINACION}\\ &amp; &amp; \text{EQUIVALENCIAELIMINACION}\\ &amp; &amp; \text{DISJUNCIONINTRODUCCION}\\ &amp; &amp; \text{ELECCION}\\ &amp; &amp; \text{GENERALIZACION} \end{eqnarray*}
</div>Sea \(Nombres_{2}\) el conjunto formado por las siguientes palabras
   <div class='eqnarray'>\begin{eqnarray*} &amp; &amp; \text{MODUSPONENS}\\ &amp; &amp; \text{TRANSITIVIDAD}\\ &amp; &amp; \text{CONJUNCIONINTRODUCCION}\\ &amp; &amp; \text{EQUIVALENCIAINTRODUCCION}\\ &amp; &amp; \text{DISJUNCIONELIMINACION}\\ &amp; &amp; \text{REEMPLAZO} \end{eqnarray*}
</div>Una <p><span class='cmti-10'>justificacion basica </span></p>es una palabra perteneciente a la union de los siguientes
conjuntos de palabras \[ \{\text{CONCLUSION},\text{AXIOMAPROPIO},\text{AXIOMALOGICO}\} \] \[ \{\alpha (\bar{k}):k\in \mathbf{N}\text{ y }\alpha \in Nombres_{1}\} \] \[ \{\alpha (\bar{j},\bar{k}):j,k\in \mathbf{N}\text{ y }\alpha \in Nombres_{2}\} \]
<!-- l. 15772 --><p class='indent'>   \[ \{\text{DIVISIONPORCASOS}(\bar{j},\bar{k},\bar{l}):j,k,l\in \mathbf{N}\} \] Usaremos \(JustBas\) para denotar el conjunto formado por todas las justificaciones basicas.
Una <span class='cmti-10'>justificacion </span>es una palabra que ya sea es una justificacion basica o pertenece a
la union de los siguientes conjuntos de palabras \[ \{\text{HIPOTESIS}\bar{k}:k\in \mathbf{N}\} \] \[ \{\text{TESIS}\bar{j}\alpha :j\in \mathbf{N}\text{ y }\alpha \in JustBas\} \] Usaremos \(Just\) para denotar
el conjunto formado por todas las justificaciones. Cabe destacar que los
elementos de \(Just\) son palabras del alfabeto formado por los siguientes simbolos
\[ (\ )\ ,\ 0\ 1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ \text{A\ B\ C\ D\ E\ G\ H\ I\ J\ L\ M\ N\ O\ P\ Q\ R\ S\ T\ U\ V\ X Z} \]
</p>
<!-- l. 15794 --><p class='noindent'><span class='paragraphHead'><a id='x1-1920008.1.3'></a><span class='cmbx-10'>Concatenaciones balanceadas de justificaciones</span></span>
   Para construir el concepto de prueba elemental deberiamos trabajar
con sucesiones finitas de justificaciones pero el siguiente lema nos dice que
podemos reemplazarlas por ciertas palabras, i.e. sus concatenaciones, sin perder
informacion.
</p>
   <div class='newtheorem'>
<!-- l. 15800 --><p class='noindent'><span class='head'>
<a id='x1-192001r211'></a>
<span class='cmbx-10'>Lema 211.</span>  </span><span class='cmti-10'>Sea</span> \(\mathbf{J}\in Just^{+}\)<span class='cmti-10'>. Hay unicos</span> \(n\geq 1\) <span class='cmti-10'>y</span> \(J_{1},...,J_{n}\in Just\) <span class='cmti-10'>tales que</span> \(\mathbf{J}=J_{1}...J_{n}\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 15805 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 15806 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos  \(J_{1},...,J_{n}\),  \(J_{1}^{\prime },...,J_{m}^{\prime }\),  con  \(n,m\geq 1\),  son  justificaciones  tales  que  \(J_{1}...J_{n}=J_{1}^{\prime }...J_{m}^{\prime }\).  Es  facil  ver  que
entonces tenemos \(J_{1}=J_{1}^{\prime }\), por lo cual \(J_{2}...J_{n}=J_{2}^{\prime }...J_{m}^{\prime }\). Un argumento inductivo nos dice que entonces
\(n=m\) y \(J_{i}=J_{i}^{\prime }\), \(i=1,...,n\)                                                                                                □

</p>
   </div>
<!-- l. 15815 --><p class='indent'>   Es decir el lema anterior nos dice que la sucesion \(J_{1},...,J_{n}\) se puede codificar con la
palabra \(J_{1}...J_{n}\) sin perder informacion. Dada \(\mathbf{J}\in Just^{+}\), usaremos \(n(\mathbf{J})\) y \(\mathbf{J}_{1},...,\mathbf{J}_{n(\mathbf{J})}\) para denotar los unicos \(n\) y \(J_{1},...,J_{n}\) cuya
existencia garantiza el lema anterior.
</p><!-- l. 15821 --><p class='indent'>   Dados \(i,j\in \omega \), usaremos \(\left \langle i,j\right \rangle \) para denotar el conjunto \(\{l\in \omega :i\leq l\leq j\}\). A los conjuntos de la forma \(\left \langle i,j\right \rangle \) los
llamaremos <span class='cmti-10'>bloques</span>.
</p><!-- l. 15825 --><p class='indent'>   Dada \(\mathbf{J}\in Just^{+}\) definamos </p><div class='gather-star'><img alt=' ' src='apunte5x.png' /></div>Diremos que \(\mathbf{J}\in Just^{+}\) es <p><span class='cmti-10'>balanceada </span></p>si se dan las siguientes
     <ol class='enumerate1'>
     <li class='enumerate' id='x1-192002x8.1.3'>Por cada \(k\in \mathbf{N}\) a lo sumo hay un \(i\) tal que \(\mathbf{J}_{i}=\) \(\mathrm{HIPOTESIS}\bar{k}\) y a lo sumo hay un \(i\) tal que \(\mathbf{J}_{i}=\) \(\mathrm{TESIS}\bar{k}\alpha \), con
     \(\alpha \in JustBas\)
     </li>
     <li class='enumerate' id='x1-192003x8.1.3'>Si \(\mathbf{J}_{i}=\mathrm{HIPOTESIS}\bar{k}\) entonces hay un \(l&gt;i\) tal que \(\mathbf{J}_{l}=\mathrm{TESIS}\bar{k}\alpha \), con \(\alpha \in JustBas\)
     </li>
     <li class='enumerate' id='x1-192004x8.1.3'>Si \(\mathbf{J}_{i}=\mathrm{TESIS}\bar{k}\alpha \), con \(\alpha \in JustBas\), entonces hay un \(l&lt;i\) tal que \(\mathbf{J}_{l}=\mathrm{HIPOTESIS}\bar{k}\)
     </li>
     <li class='enumerate' id='x1-192005x8.1.3'>Si \(B_{1},B_{2}\in \mathcal{B}^{\mathbf{J}}\), entonces \(B_{1}\cap B_{2}=\emptyset \) o \(B_{1}\subseteq B_{2}\) o \(B_{2}\subseteq B_{1}\)</li></ol>
<!-- l. 15846 --><p class='indent'>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-192006x8.1.3'>Supongamos \(\mathbf{J}\in Just^{+}\) es balanceada. Entonces
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-192008x1'>Si \(\left \langle i,j\right \rangle \in \mathcal{B}^{\mathbf{J}}\), entonces \(i&lt;j\)
         </li>
         <li class='enumerate' id='x1-192010x2'>Si \(\left \langle i,j\right \rangle ,\left \langle i^{\prime },j^{\prime }\right \rangle \in \mathcal{B}^{\mathbf{J}}\) y \(i=i^{\prime }\), entonces \(j=j^{\prime }\)
         </li>
         <li class='enumerate' id='x1-192012x3'>Si \(\left \langle i,j\right \rangle ,\left \langle i^{\prime },j^{\prime }\right \rangle \in \mathcal{B}^{\mathbf{J}}\) y \(j=j^{\prime }\), entonces \(i=i^{\prime }\)</li></ol>
     </li></ol>
<!-- l. 15860 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>8.1.4   </span> <a id='x1-1930008.1.4'></a>Pares adecuados</h5>
<!-- l. 15862 --><p class='noindent'>Para construir el concepto de prueba elemental deberiamos trabajar con sucesiones
finitas de sentencias pero el siguiente lema nos dice que podemos reemplazarlas por
ciertas palabras, i.e. sus concatenaciones, sin perder informacion.
</p>

   <div class='newtheorem'>
<!-- l. 15866 --><p class='noindent'><span class='head'>
<a id='x1-193001r212'></a>
<span class='cmbx-10'>Lema 212.</span>  </span><span class='cmti-10'>Sea</span> \(\mathbf{\varphi }\in S^{\tau +}\)<span class='cmti-10'>. Hay unicos</span> \(n\geq 1\) <span class='cmti-10'>y</span> \(\varphi _{1},...,\varphi _{n}\in S^{\tau }\) <span class='cmti-10'>tales que</span> \(\mathbf{\varphi }=\varphi _{1}...\varphi _{n}\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 15872 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 15873 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Solo hay que probar la unicidad la cual sigue de la Proposicion <a href='#x1-167006r185'>185<!-- tex4ht:ref: mordisqueo  --></a>.   □
</p>
   </div>
<!-- l. 15877 --><p class='indent'>   Es decir el lema anterior nos dice que la sucesion \(\varphi _{1},...,\varphi _{n}\) se puede codificar con la
palabra \(\varphi _{1}...\varphi _{n}\) sin perder informacion. Dada \(\mathbf{\varphi }\in S^{\tau +}\), usaremos \(n(\mathbf{\varphi })\) y \(\mathbf{\varphi }_{1},...,\mathbf{\varphi }_{n(\mathbf{\varphi })}\) para denotar los unicos \(n\) y \(\varphi _{1},...,\varphi _{n}\) cuya
existencia garantiza el lema anterior.
</p><!-- l. 15884 --><p class='indent'>   Un <span class='cmti-10'>par adecuado de tipo</span> \(\tau \) es un par \((\mathbf{\varphi },\mathbf{J})\in S^{\tau +}\times Just^{+}\) tal que \(n(\mathbf{\varphi })=n(\mathbf{J})\) y \(\mathbf{J}\) es balanceada.
</p><!-- l. 15887 --><p class='indent'>   Sea \((\mathbf{\varphi },\mathbf{J})\) un par adecuado de tipo \(\tau \). Si \(\left \langle i,j\right \rangle \in \mathcal{B}^{\mathbf{J}}\), entonces \(\mathbf{\varphi }_{i}\) sera la <span class='cmti-10'>hipotesis </span>del bloque \(\left \langle i,j\right \rangle \) en \((\mathbf{\varphi },\mathbf{J})\) y \(\mathbf{\varphi }_{j}\)
sera la <span class='cmti-10'>tesis </span>del bloque \(\left \langle i,j\right \rangle \) en \((\mathbf{\varphi },\mathbf{J})\). Diremos que \(\mathbf{\varphi }_{i}\) <span class='cmti-10'>esta bajo la hipotesis</span> \(\mathbf{\varphi }_{l}\) <span class='cmti-10'>en</span> \((\mathbf{\varphi },\mathbf{J})\) o que \(\mathbf{\varphi }_{l}\) <span class='cmti-10'>es una
</span><span class='cmti-10'>hipotesis de</span> \(\mathbf{\varphi }_{i}\) <span class='cmti-10'>en</span> \((\mathbf{\varphi },\mathbf{J})\) cuando haya en \(\mathcal{B}^{\mathbf{J}}\) un bloque de la forma \(\left \langle l,j\right \rangle \) el cual contenga a \(i\).
Sean \(i,j\in \left \langle 1,n(\mathbf{\varphi })\right \rangle .\) Diremos que \(i\) es <span class='cmti-10'>anterior </span>a \(j\) <span class='cmti-10'>en</span> \((\mathbf{\varphi },\mathbf{J})\) si \(i&lt;j\) y ademas para todo \(B\in \mathcal{B}^{\mathbf{J}}\) se tiene que
\(i\in B\Rightarrow j\in B\).
</p>
<!-- l. 15905 --><p class='noindent'><span class='paragraphHead'><a id='x1-1940008.1.4'></a><span class='cmbx-10'>Dependencia de constantes en pares adecuados</span></span>
   Sea \((\mathbf{\varphi },\mathbf{J})\) un par adecuado de tipo \(\tau \). Dadas \(e,d\in \mathcal{C}\), diremos que \(e\) <span class='cmti-10'>depende directamente de</span> \(d\) <span class='cmti-10'>en</span> \((\mathbf{\varphi },\mathbf{J})\)
si hay numeros \(1\leq l&lt;j\leq n(\mathbf{\varphi })\) tales que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-194001x8.1.4'>\(l\) es anterior a \(j\) en \((\mathbf{\varphi },\mathbf{J})\)
     </li>
     <li class='enumerate' id='x1-194002x8.1.4'>\(\mathbf{J}_{j}=\alpha \mathrm{ELECCION}(\bar{l})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\) y \((\mathbf{\varphi }_{l},\mathbf{\varphi }_{j})\in Elec^{\tau }\) via \(e\)
     </li>
     <li class='enumerate' id='x1-194003x8.1.4'>\(d\) ocurre en \(\mathbf{\varphi }_{l}\).</li></ol>
<!-- l. 15920 --><p class='indent'>   Dados \(e,d\in \mathcal{C}\), diremos que \(e\) <span class='cmti-10'>depende de</span> \(d\) <span class='cmti-10'>en</span> \((\mathbf{\varphi },\mathbf{J})\) si existen \(e_{0},...,e_{k+1}\in \mathcal{C}\), con \(k\geq 0\), tales que

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-194004x8.1.4'>\(e_{0}=e\) y \(e_{k+1}=d\)
     </li>
     <li class='enumerate' id='x1-194005x8.1.4'>\(e_{i}\) <span class='cmti-10'>depende directamente de</span> \(e_{i+1}\) <span class='cmti-10'>en</span> \((\mathbf{\varphi },\mathbf{J})\), para \(i=0,...,k\).</li></ol>
<!-- l. 15931 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>8.1.5   </span> <a id='x1-1950008.1.5'></a>Definicion de prueba</h5>
<!-- l. 15933 --><p class='noindent'>Ahora si estamos en condiciones de definir el concepto de prueba en una teoria de
primer orden. Sea \((\Sigma ,\tau )\) una teoria de primer orden. Sea \(\varphi \) una sentencia de tipo \(\tau \). Una
<span class='cmti-10'>prueba formal de</span> \(\varphi \) <span class='cmti-10'>en</span> \((\Sigma ,\tau )\) sera un par adecuado \((\mathbf{\varphi },\mathbf{J})\) de algun tipo \(\tau _{1}=(\mathcal{C}\cup \mathcal{C}_{1},\mathcal{F},\mathcal{R},a)\), con \(\mathcal{C}_{1}\) finito y disjunto con
\(\mathcal{C}\), tal que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-195001x8.1.5'>Cada \(\mathbf{\varphi }_{i}\) es una sentencia de tipo \(\tau _{1}\)
     </li>
     <li class='enumerate' id='x1-195002x8.1.5'>\(\mathbf{\varphi }_{n(\mathbf{\varphi })}=\varphi \)
     </li>
     <li class='enumerate' id='x1-195003x8.1.5'>Si \(\left \langle i,j\right \rangle \in \mathcal{B}^{\mathbf{J}}\), entonces \(\mathbf{\varphi }_{j+1}=(\mathbf{\varphi }_{i}\rightarrow \mathbf{\varphi }_{j})\) y \(\mathbf{J}_{j+1}=\alpha \mathrm{CONCLUSION}\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\)
     </li>
     <li class='enumerate' id='x1-195004x8.1.5'>Para cada \(i=1,...,n(\mathbf{\varphi })\), se da una de las siguientes
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-195005x8.1.5'>\(\mathbf{J}_{i}=\mathrm{HIPOTESIS}\bar{k}\) para algun \(k\in \mathbf{N}\)
         </li>
         <li class='enumerate' id='x1-195006x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{CONCLUSION}\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\) y hay un \(j\) tal que \(\left \langle j,i-1\right \rangle \in \mathcal{B}^{\mathbf{J}}\) y \(\mathbf{\varphi }_{i}=(\mathbf{\varphi }_{j}\rightarrow \mathbf{\varphi }_{i-1})\)
         </li>
         <li class='enumerate' id='x1-195007x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{AXIOMALOGICO}\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\) y \(\mathbf{\varphi }_{i}\) es un axioma logico de tipo \(\tau _{1}\)
         </li>
         <li class='enumerate' id='x1-195008x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{AXIOMAPROPIO}\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\) y \(\mathbf{\varphi }_{i}\in \Sigma \)
         </li>
         <li class='enumerate' id='x1-195009x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{PARTICULARIZACION}(\bar{l})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\) \(l\) anterior a \(i\) y \((\mathbf{\varphi }_{l},\mathbf{\varphi }_{i})\in Partic^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195010x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{COMMUTATIVIDAD}(\bar{l})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l\) anterior a \(i\) y \((\mathbf{\varphi }_{l},\mathbf{\varphi }_{i})\in Commut^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195011x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{ABSURDO}(\bar{l})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l\) anterior a \(i\) y \((\mathbf{\varphi }_{l},\mathbf{\varphi }_{i})\in Absur^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195012x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{EVOCACION}(\bar{l})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l\) anterior a \(i\) y \((\mathbf{\varphi }_{l},\mathbf{\varphi }_{i})\in Evoc^{\tau _{1}}\)

         </li>
         <li class='enumerate' id='x1-195013x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{EXISTENCIA}(\bar{l})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l\) anterior a \(i\) y \((\mathbf{\varphi }_{l},\mathbf{\varphi }_{i})\in Exist^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195014x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{CONJUNCIONELIMINACION}(\bar{l})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l\) anterior a \(i\) y \((\mathbf{\varphi }_{l},\mathbf{\varphi }_{i})\in ConjElim^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195015x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{DISJUNCIONINTRODUCCION}(\bar{l})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l\) anterior a \(i\) y \((\mathbf{\varphi }_{l},\mathbf{\varphi }_{i})\in DisjInt^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195016x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{EQUIVALENCIAELIMINACION}(\bar{l})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l\) anterior a \(i\) y \((\mathbf{\varphi }_{l},\mathbf{\varphi }_{i})\in EquivElim^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195017x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{MODUSPONENS}(\overline{l_{1}},\overline{l_{2}})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l_{1}\) y \(l_{2}\) anteriores a \(i\) y \((\mathbf{\varphi }_{l_{1}},\mathbf{\varphi }_{l_{2}},\mathbf{\varphi }_{i})\in ModPon^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195018x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{CONJUNCIONINTRODUCCION}(\overline{l_{1}},\overline{l_{2}})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l_{1}\) y \(l_{2}\) anteriores a \(i\) y \((\mathbf{\varphi }_{l_{1}},\mathbf{\varphi }_{l_{2}},\mathbf{\varphi }_{i})\in ConjInt^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195019x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{EQUIVALENCIAINTRODUCCION}(\overline{l_{1}},\overline{l_{2}})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l_{1}\) y \(l_{2}\) anteriores a \(i\) y \((\mathbf{\varphi }_{l_{1}},\mathbf{\varphi }_{l_{2}},\mathbf{\varphi }_{i})\in EquivInt^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195020x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{DISJUNCIONELIMINACION}(\overline{l_{1}},\overline{l_{2}})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l_{1}\) y \(l_{2}\) anteriores a \(i\) y \((\mathbf{\varphi }_{l_{1}},\mathbf{\varphi }_{l_{2}},\mathbf{\varphi }_{i})\in DisjElim^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195021x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{REEMPLAZO}(\overline{l_{1}},\overline{l_{2}})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l_{1}\) y \(l_{2}\) anteriores a \(i\) y \((\mathbf{\varphi }_{l_{1}},\mathbf{\varphi }_{l_{2}},\mathbf{\varphi }_{i})\in Reemp^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195022x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{TRANSITIVIDAD}(\overline{l_{1}},\overline{l_{2}})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l_{1}\) y \(l_{2}\) anteriores a \(i\) y \((\mathbf{\varphi }_{l_{1}},\mathbf{\varphi }_{l_{2}},\mathbf{\varphi }_{i})\in Trans^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195023x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{DIVISIONPORCASOS}(\overline{l_{1}},\overline{l_{2}},\overline{l_{3}})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l_{1},l_{2}\) y \(l_{3}\) anteriores a \(i\) y y \((\mathbf{\varphi }_{l_{1}},\mathbf{\varphi }_{l_{2}},\mathbf{\varphi }_{l_{3}},\mathbf{\varphi }_{i})\in DivPorCas^{\tau _{1}}\)
         </li>
         <li class='enumerate' id='x1-195024x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{ELECCION}(\bar{l})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l\) anterior a \(i\) y \((\mathbf{\varphi }_{l},\mathbf{\varphi }_{i})\in Elec^{\tau _{1}}\) via un nombre de cte \(e\), el cual no pertenece a \(\mathcal{C}\)
         y no ocurre en \(\mathbf{\varphi }_{1},...,\mathbf{\varphi }_{i-1}\).
         </li>
         <li class='enumerate' id='x1-195025x8.1.5'>\(\mathbf{J}_{i}=\alpha \mathrm{GENERALIZACION}(\bar{l})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), \(l\) anterior a \(i\) y \((\mathbf{\varphi }_{l},\mathbf{\varphi }_{i})\in Generaliz^{\tau _{1}}\) via un nombre de cte \(c\) el cual cumple:
             <ol class='enumerate3'>
             <li class='enumerate' id='x1-195026x8.1.5'>\(c\not \in \mathcal{C}\)
             </li>
             <li class='enumerate' id='x1-195027x8.1.5'>\(c\) no es un nombre de cte que ocurra en \(\mathbf{\varphi }\) el cual sea introducido
             por la aplicacion de la regla de eleccion; es decir para cada \(u\in \{1,...,n(\mathbf{\varphi })\}\), si \(\mathbf{J}_{u}=\alpha \mathrm{ELECCION}(\bar{v})\),
             con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), entonces no se da que \((\mathbf{\varphi }_{v},\mathbf{\varphi }_{u})\in Elec^{\tau _{1}}\) via \(c\).
             </li>
             <li class='enumerate' id='x1-195028x8.1.5'>\(c\) no ocurre en ninguna hipotesis de \(\mathbf{\varphi }_{l}\).
             </li>
             <li class='enumerate' id='x1-195029x8.1.5'>Ningun nombre de constante que ocurra en \(\mathbf{\varphi }_{l}\) o en sus hipotesis,
             depende de \(c.\)</li></ol>
         </li></ol>
     </li></ol>
<!-- l. 16019 --><p class='indent'>   @@finpagina@@

</p><!-- l. 16021 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>8.2   </span> <a id='x1-1960008.2'></a>El concepto de teorema</h4>
<!-- l. 16023 --><p class='noindent'>Cuando haya una prueba formal de \(\varphi \) en \((\Sigma ,\tau )\), diremos que \(\varphi \) es un <span class='cmti-10'>teorema </span>de la teoria \((\Sigma ,\tau )\) y
escribiremos \((\Sigma ,\tau )\vdash \varphi \). A continuacion se dan algunos ejemplos de teoremas de la teoria
\((\emptyset ,\tau )\).
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-196002x1'>\((\varphi _{1}\vee \varphi _{2})\rightarrow (\varphi _{2}\vee \varphi _{1})\) es un teorema de \((\emptyset ,\tau )\). Una prueba formal: \[ \begin{array}{llll} 1. &amp; (\varphi _{1}\vee \varphi _{2}) &amp; &amp; \text{HIPOTESIS}1\\ 2. &amp; \varphi _{1} &amp; &amp; \text{HIPOTESIS}2\\ 3. &amp; (\varphi _{2}\vee \varphi _{1}) &amp; &amp; \text{TESIS}2\text{DISJUNCIONINTRODUCCION}(2)\\ 4. &amp; (\varphi _{1}\rightarrow (\varphi _{2}\vee \varphi _{1})) &amp; &amp; \text{CONCLUSION}\\ 5. &amp; \varphi _{2} &amp; &amp; \text{HIPOTESIS}3\\ 6. &amp; (\varphi _{2}\vee \varphi _{1}) &amp; &amp; \text{TESIS}3\text{DISJUNCIONINTRODUCCION}(5)\\ 7. &amp; \varphi _{2}\rightarrow (\varphi _{2}\vee \varphi _{1}) &amp; &amp; \text{CONCLUSION}\\ 8. &amp; (\varphi _{2}\vee \varphi _{1}) &amp; &amp; \text{TESIS}1\text{DIVISIONPORCASOS}(1,4,7)\\ 9. &amp; (\varphi _{1}\vee \varphi _{2})\rightarrow (\varphi _{2}\vee \varphi _{1}) &amp; &amp; \text{CONCLUSION} \end{array} \]
     </li>
     <li class='enumerate' id='x1-196004x2'>\((\varphi _{1}\vee (\varphi _{2}\vee \varphi _{3}))\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3})\) es un teorema de \((\emptyset ,\tau )\). Una prueba formal: \[ \begin{array}{llll} 1. &amp; (\varphi _{1}\vee (\varphi _{2}\vee \varphi _{3})) &amp; &amp; \text{HIPOTESIS}1\\ 2. &amp; \varphi _{1} &amp; &amp; \text{HIPOTESIS}2\\ 3. &amp; (\varphi _{1}\vee \varphi _{2}) &amp; &amp; \text{DISJUNCIONINTRODUCCION}(2)\\ 4. &amp; ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{TESIS}2\text{DISJUNCIONINTRODUCCION}(3)\\ 5. &amp; \varphi _{1}\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{CONCLUSION}\\ 6. &amp; (\varphi _{2}\vee \varphi _{3}) &amp; &amp; \text{HIPOTESIS}3\\ 7. &amp; \varphi _{2} &amp; &amp; \text{HIPOTESIS}4\\ 8. &amp; (\varphi _{1}\vee \varphi _{2}) &amp; &amp; \text{DISJUNCIONINTRODUCCION}(6)\\ 9. &amp; ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{TESIS}4\text{DISJUNCIONINTRODUCCION}(7)\\ 10. &amp; \varphi _{2}\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{CONCLUSION}\\ 11. &amp; \varphi _{3} &amp; &amp; \text{HIPOTESIS}5\\ 12. &amp; ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{TESIS}5\text{DISJUNCIONINTRODUCCION}(11)\\ 13. &amp; \varphi _{3}\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{CONCLUSION}\\ 14. &amp; ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{TESIS}3\text{DIVISIONPORCASOS}(6,10,13)\\ 15. &amp; (\varphi _{2}\vee \varphi _{3})\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{CONCLUSION}\\ 16. &amp; ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{TESIS}1\text{DIVISIONPORCASOS}(1,5,15)\\ 17. &amp; (\varphi _{1}\vee (\varphi _{2}\vee \varphi _{3}))\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{CONCLUSION} \end{array} \]
     </li>
     <li class='enumerate' id='x1-196006x3'>\(((\varphi \wedge (\varphi \vee \psi ))\leftrightarrow \varphi )\) es un teorema de \((\emptyset ,\tau )\). Una prueba formal: \[ \begin{array}{llll} 1.\; &amp; (\varphi \wedge (\varphi \vee \psi )) &amp; &amp; \text{HIPOTESIS}1\\ 2.\; &amp; \varphi &amp; &amp; \text{TESIS}1\text{CONJUNCIONELIMINACION}(1)\\ 3.\; &amp; (\varphi \wedge (\varphi \vee \psi ))\rightarrow \varphi &amp; &amp; \text{CONCLUSION}\\ 4.\; &amp; \varphi &amp; &amp; \text{HIPOTESIS}2\\ 5. &amp; (\varphi \vee \psi ) &amp; &amp; \text{DISJUNCIONINTRODUCCION}(4)\\ 6. &amp; (\varphi \wedge (\varphi \vee \psi )) &amp; &amp; \text{TESIS}2\text{CONJUNCIONINTRODUCCION}(4,5)\\ 7. &amp; \varphi \rightarrow (\varphi \wedge (\varphi \vee \psi )) &amp; &amp; \text{CONCLUSION}\\ 8. &amp; ((\varphi \wedge (\varphi \vee \psi ))\leftrightarrow \varphi ) &amp; &amp; \text{EQUIVALENCIAINTRODUCCION}(3,7) \end{array} \]
     </li>
     <li class='enumerate' id='x1-196008x4'>\(((\varphi \vee (\varphi \wedge \psi ))\leftrightarrow \varphi )\) es un teorema de \((\emptyset ,\tau )\). Una prueba formal: \[ \begin{array}{llll} 1.\; &amp; (\varphi \vee (\varphi \wedge \psi )) &amp; &amp; \text{HIPOTESIS}1\\ 2.\; &amp; \varphi &amp; &amp; \text{HIPOTESIS}2\\ 3.\; &amp; \varphi &amp; &amp; \text{TESIS}2\text{EVOCACION}(2)\\ 4.\; &amp; \varphi \rightarrow \varphi &amp; &amp; \text{CONCLUSION}\\ 5. &amp; (\varphi \wedge \psi ) &amp; &amp; \text{HIPOTESIS}3\\ 6. &amp; \varphi &amp; &amp; \text{TESIS}3\text{CONJUNCIONELIMINACION}(5)\\ 7. &amp; (\varphi \wedge \psi )\rightarrow \varphi &amp; &amp; \text{CONCLUSION}\\ 8. &amp; \varphi &amp; &amp; \text{TESIS}1\text{DIVISIONPORCASOS}(1,4,7)\\ 9. &amp; (\varphi \vee (\varphi \wedge \psi ))\rightarrow \varphi &amp; &amp; \text{CONCLUSION}\\ 10. &amp; \varphi &amp; &amp; \text{HIPOTESIS}4\\ 11. &amp; (\varphi \vee (\varphi \wedge \psi )) &amp; &amp; \text{TESIS}4\text{DISJUNCIONINTRODUCCION}(10)\\ 12. &amp; \varphi \rightarrow (\varphi \vee (\varphi \wedge \psi )) &amp; &amp; \text{CONCLUSION}\\ 13. &amp; ((\varphi \vee (\varphi \wedge \psi ))\leftrightarrow \varphi ) &amp; &amp; \text{EQUIVALENCIAINTRODUCCION}(9,12) \end{array} \]
     </li>
     <li class='enumerate' id='x1-196010x5'>\((\varphi \wedge (\varphi _{1}\vee \varphi _{2}))\rightarrow ((\varphi \wedge \varphi _{1})\vee (\varphi \wedge \varphi _{2}))\) es un teorema de \((\emptyset ,\tau )\). Una prueba formal: \[ \begin{array}{llll} 1.\; &amp; (\varphi \wedge (\varphi _{1}\vee \varphi _{2})) &amp; &amp; \text{HIPOTESIS}1\\ 2.\; &amp; \varphi &amp; &amp; \text{CONJUNCIONELIMINACION}(1)\\ 3.\; &amp; (\varphi _{1}\vee \varphi _{2}) &amp; &amp; \text{CONJUNCIONELIMINACION}(1)\\ 4.\; &amp; \varphi _{1} &amp; &amp; \text{HIPOTESIS}2\\ 5. &amp; (\varphi \wedge \varphi _{1}) &amp; &amp; \text{CONJUNCIONINTRODUCCION}(2,4)\\ 6. &amp; ((\varphi \wedge \varphi _{1})\vee (\varphi \wedge \varphi _{2})) &amp; &amp; \text{TESIS}2\text{DISJUNCIONINTRODUCCION}(5)\\ 7. &amp; \varphi _{1}\rightarrow ((\varphi \wedge \varphi _{1})\vee (\varphi \wedge \varphi _{2})) &amp; &amp; \text{CONCLUSION}\\ 8. &amp; \varphi _{2} &amp; &amp; \text{HIPOTESIS}3\\ 9. &amp; (\varphi \wedge \varphi _{2}) &amp; &amp; \text{CONJUNCIONINTRODUCCION}(2,8)\\ 10. &amp; ((\varphi \wedge \varphi _{1})\vee (\varphi \wedge \varphi _{2})) &amp; &amp; \text{TESIS}3\text{DISJUNCIONINTRODUCCION}(9)\\ 11. &amp; \varphi _{2}\rightarrow ((\varphi \wedge \varphi _{1})\vee (\varphi \wedge \varphi _{2})) &amp; &amp; \text{CONCLUSION}\\ 12. &amp; ((\varphi \wedge \varphi _{1})\vee (\varphi \wedge \varphi _{2})) &amp; &amp; \text{TESIS}1\text{DIVISIONPORCASOS}(3,7,11)\\ 13. &amp; (\varphi \wedge (\varphi _{1}\vee \varphi _{2}))\rightarrow ((\varphi \wedge \varphi _{1})\vee (\varphi \wedge \varphi _{2})) &amp; &amp; \text{CONCLUSION} \end{array} \]
     </li>
     <li class='enumerate' id='x1-196012x6'>\(((\varphi \wedge \varphi _{1})\vee (\varphi \wedge \varphi _{2}))\rightarrow (\varphi \wedge (\varphi _{1}\vee \varphi _{2}))\) es un teorema de \((\emptyset ,\tau )\). Una prueba formal: \[ \begin{array}{llll} 1.\; &amp; ((\varphi \wedge \varphi _{1})\vee (\varphi \wedge \varphi _{2})) &amp; &amp; \text{HIPOTESIS}1\\ 2.\; &amp; (\varphi \wedge \varphi _{1}) &amp; &amp; \text{HIPOTESIS}2\\ 3.\; &amp; \varphi &amp; &amp; \text{CONJUNCIONELIMINACION}(2)\\ 4.\; &amp; \varphi _{1} &amp; &amp; \text{CONJUNCIONELIMINACION}(2)\\ 5. &amp; (\varphi _{1}\vee \varphi _{2}) &amp; &amp; \text{DISJUNCIONINTRODUCCION}(4)\\ 6. &amp; \varphi \wedge (\varphi _{1}\vee \varphi _{2}) &amp; &amp; \text{TESIS}2\text{CONJUNCIONINTRODUCCION}(3,5)\\ 7. &amp; (\varphi \wedge \varphi _{1})\rightarrow (\varphi \wedge (\varphi _{1}\vee \varphi _{2})) &amp; &amp; \text{CONCLUSION}\\ 8. &amp; (\varphi \wedge \varphi _{2}) &amp; &amp; \text{HIPOTESIS}3\\ 9. &amp; \varphi &amp; &amp; \text{CONJUNCIONELIMINACION}(8)\\ 10. &amp; \varphi _{2} &amp; &amp; \text{CONJUNCIONELIMINACION}(8)\\ 11. &amp; (\varphi _{1}\vee \varphi _{2}) &amp; &amp; \text{DISJUNCIONINTRODUCCION}(10)\\ 12. &amp; \varphi \wedge (\varphi _{1}\vee \varphi _{2}) &amp; &amp; \text{TESIS}3\text{CONJUNCIONINTRODUCCION}(9,11)\\ 13. &amp; (\varphi \wedge \varphi _{2})\rightarrow (\varphi \wedge (\varphi _{1}\vee \varphi _{2})) &amp; &amp; \text{CONCLUSION}\\ 14. &amp; (\varphi \wedge (\varphi _{1}\vee \varphi _{2})) &amp; &amp; \text{TESIS}1\text{DIVISIONPORCASOS}(1,7,13)\\ 15. &amp; ((\varphi \wedge \varphi _{1})\vee (\varphi \wedge \varphi _{2}))\rightarrow (\varphi \wedge (\varphi _{1}\vee \varphi _{2})) &amp; &amp; \text{CONCLUSION} \end{array} \]
     </li>
     <li class='enumerate' id='x1-196014x7'>Sea \(\tau \) un tipo cualquiera y sea \(\varphi =_{d}\varphi (v)\) una formula de tipo \(\tau \). Ya que \((\lnot \forall v\varphi \leftrightarrow \exists v\lnot \varphi )\) es un axioma
     logico, tenemos que \[ ((\lnot \forall v\varphi \leftrightarrow \exists v\lnot \varphi ),\text{AXIOMALOGICO}) \] es una prueba formal de \((\lnot \forall v\varphi \leftrightarrow \exists v\lnot \varphi )\) en la teoria \((\emptyset ,\tau )\). A continuacion
     se da una prueba formal en la teoria \((\emptyset ,\tau )\) de la sentencia \((\lnot \forall v\varphi \leftrightarrow \exists v\lnot \varphi )\) la cual no usa el
     hecho de que \((\lnot \forall v\varphi \leftrightarrow \exists v\lnot \varphi )\) sea un axioma logico. Notar que en las primeras 10 lineas se
     prueba \((\lnot \exists v\lnot \varphi \rightarrow \lnot \lnot \forall v\varphi )\), es decir el contraresiproco de \((\lnot \forall v\varphi \rightarrow \exists v\lnot \varphi )\). De la linea 11 hasta la 17 se prueba
     \((\lnot \forall v\varphi \rightarrow \exists v\lnot \varphi )\). En las lineas restantes se prueba la implicacion reciproca de \((\lnot \forall v\varphi \rightarrow \exists v\lnot \varphi )\), es decir \((\exists v\lnot \varphi \rightarrow \lnot \forall v\varphi )\)
     y en el ultimo paso se obtiene \((\lnot \forall v\varphi \leftrightarrow \exists v\lnot \varphi )\) por la regla de equivalencia-introduccion.
     Cabe obsservar que esta prueba formal no es natural u obvia, mas bien es
     dificil de encontrar. \[ \begin{array}{clll} 1. &amp; \lnot \exists v\lnot \varphi &amp; &amp; \text{HIPOTESIS}1\\ 2. &amp; \lnot \varphi (c) &amp; &amp; \text{HIPOTESIS}2\\ 3. &amp; \exists v\lnot \varphi &amp; &amp; \text{EXISTENCIAL}(2)\\ 4. &amp; (\exists v\lnot \varphi \wedge \lnot \exists v\lnot \varphi ) &amp; &amp; \text{TESIS}2\text{CONJUNCIONINTRODUCCION}(3,1)\\ 5. &amp; \lnot \varphi (c)\rightarrow (\exists v\lnot \varphi \wedge \lnot \exists v\lnot \varphi ) &amp; &amp; \text{CONCLUSION}\\ 6. &amp; \varphi (c) &amp; &amp; \text{ABSURDO}(5)\\ 7. &amp; \forall v\varphi &amp; &amp; \text{GENERALIZACION}(6)\\ 8. &amp; (\forall v\varphi \leftrightarrow \lnot \lnot \forall v\varphi ) &amp; &amp; \text{AXIOMALOGICO}\\ 9. &amp; \lnot \lnot \forall v\varphi &amp; &amp; \text{TESIS}1\text{REEMPLAZO}(7,8)\\ 10. &amp; (\lnot \exists v\lnot \varphi \rightarrow \lnot \lnot \forall v\varphi ) &amp; &amp; \text{CONCLUSION}\\ 11. &amp; \lnot \forall v\varphi &amp; &amp; \text{HIPOTESIS}3\\ 12. &amp; \lnot \exists v\lnot \varphi &amp; &amp; \text{HIPOTESIS}4\\ 13. &amp; \lnot \lnot \forall v\varphi &amp; &amp; \text{MODUSPONENS}(12,10)\\ 14. &amp; (\lnot \forall v\varphi \wedge \lnot \lnot \forall v\varphi ) &amp; &amp; \text{TESIS}4\text{CONJUNCIONINTRODUCCION}(11,13)\\ 15. &amp; \lnot \exists v\lnot \varphi \rightarrow (\lnot \forall v\varphi \wedge \lnot \lnot \forall v\varphi ) &amp; &amp; \text{CONCLUSION}\\ 16. &amp; \exists v\lnot \varphi &amp; &amp; \text{TESIS}3\text{ABSURDO}(15)\\ 17. &amp; (\lnot \forall v\varphi \rightarrow \exists v\lnot \varphi ) &amp; &amp; \text{CONCLUSION}\\ 18. &amp; \exists v\lnot \varphi &amp; &amp; \text{HIPOTESIS}5\\ 19. &amp; \lnot \varphi (e) &amp; &amp; \text{ELECCION}(18)\\ 20. &amp; \forall v\varphi &amp; &amp; \text{HIPOTESIS}6\\ 21. &amp; \varphi (e) &amp; &amp; \text{PARTICULARIZACION}(20)\\ 22. &amp; (\varphi (e)\wedge \lnot \varphi (e)) &amp; &amp; \text{TESIS}6\text{CONJUNCIONINTRODUCCION}(21,19)\\ 23. &amp; \forall v\varphi \rightarrow (\varphi (e)\wedge \lnot \varphi (e)) &amp; &amp; \text{CONCLUSION}\\ 24. &amp; \lnot \forall v\varphi &amp; &amp; \text{TESIS}5\text{ABSURDO}(23)\\ 25. &amp; (\exists v\lnot \varphi \rightarrow \lnot \forall v\varphi ) &amp; &amp; \text{CONCLUSION}\\ 26. &amp; (\lnot \forall v\varphi \leftrightarrow \exists v\lnot \varphi ) &amp; &amp; \text{EQUIVALENCIAINTRODUCCION}(17,25) \end{array} \]
     <!-- l. 16190 --><p class='noindent'>En virtud de la prueba formal anterior se tiene que si redujeramos la
     lista de axiomas logicos sacando las sentencias de la forma \((\lnot \forall v\varphi \leftrightarrow \exists v\lnot \varphi )\), el concepto
     de prueba formal resultante seria equivalente al dado. La razon por la
     cual se incluyen las sentencias de la forma \((\lnot \forall v\varphi \leftrightarrow \exists v\lnot \varphi )\) como axiomas logicos es que
     nuestra definicion de prueba formal en una teoria intenta modelizar o
     describir en forma matematica a las pruebas reales de los matematicos y
     la sentencia \((\lnot \forall v\varphi \leftrightarrow \exists v\lnot \varphi )\) es obviamente cierta para un matematico por lo cual seria un
     detalle artificioso de nuestra definicion si dicha sentencia resultara dificil
     de probar con el concepto de prueba formalizado. Dicho de otra forma,
     nuestro concepto de prueba formal no modelizaria en forma natural a las
     pruebas matematicas reales. No sucede lo mismo con los axiomas de la
     forma \((\lnot \exists v\varphi \leftrightarrow \forall v\lnot \varphi )\) los cuales se pueden probar formalmente en forma directa (y sin

     usar axiomas de las ultimas dos formas de axiomas logicos) tal como lo
     haria un matematico. Sin envargo hemos elejido incluir a las sentencias de
     la forma \((\lnot \exists v\varphi \leftrightarrow \forall v\lnot \varphi )\) como axiomas logicos por una cuestion estetica y mnemotecnica
     ya que ambos axiomas \((\lnot \forall v\varphi \leftrightarrow \exists v\lnot \varphi )\) y \((\lnot \exists v\varphi \leftrightarrow \forall v\lnot \varphi )\) estan muy emparentados ya que nos dicen como
     ”eliminar la negacion de un cuantificador”.</p></li></ol>
<!-- l. 16213 --><p class='noindent'>\(\bigskip \)
</p><!-- l. 16215 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>8.3   </span> <a id='x1-1970008.3'></a>Propiedades basicas de pruebas y teoremas</h4>
<!-- l. 16217 --><p class='noindent'>Por supuesto los numeros asociados a las hipotesis en una prueba son completamente
arbitrarios y pueden cambiarse, es decir:
</p>
   <div class='newtheorem'>
<!-- l. 16219 --><p class='noindent'><span class='head'>
<a id='x1-197001r213'></a>
<span class='cmbx-10'>Lema 213 </span>(Cambio de indice de hipotesis)<span class='cmbx-10'>.</span>  </span><span class='cmti-10'>Sea</span> \((\mathbf{\varphi },\mathbf{J})\) <span class='cmti-10'>una prueba formal de</span> \(\varphi \) <span class='cmti-10'>en</span> \((\Sigma ,\tau )\)<span class='cmti-10'>.
</span><span class='cmti-10'>Sea</span> \(m\in \mathbf{N}\) <span class='cmti-10'>tal que</span> \(\mathbf{J}_{i}\neq \) \(\mathrm{HIPOTESIS}\bar{m}\)<span class='cmti-10'>, para cada</span> \(i=1,...,n(\mathbf{\varphi })\)<span class='cmti-10'>. Supongamos que</span> \(\mathbf{J}_{i}=\) \(\mathrm{HIPOTESIS}\bar{k}\) <span class='cmti-10'>y que</span> \(\mathbf{J}_{j}=\) \(\mathrm{TESIS}\bar{k}\alpha \)<span class='cmti-10'>, con</span> \([\alpha ]_{1}\notin Num\)<span class='cmti-10'>. Sea</span> \(\mathbf{\tilde{J}}\) <span class='cmti-10'>el resultado de
</span><span class='cmti-10'>reemplazar en</span> \(\mathbf{J}\) <span class='cmti-10'>la justificacion</span> \(\mathbf{J}_{i}\) <span class='cmti-10'>por</span> \(\mathrm{HIPOTESIS}\bar{m}\) <span class='cmti-10'>y reemplazar la justificacion</span> \(\mathbf{J}_{j}\) <span class='cmti-10'>por</span> \(\mathrm{TESIS}\bar{m}\alpha \)<span class='cmti-10'>. Entonces</span>
\((\mathbf{\varphi },\mathbf{\tilde{J}})\) <span class='cmti-10'>es una prueba formal de</span> \(\varphi \) <span class='cmti-10'>en</span> \((\Sigma ,\tau )\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 16234 --><p class='indent'>   Tambien podemos cambiar los nombres de cte auxiliares
</p>
   <div class='newtheorem'>
<!-- l. 16235 --><p class='noindent'><span class='head'>
<a id='x1-197002r214'></a>
<span class='cmbx-10'>Lema 214 </span>(Cambio de ctes auxiliares)<span class='cmbx-10'>.</span>  </span><span class='cmti-10'>Sea</span> \((\mathbf{\varphi },\mathbf{J})\) <span class='cmti-10'>una prueba formal de</span> \(\varphi \) <span class='cmti-10'>en</span> \((\Sigma ,\tau )\)<span class='cmti-10'>. Sea</span> \(\mathcal{C}_{1}\)
<span class='cmti-10'>el conjunto de nombres de constante que ocurren en</span> \(\mathbf{\varphi }\) <span class='cmti-10'>y que no pertenecen a</span> \(\mathcal{C}\)<span class='cmti-10'>.
</span><span class='cmti-10'>Sea</span> \(e\in \mathcal{C}_{1}\)<span class='cmti-10'>. Sea</span> \(\tilde{e}\notin \mathcal{C}\cup \mathcal{C}_{1}\) <span class='cmti-10'>tal que</span> \((\mathcal{C}\cup (\mathcal{C}_{1}-\{e\})\cup \{\tilde{e}\},\mathcal{F},\mathcal{R},a)\) <span class='cmti-10'>es un tipo. Sea</span> \(\mathbf{\tilde{\varphi }}_{i}=\) <span class='cmti-10'>resultado de reemplazar en</span> \(\mathbf{\varphi }_{i}\) <span class='cmti-10'>cada ocurrencia
</span><span class='cmti-10'>de</span> \(e\) <span class='cmti-10'>por</span> \(\tilde{e}.\) <span class='cmti-10'>Entonces</span> \((\mathbf{\tilde{\varphi }}_{1}...\mathbf{\tilde{\varphi }}_{n(\mathbf{\varphi })},\mathbf{J})\) <span class='cmti-10'>es una prueba formal de</span> \(\varphi \) <span class='cmti-10'>en</span> \((\Sigma ,\tau )\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 16247 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 16248 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Sean </p><div class='eqnarray'>\begin{eqnarray*} \tau _{1} &amp; = &amp; (\mathcal{C}\cup \mathcal{C}_{1},\mathcal{F},\mathcal{R},a)\\ \tau _{2} &amp; = &amp; (\mathcal{C}\cup (\mathcal{C}_{1}-\{e\})\cup \{\tilde{e}\},\mathcal{F},\mathcal{R},a) \end{eqnarray*}
</div>Para cada \(c\in \mathcal{C}\cup (\mathcal{C}_{1}-\{e\})\) definamos \(\tilde{c}=c\). Notese que el mapeo \(c\rightarrow \tilde{c}\) es una biyeccion entre el conjunto de
nombres de constante de \(\tau _{1}\) y el conjunto de nombres de cte de \(\tau _{2}\). Para cada \(t\in T^{\tau _{1}}\) sea \(\tilde{t}=\)
resultado de reemplazar en \(t\) cada ocurrencia de \(c\) por \(\tilde{c}\), para cada \(c\in \mathcal{C}\cup \mathcal{C}_{1}\). Analogamente para
una formula \(\psi \in F^{\tau _{1}}\), sea \(\tilde{\psi }=\) resultado de reemplazar en \(\psi \) cada ocurrencia de \(c\) por \(\tilde{c}\),
para cada \(c\in \mathcal{C}\cup \mathcal{C}_{1}\). Notese que los mapeos \(t\rightarrow \tilde{t}\) y \(\psi \rightarrow \tilde{\psi }\) son biyecciones naturales entre \(T^{\tau _{1}}\) y \(T^{\tau _{2}}\) y
entre \(F^{\tau _{1}}\) y \(F^{\tau _{2}}\), respectivamente. Notese que cualesquiera sean \(\psi _{1},\psi _{2}\in F^{\tau _{1}}\), tenemos que \(\psi _{1}\) se
deduce de \(\psi _{2}\) por la regla de generalizacion con constante \(c\) sii \(\tilde{\psi }_{1}\) se deduce de \(\tilde{\psi }_{2}\) por
la regla de generalizacion con constante \(\tilde{c}\). Para las otras reglas sucede lo
mismo. Notese tambien que \(c\) ocurre en \(\psi \) sii \(\tilde{c}\) ocurre en \(\tilde{\psi }.\) Mas aun notese que \(c\)
depende de \(d\) en \((\mathbf{\varphi },\mathbf{J})\) sii \(\tilde{c}\) depende de \(\tilde{d}\) en \((\mathbf{\tilde{\varphi }},\mathbf{J})\), donde \(\mathbf{\tilde{\varphi }}=\widetilde{\mathbf{\varphi }_{1}}...\widetilde{\mathbf{\varphi }_{n(\mathbf{\varphi })}}\). Ahora es facil chequear que \((\mathbf{\tilde{\varphi }},\mathbf{J})\) es
una prueba formal de \(\varphi \) en \((\Sigma ,\tau )\) basandose en que \((\mathbf{\varphi },\mathbf{J})\) es una prueba formal de \(\varphi \) en
\((\Sigma ,\tau )\).                                                                                                     □
   </div>
   <div class='newtheorem'>
<!-- l. 16280 --><p class='noindent'><span class='head'>
<a id='x1-197003r215'></a>
<span class='cmbx-10'>Lema 215.</span>  </span><span class='cmti-10'>Sea</span> \((\Sigma ,\tau )\) <span class='cmti-10'>una teoria.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-197004x215'><span class='cmti-10'>Si</span> \((\Sigma ,\tau )\vdash \varphi _{1},...,\varphi _{n}\) <span class='cmti-10'>y</span> \((\Sigma \cup \{\varphi _{1},...,\varphi _{n}\},\tau )\vdash \varphi ,\) <span class='cmti-10'>entonces</span> \((\Sigma ,\tau )\vdash \varphi .\)
     </li>
     <li class='enumerate' id='x1-197005x215'><span class='cmti-10'>Si</span> \((\Sigma ,\tau )\vdash \varphi _{1},...,\varphi _{n}\) <span class='cmti-10'>y</span> \(\varphi \) <span class='cmti-10'>se deduce por alguna regla universal a partir de</span> \(\varphi _{1},...,\varphi _{n}\)<span class='cmti-10'>, entonces</span> \((\Sigma ,\tau )\vdash \varphi \)<span class='cmti-10'>.</span>
     </li>
     <li class='enumerate' id='x1-197006x215'>\((\Sigma ,\tau )\vdash (\varphi \rightarrow \psi )\) <span class='cmti-10'>si y solo si</span> \((\Sigma \cup \{\varphi \},\tau )\vdash \psi \)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 16292 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 16293 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(1) Notese que basta con hacer el caso \(n=1\). Supongamos entonces que \((\Sigma ,\tau )\vdash \varphi _{1}\) y \((\Sigma \cup \{\varphi _{1}\},\tau )\vdash \varphi \).
Sea \((\alpha _{1}...\alpha _{h},I_{1}...I_{h})\) una prueba formal de \(\varphi _{1}\) en \((\Sigma ,\tau )\). Sea \((\psi _{1}...\psi _{m},J_{1}...J_{m})\) una prueba formal de \(\varphi \) en \((\Sigma \cup \{\varphi _{1}\},\tau )\). Notese
que por los Lemas <a href='#x1-197001r213'>213<!-- tex4ht:ref: cambio-indice-hipotesis  --></a> y <a href='#x1-197002r214'>214<!-- tex4ht:ref: cambio-ctes  --></a> podemos suponer que estas dos pruebas no
comparten ningun nombre de constante auxiliar y que tampoco comparten
numeros asociados a hipotesis o tesis. Para cada \(i=1,...,m\), definamos \(\widetilde{J_{i}}\) de la siguiente
manera.

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-197007x8.3'>Si \(J_{i}=\alpha \mathrm{AXIOMAPROPIO}\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\) y \(\psi _{i}=\varphi _{1}\), entonces \(\widetilde{J_{i}}=\alpha \mathrm{EVOCACION}(\overline{h})\)
     </li>
     <li class='enumerate' id='x1-197008x8.3'>Si \(J_{i}=\alpha \mathrm{AXIOMAPROPIO}\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\) y \(\psi _{i}\notin \{\varphi _{1}\}\), entonces \(\widetilde{J_{i}}=\alpha \mathrm{AXIOMAPROPIO}\).
     </li>
     <li class='enumerate' id='x1-197009x8.3'>Si \(J_{i}=\alpha \mathrm{AXIOMALOGICO}\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), entonces \(\widetilde{J_{i}}=\alpha \mathrm{AXIOMALOGICO}\)
     </li>
     <li class='enumerate' id='x1-197010x8.3'>Si \(J_{i}=\alpha \mathrm{CONCLUSION}\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), entonces \(\widetilde{J_{i}}=\alpha \mathrm{CONCLUSION}\).
     </li>
     <li class='enumerate' id='x1-197011x8.3'>Si \(J_{i}=\mathrm{HIPOTESIS}\bar{k}\), entonces \(\widetilde{J_{i}}=\mathrm{HIPOTESIS}\bar{k}\)
     </li>
     <li class='enumerate' id='x1-197012x8.3'>Si \(J_{i}=\alpha R(\overline{l_{1}},...,\overline{l_{k}})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), entonces \(\widetilde{J_{i}}=\alpha R(\overline{l_{1}+h},...,\overline{l_{k}+h})\)</li></ol>
<!-- l. 16317 --><p class='noindent'>Es facil chequear que \[ (\alpha _{1}...\alpha _{h}\psi _{1}...\psi _{m},I_{1}...I_{h}\widetilde{J_{1}}...\widetilde{J_{m}}) \] es una prueba formal de \(\varphi \) en \((\Sigma ,\tau )\)
</p><!-- l. 16323 --><p class='indent'>   (2) Supongamos que \((\Sigma ,\tau )\vdash \varphi _{1},...,\varphi _{n}\) y que \(\varphi \) se deduce por regla \(R\) a partir de \(\varphi _{1},...,\varphi _{n}\), con \(R\) universal.
Notese que \[ \begin{array}{llll} 1.\; &amp; \varphi _{1} &amp; &amp; \text{AXIOMAPROPIO}\\ 2.\; &amp; \varphi _{2} &amp; &amp; \text{AXIOMAPROPIO}\\ \vdots &amp; \vdots &amp; &amp; \vdots \\ n. &amp; \varphi _{n} &amp; &amp; \text{AXIOMAPROPIO}\\ n+1. &amp; \varphi &amp; &amp; R(\bar{1},...,\bar{n}) \end{array} \] es una prueba formal de \(\varphi \) en \((\Sigma \cup \{\varphi _{1},...,\varphi _{n}\},\tau )\), lo cual por (1) nos dice que \((\Sigma ,\tau )\vdash \varphi \).
</p><!-- l. 16338 --><p class='indent'>   (3) Supongamos \((\Sigma ,\tau )\vdash (\varphi \rightarrow \psi )\). Entonces tenemos que \((\Sigma \cup \{\varphi \},\tau )\vdash (\varphi \rightarrow \psi ),\varphi \), lo cual por (2) nos dice que \((\Sigma \cup \{\varphi \},\tau )\vdash \psi \).
Supongamos ahora que \((\Sigma \cup \{\varphi \},\tau )\vdash \psi \). Sea \((\varphi _{1}...\varphi _{n},J_{1}...,J_{n})\) una prueba formal de \(\psi \) en \((\Sigma \cup \{\varphi \},\tau )\). Para cada \(i=1,...,n\), definamos \(\widetilde{J_{i}}\) de la
siguiente manera.
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-197013x8.3'>Si \(\varphi _{i}=\varphi \) y \(J_{i}=\alpha \mathrm{AXIOMAPROPIO}\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), entonces \(\widetilde{J_{i}}=\alpha \mathrm{EVOCACION}(1)\)
     </li>
     <li class='enumerate' id='x1-197014x8.3'>Si \(\varphi _{i}\neq \varphi \) y \(J_{i}=\alpha \mathrm{AXIOMAPROPIO}\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), entonces \(\widetilde{J_{i}}=\alpha \mathrm{AXIOMAPROPIO}\)
     </li>
     <li class='enumerate' id='x1-197015x8.3'>Si \(J_{i}=\alpha \mathrm{AXIOMALOGICO}\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), entonces \(\widetilde{J_{i}}=\alpha \mathrm{AXIOMALOGICO}\)
     </li>
     <li class='enumerate' id='x1-197016x8.3'>Si \(J_{i}=\alpha \mathrm{CONCLUSION}\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), entonces \(\widetilde{J_{i}}=\alpha \mathrm{CONCLUSION}\)
     </li>
     <li class='enumerate' id='x1-197017x8.3'>Si \(J_{i}=\mathrm{HIPOTESIS}\bar{k}\), entonces \(\widetilde{J_{i}}=\mathrm{HIPOTESIS}\bar{k}\)
     </li>
     <li class='enumerate' id='x1-197018x8.3'>Si \(J_{i}=\alpha R(\overline{l_{1}},...,\overline{l_{k}})\), con \(\alpha \in \{\varepsilon \}\cup \{\mathrm{TESIS}\bar{k}:k\in \mathbf{N}\}\), entonces \(\widetilde{J_{i}}=\alpha P(\overline{l_{1}+1},...,\overline{l_{k}+1})\)</li></ol>
<!-- l. 16361 --><p class='noindent'>Sea \(m\) tal que ninguna \(J_{i}\) es igual a \(\mathrm{HIPOTESIS}\bar{m}\). Notese que \(\widetilde{J_{n}}\) no es de la forma \(\mathrm{TESIS}\bar{k}\beta \) ni de la forma \(\mathrm{HIPOTESIS}\bar{k}\) (por
que?) por lo cual \(\mathrm{TESIS}\bar{m}\widetilde{J_{n}}\) es una justificacion. Es facil chequear que \[ (\varphi \varphi _{1}...\varphi _{n}(\varphi \rightarrow \psi ),\text{HIPOTESIS}\bar{m}\widetilde{J_{1}}...\widetilde{J_{n-1}}\mathrm{TESIS}\bar{m}\widetilde{J_{n}}\text{CONCLUSION}) \] es una prueba formal de
\((\varphi \rightarrow \psi )\) en \((\Sigma ,\tau )\)                                                                                                 □
</p>
   </div>

<!-- l. 16377 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>8.4   </span> <a id='x1-1980008.4'></a>Consistencia</h4>
<!-- l. 16379 --><p class='noindent'>Una teoria \((\Sigma ,\tau )\) sera <span class='cmti-10'>inconsistente </span>cuando haya una sentencia \(\varphi \) tal que \((\Sigma ,\tau )\vdash (\varphi \wedge \lnot \varphi ).\) Una teoria \((\Sigma ,\tau )\) sera
<span class='cmti-10'>consistente </span>cuando no sea inconsistente.
</p>
   <div class='newtheorem'>
<!-- l. 16383 --><p class='noindent'><span class='head'>
<a id='x1-198001r216'></a>
<span class='cmbx-10'>Lema 216.</span>  </span><span class='cmti-10'>Sea</span> \((\Sigma ,\tau )\) <span class='cmti-10'>una teoria.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-198002x216'><span class='cmti-10'>Si</span> \((\Sigma ,\tau )\) <span class='cmti-10'>es inconsistente, entonces</span> \((\Sigma ,\tau )\vdash \varphi \)<span class='cmti-10'>, para toda sentencia</span> \(\varphi .\)
     </li>
     <li class='enumerate' id='x1-198003x216'><span class='cmti-10'>Si</span> \((\Sigma ,\tau )\) <span class='cmti-10'>es consistente y</span> \((\Sigma ,\tau )\vdash \varphi \)<span class='cmti-10'>, entonces</span> \((\Sigma \cup \{\varphi \},\tau )\) <span class='cmti-10'>es consistente.</span>
     </li>
     <li class='enumerate' id='x1-198004x216'><span class='cmti-10'>Si</span> \((\Sigma ,\tau )\not \vdash \lnot \varphi \)<span class='cmti-10'>, entonces</span> \((\Sigma \cup \{\varphi \},\tau )\) <span class='cmti-10'>es consistente.</span></li></ol>
   </div>
<!-- l. 16395 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 16396 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(1) Si \((\Sigma ,\tau )\) es inconsistente, entonces por definicion tenemos que \((\Sigma ,\tau )\vdash \psi \wedge \lnot \psi \) para alguna
sentencia \(\psi \). Dada una sentencia cualquiera \(\varphi \) tenemos que \(\varphi \) se deduce por la regla
del absurdo a partir de \(\psi \wedge \lnot \psi \) con lo cual (2) del Lema <a href='#x1-197003r215'>215<!-- tex4ht:ref: prop-bas-prueb  --></a> nos dice que \((\Sigma ,\tau )\vdash \varphi \)
</p><!-- l. 16402 --><p class='indent'>   (2) Supongamos \((\Sigma ,\tau )\) es consistente y \((\Sigma ,\tau )\vdash \varphi \). Si \((\Sigma \cup \{\varphi \},\tau )\) fuera inconsistente, entonces \((\Sigma \cup \{\varphi \},\tau )\vdash \psi \wedge \lnot \psi \), para
alguna sentencia \(\psi \), lo cual por (1) del Lema <a href='#x1-197003r215'>215<!-- tex4ht:ref: prop-bas-prueb  --></a> nos diria que \((\Sigma ,\tau )\vdash \psi \wedge \lnot \psi \), es decir nos diria
que \((\Sigma ,\tau )\) es inconsistente.
</p><!-- l. 16408 --><p class='indent'>   (3) es dejada al lector.                                                                    □
</p>
   </div>

<!-- l. 16413 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>8.5   </span> <a id='x1-1990008.5'></a>El teorema de correccion</h4>
<!-- l. 16415 --><p class='noindent'>Como ya vimos en las secciones anteriores, el concepto matematico de prueba formal
en una teoria \((\Sigma ,\tau )\) fue hecho como un intento de modelizar ciertas pruebas que realizan
los matematicos profecionales, a las que llamamos pruebas elementales. Es claro que
cuando un matematico hace una prueba elemental de una setencia \(\varphi \) en una teoria \((\Sigma ,\tau )\),
comienza imaginando una estructura \(\mathbf{A}\) de tipo \(\tau \) la cual satisface todas las
sentencias de \(\Sigma \), y luego, y en forma obvia, las sentencias que van apareciendo
tambien valen en \(\mathbf{A}\), interpretando adecuadamente los nombres de constante
auxiliares introducidos. Esto por supuesto finalmente nos conduce a saber que \(\mathbf{A}\)
satisface tambien \(\varphi \). En algun sentido la mision de una prueba es justamente eso:
justificar con solidez que la sentencia a probar vale en todos los modelos de la
teoria.
</p><!-- l. 16430 --><p class='indent'>   O sea que si nuestro concepto de prueba formal permitiera probar sentencias que
no sean verdaderas en todos los modelos de la teoria, no seria correcto o fiable.
Este no es el caso y el teorema que asegura que las pruebas formales solo
prueban sentencias verdaderas en todos los modelos se llama Teorema de
Correccion. Lo enunciaremos fomalmente a continuacion aunque no daremos la
prueba ya que es dificultosa. Antes una definicion. Dadas \((\Sigma ,\tau )\) una teoria y \(\varphi \) una
sentencia de tipo \(\tau \), escribiremos \((\Sigma ,\tau )\models \varphi \) cuando \(\varphi \) sea verdadera en todo modelo de
\((\Sigma ,\tau )\).
</p>
   <div class='newtheorem'>
<!-- l. 16441 --><p class='noindent'><span class='head'>
<a id='x1-199001r217'></a>
<span class='cmbx-10'>Teorema 217 </span>(Teorema de Correccion)<span class='cmbx-10'>.</span>  </span>\((\Sigma ,\tau )\vdash \varphi \) <span class='cmti-10'>implica</span> \((\Sigma ,\tau )\models \varphi \)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 16445 --><p class='indent'>   Un corolario muy importante es el siguiente.
</p>
   <div class='newtheorem'>
<!-- l. 16446 --><p class='noindent'><span class='head'>
<a id='x1-199002r218'></a>
<span class='cmbx-10'>Corollary 218.</span>  </span><span class='cmti-10'>Si</span> \((\Sigma ,\tau )\) <span class='cmti-10'>tiene un modelo, entonces</span> \((\Sigma ,\tau )\) <span class='cmti-10'>es consistente.</span>
</p>
   </div>
<!-- l. 16451 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 16452 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Supongamos \(\mathbf{A}\) es un modelo de \((\Sigma ,\tau ).\) Si \((\Sigma ,\tau )\) fuera inconsistente, tendriamos que
hay una \(\varphi \in S^{t}\) tal que \((\Sigma ,\tau )\vdash (\varphi \wedge \lnot \varphi )\), lo cual por el Teorema de Correccion nos diria que \(\mathbf{A}\models (\varphi \wedge \lnot \varphi )\)          □
</p>
   </div>
<!-- l. 16459 --><p class='indent'>   Concluimos la subseccion dando algunos ejemplos que muestran que si
hacemos mas permisiva la definicion de prueba formal, esta ya no resulta
correcta.
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-199003x8.5'>Este ejemplo muestra que en la sentencia a generalizar (dentro de una
     prueba formal) no puede ocurrir un nombre de cte el cual dependa del
     nombre de cte a generalizar. Sea \(\tau =(\emptyset ,\{f^{1}\},\emptyset ,a)\) y sea \(\Sigma =\{\forall y\exists x\;y\equiv f(x)\}\). Sea \(T=(\Sigma ,\tau )\). Notese que una estructura \(\mathbf{A}\)
     de tipo \(\tau \) es modelo de \(T\) sii \(f^{\mathbf{A}}\) es una funcion sobre. Consideremos \[ \begin{array}{llll} \ 1. &amp; \forall y\exists x\;y\equiv f(x) &amp; &amp; \text{AXIOMAPROPIO}\\ \ 2. &amp; \exists x\;y_{0}\equiv f(x) &amp; &amp; \text{PARTICULARIZACION}(1)\\ \ 3. &amp; y_{0}\equiv f(e) &amp; &amp; \text{ELECCION}(2)\\ \ 4. &amp; \forall y\;y\equiv f(e) &amp; &amp; \text{GENERALIZACION}(3)\\ \ 5. &amp; c\equiv f(e) &amp; &amp; \text{PARTICULARIZACION}(4)\\ \ 6. &amp; d\equiv f(e) &amp; &amp; \text{PARTICULARIZACION}(4)\\ \ 7. &amp; f(e)\equiv d &amp; &amp; \text{COMMUTATIVIDAD}(6)\\ \ 8. &amp; c\equiv d &amp; &amp; \text{TRANSITIVIDAD}(5,7)\\ \ 9. &amp; \forall y\;c\equiv y &amp; &amp; \text{GENERALIZACION}(8)\\ 10. &amp; \forall x\forall y\;x\equiv y &amp; &amp; \text{GENERALIZACION}(9) \end{array} \] Obviamente,
     si permitieramos que lo anterior fuera una prueba formal, dejaria de valer
     el teorema de correccion ya que hay muchos modelos de \(T\), los cuales no
     satisfacen \(\forall x\forall y\;x\equiv y\).
     </li>
     <li class='enumerate' id='x1-199004x8.5'>El siguiente ejemplo muestra que el nombre de cte a generalizar no puede
     ocurrir en hipotesis de la sentencia a la cual se le aplica la generalizacion.
     Sea \(\tau =(\{1\},\emptyset ,\emptyset ,\emptyset )\) y sea \(T=(\emptyset ,\tau )\). Consideremos \[ \begin{array}{llll} 1.\; &amp; c\equiv 1 &amp; &amp; \text{HIPOTESIS}1\\ 2.\; &amp; \forall x\;x\equiv 1 &amp; &amp; \text{TESIS}1\text{GENERALIZACION}(1)\\ 3.\; &amp; (c\equiv 1\rightarrow \forall x\;x\equiv 1) &amp; &amp; \text{CONCLUSION}\\ 4.\; &amp; \forall y\;\left (y\equiv 1\rightarrow \forall x\;x\equiv 1\right ) &amp; &amp; \text{GENERALIZACION}(3)\\ 5.\; &amp; \left (1\equiv 1\rightarrow \forall x\;x\equiv 1\right ) &amp; &amp; \text{PARTICULARIZACION}(4)\\ 6. &amp; 1\equiv 1 &amp; &amp; \text{AXIOMALOGICO}\\ 7. &amp; \forall x\;x\equiv 1 &amp; &amp; \text{MODUSPONENS}(5,6) \end{array} \] Si permitieramos que lo anterior fuera una
     prueba formal, dejaria de valer el teorema de correccion ya que hay muchos
     modelos de \(T\) (toda estructura es un modelo de \(T\)) los cuales no satisfacen \(\forall x\;x\equiv 1\).
     </li>
     <li class='enumerate' id='x1-199005x8.5'>El siguiente ejemplo muestra que la sentencia a generalizar no puede tener
     una hipotesis en las cual ocurra un nombre de cte que dependa del nombre
     de cte que se generaliza. Sea \(\tau =(\emptyset ,\emptyset ,\emptyset ,\emptyset )\) y sea \(T=(\emptyset ,\tau )\). Consideremos \[ \begin{array}{llll} \ 1. &amp; c\equiv c &amp; &amp; \text{AXIOMALOGICO}\\ \ 2. &amp; \exists z\;z\equiv c &amp; &amp; \text{EXISTENCIA}(1)\\ \ 3. &amp; e\equiv c &amp; &amp; \text{ELECCION}(2)\\ \ 4. &amp; d\equiv e &amp; &amp; \text{HIPOTESIS}1\\ \ 5. &amp; d\equiv c &amp; &amp; \text{TRANSITIVIDAD}(4,3)\\ \ 6. &amp; \forall y\;d\equiv y &amp; &amp; \text{TESIS}1\text{GENERALIZACION}(5)\\ \ 7. &amp; d\equiv e\rightarrow \forall y\;d\equiv y &amp; &amp; \text{CONCLUSION}\\ \ 8. &amp; \forall x(x\equiv e\rightarrow \forall y\;x\equiv y) &amp; &amp; \text{GENERALIZACION}(7)\\ \ 9. &amp; e\equiv e\rightarrow \forall y\;e\equiv y &amp; &amp; \text{PARTICULARIZACION}(8)\\ 10. &amp; e\equiv e &amp; &amp; \text{AXIOMALOGICO}\\ 11. &amp; \forall y\;e\equiv y &amp; &amp; \text{MODUSPONENS}(10,9)\\ 12. &amp; \forall y\;c\equiv y &amp; &amp; \text{REEMPLAZO}(3,11)\\ 13. &amp; \forall x\forall y\;x\equiv y &amp; &amp; \text{GENERALIZACION}(12) \end{array} \]</li></ol>
<!-- l. 16528 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>8.6   </span> <a id='x1-2000008.6'></a>El algebra de Lindenbaum</h4>
<!-- l. 16530 --><p class='noindent'>Recordemos que dado un tipo \(\tau \), con \(S^{\tau }\) denotamos el conjunto de las sentencias de tipo \(\tau \),
es decir \[ S^{\tau }=\{\varphi \in F^{\tau }:Li(\varphi )=\emptyset \} \] Sea \(T=(\Sigma ,\tau )\) una teoria. Podemos definir la siguiente relacion sobre \(S^{\tau }\): \[ \varphi \dashv \vdash _{T}\psi \text{ si y solo si }T\vdash \left (\varphi \leftrightarrow \psi \right ) \] Es decir
\[ \dashv \vdash _{T}=\{(\varphi ,\psi )\in S^{\tau }:T\vdash \left (\varphi \leftrightarrow \psi \right )\} \]
</p>
   <div class='newtheorem'>
<!-- l. 16545 --><p class='noindent'><span class='head'>
<a id='x1-200001r219'></a>

<span class='cmbx-10'>Lema 219.</span>  </span>\(\dashv \vdash _{T}\) <span class='cmti-10'>es una relacion de equivalencia.</span>
</p>
   </div>
<!-- l. 16549 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 16550 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>La  relacion  es  reflexiva  ya  que  \((\varphi \leftrightarrow \varphi )\)  es  un  axioma  logico  y  por  lo  tanto
\(((\varphi \leftrightarrow \varphi ),\)AXIOMALOGICO\()\) es una prueba formal de \((\varphi \leftrightarrow \varphi )\) en \(T\). Veamos que es simetrica.
Supongamos  que  \(\varphi \dashv \vdash _{T}\psi \),  es  decir  \(T\vdash \left (\varphi \leftrightarrow \psi \right )\).  Ya  que  \(\left (\psi \leftrightarrow \varphi \right )\)  se  deduce  de  \((\varphi \leftrightarrow \psi )\)  por  la  regla  de
commutatividad, (2) del Lema <a href='#x1-197003r215'>215<!-- tex4ht:ref: prop-bas-prueb  --></a> nos dice que \(T\vdash \left (\psi \leftrightarrow \varphi \right )\).
</p><!-- l. 16559 --><p class='indent'>   Analogamente, usando la regla de transitividad se puede probar que \(\dashv \vdash _{T}\) es
transitiva.                                                                                         □
</p>
   </div>
<!-- l. 16566 --><p class='indent'>   Una sentencia \(\varphi \) se dice <span class='cmti-10'>refutable en</span> \((\Sigma ,\tau )\) si \((\Sigma ,\tau )\vdash \lnot \varphi \).
</p>
   <div class='newtheorem'>
<!-- l. 16568 --><p class='noindent'><span class='head'>
<a id='x1-200002r220'></a>
<span class='cmbx-10'>Lema 220.</span>  </span><span class='cmti-10'>Dada una teoria</span> \(T=(\Sigma ,\tau )\)<span class='cmti-10'>, se tiene que:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-200003x220'>\(\{\varphi \in S^{\tau }:\varphi \) <span class='cmti-10'>es un teorema de</span> \(T\}\in S^{\tau }/\mathrm{\dashv \vdash }_{T}\)
     </li>
     <li class='enumerate' id='x1-200004x220'>\(\{\varphi \in S^{\tau }:\varphi \) <span class='cmti-10'>es refutable en</span> \(T\}\in S^{\tau }/\mathrm{\dashv \vdash }_{T}\)</li></ol>
   </div>
<!-- l. 16577 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 16578 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Haremos la prueba de (2) y dejaremos la prueba de (1) como ejercicio.
Sean \(\varphi ,\psi \) refutables en \(T\), veremos que \(\varphi \dashv \vdash _{T}\psi \). Notese que \[ \begin{array}{llll} 1.\; &amp; \varphi &amp; &amp; \text{HIPOTESIS}1\\ 2.\; &amp; \lnot \psi &amp; &amp; \text{HIPOTESIS}2\\ 3.\; &amp; \lnot \varphi &amp; &amp; \text{AXIOMAPROPIO}\\ 4.\; &amp; (\varphi \wedge \lnot \varphi ) &amp; &amp; \text{TESIS}2\text{CONJUNCIONINTRODUCCION}(1,3)\\ 5. &amp; \lnot \psi \rightarrow (\varphi \wedge \lnot \varphi ) &amp; &amp; \text{CONCLUSION}\\ 6. &amp; \psi &amp; &amp; \text{TESIS}1\text{ABSURDO}(5)\\ 7. &amp; (\varphi \rightarrow \psi ) &amp; &amp; \text{CONCLUSION}\\ 8. &amp; \psi &amp; &amp; \text{HIPOTESIS}3\\ 9. &amp; \lnot \varphi &amp; &amp; \text{HIPOTESIS}4\\ 10. &amp; \lnot \psi &amp; &amp; \text{AXIOMAPROPIO}\\ 11. &amp; (\psi \wedge \lnot \psi ) &amp; &amp; \text{TESIS}4\text{CONJUNCIONINTRODUCCION}(8,10)\\ 12. &amp; \lnot \varphi \rightarrow (\psi \wedge \lnot \psi ) &amp; &amp; \text{CONCLUSION}\\ 13. &amp; \varphi &amp; &amp; \text{TESIS}3\text{ABSURDO}(12)\\ 14. &amp; (\psi \rightarrow \varphi ) &amp; &amp; \text{CONCLUSION}\\ 15. &amp; (\varphi \leftrightarrow \psi ) &amp; &amp; \text{EQUIVALENCIAINTRODUCCION}(7,14) \end{array} \] justifica que \((\Sigma \cup \{\lnot \varphi ,\lnot \psi \},\tau )\vdash (\varphi \leftrightarrow \psi )\) lo cual por (1) del
Lema <a href='#x1-197003r215'>215<!-- tex4ht:ref: prop-bas-prueb  --></a> nos dice que \((\Sigma ,\tau )\vdash (\varphi \leftrightarrow \psi )\), obteniendo que \(\varphi \dashv \vdash _{T}\psi \). Para terminar de probar (2) faltaria
ver que si \(\varphi \) es refutable en \(T\) y \(\varphi \dashv \vdash _{T}\psi \), entonces \(\psi \) es refutable en \(T\). Dejamos al lector la
prueba.                                                                                            □

</p>
   </div>
<!-- l. 16608 --><p class='indent'>   Dada una teoria \(T=(\Sigma ,\tau )\) y \(\varphi \in S^{\tau }\), \([\varphi ]_{T}\) denotara la clase de \(\varphi \) con respecto a la relacion de
equivalencia \(\dashv \vdash _{T}\). Definiremos sobre \(S^{\tau }/\mathrm{\dashv \vdash }_{T}\) las siguiente operacion binaria \(\mathsf{s}^{T}\): \[ [\varphi ]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\psi ]_{T}=[(\varphi \vee \psi )]_{T} \] Una observacion
importante es que para que la definicion anterior de la operacion \(\mathsf{s}^{T}\) sea inambigua,
debemos probar la siguiente propiedad
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-200005x8.6'>Si \([\varphi ]_{T}=[\varphi ^{\prime }]_{T}\) y \([\psi ]_{T}=[\psi ^{\prime }]_{T}\) entonces \([(\varphi \vee \psi )]_{T}=[(\varphi ^{\prime }\vee \psi ^{\prime })]_{T}\)</li></ol>
<!-- l. 16622 --><p class='noindent'>Es decir debemos probar que si \(T\vdash \left (\varphi \leftrightarrow \varphi ^{\prime }\right )\) y \(T\vdash \left (\psi \leftrightarrow \psi ^{\prime }\right )\), entonces \(T\vdash ((\varphi \vee \psi )\leftrightarrow (\varphi ^{\prime }\vee \psi ^{\prime }))\). Pero esto sigue de (1) del Lema <a href='#x1-197003r215'>215<!-- tex4ht:ref: prop-bas-prueb  --></a> ya
que \[ \begin{array}{llll} 1.\; &amp; \left (\varphi \leftrightarrow \varphi ^{\prime }\right ) &amp; &amp; \text{AXIOMAPROPIO}\\ 2.\; &amp; \left (\psi \leftrightarrow \psi ^{\prime }\right ) &amp; &amp; \text{AXIOMAPROPIO}\\ 3.\; &amp; ((\varphi \vee \psi )\leftrightarrow (\varphi \vee \psi )) &amp; &amp; \text{AXIOMALOGICO}\\ 4.\; &amp; ((\varphi \vee \psi )\leftrightarrow (\varphi ^{\prime }\vee \psi )) &amp; &amp; \text{REEMPLAZO}(1,3)\\ 5.\; &amp; ((\varphi \vee \psi )\leftrightarrow (\varphi ^{\prime }\vee \psi ^{\prime })) &amp; &amp; \text{REEMPLAZO}(2,4) \end{array} \] atestigua que \((\Sigma \cup \{\left (\varphi \leftrightarrow \varphi ^{\prime }\right ),\left (\psi \leftrightarrow \psi ^{\prime }\right )\},\tau )\vdash ((\varphi \vee \psi )\leftrightarrow (\varphi ^{\prime }\vee \psi ^{\prime }))\). En forma analoga se puede ver que las siguientes igualdades
definen en forma inambigua una operacion binaria \(\mathsf{i}^{T}\) sobre \(S^{\tau }/\mathrm{\dashv \vdash }_{T}\) y una operacion unaria \(^{\mathsf{c}^{T}}\)
sobre \(S^{\tau }/\mathrm{\dashv \vdash }_{T}\):
</p>
   <div class='eqnarray'>\begin{eqnarray*} [\varphi ]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\psi ]_{T} &amp; = &amp; [(\varphi \wedge \psi )]_{T}\\ ([\varphi ]_{T})^{\mathsf{c}^{T}} &amp; = &amp; [\lnot \varphi ]_{T} \end{eqnarray*}
</div>Dejamos al lector los detalles.
<!-- l. 16647 --><p class='indent'>   Dada una teoria \(T=(\Sigma ,\tau )\), denotemos con \(1^{T}\) al conjunto \(\{\varphi \in S^{\tau }:\varphi \) es un teorema de \(T\}\) y con \(0^{T}\) al
conjunto \(\{\varphi \in S^{\tau }:\varphi \) es refutable en \(T\}\). Ya vimos en un lema anterior que \(0^{T}\) y \(1^{T}\) pertenecen a \(S^{\tau }/\mathrm{\dashv \vdash }_{T}\).
Podemos enunciar ahora el siguiente resultado, inspirado en la idea clasica de Boole
para el calculo proposicional.
</p>
   <div class='newtheorem'>
<!-- l. 16653 --><p class='noindent'><span class='head'>
<a id='x1-200006r221'></a>
<span class='cmbx-10'>Teorema 221.</span>  </span><span class='cmti-10'>Sea</span> \(T=(\Sigma ,\tau )\) <span class='cmti-10'>una teoria. Entonces</span> \((S^{\tau }/\mathrm{\dashv \vdash }_{T},\mathsf{s}^{T},\mathsf{i}^{T},^{\mathsf{c}^{T}},0^{T},1^{T})\) <span class='cmti-10'>es un algebra de Boole.</span>
</p>
   </div>
<!-- l. 16658 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 16659 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Por definicion de algebra de Boole, debemos probar que cualesquiera sean \(\varphi _{1},\varphi _{2},\varphi _{3}\in S^{\tau }\), se
cumplen las siguientes igualdades:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-200007x8.6'>\([\varphi _{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi _{1}]_{T}=[\varphi _{1}]_{T}\)
     </li>
     <li class='enumerate' id='x1-200008x8.6'>\([\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi _{1}]_{T}=[\varphi _{1}]_{T}\)

     </li>
     <li class='enumerate' id='x1-200009x8.6'>\([\varphi _{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi _{2}]_{T}=[\varphi _{2}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi _{1}]_{T}\)
     </li>
     <li class='enumerate' id='x1-200010x8.6'>\([\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi _{2}]_{T}=[\varphi _{2}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi _{1}]_{T}\)
     </li>
     <li class='enumerate' id='x1-200011x8.6'>\([\varphi _{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}([\varphi _{2}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi _{3}]_{T})=([\varphi _{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi _{2}]_{T})\;\mathsf{i}^{T}\mathsf{\;}[\varphi _{3}]_{T}\)
     </li>
     <li class='enumerate' id='x1-200012x8.6'>\([\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}([\varphi _{2}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi _{3}]_{T})=([\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi _{2}]_{T})\;\mathsf{s}^{T}\mathsf{\;}[\varphi _{3}]_{T}\)
     </li>
     <li class='enumerate' id='x1-200013x8.6'>\([\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}([\varphi _{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi _{2}]_{T})=[\varphi _{1}]_{T}\)
     </li>
     <li class='enumerate' id='x1-200014x8.6'>\([\varphi _{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}([\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi _{2}]_{T})=[\varphi _{1}]_{T}\)
     </li>
     <li class='enumerate' id='x1-200015x8.6'>\(0^{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi _{1}]_{T}=[\varphi _{1}]_{T}\)
     </li>
     <li class='enumerate' id='x1-200016x8.6'>\([\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}1^{T}=1^{T}\)
     </li>
     <li class='enumerate' id='x1-200017x8.6'>\([\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}([\varphi _{1}]_{T})^{\mathsf{c}^{T}}=1^{T}\)
     </li>
     <li class='enumerate' id='x1-200018x8.6'>\([\varphi _{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}([\varphi _{1}]_{T})^{\mathsf{c}^{T}}=0^{T}\)
     </li>
     <li class='enumerate' id='x1-200019x8.6'>\([\varphi _{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}([\varphi _{2}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi _{3}]_{T})=([\varphi _{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi _{2}]_{T})\;\mathsf{s}^{T}\mathsf{\;}([\varphi _{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi _{3}]_{T})\)</li></ol>
<!-- l. 16677 --><p class='noindent'>Veamos por ejemplo que se da (10), es decir probaremos que \([\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}1^{T}=1^{T}\), cualesquiera sea la
sentencia \(\varphi _{1}\). Ya que \(\forall x_{1}(x_{1}\equiv x_{1})\) es un teorema de \(T\), atestiguado por la prueba formal \[ \begin{array}{llll} 1.\; &amp; c\equiv c &amp; &amp; \text{AXIOMALOGICO}\\ 2.\; &amp; \forall x_{1}(x_{1}\equiv x_{1}) &amp; &amp; \text{GENERALIZACION}(1) \end{array} \] (\(c\) es un
nombre de cte no perteneciente a \(\mathcal{C}\) y tal que \((\mathcal{C}\cup \{c\},\mathcal{F},\mathcal{R},a)\) es un tipo), tenemos que el Lema <a href='#x1-200002r220'>220<!-- tex4ht:ref: 0 y 1 del algebra de lindembaum  --></a>
nos dice que \(1^{T}=\{\varphi \in S^{\tau }:\varphi \) es un teorema de \(T\}=[\forall x_{1}(x_{1}\equiv x_{1})]_{T}\). Es decir que para probar (10) debemos probar que
para cualquier \(\varphi _{1}\in S^{\tau }\), se da que \[ [\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\forall x_{1}(x_{1}\equiv x_{1})]_{T}=\{\varphi \in S^{\tau }:\varphi \text{ }\mathrm{es\ un\ teorema\ de\ }T\} \] Ya que \([\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\forall x_{1}(x_{1}\equiv x_{1})]_{T}=[\varphi _{1}\vee \forall x_{1}(x_{1}\equiv x_{1})]_{T}\), debemos probar que \(\varphi _{1}\vee \forall x_{1}(x_{1}\equiv x_{1})\) es un teorema de \(T\), lo cual
es atestiguado por la siguiente prueba formal \[ \begin{array}{llll} 1.\; &amp; c\equiv c &amp; &amp; \text{AXIOMALOGICO}\\ 2.\; &amp; \forall x_{1}(x_{1}\equiv x_{1}) &amp; &amp; \text{GENERALIZACION}(1)\\ 3. &amp; (\varphi _{1}\vee \forall x_{1}(x_{1}\equiv x_{1})) &amp; &amp; \text{DISJUNCIONINTRODUCCION}(2) \end{array} \] Veamos ahora que se da (6), es decir
veamos que \[ [\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}([\varphi _{2}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi _{3}]_{T})=([\varphi _{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi _{2}]_{T})\;\mathsf{s}^{T}\mathsf{\;}[\varphi _{3}]_{T} \] cualesquiera sean \(\varphi _{1},\varphi _{2},\varphi _{3}\in S^{\tau }\). Sean \(\varphi _{1},\varphi _{2},\varphi _{3}\in S^{\tau }\) fijas. Por la definicion de la operacion \(\mathsf{s}^{T}\)
debemos probar que \[ [(\varphi _{1}\vee (\varphi _{2}\vee \varphi _{3}))]_{T}=[((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3})]_{T} \] es decir, debemos probar que \[ T\vdash ((\varphi _{1}\vee (\varphi _{2}\vee \varphi _{3}))\leftrightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3})) \] Notese que por (2) del Lema <a href='#x1-197003r215'>215<!-- tex4ht:ref: prop-bas-prueb  --></a>,
basta con probar que </p><div class='eqnarray'>\begin{eqnarray*} T &amp; \vdash &amp; ((\varphi _{1}\vee (\varphi _{2}\vee \varphi _{3}))\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}))\\ T &amp; \vdash &amp; (((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3})\rightarrow (\varphi _{1}\vee (\varphi _{2}\vee \varphi _{3}))) \end{eqnarray*}
</div>La siguiente es una prueba formal de \(((\varphi _{1}\vee (\varphi _{2}\vee \varphi _{3}))\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}))\) en \(T\) y dejamos al lector la otra prueba formal. \[ \begin{array}{llll} 1. &amp; (\varphi _{1}\vee (\varphi _{2}\vee \varphi _{3})) &amp; &amp; \text{HIPOTESIS}1\\ 2. &amp; \varphi _{1} &amp; &amp; \text{HIPOTESIS}2\\ 3. &amp; (\varphi _{1}\vee \varphi _{2}) &amp; &amp; \text{DISJUNCIONINTRODUCCION}(2)\\ 4. &amp; ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{TESIS}2\text{DISJUNCIONINTRODUCCION}(3)\\ 5. &amp; \varphi _{1}\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{CONCLUSION}\\ 6. &amp; (\varphi _{2}\vee \varphi _{3}) &amp; &amp; \text{HIPOTESIS}3\\ 7. &amp; \varphi _{2} &amp; &amp; \text{HIPOTESIS}4\\ 8. &amp; (\varphi _{1}\vee \varphi _{2}) &amp; &amp; \text{DISJUNCIONINTRODUCCION}(6)\\ 9. &amp; ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{TESIS}4\text{DISJUNCIONINTRODUCCION}(7)\\ 10. &amp; \varphi _{2}\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{CONCLUSION}\\ 11. &amp; \varphi _{3} &amp; &amp; \text{HIPOTESIS}5\\ 12. &amp; ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{TESIS}5\text{DISJUNCIONINTRODUCCION}(11)\\ 13. &amp; \varphi _{3}\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{CONCLUSION}\\ 14. &amp; ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{TESIS}3\text{DIVISIONPORCASOS}(6,10,13)\\ 15. &amp; (\varphi _{2}\vee \varphi _{3})\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{CONCLUSION}\\ 16. &amp; ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{TESIS}1\text{DIVISIONPORCASOS}(1,5,15)\\ 17. &amp; (\varphi _{1}\vee (\varphi _{2}\vee \varphi _{3}))\rightarrow ((\varphi _{1}\vee \varphi _{2})\vee \varphi _{3}) &amp; &amp; \text{CONCLUSION} \end{array} \]
El resto de las propiedades pueden ser probadas en forma similar, algunas de las
pruebas formales necesarias han sido dadas en los ejemplos que siguen a la definicion
de prueba formal                                                                               □
   </div>
<!-- l. 16755 --><p class='indent'>   @@finpagina@@

</p><!-- l. 16759 --><p class='indent'>   Dada una teoria \(T=(\Sigma ,\tau )\), denotaremos con \(\mathcal{A}_{T}\) al algebra de Boole \((S^{\tau }/\mathrm{\dashv \vdash }_{T},\mathsf{s}^{T},\mathsf{i}^{T},^{\mathsf{c}^{T}},0^{T},1^{T})\). El algebra \(\mathcal{A}_{T}\) sera llamada
el <span class='cmti-10'>algebra de Lindenbaum de la teoria</span> \(T\). El siguiente lema nos da una descripcion
agradable del orden parcial asociado al algebra \(\mathcal{A}_{T}\).
</p>
   <div class='newtheorem'>
<!-- l. 16764 --><p class='noindent'><span class='head'>
<a id='x1-200020r222'></a>
<span class='cmbx-10'>Lema 222.</span>  </span><span class='cmti-10'>Sea</span> \(T\) <span class='cmti-10'>una teoria y sea</span> \(\leq ^{T}\) <span class='cmti-10'>el orden parcial asociado al algebra de Boole</span>
\(\mathcal{A}_{T}\) <span class='cmti-10'>(es decir</span> \([\varphi ]_{T}\leq ^{T}[\psi ]_{T}\) <span class='cmti-10'>si y solo si</span> \([\varphi ]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\psi ]_{T}=[\psi ]_{T}\)<span class='cmti-10'>). Entonces se tiene que </span>\[ [\varphi ]_{T}\leq ^{T}[\psi ]_{T}\text{ si y solo si }T\vdash \left (\varphi \rightarrow \psi \right ) \]
</p>
   </div>
<!-- l. 16774 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 16775 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos que \([\varphi ]_{T}\leq ^{T}[\psi ]_{T}\), es decir supongamos que \([\varphi ]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\psi ]_{T}=[\psi ]_{T}\). Por la definicion de \(\mathsf{s}^{T}\) tenemos
que \([(\varphi \vee \psi )]_{T}=[\psi ]_{T}\), es decir \(T\vdash ((\varphi \vee \psi )\leftrightarrow \psi )\). Es facil ver entonces que \(T\vdash \left (\varphi \rightarrow \psi \right )\). Reciprocamente si \(T\vdash \left (\varphi \rightarrow \psi \right )\), entonces facilmente
podemos probar que \(T\vdash ((\varphi \vee \psi )\leftrightarrow \psi )\), lo cual nos dice que \([(\varphi \vee \psi )]_{T}=[\psi ]_{T}\). Por la definicion de\(\ \mathsf{s}^{T}\) tenemos que \([\varphi ]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\psi ]_{T}=[\psi ]_{T}\),
lo cual nos dice que \([\varphi ]_{T}\leq ^{T}[\psi ]_{T}\)                                                                           □
</p>
   </div>
<!-- l. 16789 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>8.7   </span> <a id='x1-2010008.7'></a>Teorema de completitud</h4>
<!-- l. 16791 --><p class='noindent'>Hasta el momento tenemos una definicion matematica de prueba formal que modeliza
el concepto intuitivo de prueba elemental, el cual corresponde al mundo real de los
matematicos profecionales. Ahora bien, nada nos asegura que no aparesca un
matematico que realize una prueba elemental de una sentencia \(\varphi \) en una teoria \((\Sigma ,\tau )\), y
que no haya una prueba formal de \(\varphi \) en \((\Sigma ,\tau )\). En tal caso nuestro concepto de
prueba seria incompleto (como modelo) aunque, como ya se vio, el mismo
es correcto. Esto podria pasar por ejemplo si nos hubiesemos olvidado de
incluir en nuestra definicion de prueba formal alguna regla o accion que el
matematico usara para probar dicha \(\varphi \), es decir nos podria pasar que no podamos
”traducir” dicha prueba elemental a una prueba formal. Parese dificil poder
asegurar o probar que nuestro concepto de prueba formal sea completo en el
sentido antes descripto ya que el concepto de prueba elemental es empirico
puesto que depende de las acciones de la comunidad matematica profecional y

ademas no tiene una formulacion precisa. Por otra parte nada nos asegura
que los matematicos profecionales no vayan a descubrir en el futuro algun
nuevo ”truco” elemental y que nuestro concepto que era completo pase a ser
incompleto.
</p><!-- l. 16811 --><p class='indent'>   Fue un verdadero desafio cientifico (de los años cercanos a 1900) lidiar con estos
problemas, y el teorema de completitud de Godel resuelve todo de una manera limpia
y asombrosa. La razon es muy simple: Godel prueba que si una sentencia \(\varphi \) es
verdadera en todos los modelos de \((\Sigma ,\tau )\), entonces hay una prueba formal de \(\varphi \) en \((\Sigma ,\tau )\). Ya que
toda prueba elemental que haga un matematico siempre probara una sentencia que
es verdadera en cada modelo de \((\Sigma ,\tau )\), el teorema de Godel nos garantiza que
para cada prueba elemental habra una prueba formal que pruebe la misma
sentencia!
</p><!-- l. 16821 --><p class='indent'>   Por supuesto queda la posibilidad de que una prueba elemental dada por algun
matematico no sea traducible en forma natural a una prueba formal que pruebe lo
mismo (mas alla de que sepamos que hay una). Sin envargo el lector se ira
convenciendo que esto es improbable que suceda, a medida que vaya formalizando
distintas pruebas elementales clasicas dadas por los matemticos a lo largo de la
historia.
</p><!-- l. 16828 --><p class='indent'>   Para probar el teorema de completitud necesitaremos algunos resultados.
</p>
   <div class='newtheorem'>
<!-- l. 16829 --><p class='noindent'><span class='head'>
<a id='x1-201001r223'></a>
<span class='cmbx-10'>Lema 223.</span>  </span><span class='cmti-10'>Sean</span> \(\tau =(\mathcal{C},\mathcal{F},\mathcal{R},a)\) <span class='cmti-10'>y</span> \(\tau ^{\prime }=(\mathcal{C}^{\prime },\mathcal{F}^{\prime },\mathcal{R}^{\prime },a^{\prime })\) <span class='cmti-10'>tipos.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-201002x223'><span class='cmti-10'>Si</span> \(\mathcal{C}\subseteq \mathcal{C}^{\prime }\)<span class='cmti-10'>,</span> \(\mathcal{F}\subseteq \mathcal{F}^{\prime }\)<span class='cmti-10'>,</span> \(\mathcal{R}\subseteq \mathcal{R}^{\prime }\) <span class='cmti-10'>y</span> \(a^{\prime }|_{\mathcal{F}\cup \mathcal{R}}=a\)<span class='cmti-10'>, entonces</span> \((\Sigma ,\tau )\vdash \varphi \) <span class='cmti-10'>implica</span> \((\Sigma ,\tau ^{\prime })\vdash \varphi \)
     </li>
     <li class='enumerate' id='x1-201003x223'><span class='cmti-10'>Si</span> \(\mathcal{C}\subseteq \mathcal{C}^{\prime }\)<span class='cmti-10'>,</span> \(\mathcal{F}=\mathcal{F}^{\prime }\)<span class='cmti-10'>,</span> \(\mathcal{R}=\mathcal{R}^{\prime }\) <span class='cmti-10'>y</span> \(a^{\prime }=a\)<span class='cmti-10'>, entonces</span> \((\Sigma ,\tau ^{\prime })\vdash \varphi \) <span class='cmti-10'>implica</span> \((\Sigma ,\tau )\vdash \varphi \)<span class='cmti-10'>, cada vez que</span> \(\Sigma \cup \{\varphi \}\subseteq S^{\tau }.\)</li></ol>
   </div>
<!-- l. 16843 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 16844 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(1) Supongamos \((\Sigma ,\tau )\vdash \varphi \). Entonces hay una prueba formal \((\varphi _{1}...\varphi _{n},J_{1}...J_{n})\) de \(\varphi \) en \((\Sigma ,\tau )\). Notese que
aplicando varias veces el Lema <a href='#x1-197002r214'>214<!-- tex4ht:ref: cambio-ctes  --></a> podemos obtener una prueba formal \((\tilde{\varphi }_{1}...\tilde{\varphi }_{n},J_{1}...J_{n})\) de \(\varphi \) en \((\Sigma ,\tau )\) la
cual cumple que si \(\mathcal{C}_{2}\) es el conjunto de nombres de constante que ocurren en \(\tilde{\varphi }_{1}...\tilde{\varphi }_{n}\) y que no
pertenecen a \(\mathcal{C}\), entonces:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-201004x8.7'>\(\mathcal{C}_{2}\cap \mathcal{C}^{\prime }=\emptyset \)

     </li>
     <li class='enumerate' id='x1-201005x8.7'>\((\mathcal{C}^{\prime }\cup \mathcal{C}_{2},\mathcal{F}^{\prime },\mathcal{R}^{\prime },a^{\prime })\) es un tipo</li></ol>
<!-- l. 16856 --><p class='noindent'>Pero entonces \((\tilde{\varphi }_{1}...\tilde{\varphi }_{n},J_{1}...J_{n})\) es una prueba formal de \(\varphi \) en \((\Sigma ,\tau ^{\prime })\), con lo cual \((\Sigma ,\tau ^{\prime })\vdash \varphi \)
</p><!-- l. 16860 --><p class='indent'>   (2) Supongamos \((\Sigma ,\tau ^{\prime })\vdash \varphi \). Entonces hay una prueba formal \((\mathbf{\varphi },\mathbf{J})\) de \(\varphi \) en \((\Sigma ,\tau ^{\prime })\). Veremos que \((\mathbf{\varphi },\mathbf{J})\) es una
prueba formal de \(\varphi \) en \((\Sigma ,\tau )\). Ya que \((\mathbf{\varphi },\mathbf{J})\) es una prueba formal de \(\varphi \) en \((\Sigma ,\tau ^{\prime })\) hay un conjunto finito \(\mathcal{C}_{1}\),
disjunto con \(\mathcal{C}^{\prime }\), tal que \((\mathcal{C}^{\prime }\cup \mathcal{C}_{1},\mathcal{F},\mathcal{R},a)\) es un tipo y cada \(\mathbf{\varphi }_{i}\) es una sentencia de tipo \((\mathcal{C}^{\prime }\cup \mathcal{C}_{1},\mathcal{F},\mathcal{R},a)\). Sea \(\widetilde{\mathcal{C}_{1}}=\mathcal{C}_{1}\cup (\mathcal{C}^{\prime }-\mathcal{C})\). Notese que \(\mathcal{C}\cup \widetilde{\mathcal{C}_{1}}=\mathcal{C}^{\prime }\cup \mathcal{C}_{1}\)
por lo cual \((\mathcal{C}\cup \widetilde{\mathcal{C}_{1}},\mathcal{F},\mathcal{R},a)\) es un tipo y cada \(\mathbf{\varphi }_{i}\) es una sentencia de tipo \((\mathcal{C}\cup \widetilde{\mathcal{C}_{1}},\mathcal{F},\mathcal{R},a)\). Esto nos dice que \((\mathbf{\varphi },\mathbf{J})\) cumple
(1) de la definicion de prueba formal en \((\Sigma ,\tau )\). Todos los otros puntos se cumplen en forma
directa, exepto los puntos (4)(t) y (4)(u)(i) para los cuales es necesario notar que
\(\mathcal{C}\subseteq \mathcal{C}^{\prime }\).                                                                                                     □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 16881 --><p class='noindent'><span class='head'>
<a id='x1-201006r224'></a>
<span class='cmbx-10'>Lema 224 </span>(Lema del infimo)<span class='cmbx-10'>.</span>  </span><span class='cmti-10'>Sea</span> \(T=(\Sigma ,\tau )\) <span class='cmti-10'>una teoria y supongamos que</span> \(\tau \) <span class='cmti-10'>tiene una
</span><span class='cmti-10'>cantidad  infinita  de  nombres  de  cte  que  no  ocurren  en  las  sentencias  de</span>  \(\Sigma \)<span class='cmti-10'>.
</span><span class='cmti-10'>Entonces para cada formula</span> \(\varphi =_{d}\varphi (v)\)<span class='cmti-10'>, se tiene que en el algebra de Lindembaum</span> \(\mathcal{A}_{T}\)<span class='cmti-10'>: </span>\[ [\forall v\varphi (v)]_{T}=\inf (\{[\varphi (t)]_{T}:t\in T_{c}^{\tau }\}). \]
</p>
   </div>
<!-- l. 16891 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 16892 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Haremos primero el caso en que \(v\) no ocurre acotadamente en \(\varphi \). Primero
notese que \([\forall v\varphi (v)]_{T}\leq ^{T}[\varphi (t)]_{T}\), para todo termino cerrado \(t\), ya que podemos dar la siguiente prueba
formal: \[ \begin{array}{cllll} 1. &amp; \forall v\varphi (v) &amp; &amp; &amp; \text{HIPOTESIS}1\\ 2. &amp; \varphi (t) &amp; &amp; &amp; \text{TESIS}1\text{PARTICULARIZACION}(1)\\ 3. &amp; (\forall v\varphi (v)\rightarrow \varphi (t)) &amp; &amp; &amp; \text{CONCLUSION} \end{array} \] Supongamos ahora que \([\psi ]_{T}\leq ^{T}[\varphi (t)]_{T}\), para todo termino cerrado \(t.\) Por hipotesis hay
un nombre de cte \(c\in \mathcal{C}\) el cual no ocurre en los elementos de \(\Sigma \cup \{\psi ,\varphi (v)\}\). Ya que \([\psi ]_{T}\leq ^{T}[\varphi (c)]_{T}\), hay una
prueba formal \((\varphi _{1}...\varphi _{n},J_{1}...J_{n})\) de \(\left (\psi \rightarrow \varphi (c)\right )\) en \(T\). Pero entonces es facil de chequear que la siguiente es una
prueba formal en \((\Sigma ,(\mathcal{C}-\{c\},\mathcal{F},\mathcal{R},a))\) de \(\left (\psi \rightarrow \forall v\varphi (v)\right )\): \[ \begin{array}{rlcl} 1. &amp; \varphi _{1} &amp; &amp; J_{1}\\ 2. &amp; \varphi _{2} &amp; &amp; J_{2}\\ \vdots &amp; \vdots &amp; &amp; \vdots \\ n. &amp; \varphi _{n}=\left (\psi \rightarrow \varphi (c)\right ) &amp; &amp; J_{n}\\ n+1. &amp; \psi &amp; &amp; \text{HIPOTESIS}\bar{m}\\ n+2. &amp; \varphi (c) &amp; &amp; \text{MODUSPONENS}(\overline{n+1},\bar{n})\\ n+3. &amp; \forall v\varphi (v) &amp; &amp; \text{TESIS}\bar{m}\text{GENERALIZACION}(\overline{n+2})\\ n+4. &amp; \left (\psi \rightarrow \forall v\varphi (v)\right ) &amp; &amp; \text{CONCLUSION} \end{array} \] (con \(m\) elejido suficientemente grande y \(\tau _{1}=\tau \) en la definicion
de prueba, es decir con \(c\) como el unico nombre de cte auxiliar de la prueba). Por
el Lema <a href='#x1-201001r223'>223<!-- tex4ht:ref: tipos-parecidos  --></a> tenemos entonces que \(T\vdash \left (\psi \rightarrow \forall v\varphi (v)\right )\). Cabe destacar que es necesaria la asumsion
de que \(v\) no ocurra acotadamente en \(\varphi \) para que \((\varphi (c),\forall v\varphi (v))\in Generaliz^{\tau }\) (por que?).
</p><!-- l. 16931 --><p class='indent'>   Ahora supongamos el caso mas general donde \(v\) puede ocurrir acotadamente
en \(\varphi \). Sea \(\gamma =\varphi (w)\), donde \(w\) es una variable que no ocurre en \(\varphi \). Claramente \(Li(\gamma )\subseteq \{w\}\). Declaremos \(\gamma =_{d}\gamma (w)\).
Notese que \(w\) no ocurre acotadamente en \(\gamma \). Por lo ya probado tenemos que \[ [\forall w\gamma (w)]_{T}=\inf (\{[\gamma (t)]_{T}:t\in T_{c}^{\tau }\}) \] Pero
\([\forall v\varphi (v)]_{T}=[\forall w\gamma (w)]_{T}\) ya que \[ \begin{array}{rlcl} 1. &amp; \forall v\varphi (v) &amp; &amp; \text{HIPOTESIS}1\\ 2. &amp; \varphi (c)\text{ (es igual a }\gamma (c)\text{)} &amp; &amp; \text{PARTICULARIZACION}(1)\\ 3. &amp; \forall w\gamma (w) &amp; &amp; \text{TESIS}1\text{GENERALIZACION}(2)\\ 4. &amp; (\forall v\varphi (v)\rightarrow \forall w\gamma (w)) &amp; &amp; \text{CONCLUSION} \end{array} \] y \[ \begin{array}{rlcl} 1. &amp; \forall w\gamma (w) &amp; &amp; \text{HIPOTESIS}1\\ 2. &amp; \varphi (c)\text{ (es igual a }\gamma (c)\text{)} &amp; &amp; \text{PARTICULARIZACION}(1)\\ 3. &amp; &amp; &amp; \text{TESIS}1\text{GENERALIZACION}(2)\\ 4. &amp; (\forall v\varphi (v)\rightarrow \forall w\gamma (w)) &amp; &amp; \text{CONCLUSION} \end{array} \]
</p><!-- l. 16958 --><p class='indent'>   es claro que </p><div class='eqnarray'>\begin{eqnarray*} [\forall v\varphi (v)]_{T} &amp; = &amp; [\forall w\gamma (w)]_{T}\\{} [\varphi (t)]_{T} &amp; = &amp; [\gamma (t)]_{T}\text{ para cada }t\in T_{c}^{\tau }\}) \end{eqnarray*}
</div>por lo cual obtenemos que \[ [\forall v\varphi (v)]_{T}=\inf (\{[\varphi (t)]_{T}:t\in T_{c}^{\tau }\}). \]                                                                  □

   </div>
   <div class='newtheorem'>
<!-- l. 16971 --><p class='noindent'><span class='head'>
<a id='x1-201007r225'></a>
<span class='cmbx-10'>Lema 225 </span>(Lema de Coincidencia)<span class='cmbx-10'>.</span>  </span><span class='cmti-10'>Sean</span> \(\tau \) <span class='cmti-10'>y</span> \(\tau ^{\prime }\) <span class='cmti-10'>dos tipos cualesquiera y sea</span> \(\tau _{\cap }=(\mathcal{C}_{\cap },\mathcal{F}_{\cap },\mathcal{R}_{\cap },a_{\cap })\)<span class='cmti-10'>, donde</span>
</p><div class='eqnarray'>\begin{eqnarray*} \mathcal{C}_{\cap } &amp; = &amp; \mathcal{C}\cap \mathcal{C}^{\prime }\\ \mathcal{F}_{\cap } &amp; = &amp; \{f\in \mathcal{F}\cap \mathcal{F}^{\prime }:a(f)=a^{\prime }(f)\}\\ \mathcal{R}_{\cap } &amp; = &amp; \{r\in \mathcal{R}\cap \mathcal{R}^{\prime }:a(r)=a^{\prime }(r)\}\\ a_{\cap } &amp; = &amp; a|_{\mathcal{F}_{\cap }\cup \mathcal{R}_{\cap }} \end{eqnarray*}
</div><span class='cmti-10'>Entonces</span> \(\tau _{\cap }\) <span class='cmti-10'>es un tipo tal que</span> \(T^{\tau _{\cap }}=T^{\tau }\cap T^{\tau ^{\prime }}\) <span class='cmti-10'>y</span> \(F^{\tau _{\cap }}=F^{\tau }\cap F^{\tau ^{\prime }}\)<span class='cmti-10'>. Sean</span> \(\mathbf{A}\) <span class='cmti-10'>y</span> \(\mathbf{A}^{\prime }\) <span class='cmti-10'>modelos de tipo</span> \(\tau \) <span class='cmti-10'>y</span> \(\tau ^{\prime }\) <span class='cmti-10'>respectivamente.
</span><span class='cmti-10'>Supongamos que</span> \(A=A^{\prime }\) <span class='cmti-10'>y que</span> \(c^{\mathbf{A}}=c^{\mathbf{A}^{\prime }}\)<span class='cmti-10'>, para cada</span> \(c\in \mathcal{C}_{\cap }\)<span class='cmti-10'>,</span> \(f^{\mathbf{A}}=f^{\mathbf{A}^{\prime }}\)<span class='cmti-10'>, para cada</span> \(f\in \mathcal{F}_{\cap }\) <span class='cmti-10'>y</span> \(r^{\mathbf{A}}=r^{\mathbf{A}^{\prime }}\)<span class='cmti-10'>, para cada</span> \(r\in \mathcal{R}_{\cap }\)<span class='cmti-10'>.</span>
     <ol class='enumerate1'>
     <li class='enumerate' id='x1-201008x225'><span class='cmti-10'>Para cada</span> \(t=_{d}t(\vec{v})\in T^{\tau _{\cap }}\) <span class='cmti-10'>se tiene que</span> \(t^{\mathbf{A}}[\vec{a}]=t^{\mathbf{A}^{\prime }}[\vec{a}]\)<span class='cmti-10'>, para cada</span> \(\vec{a}\in A^{n}\)
     </li>
     <li class='enumerate' id='x1-201009x225'><span class='cmti-10'>Para cada</span> \(\varphi =_{d}\varphi (\vec{v})\in F^{\tau _{\cap }}\) <span class='cmti-10'>se tiene que </span>\[ \mathbf{A}\models \varphi [\vec{a}]\text{ si y solo si }\mathbf{A}^{\prime }\models \varphi [\vec{a}]\text{.} \]
     </li>
     <li class='enumerate' id='x1-201010x225'><span class='cmti-10'>Si</span> \(\Sigma \cup \{\varphi \}\subseteq S^{\tau _{\cap }}\)<span class='cmti-10'>, entonces </span>\[ (\Sigma ,\tau )\models \varphi \text{ sii }(\Sigma ,\tau ^{\prime })\models \varphi \text{.} \]</li></ol>
   </div>
<!-- l. 17002 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17003 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Dejamos al lector probar que \(\tau _{\cap }\) es un tipo, \(T^{\tau _{\cap }}=T^{\tau }\cap T^{\tau ^{\prime }}\) y \(F^{\tau _{\cap }}=F^{\tau }\cap F^{\tau ^{\prime }}\).
</p><!-- l. 17006 --><p class='indent'>   (a) y (b) son directos por induccion.
</p><!-- l. 17008 --><p class='indent'>   (c) Supongamos que \((\Sigma ,\tau )\models \varphi \). Sea \(\mathbf{A}^{\prime }\) un modelo de \(\tau ^{\prime }\) tal que \(\mathbf{A}^{\prime }\models \Sigma \). Sea \(a\in A^{\prime }\) un elemento fijo. Sea \(\mathbf{A}\) el
modelo de tipo \(\tau \) definido de la siguiente manera
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-201011x8.7'>universo de \(\mathbf{A}=\) \(A^{\prime }\)
     </li>
     <li class='enumerate' id='x1-201012x8.7'>\(c^{\mathbf{A}}=c^{\mathbf{A}^{\prime }}\), para cada \(c\in \mathcal{C}_{\cap }\),
     </li>
     <li class='enumerate' id='x1-201013x8.7'>\(f^{\mathbf{A}}=f^{\mathbf{A}^{\prime }}\), para cada \(f\in \mathcal{F}_{\cap }\)
     </li>
     <li class='enumerate' id='x1-201014x8.7'>\(r^{\mathbf{A}}=r^{\mathbf{A}^{\prime }}\), para cada \(r\in \mathcal{R}_{\cap }\)
     </li>
     <li class='enumerate' id='x1-201015x8.7'>\(c^{\mathbf{A}}=a\), para cada \(c\in \mathcal{C}-\mathcal{C}_{\cap }\)

     </li>
     <li class='enumerate' id='x1-201016x8.7'>\(f^{\mathbf{A}}(a_{1},...,a_{a(f)})=a\), para cada \(f\in \mathcal{F}-\mathcal{F}_{\cap }\), \(a_{1},...,a_{a(f)}\in A^{\prime }\)
     </li>
     <li class='enumerate' id='x1-201017x8.7'>\(r^{\mathbf{A}}=\emptyset \), para cada \(r\in \mathcal{R-R}_{\cap }\)</li></ol>
<!-- l. 17022 --><p class='noindent'>Ya que \(\mathbf{A}^{\prime }\models \Sigma \), (b) nos dice que \(\mathbf{A}\models \Sigma \), lo cual nos dice que \(\mathbf{A}\models \varphi \). Nuevamente por (b) tenemos que \(\mathbf{A}^{\prime }\models \varphi \), con
lo cual hemos probado que \((\Sigma ,\tau ^{\prime })\models \varphi \)                                                                  □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 17029 --><p class='noindent'><span class='head'>
<a id='x1-201018r226'></a>
<span class='cmbx-10'>Lema 226.</span>  </span><span class='cmti-10'>Sea</span> \(\tau \) <span class='cmti-10'>un tipo. Hay una infinitupla</span> \((\gamma _{1},\gamma _{2},...)\in F^{\tau \mathbf{N}}\) <span class='cmti-10'>tal que:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-201019x226'>\(\left \vert Li(\gamma _{j})\right \vert \leq 1\)<span class='cmti-10'>, para cada</span> \(j=1,2,...\)
     </li>
     <li class='enumerate' id='x1-201020x226'><span class='cmti-10'>Si</span> \(\left \vert Li(\gamma )\right \vert \leq 1\)<span class='cmti-10'>, entonces</span> \(\gamma =\gamma _{j}\)<span class='cmti-10'>, para algun</span> \(j\in \mathbf{N}\)</li></ol>
   </div>
<!-- l. 17039 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17040 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que las formulas de tipo \(\tau \) son palabras de algun alfabeto finito \(A\). Dado
un orden total \(\leq \) para \(A\), podemos definir </p><div class='eqnarray'>\begin{eqnarray*} \gamma _{1} &amp; = &amp; \min \nolimits _{\alpha }^{\leq }\left (\alpha \in F^{\tau }\wedge \left \vert Li(\alpha )\right \vert \leq 1\right )\\ \gamma _{t+1} &amp; = &amp; \min \nolimits _{\alpha }^{\leq }\left (\alpha \in F^{\tau }\wedge \left \vert Li(\alpha )\right \vert \leq 1\wedge (\forall i\in \omega )_{i\leq t}\alpha \neq \gamma _{i}\right ) \end{eqnarray*}
</div>Notese que para \(t\in \mathbf{N}\), tenemos que \(\gamma _{t}=t\)-esimo elemento de \(\{\alpha \in F^{\tau }:\left \vert Li(\alpha )\right \vert \leq 1\}\), con respecto al orden
total de \(A^{\ast }\) inducido por \(\leq \). Claramente entonces la infinitupla \((\gamma _{1},\gamma _{2},...)\) cumple (1) y
(2).                                                                                                 □
   </div>
<!-- l. 17056 --><p class='indent'>   Ahora si, el famoso resultado de Godel.
</p>
   <div class='newtheorem'>
<!-- l. 17057 --><p class='noindent'><span class='head'>
<a id='x1-201021r227'></a>

<span class='cmbx-10'>Teorema 227 </span>(Teorema de Completitud)<span class='cmbx-10'>.</span>  </span><span class='cmti-10'>Sea</span> \(T=(\Sigma ,\tau )\) <span class='cmti-10'>una teoria de primer orden. Si</span>
\(T\models \varphi \)<span class='cmti-10'>, entonces</span> \(T\vdash \varphi \)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 17062 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17063 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Primero probaremos completitud para el caso en que \(\tau \) tiene una cantidad
infinita de nombres de cte que no ocurren en las sentencias de \(\Sigma \). Lo probaremos por el
absurdo, es decir supongamos que hay una sentencia \(\varphi _{0}\) tal que \(T\models \varphi _{0}\) y \(T\not \vdash \varphi _{0}\). Notese
que ya que \(T\not \vdash \varphi _{0}\), tenemos que \([\lnot \varphi _{0}]_{T}\not =0^{T}\). Por el lema anterior hay una infinitupla \((\gamma _{1},\gamma _{2},...)\in F^{\tau \mathbf{N}}\) tal
que:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-201022x8.7'>\(\left \vert Li(\gamma _{j})\right \vert \leq 1\), para cada \(j=1,2,...\)
     </li>
     <li class='enumerate' id='x1-201023x8.7'>Si \(\left \vert Li(\gamma )\right \vert \leq 1\), entonces \(\gamma =\gamma _{j}\), para algun \(j\in \mathbf{N}\)</li></ol>
<!-- l. 17076 --><p class='noindent'>Para cada \(j\in \mathbf{N}\), sea \(w_{j}\in Var\) tal que \(Li(\gamma _{j})\subseteq \{w_{j}\}\). Para cada \(j\), declaremos \(\gamma _{j}=_{d}\gamma _{j}(w_{j})\). Notese que por el Lema <a href='#x1-201006r224'>224<!-- tex4ht:ref: lema-del-infimo  --></a> tenemos
que \(\inf \{[\gamma _{j}(t)]_{T}:t\in T_{c}^{\tau }\}=[\forall w_{j}\gamma _{j}(w_{j})]_{T}\), para cada \(j=1,2,...\). Por el Teorema de Rasiova y Sikorski tenemos que hay un filtro
primo \(\mathcal{U}\) de \(\mathcal{A}_{T}\), el cual cumple:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-201024x8.7'>\([\lnot \varphi _{0}]_{T}\in \mathcal{U}\)
     </li>
     <li class='enumerate' id='x1-201025x8.7'>Para cada \(j\in \mathbf{N}\), \(\{[\gamma _{j}(t)]_{T}:t\in T_{c}^{\tau }\}\subseteq \mathcal{U}\) implica que \([\forall w_{j}\gamma _{j}(w_{j})]_{T}\in \mathcal{U}\)</li></ol>
<!-- l. 17087 --><p class='noindent'>Ya que la infinitupla \((\gamma _{1},\gamma _{2},...)\) cubre todas las formulas con a lo sumo una variable libre, podemos
reescribir la propiedad (b) de la siguiente manera
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-201026x8.7'>Para cada \(\varphi =_{d}\varphi (v)\in F^{\tau }\), si \(\{[\varphi (t)]_{T}:t\in T_{c}^{\tau }\}\subseteq \mathcal{U}\) entonces \([\forall v\varphi (v)]_{T}\in \mathcal{U}\)</li></ol>
<!-- l. 17094 --><p class='noindent'>Definamos sobre \(T_{c}^{\tau }\) la siguiente relacion: \[ t\bowtie s\text{ si y solo si }[(t\equiv s)]_{T}\in \mathcal{U}\text{.} \] Veamos entonces que:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-201027x8.7'>\(\bowtie \) es de equivalencia.
     </li>
     <li class='enumerate' id='x1-201028x8.7'>Para cada \(\varphi =_{d}\varphi (v_{1},...,v_{n})\in F^{\tau }\), \(t_{1},...,t_{n},s_{1},...,s_{n}\in T_{c}^{\tau }\), si \(t_{1}\bowtie s_{1}\), \(t_{2}\bowtie s_{2}\), \(...\), \(t_{n}\bowtie s_{n}\), entonces \([\varphi (t_{1},...,t_{n})]_{T}\in \mathcal{U}\) si y solo si \([\varphi (s_{1},...,s_{n})]_{T}\in \mathcal{U}\).
     </li>
     <li class='enumerate' id='x1-201029x8.7'>Para cada \(f\in \mathcal{F}_{n}\), \(t_{1},...,t_{n},s_{1},...,s_{n}\in T_{c}^{\tau }\), \[ t_{1}\bowtie s_{1},t_{2}\bowtie s_{2},...,\;t_{n}\bowtie s_{n}\text{ implica }f(t_{1},...,t_{n})\bowtie f(s_{1},...,s_{n}). \]</li></ol>

<!-- l. 17110 --><p class='noindent'>Probaremos (2). Notese que \[ T\vdash \left ((t_{1}\equiv s_{1})\wedge (t_{2}\equiv s_{2})\wedge ...\wedge (t_{n}\equiv s_{n})\wedge \varphi (t_{1},...,t_{n})\right )\rightarrow \varphi (s_{1},...,s_{n}) \] lo cual nos dice que \[ [(t_{1}\equiv s_{1})]_{T}\;\mathsf{i}^{T}\mathsf{\;}[(t_{2}\equiv s_{2})]_{T}\;\mathsf{i}^{T}\mathsf{\;}...\;\mathsf{i}^{T}\mathsf{\;}[(t_{n}\equiv s_{n})]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi (t_{1},...,t_{n})]_{T}\leq ^{T}[\varphi (s_{1},...,s_{n})]_{T} \] de lo cual se desprende que \[ [\varphi (t_{1},...,t_{n})]_{T}\in \mathcal{U}\text{ implica }[\varphi (s_{1},...,s_{n})]_{T}\in \mathcal{U} \] ya que \(\mathcal{U}\) es
un filtro. La otra implicacion es analoga.
</p><!-- l. 17124 --><p class='indent'>   Para probar (3) podemos tomar \(\varphi =\left (f(v_{1},...,v_{n})\equiv f(s_{1},...,s_{n})\right )\) y aplicar (2).
</p><!-- l. 17127 --><p class='indent'>   Definamos ahora un modelo \(\mathbf{A}_{\mathcal{U}}\) de tipo \(\tau \) de la siguiente manera:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-201030x8.7'>Universo de \(\mathbf{A}_{\mathcal{U}}=T_{c}^{\tau }/\mathrm{\bowtie }\)
     </li>
     <li class='enumerate' id='x1-201031x8.7'>\(c^{\mathbf{A}_{\mathcal{U}}}=c/\mathrm{\bowtie }\), para cada \(c\in \mathcal{C}\).
     </li>
     <li class='enumerate' id='x1-201032x8.7'>\(f^{\mathbf{A}_{\mathcal{U}}}(t_{1}/\mathrm{\bowtie },...,t_{n}/\mathrm{\bowtie })=f(t_{1},...,t_{n})/\mathrm{\bowtie }\), para cada \(f\in \mathcal{F}_{n}\), \(t_{1},...,t_{n}\in T_{c}^{\tau }\;\)
     </li>
     <li class='enumerate' id='x1-201033x8.7'>\(r^{\mathbf{A}_{\mathcal{U}}}=\{(t_{1}/\mathrm{\bowtie },...,t_{n}/\mathrm{\bowtie }):[r(t_{1},...,t_{n})]_{T}\in \mathcal{U}\}\), para cada \(r\in \mathcal{R}_{n}\).</li></ol>
<!-- l. 17137 --><p class='noindent'>Notese que la definicion de \(f^{\mathbf{A}_{\mathcal{U}}}\) es inambigua por (3). Probaremos las siguientes propiedades
basicas:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-201034x8.7'>Para cada \(t=_{d}t(v_{1},...,v_{n})\in T^{\tau }\), \(t_{1},...,t_{n}\in T_{c}^{\tau }\), tenemos que \[ t^{\mathbf{A}_{\mathcal{U}}}[t_{1}/\mathrm{\bowtie },...,t_{n}/\mathrm{\bowtie }]=t(t_{1},...,t_{n})/\mathrm{\bowtie } \]
     </li>
     <li class='enumerate' id='x1-201035x8.7'>Para cada \(\varphi =_{d}\varphi (v_{1},...,v_{n})\in F^{\tau }\), \(t_{1},...,t_{n}\in T_{c}^{\tau }\), tenemos que \[ \mathbf{A}_{\mathcal{U}}\models \varphi [t_{1}/\mathrm{\bowtie },...,t_{n}/\mathrm{\bowtie }]\text{ si y solo si }[\varphi (t_{1},...,t_{n})]_{T}\in \mathcal{U}. \]</li></ol>
<!-- l. 17151 --><p class='noindent'>La prueba de (4) es directa por induccion. Probaremos (5) por induccion en el \(k\) tal que \(\varphi \in F_{k}^{\tau }\).
El caso \(k=0\) es dejado al lector. Supongamos (5) vale para \(\varphi \in F_{k}^{\tau }\). Sea \(\varphi =_{d}\varphi (v_{1},...,v_{n})\in F_{k+1}^{\tau }-F_{k}^{\tau }\). Hay varios
casos:
</p><!-- l. 17157 --><p class='indent'>   CASO \(\varphi =\left (\varphi _{1}\vee \varphi _{2}\right )\).
</p><!-- l. 17159 --><p class='indent'>   Notese que por la Convencion Notacional 6, tenemos que \(\varphi _{i}=_{d}\varphi _{i}(v_{1},...,v_{n})\). Tenemos entonces \[ \begin{array}{c} \mathbf{A}_{\mathcal{U}}\models \varphi [t_{1}/\mathrm{\bowtie },...,t_{n}/\mathrm{\bowtie }]\\ \Updownarrow \\ \mathbf{A}_{\mathcal{U}}\models \varphi _{1}[t_{1}/\mathrm{\bowtie },...,t_{n}/\mathrm{\bowtie }]\text{ o }\mathbf{A}_{\mathcal{U}}\models \varphi _{2}[t_{1}/\mathrm{\bowtie },...,t_{n}/\mathrm{\bowtie }]\\ \Updownarrow \\{} [\varphi _{1}(t_{1},...,t_{n})]_{T}\in \mathcal{U}\text{ o }[\varphi _{2}(t_{1},...,t_{n})]_{T}\in \mathcal{U}\\ \Updownarrow \\{} [\varphi _{1}(t_{1},...,t_{n})]_{T}\ \mathsf{s}^{T}\mathsf{\ }[\varphi _{2}(t_{1},...,t_{n})]_{T}\in \mathcal{U}\\ \Updownarrow \\{} [\left (\varphi _{1}(t_{1},...,t_{n})\vee \varphi _{2}(t_{1},...,t_{n})\right )]_{T}\in \mathcal{U}\\ \Updownarrow \\{} [\varphi (t_{1},...,t_{n})]_{T}\in \mathcal{U}. \end{array} \]
CASO \(\varphi =\forall v\varphi _{1}\), con \(v\in Var-\{v_{1},...,v_{n}\}\). Notese que por la Convencion Notacional 6, tenemos que \(\varphi _{1}=_{d}\varphi _{1}(v_{1},...,v_{n},v)\). Tenemos
entonces \[ \begin{array}{c} \mathbf{A}_{\mathcal{U}}\models \varphi [t_{1}/\mathrm{\bowtie },...,t_{n}/\mathrm{\bowtie }]\\ \Updownarrow \\ \mathbf{A}_{\mathcal{U}}\models \varphi _{1}[t_{1}/\mathrm{\bowtie },...,t_{n}/\mathrm{\bowtie },t/\mathrm{\bowtie }]\text{, para todo }t\in T_{c}^{\tau }\\ \Updownarrow \\{} [\varphi _{1}(t_{1},...,t_{n},t)]_{T}\in \mathcal{U}\text{, para todo }t\in T_{c}^{\tau }\\ \Updownarrow \\{} [\forall v\varphi _{1}(t_{1},...,t_{n},v)]_{T}\in \mathcal{U}\\ \Updownarrow \\{} [\varphi (t_{1},...,t_{n})]_{T}\in \mathcal{U}. \end{array} \] CASO \(\varphi =\exists v\varphi _{1}\), con \(v\in Var-\{v_{1},...,v_{n}\}\). Notese que por la Convencion Notacional 6, tenemos que \(\varphi _{1}=_{d}\varphi _{1}(v_{1},...,v_{n},v)\).
Tenemos entonces \[ \begin{array}{c} \mathbf{A}_{\mathcal{U}}\models \varphi [t_{1}/\mathrm{\bowtie },...,t_{n}/\mathrm{\bowtie }]\\ \Updownarrow \\ \mathbf{A}_{\mathcal{U}}\models \varphi _{1}[t_{1}/\mathrm{\bowtie },...,t_{n}/\mathrm{\bowtie },t/\mathrm{\bowtie }]\text{, para algun }t\in T_{c}^{\tau }\\ \Updownarrow \\{} [\varphi _{1}(t_{1},...,t_{n},t)]_{T}\in \mathcal{U}\text{, para algun }t\in T_{c}^{\tau }\\ \Updownarrow \\ ([\varphi _{1}(t_{1},...,t_{n},t)]_{T})^{\mathsf{c}^{T}}\not \in \mathcal{U}\text{, para algun }t\in T_{c}^{\tau }\\ \Updownarrow \\{} [\lnot \varphi _{1}(t_{1},...,t_{n},t)]_{T}\not \in \mathcal{U}\text{, para algun }t\in T_{c}^{\tau }\\ \Updownarrow \\{} [\forall v\;\lnot \varphi _{1}(t_{1},...,t_{n},v)]_{T}\not \in \mathcal{U}\\ \Updownarrow \\ ([\forall v\;\lnot \varphi _{1}(t_{1},...,t_{n},v)]_{T})^{\mathsf{c}^{T}}\in \mathcal{U}\\ \Updownarrow \\{} [\lnot \forall v\;\lnot \varphi _{1}(t_{1},...,t_{n},v)]_{T}\in \mathcal{U}\\ \Updownarrow \\{} [\varphi (t_{1},...,t_{n})]_{T}\in \mathcal{U}. \end{array} \] Pero ahora notese que (5) en particular nos dice que para cada
sentencia \(\psi \in S^{\tau }\), \(\mathbf{A}_{\mathcal{U}}\models \psi \) si y solo si \([\psi ]_{T}\in \mathcal{U}.\) De esta forma llegamos a que \(\mathbf{A}_{\mathcal{U}}\models \Sigma \) y \(\mathbf{A}_{\mathcal{U}}\models \lnot \varphi _{0}\), lo cual contradice la
suposicion de que \(T\models \varphi _{0}.\)
</p><!-- l. 17222 --><p class='indent'>   Ahora supongamos que \(\tau \) es cualquier tipo. Sean \(s_{1}\) y \(s_{2}\) un par de simbolos no
pertenecientes a la lista \[ \forall \ \ \exists \ \ \lnot \ \ \vee \ \ \wedge \ \ \rightarrow \ \ \leftrightarrow \ \ (\ \ )\ \ ,\ \equiv \ \ \mathsf{X}\ \ \mathit{0}\ \ \mathit{1}\ \ ...\ \ \mathit{9}\ \ \mathbf{0}\ \ \mathbf{1}\ \ ...\ \ \mathbf{9} \] y tales que ninguno ocurra en alguna palabra de \(\mathcal{C}\cup \mathcal{F}\cup \mathcal{R}.\) Si \(T\models \varphi \),
entonces usando el Lema de Coincidencia se puede ver que \((\Sigma ,(\mathcal{C}\cup \{s_{1}s_{2}s_{1},s_{1}s_{2}s_{2}s_{1},...\},\mathcal{F},\mathcal{R},a))\models \varphi \), por lo cual \[ (\Sigma ,(\mathcal{C}\cup \{s_{1}s_{2}s_{1},s_{1}s_{2}s_{2}s_{1},...\},\mathcal{F},\mathcal{R},a))\vdash \varphi . \] Pero por
Lema <a href='#x1-201001r223'>223<!-- tex4ht:ref: tipos-parecidos  --></a>, tenemos que \(T\vdash \varphi .\)                                                                      □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 17236 --><p class='noindent'><span class='head'>
<a id='x1-201036r228'></a>
<span class='cmbx-10'>Corollary 228.</span>  </span><span class='cmti-10'>Toda teoria consistente tiene un modelo.</span>

</p>
   </div>
<!-- l. 17240 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17241 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \((\Sigma ,\tau )\) es consistente y no tiene modelos. Entonces \((\Sigma ,\tau )\models \left (\varphi \wedge \lnot \varphi \right )\), con lo cual
por completitud \((\Sigma ,\tau )\vdash \left (\varphi \wedge \lnot \varphi \right )\), lo cual es absurdo.                                                      □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 17247 --><p class='noindent'><span class='head'>
<a id='x1-201037r229'></a>
<span class='cmbx-10'>Corollary 229 </span>(Teorema de Compacidad)<span class='cmbx-10'>.</span>  </span><span class='cmti-10'>Sea</span> \((\Sigma ,\tau )\) <span class='cmti-10'>una teoria.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-201038x229'><span class='cmti-10'>Si</span> \((\Sigma ,\tau )\) <span class='cmti-10'>es tal que</span> \((\Sigma _{0},\tau )\) <span class='cmti-10'>tiene un modelo, para cada subconjunto finito</span> \(\Sigma _{0}\subseteq \Sigma \)<span class='cmti-10'>, entonces</span> \((\Sigma ,\tau )\)
     <span class='cmti-10'>tiene un modelo</span>
     </li>
     <li class='enumerate' id='x1-201039x229'><span class='cmti-10'>Si</span> \((\Sigma ,\tau )\models \varphi \)<span class='cmti-10'>, entonces hay un subconjunto finito</span> \(\Sigma _{0}\subseteq \Sigma \) <span class='cmti-10'>tal que</span> \((\Sigma _{0},\tau )\models \varphi \)<span class='cmti-10'>.</span></li></ol>
   </div>
<!-- l. 17258 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17259 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>(a)  Veamos  que  \((\Sigma ,\tau )\)  es  consistente.  Supongamos  lo  contrario,  es  decir
supongamos \((\Sigma ,\tau )\vdash \left (\varphi \wedge \lnot \varphi \right )\), para alguna sentencia \(\varphi \). Notese que entonces hay un subconjunto
finito \(\Sigma _{0}\subseteq \Sigma \) tal que la teoria \((\Sigma _{0},\tau )\vdash \left (\varphi \wedge \lnot \varphi \right )\) (\(\Sigma _{0}\) puede ser formado con los axiomas de \(\Sigma \) usados en una
prueba formal que atestigue que \((\Sigma ,\tau )\vdash \left (\varphi \wedge \lnot \varphi \right )\)). Pero esto es absurdo ya que por hypotesis
dicha teoria \((\Sigma _{0},\tau )\) tiene un modelo. O sea que \((\Sigma ,\tau )\) es consistente por lo cual tiene un
modelo.
</p><!-- l. 17269 --><p class='indent'>   (b) Si \((\Sigma ,\tau )\models \varphi \), entonces por completitud, \((\Sigma ,\tau )\vdash \varphi \). Pero entonces hay un subconjunto finito
\(\Sigma _{0}\subseteq \Sigma \) tal que \((\Sigma _{0},\tau )\vdash \varphi \), es decir tal que \((\Sigma _{0},\tau )\models \varphi \) (correccion).                                                   □
</p>
   </div>
<!-- l. 17274 --><p class='indent'>   @@finpagina@@

</p><!-- l. 17279 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>8.8   </span> <a id='x1-2020008.8'></a>Interpretacion semantica del algebra de Lindembaum</h4>
<!-- l. 17281 --><p class='noindent'>Usando lo teoremas de correccion y completitud podemos dar una representacion
semantica del algebra de Lindembaum. Sea \(T=(\Sigma ,\tau )\) una teoria. Dada \(\varphi \in S^{\tau }\) definamos \[ \mathrm{Mod}_{T}(\varphi )=\{\mathbf{A}:\mathbf{A}\text{ es modelo de }T\text{ y }\mathbf{A}\vDash \varphi \} \] Definamos
tambien \[ \mathrm{Mod}_{T}=\{\mathbf{A}:\mathbf{A}\text{ es modelo de }T\} \] Dado \(S\subseteq \mathrm{Mod}_{T}\) definamos \[ S^{c}=\mathrm{Mod}_{T}-S \]
</p>
   <div class='newtheorem'>
<!-- l. 17296 --><p class='noindent'><span class='head'>
<a id='x1-202001r230'></a>
<span class='cmbx-10'>Lema 230.</span>  </span>\(\{\mathrm{Mod}_{T}(\varphi ):\varphi \in S^{\tau }\}\) <span class='cmti-10'>es un subuniverso del algebra de Boole</span> \((\mathcal{P}(\mathrm{Mod}_{T}),\cup ,\cap ,^{c},\emptyset ,\mathrm{Mod}_{T})\)
</p>
   </div>
<!-- l. 17301 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17302 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que </p><div class='eqnarray'>\begin{eqnarray*} \emptyset &amp; = &amp; \mathrm{Mod}_{T}(\exists x_{1}\lnot (x_{1}\equiv x_{1}))\\ \mathrm{Mod}_{T} &amp; = &amp; \mathrm{Mod}_{T}(\forall x_{1}(x_{1}\equiv x_{1}))\\ \mathrm{Mod}_{T}(\varphi )\cap \mathrm{Mod}_{T}(\psi ) &amp; = &amp; \mathrm{Mod}_{T}((\varphi \wedge \psi ))\\ \mathrm{Mod}_{T}(\varphi )\cup \mathrm{Mod}_{T}(\psi ) &amp; = &amp; \mathrm{Mod}_{T}((\varphi \vee \psi ))\\ \mathrm{Mod}_{T}(\varphi )^{c} &amp; = &amp; \mathrm{Mod}_{T}(\lnot \varphi ) \end{eqnarray*}
</div>                                                                 □
   </div>
   <div class='newtheorem'>
<!-- l. 17313 --><p class='noindent'><span class='head'>
<a id='x1-202002r231'></a>
<span class='cmbx-10'>Lema 231.</span>  </span><span class='cmti-10'>Dadas</span> \(\varphi ,\psi \in S^{\tau }\) <span class='cmti-10'>se tiene:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-202003x231'>\([\varphi ]_{T}\leq ^{T}[\psi ]_{T}\) <span class='cmti-10'>sii</span> \(\mathrm{Mod}_{T}(\varphi )\subseteq \mathrm{Mod}_{T}(\psi )\)
     </li>
     <li class='enumerate' id='x1-202004x231'>\([\varphi ]_{T}=[\psi ]_{T}\) <span class='cmti-10'>sii</span> \(\mathrm{Mod}_{T}(\varphi )=\mathrm{Mod}_{T}(\psi )\)
     </li>
     <li class='enumerate' id='x1-202005x231'>\([\varphi ]_{T}&lt;^{T}[\psi ]_{T}\) <span class='cmti-10'>sii</span> \(\mathrm{Mod}_{T}(\varphi )\subsetneqq \mathrm{Mod}_{T}(\psi )\)</li></ol>
   </div>
<!-- l. 17322 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17323 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>(1) Dejamos al lector justificar las siguientes equivalencias: \[ [\varphi ]_{T}\leq ^{T}[\psi ]_{T}\text{ sii }T\vdash (\varphi \rightarrow \psi )\text{ sii }T\models (\varphi \rightarrow \psi )\text{ sii }\mathrm{Mod}_{T}(\varphi )\subseteq \mathrm{Mod}_{T}(\psi ) \] (2) y (3)
siguen de (1)                                                                                     □
</p>
   </div>
<!-- l. 17331 --><p class='indent'>   Ya que \(\{\mathrm{Mod}_{T}(\varphi ):\varphi \in S^{\tau }\}\) es un subuniverso de \((\mathcal{P}(\mathrm{Mod}_{T}),\cup ,\cap ,^{c},\emptyset ,\mathrm{Mod}_{T})\), tenemos que \((\{\mathrm{Mod}_{T}(\varphi ):\varphi \in S^{\tau }\},\cup ,\cap ,^{c},\emptyset ,\mathrm{Mod}_{T})\) es un algebra de Boole. Notese que
(2) del lema anterior nos asegura que \[ \begin{array}{rcl} S^{\tau }/\mathrm{\dashv \vdash }_{T} &amp; \rightarrow &amp; \{\mathrm{Mod}_{T}(\varphi ):\varphi \in S^{\tau }\}\\{} [\varphi ]_{T} &amp; \rightarrow &amp; \mathrm{Mod}_{T}(\varphi ) \end{array} \] define en forma inhambigua una funcion.
Tenemos entonces el siguiente
</p>
   <div class='newtheorem'>
<!-- l. 17343 --><p class='noindent'><span class='head'>
<a id='x1-202006r232'></a>
<span class='cmbx-10'>Teorema 232.</span>  </span><span class='cmti-10'>La funcion </span>\[ \begin{array}{rcl} S^{\tau }/\mathrm{\dashv \vdash }_{T} &amp; \rightarrow &amp; \{\mathrm{Mod}_{T}(\varphi ):\varphi \in S^{\tau }\}\\{} [\varphi ]_{T} &amp; \rightarrow &amp; \mathrm{Mod}_{T}(\varphi ) \end{array} \] <span class='cmti-10'>es un isomorfismo de</span> \(\mathcal{A}_{T}\) <span class='cmti-10'>en</span> \((\{\mathrm{Mod}_{T}(\varphi ):\varphi \in S^{\tau }\},\cup ,\cap ,^{c},\emptyset ,\mathrm{Mod}_{T})\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 17354 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17355 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Llamemosle \(f\) a la funcion del enunciado. Es claro que \(f\) es sobre. Ademas
(2) del lema anterior nos dice que \(f\) es inyectiva. Ademas usando las igualdades
de la prueba del Lema <a href='#x1-202001r230'>230<!-- tex4ht:ref: bolcitas  --></a>, facilmente podemos ver que \(f\) es un homomorfismo
por lo cual es un isomorfismo.                                                               □
</p>
   </div>
<!-- l. 17363 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>8.9   </span> <a id='x1-2030008.9'></a>Teorias completas</h4>
<!-- l. 17365 --><p class='noindent'>Una teoria \((\Sigma ,\tau )\) sera llamada <span class='cmti-10'>completa </span>cuando para cada \(\varphi \in S^{\tau }\) se de que \((\Sigma ,\tau )\vdash \varphi \) o \((\Sigma ,\tau )\vdash \lnot \varphi \). Es poco frecuente
que una teoria consistente sea completa y esto lo veremos claro despues del siguiente
resultado.
</p>
   <div class='newtheorem'>
<!-- l. 17370 --><p class='noindent'><span class='head'>
<a id='x1-203001r233'></a>

<span class='cmbx-10'>Proposition 233.</span>  </span><span class='cmti-10'>Sea</span> \((\Sigma ,\tau )\) <span class='cmti-10'>una teoria consistente. Son equivalentes</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-203002x233'>\((\Sigma ,\tau )\) <span class='cmti-10'>es completa</span>
     </li>
     <li class='enumerate' id='x1-203003x233'><span class='cmti-10'>Todos los modelos de</span> \((\Sigma ,\tau )\) <span class='cmti-10'>son elementalmente equivalentes</span>
     </li>
     <li class='enumerate' id='x1-203004x233'><span class='cmti-10'>Hay  una  estructura</span>  \(\mathbf{A}\)  <span class='cmti-10'>tal  que  los  teoremas  de</span>  \((\Sigma ,\tau )\)  <span class='cmti-10'>son  exactamente  las
     </span><span class='cmti-10'>sentencias verdaderas en</span> \(\mathbf{A}\)
     </li>
     <li class='enumerate' id='x1-203005x233'>\(\mathcal{A}_{(\Sigma ,\tau )}\) <span class='cmti-10'>tiene exactamente dos elementos</span></li></ol>
   </div>
<!-- l. 17381 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17382 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos vale (1). Probaremos (2). Supongamos \(\mathbf{A},\mathbf{B}\) son modelos de \((\Sigma ,\tau )\) y
supongamos \(\mathbf{A}\models \varphi \). Entonces no puede darse \((\Sigma ,\tau )\vdash \lnot \varphi \) (use correccion) por lo cual tenemos
que \((\Sigma ,\tau )\vdash \varphi \). Ya que \(\mathbf{B}\) es modelo de \((\Sigma ,\tau )\) tenemos entonces que \(\mathbf{B}\models \varphi \). Esto prueba que \(\mathbf{A}\) y \(\mathbf{B}\) son
elementalmente equivalentes.
</p><!-- l. 17389 --><p class='indent'>   Ahora supongamos vale (2). Probaremos (3). Ya que \((\Sigma ,\tau )\) es consistente, tiene al
menos un modelo. Sea \(\mathbf{A}\) uno de ellos. Por correccion todo teorema es verdadero
en \(\mathbf{A}\). Reciprocamente si \(\mathbf{A}\models \varphi \), entonces, por (2), todo modelo de \((\Sigma ,\tau )\) satisface \(\varphi \), lo cual
nos dice que \(\varphi \) es un teorema.
</p><!-- l. 17396 --><p class='indent'>   Obviamente (3) impica que toda sentencia es o un teorema o refutable y esto
nos dice que \(0^{(\Sigma ,\tau )}\cup 1^{(\Sigma ,\tau )}=S^{\tau }\). Ya que \(0^{(\Sigma ,\tau )}\cap 1^{(\Sigma ,\tau )}=\emptyset \) puesto que \((\Sigma ,\tau )\) es consistente, tenemos que vale (4).
</p><!-- l. 17401 --><p class='indent'>   Es trivial que (4) implica (1).                                                           □
</p>
   </div>
<!-- l. 17405 --><p class='indent'>   Ya que lo mas comun es que una teoria tenga un par de modelos no
elementalmente equivalentes, la mayoria de las teorias no son completas.

</p><!-- l. 17411 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>8.10   </span> <a id='x1-2040008.10'></a>La aritmetica de Peano</h4>
<!-- l. 17413 --><p class='noindent'>En esta seccion desarrollaremos las propiedades basicas de \(Arit\), una teoria de primer
orden la cual modeliza a la aritmetica. Esta teoria ha sido paradigmatica en el
desarrollo de la logica.
</p><!-- l. 17417 --><p class='indent'>   Sea \(\tau _{A}=(\{0,1\},\{+^{2},.^{2}\},\{\leq ^{2}\},a)\). Denotemos con \(\mathbf{\omega }\) a la estructura de tipo \(\tau _{A}\) que tiene a \(\omega \) como universo e
interpreta los nombres de \(\tau _{A}\) en la manera usual, es decir \[ \begin{array}{l} 0^{\mathbf{\omega }}=0\\ 1^{\mathbf{\omega }}=1\\ \leq ^{\mathbf{\omega }}=\{(n,m)\in \omega ^{2}:n\leq m\}\\ +^{\mathbf{\omega }}(n,m)=n+m\text{, para cada }n,m\in \omega \\ .^{\mathbf{\omega }}(n,m)=n.m\text{, para cada }n,m\in \omega \end{array} \] Sea \(\Sigma \) el conjunto formado por
las siguientes sentencias:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-204002x1'>\(\forall x_{1}\forall x_{2}\forall x_{3}\;x_{1}+(x_{2}+x_{3})\equiv (x_{1}+x_{2})+x_{3}\)
     </li>
     <li class='enumerate' id='x1-204004x2'>\(\forall x_{1}\forall x_{2}\;x_{1}+x_{2}\equiv x_{2}+x_{1}\)
     </li>
     <li class='enumerate' id='x1-204006x3'>\(\forall x_{1}\forall x_{2}\forall x_{3}\;x_{1}.(x_{2}.x_{3})\equiv (x_{1}.x_{2}).x_{3}\)
     </li>
     <li class='enumerate' id='x1-204008x4'>\(\forall x_{1}\forall x_{2}\;x_{1}.x_{2}\equiv x_{2}.x_{1}\)
     </li>
     <li class='enumerate' id='x1-204010x5'>\(\forall x_{1}\;x_{1}+0\equiv x_{1}\)
     </li>
     <li class='enumerate' id='x1-204012x6'>\(\forall x_{1}\;x_{1}.0\equiv 0\)
     </li>
     <li class='enumerate' id='x1-204014x7'>\(\forall x_{1}\;x_{1}.1\equiv x_{1}\)
     </li>
     <li class='enumerate' id='x1-204016x8'>\(\forall x_{1}\forall x_{2}\forall x_{3}\;x_{1}.(x_{2}+x_{3})\equiv (x_{1}.x_{2})+(x_{1}.x_{3})\)
     </li>
     <li class='enumerate' id='x1-204018x9'>\(\forall x_{1}\forall x_{2}\forall x_{3}\;(x_{1}+x_{3}\equiv x_{2}+x_{3}\rightarrow x_{1}\equiv x_{2})\)
     </li>
     <li class='enumerate' id='x1-204020x10'>\(\forall x_{1}\;x_{1}\leq x_{1}\)
     </li>
     <li class='enumerate' id='x1-204022x11'>\(\forall x_{1}\forall x_{2}\forall x_{3}\;((x_{1}\leq x_{2}\wedge x_{2}\leq x_{3})\rightarrow x_{1}\leq x_{3})\)
     </li>
     <li class='enumerate' id='x1-204024x12'>\(\forall x_{1}\forall x_{2}\;((x_{1}\leq x_{2}\wedge x_{2}\leq x_{1})\rightarrow x_{1}\equiv x_{2})\)
     </li>
     <li class='enumerate' id='x1-204026x13'>\(\forall x_{1}\forall x_{2}\;(x_{1}\leq x_{2}\vee x_{2}\leq x_{1})\)
     </li>
     <li class='enumerate' id='x1-204028x14'>\(\forall x_{1}\forall x_{2}\;(x_{1}\leq x_{2}\leftrightarrow \exists x_{3}\;x_{2}\equiv x_{1}+x_{3})\)

     </li>
     <li class='enumerate' id='x1-204030x15'>\(0&lt;1\)</li></ol>
<!-- l. 17448 --><p class='noindent'>Es facil ver que todas estas sentencias son satisfechas por \(\mathbf{\omega }\) por lo cual \(\mathbf{\omega }\) es un modelo de
la teoria \((\Sigma ,\tau _{A})\). Definamos \[ Verd_{\mathbf{\omega }}=\{\varphi \in S^{\tau _{A}}:\mathbf{\omega }\models \varphi \} \] Es claro que todo teorema de \((\Sigma ,\tau _{A})\) pertenece a \(Verd_{\mathbf{\omega }}\) (por que?). Un
pregunta interesante es si toda sentencia \(\varphi \in Verd_{\mathbf{\omega }}\) es un teorema de \((\Sigma ,\tau _{A})\), es decir puede ser
probada en forma elemental partiendo de los axiomas de \(\Sigma \). La respuesta es no y lo
explicaremos a continuacion. Sea \(\mathbf{Q}^{\geq 0}\) la estructura de tipo \(\tau _{A}\) que tiene a \(\{r\in \mathbf{Q}:r\geq 0\}\) como universo e
interpreta los nombres de \(\tau _{A}\) en la manera usual. Note que \(\mathbf{Q}^{\geq 0}\) tambien es un modelo de \((\Sigma ,\tau _{A})\).
Pero entonces todo teorema de \((\Sigma ,\tau _{A})\) debe ser verdadero en \(\mathbf{Q}^{\geq 0}\). Pero la sentencia \(\forall x\ (x\leq 1\rightarrow (x\equiv 0\vee x\equiv 1))\)
es falsa en \(\mathbf{Q}^{\geq 0}\) por lo cual no es un teorema de \((\Sigma ,\tau _{A})\) y sin envargo pertenece a \(Verd_{\mathbf{\omega }}\).
Es decir los axiomas de \(\Sigma \) son demaciado generales y deberiamos agregarle
axiomas que sean mas caracteristicos de la estructura particular de \(\mathbf{\omega }\). En esa
direccion, a continuacion extenderemos el conjunto \(\Sigma \) con axiomas que nos
permitiran hacer pruebas por induccion tal como se lo hace en la aritmetica
basica.
</p><!-- l. 17472 --><p class='indent'>   Dada una formula \(\psi \in F^{\tau _{A}}\) y variables \(v_{1},...,v_{n+1}\), con \(n\geq 0\), tales que \(Li(\psi )\subseteq \{v_{1},...,v_{n+1}\}\) y \(v_{i}\neq v_{j}\) siempre que \(i\neq j\), denotaremos con \(Ind_{\psi ,v_{1},...,v_{n+1}}\)
a la siguiente sentencia de tipo \(\tau _{A}\) \[ \forall v_{1}...\forall v_{n}\ ((\psi (\vec{v},0)\wedge \forall v_{n+1}\ (\psi (\vec{v},v_{n+1})\rightarrow \psi (\vec{v},+(v_{n+1},1))))\rightarrow \forall v_{n+1}\ \psi (\vec{v},v_{n+1})) \] donde suponemos que hemos declarado \(\psi =_{d}\psi (v_{1},...,v_{n+1})\). Notese que
si por ejemplo \(Li(\psi )\subseteq \{x_{1},x_{2},x_{3}\}\), entonces las seis sentencias
</p><!-- l. 17485 --><p class='indent'>   \[ Ind_{\psi ,x_{1},x_{2},x_{3}}\ \ Ind_{\psi ,x_{1},x_{3},x_{2}}\ \ Ind_{\psi ,x_{2},x_{1},x_{3}}\ \ Ind_{\psi ,x_{2},x_{3},x_{1}}\ \ Ind_{\psi ,x_{3},x_{1},x_{2}}\ \ Ind_{\psi ,x_{3},x_{2},x_{1}} \] son todas distintas.
</p><!-- l. 17488 --><p class='indent'>   Sea \(\Sigma _{A}\) el conjunto que resulta de agregarle a \(\Sigma \) todas las sentencias de la forma \(Ind_{\psi ,v_{1},...,v_{n+1}}\).
Notese que el conjunto \(\Sigma _{A}\) es infinito.
</p><!-- l. 17492 --><p class='indent'>   La teoria \((\Sigma _{A},\tau _{A})\) sera llamada <span class='cmti-10'>Aritmetica de Peano </span>y la denotaremos con \(Arit\). Es
intuitivamente claro que
</p>
   <div class='newtheorem'>
<!-- l. 17494 --><p class='noindent'><span class='head'>
<a id='x1-204031r234'></a>
<span class='cmbx-10'>Lema 234.</span>  </span>\(\mathbf{\omega }\) <span class='cmti-10'>es un modelo de</span> \(Arit\)
</p>
   </div>
<!-- l. 17498 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17499 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sean \(\psi \in F^{\tau _{A}}\) y \(v_{1},...,v_{n+1}\), con \(n\geq 0\), tales que \(Li(\psi )\subseteq \{v_{1},...,v_{n+1}\}\) y \(v_{i}\neq v_{j}\) siempre que \(i\neq j\). Veremos que \(\mathbf{\omega }\vDash Ind_{\psi ,v_{1},...,v_{n+1}}\). Declaremos \(\psi =_{d}\psi (v_{1},...,v_{n},v_{n+1})\). Sea \[ \varphi =((\psi (\vec{v},0)\wedge \forall v_{n+1}\ (\psi (\vec{v},v_{n+1})\rightarrow \psi (\vec{v},+(v_{n+1},1)))\rightarrow \forall v_{n+1}\ \psi (\vec{v},v_{n+1})) \]
Declaremos \(\varphi =_{d}\varphi (v_{1},...,v_{n})\). Notese que \(\mathbf{\omega }\vDash Ind_{\psi ,v_{1},...,v_{n+1}}\) si y solo si para cada \(a_{1},...,a_{n}\in \omega \) se tiene que \(\mathbf{\omega }\vDash \varphi [\vec{a}]\). Sean \(a_{1},...,a_{n}\in \omega \) fijos. Probaremos
que \(\mathbf{\omega }\vDash \varphi [\vec{a}]\). Notar que si \[ \mathbf{\omega }\nvDash (\psi (\vec{v},0)\wedge \forall v_{n+1}\ (\psi (\vec{v},v_{n+1})\rightarrow \psi (\vec{v},+(v_{n+1},1)))[\vec{a}] \] entonces \(\mathbf{\omega }\vDash \varphi [\vec{a}]\) por lo cual podemos hacer solo el caso en que \[ \mathbf{\omega }\vDash (\psi (\vec{v},0)\wedge \forall v_{n+1}\ (\psi (\vec{v},v_{n+1})\rightarrow \psi (\vec{v},+(v_{n+1},1)))[\vec{a}] \] Para
probar que \(\mathbf{\omega }\vDash \varphi [\vec{a}]\), deberemos probar entonces que \(\mathbf{\omega }\vDash \forall v_{n+1}\ \psi (\vec{v},v_{n+1})[\vec{a}]\). Sea \(S=\{a\in \omega :\mathbf{\omega }\vDash \psi (\vec{v},v_{n+1})[\vec{a},a]\}\). Ya que \(\mathbf{\omega }\vDash \psi (\vec{v},0)[\vec{a}]\), es facil ver
usando el lema de reemplazo que \(\mathbf{\omega }\vDash \psi (\vec{v},v_{n+1})[\vec{a},0]\), lo cual nos dice que \(0\in S\). Ya que \(\mathbf{\omega }\vDash \forall v_{n+1}\ (\psi (\vec{v},v_{n+1})\rightarrow \psi (\vec{v},+(v_{n+1},1))[\vec{a}]\), tenemos
que

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-204032x8.10'>Para cada \(a\in \omega \), si \(\mathbf{\omega }\vDash \psi (\vec{v},v_{n+1})[\vec{a},a]\), entonces \(\mathbf{\omega }\vDash \psi (\vec{v},+(v_{n+1},1))[\vec{a},a]\).</li></ol>
<!-- l. 17529 --><p class='noindent'>Pero por el lema de reemplazo, tenemos que \(\mathbf{\omega }\vDash \psi (\vec{v},+(v_{n+1},1))[\vec{a},a]\) sii \(\mathbf{\omega }\vDash \psi (\vec{v},v_{n+1})[\vec{a},a+1]\), lo cual nos dice que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-204033x8.10'>Para cada \(a\in \omega \), si \(\mathbf{\omega }\vDash \psi (\vec{v},v_{n+1})[\vec{a},a]\), entonces \(\mathbf{\omega }\vDash \psi (\vec{v},v_{n+1})[\vec{a},a+1]\).</li></ol>
<!-- l. 17536 --><p class='noindent'>Ya que \(0\in S\) y (2) nos dice que \(a\in S\) implica \(a+1\in S\), tenemos que \(S=\omega \). Es decir que para cada \(a\in \omega \), se da que \(\mathbf{\omega }\vDash \psi (\vec{v},v_{n+1})[\vec{a},a]\) lo
cual nos dice que \(\mathbf{\omega }\vDash \forall v_{n+1}\ \psi (\vec{v},v_{n+1})[\vec{a}]\).
</p><!-- l. 17541 --><p class='indent'>   Es rutina probar que \(\mathbf{\omega }\) satisface los otros 15 axiomas de \(Arit\).                       □
</p>
   </div>
<!-- l. 17546 --><p class='indent'>   El modelo \(\mathbf{\omega }\) es llamado el <span class='cmti-10'>modelo standard </span>de \(Arit\).
</p><!-- l. 17551 --><p class='indent'>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-204034x8.10'>Pruebe que \(\mathbf{Q}^{\geq 0}\) no es un modelo de \(Arit\), dando una ”propiedad inductiva que no
     cumpla”</li></ol>
<!-- l. 17557 --><p class='indent'>   Definamos el mapeo \(\widehat{\ \ \ }:\omega \rightarrow \{(\;)\;,\;+\;0\;1\}^{\ast }\) de la siguiente manera </p><div class='eqnarray'>\begin{eqnarray*} \widehat{0} &amp; = &amp; 0\\ \widehat{1} &amp; = &amp; 1\\ \widehat{n+1} &amp; = &amp; +(\widehat{n},1)\text{, para cada }n\geq 1 \end{eqnarray*}
</div>
   <div class='newtheorem'>
<!-- l. 17567 --><p class='noindent'><span class='head'>
<a id='x1-204035r235'></a>
<span class='cmbx-10'>Proposition 235.</span>  </span><span class='cmti-10'>Hay un modelo de</span> \(Arit\) <span class='cmti-10'>el cual no es isomorfo a</span> \(\mathbf{\omega }\)
</p>
   </div>
<!-- l. 17571 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17572 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea \(\tau =(\{0,1,\blacktriangle \},\{+^{2},.^{2}\},\{\leq ^{2}\},a)\) y sea \(\Sigma =\Sigma _{A}\cup \{\lnot (\widehat{n}\equiv \blacktriangle ):n\in \omega \}\). Por el Teorema de Compacidad la teoria \((\Sigma ,\tau )\) tiene un modelo \(\mathbf{A}=(A,i)\).
Ya que \[ \mathbf{A}\vDash \lnot (\widehat{n}\equiv \blacktriangle )\text{, para cada }n\in \omega \] tenemos que
</p><!-- l. 17583 --><p class='indent'>   \[ i(\blacktriangle )\neq \widehat{n}^{\mathbf{A}}\text{, para cada }n\in \omega \] Por el Lema de Coincidencia la estructura \(\mathbf{B}=(A,i|_{\{0,1,+,.,\leq \}})\) es un modelo de \(Arit\). Ademas dicho
lema nos garantiza que \(\widehat{n}^{\mathbf{B}}=\widehat{n}^{\mathbf{A}}\), para cada \(n\in \omega \), por lo cual tenemos que \[ i(\blacktriangle )\neq \widehat{n}^{\mathbf{B}}\text{, para cada }n\in \omega \] Veamos que \(\mathbf{B}\) no
es isomorfo a \(\mathbf{\omega }\). Supongamos \(F:\omega \rightarrow A\) es un isomorfismo de \(\mathbf{\omega }\) en \(\mathbf{B}\). Es facil de probar por
induccion en \(n\) que \(F(n)=\widehat{n}^{\mathbf{B}}\), para cada \(n\in \omega \). Pero esto produce un absurdo ya que nos dice
que \(i(\blacktriangle )\) no esta en la imagen de \(F\).                                                              □

</p>
   </div>
<!-- l. 17598 --><p class='indent'>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-204036x8.10'>Dado un modelo \(\mathbf{A}\) de \(Arit\) y elementos \(a,b\in A\), diremos que \(a\) <span class='cmti-10'>divide a</span> \(b\) <span class='cmti-10'>en</span> \(\mathbf{A}\) cuando
     haya un \(c\in A\) tal que \(b=.^{\mathbf{A}}(c,a).\) Un elemento \(a\in A\) sera llamado <span class='cmti-10'>primo en</span> \(\mathbf{A}\)<span class='cmti-10'> </span>si \(a\neq 1^{\mathbf{A}}\) y sus unicos
     divisores son \(1^{\mathbf{A}}\) y \(a\). Pruebe que hay un modelo de \(Arit\), \(\mathbf{A}\), en el cual hay infinitos
     primos no pertenecientes a \(\{\widehat{n}^{\mathbf{A}}:n\in \omega \}\).</li></ol>
   <div class='newtheorem'>
<!-- l. 17609 --><p class='noindent'><span class='head'>
<a id='x1-204037r236'></a>
<span class='cmbx-10'>Lema 236.</span>  </span><span class='cmti-10'>Las siguientes sentencias son teoremas de la aritmetica de Peano:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-204038x236'>\(\forall x\;0\leq x\)
     </li>
     <li class='enumerate' id='x1-204039x236'>\(\forall x\;(x\leq 0\rightarrow x\equiv 0)\)
     </li>
     <li class='enumerate' id='x1-204040x236'>\(\forall x\forall y\;(x+y\equiv 0\rightarrow (x\equiv 0\wedge y\equiv 0))\)
     </li>
     <li class='enumerate' id='x1-204041x236'>\(\forall x\;(\lnot (x\equiv 0)\rightarrow \exists z\ (x\equiv z+1))\)
     </li>
     <li class='enumerate' id='x1-204042x236'>\(\forall x\forall y\;(x&lt;y\rightarrow x+1\leq y)\)
     </li>
     <li class='enumerate' id='x1-204043x236'>\(\forall x\forall y\;(x&lt;y+1\rightarrow x\leq y)\)
     </li>
     <li class='enumerate' id='x1-204044x236'>\(\forall x\forall y\;(x\leq y+1\rightarrow (x\leq y\vee x\equiv y+1))\)
     </li>
     <li class='enumerate' id='x1-204045x236'>\(\forall x\forall y\;((x\leq y\wedge y\leq x+1)\rightarrow (x\equiv y\vee x\equiv y+1))\) <span class='cmti-10'>(use (7))</span>
     </li>
     <li class='enumerate' id='x1-204046x236'>\(\forall x\forall y\;(\lnot y\equiv 0\rightarrow \exists q\exists r\;x\equiv q.y+r\wedge r&lt;y)\)</li></ol>
   </div>
<!-- l. 17625 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17626 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>(1) es dejada al lector.
</p><!-- l. 17628 --><p class='indent'>   (2) \[ \begin{array}{lllll} \;1. &amp; x_{0}\leq 0 &amp; &amp; &amp; \text{HIPOTESIS}1\\ \;2. &amp; \forall x\;0\leq x &amp; &amp; &amp; \text{TEOREMA}\\ \;3. &amp; 0\leq x_{0} &amp; &amp; &amp; \text{PARTICULARIZACION}(2)\\ \;4. &amp; x_{0}\leq 0\wedge 0\leq x_{0} &amp; &amp; &amp; \text{CONJUNCIONINTRODUCCION}(1,3)\\ \;5. &amp; \forall x_{1}\forall x_{2}\;((x_{1}\leq x_{2}\wedge x_{2}\leq x_{1})\rightarrow x_{1}\equiv x_{2}) &amp; &amp; &amp; \text{AXIOMAPROPIO}\\ \;6. &amp; \forall x_{2}\;((x_{0}\leq x_{2}\wedge x_{2}\leq x_{0})\rightarrow x_{0}\equiv x_{2}) &amp; &amp; &amp; \text{PARTICULARIZACION}(5)\\ \;7. &amp; ((x_{0}\leq 0\wedge 0\leq x_{0})\rightarrow x_{0}\equiv 0) &amp; &amp; &amp; \text{PARTICULARIZACION}(6)\\ \;8. &amp; x_{0}\equiv 0 &amp; &amp; &amp; \text{TESIS}1\text{MODUSPONENS}(4,7)\\ \;9. &amp; x_{0}\leq 0\rightarrow x_{0}\equiv 0 &amp; &amp; &amp; \text{CONCLUSION}\\ 10. &amp; \forall x\ (x\leq 0\rightarrow x\equiv 0) &amp; &amp; &amp; \text{GENERALIZACION}(9) \end{array} \]
</p><!-- l. 17644 --><p class='indent'>   (3) \[ \begin{array}{lllll} \;1. &amp; x_{0}+y_{0}\equiv 0 &amp; &amp; &amp; \text{HIPOTESIS}1\\ \;2. &amp; 0\equiv x_{0}+y_{0} &amp; &amp; &amp; \text{COMMUTATIVIDAD}(1)\\ \;3. &amp; \exists x_{3}\ (0\equiv x_{0}+x_{3}) &amp; &amp; &amp; \text{EXISTENCIAL}(2)\\ \;4. &amp; \forall x_{1}\forall x_{2}\;(x_{1}\leq x_{2}\leftrightarrow \exists x_{3}\;x_{2}\equiv x_{1}+x_{3}) &amp; &amp; &amp; \text{AXIOMAPROPIO}\\ \;5. &amp; x_{0}\leq 0\leftrightarrow \exists x_{3}\;0\equiv x_{0}+x_{3}) &amp; &amp; &amp; \text{PARTICULARIZACION}^{2}(5)\\ \;6. &amp; x_{0}\leq 0 &amp; &amp; &amp; \text{REEMPLAZO}(5,3)\\ \;7. &amp; \forall x\ 0\leq x &amp; &amp; &amp; \text{TEOREMA}\\ \;8. &amp; 0\leq x_{0} &amp; &amp; &amp; \text{PARTICULARIZACION}(7)\\ \;9. &amp; x_{0}\leq 0\wedge 0\leq x_{0} &amp; &amp; &amp; \text{CONJUNCIONINTRODUCCION}(6,8)\\ 10. &amp; \forall x_{1}\forall x_{2}\;((x_{1}\leq x_{2}\wedge x_{2}\leq x_{1})\rightarrow x_{1}\equiv x_{2}) &amp; &amp; &amp; \text{AXIOMAPROPIO}\\ 11. &amp; ((x_{0}\leq 0\wedge 0\leq x_{0})\rightarrow x_{0}\equiv 0) &amp; &amp; &amp; \text{PARTICULARIZACION}^{2}(10)\\ 12. &amp; x_{0}\equiv 0 &amp; &amp; &amp; \text{MODUSPONENS}(9,11)\\ 13. &amp; 0+y_{0}\equiv 0 &amp; &amp; &amp; \text{REEMPLAZO}(12,1)\\ 14. &amp; \forall y\ y\equiv 0+y &amp; &amp; &amp; \text{TEOREMA}\\ 15. &amp; y_{0}\equiv 0+y_{0} &amp; &amp; &amp; \text{PARTICULARIZACION}(14)\\ 16. &amp; y_{0}\equiv 0 &amp; &amp; &amp; \text{TRANSITIVIDAD}(15,13)\\ 17. &amp; x_{0}\equiv 0\wedge y_{0}\equiv 0 &amp; &amp; &amp; \text{TESIS}1\text{CONJUNCIONINTRODUCCION}(12,16)\\ 18. &amp; x_{0}+y_{0}\equiv 0\rightarrow (x_{0}\equiv 0\wedge y_{0}\equiv 0) &amp; &amp; &amp; \text{CONCLUSION}\\ 19. &amp; \forall x\forall y\;(x+y\equiv 0\rightarrow (x\equiv 0\wedge y\equiv 0)) &amp; &amp; &amp; \text{GENERALIZACION}^{2}(18) \end{array} \]                                                                                             □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 17671 --><p class='noindent'><span class='head'>
<a id='x1-204047r237'></a>
<span class='cmbx-10'>Lema 237.</span>  </span><span class='cmti-10'>Sean</span> \(n,m\in \omega \) <span class='cmti-10'>y sea</span> \(t\in T_{c}^{\tau _{A}}\)<span class='cmti-10'>. Las siguientes sentencias son teoremas de la aritmetica de
</span><span class='cmti-10'>Peano:</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-204048x237'>\((+(\widehat{n},\widehat{m})\equiv \widehat{n+m})\)
     </li>
     <li class='enumerate' id='x1-204049x237'>\((.(\widehat{n},\widehat{m})\equiv \widehat{n.m})\)
     </li>
     <li class='enumerate' id='x1-204050x237'>\(\forall x\;(x\leq \widehat{n}\rightarrow (x\equiv \widehat{0}\vee x\equiv \widehat{1}\vee ...\vee x\equiv \widehat{n}))\)
     </li>
     <li class='enumerate' id='x1-204051x237'>\((t\equiv \widehat{t^{\mathbf{\omega }}})\)</li></ol>
   </div>
   <div class='newtheorem'>
<!-- l. 17686 --><p class='noindent'><span class='head'>
<a id='x1-204052r238'></a>
<span class='cmbx-10'>Lema 238.</span>  </span><span class='cmti-10'>Si</span> \(\varphi \) <span class='cmti-10'>es una sentencia atomica o negacion de atomica y</span> \(\mathbf{\omega }\models \varphi \)<span class='cmti-10'>, entonces</span> \(Arit\vdash \varphi \)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 17691 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17692 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Hay cuatro casos.
</p><!-- l. 17694 --><p class='indent'>   Caso \(\varphi =(t\equiv s)\), con \(t,s\) terminos cerrados.
</p><!-- l. 17696 --><p class='indent'>   Ya que \(\mathbf{\omega }\models \varphi \), tenemos que \(t^{\mathbf{\omega }}=s^{\mathbf{\omega }}\) y por lo tanto \(\widehat{t^{\mathbf{\omega }}}=\widehat{s^{\mathbf{\omega }}}\). Por el lema anterior tenemos que \(Arit\vdash (t\equiv \widehat{t^{\mathbf{\omega }}}),(s\equiv \widehat{s^{\mathbf{\omega }}})\) lo
cual, ya que \(\widehat{t^{\mathbf{\omega }}}\) y \(\widehat{s^{\mathbf{\omega }}}\) son el mismo termino nos dice por la regla de transitividad que
\(Arit\vdash (t\equiv s)\).
</p><!-- l. 17702 --><p class='indent'>   Caso \(\varphi =(t\leq s)\), con \(t,s\) terminos cerrados.
</p><!-- l. 17704 --><p class='indent'>   Ya que \(\mathbf{\omega }\models \varphi \), tenemos que \(t^{\mathbf{\omega }}\leq s^{\mathbf{\omega }}\) y por lo tanto hay un \(k\in \omega \) tal que \(t^{\mathbf{\omega }}+k=s^{\mathbf{\omega }}\). Se tiene entonces que
\(\widehat{t^{\mathbf{\omega }}+k}=\widehat{s^{\mathbf{\omega }}}\). Por el lema anterior tenemos que \(Arit\vdash +(\widehat{t^{\mathbf{\omega }}},\widehat{k})\equiv \widehat{t^{\mathbf{\omega }}+k}\) lo cual nos dice que \[ Arit\vdash +(\widehat{t^{\mathbf{\omega }}},\widehat{k})\equiv \widehat{s^{\mathbf{\omega }}} \] Pero el lema anterior
nos dice que \[ Arit\vdash (t\equiv \widehat{t^{\mathbf{\omega }}}),(s\equiv \widehat{s^{\mathbf{\omega }}}) \] y por lo tanto la regla de reemplazo nos asegura que \(Arit\vdash +(t,\widehat{k})\equiv s\). Ya que \[ \forall x_{1}\forall x_{2}\;(x_{1}\leq x_{2}\leftrightarrow \exists x_{3}\;x_{2}\equiv x_{1}+x_{3}) \] es
un axioma de \(Arit\), tenemos que \(Arit\vdash (t\leq s)\).
</p><!-- l. 17723 --><p class='indent'>   Caso \(\varphi =\lnot (t\equiv s)\), con \(t,s\) terminos cerrados.
</p><!-- l. 17725 --><p class='indent'>   Caso \(\varphi =\lnot (t\leq s)\), con \(t,s\) terminos cerrados.                                                          □
</p>
   </div>
<!-- l. 17729 --><p class='indent'>   El siguiente lema muestra que en \(Arit\) se pueden probar ciertas sentencias las cuales
emulan el principio de induccion completa.
</p>
   <div class='newtheorem'>
<!-- l. 17731 --><p class='noindent'><span class='head'>
<a id='x1-204053r239'></a>
<span class='cmbx-10'>Lema 239.</span>  </span><span class='cmti-10'>Sea</span> \(\varphi =_{d}\varphi (\vec{v},v)\in F^{\tau _{A}}\)<span class='cmti-10'>. Supongamos</span> \(v\) <span class='cmti-10'>es sustituible por</span> \(w\) <span class='cmti-10'>en</span> \(\varphi \) <span class='cmti-10'>y</span> \(w\notin \{v_{1},...,v_{n}\}\)<span class='cmti-10'>. Entonces: </span>\[ Arit\vdash \forall \vec{v}((\varphi (\vec{v},0)\wedge \forall v(\forall w(w&lt;v\rightarrow \varphi (\vec{v},w))\rightarrow \varphi (\vec{v},v)))\rightarrow \forall v\varphi (\vec{v},v)) \]
</p>
   </div>
<!-- l. 17740 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17741 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea \(\tilde{\varphi }=\forall w(w\leq v\rightarrow \varphi (\vec{v},w))\). Notar que \(Li(\tilde{\varphi })\subseteq \{v_{1},...,v_{n},v\}\). Declaremos \(\tilde{\varphi }=_{d}\tilde{\varphi }(\vec{v},v)\). Para hacer la prueba formal usaremos el
axioma \(Ind_{\tilde{\varphi },v_{1},...,v_{n},v}\). Salvo por el uso de algunos teoremas simples y el uso simultaneo de
las reglas de particularizacion y generalizacion, la siguiente es la prueba formal
buscada. \[ \begin{array}{lllll} \;1. &amp; (\varphi (\vec{c},0)\wedge \forall v(\forall w(w&lt;v\rightarrow \varphi (\vec{c},w))\rightarrow \varphi (\vec{c},v)) &amp; &amp; &amp; \text{HIPOTESIS}1\\ \;2. &amp; \;\;\;w_{0}\leq 0 &amp; &amp; &amp; \text{HIPOTESIS}2\\ \;3. &amp; \;\;\;\forall x\;(x\leq 0\rightarrow x\equiv 0) &amp; &amp; &amp; \text{TEOREMA}\\ \;4. &amp; \;\;\;w_{0}\leq 0\rightarrow w_{0}\equiv 0 &amp; &amp; &amp; \text{PARTICULARIZACION}(3)\\ \;5. &amp; \;\;\;w_{0}\equiv 0 &amp; &amp; &amp; \text{MODUSPONENS}(2,4)\\ \;6. &amp; \;\;\;\varphi (\vec{c},0) &amp; &amp; &amp; \text{CONJUNCIONELIMINACION}(1)\\ \;7. &amp; \;\;\;\varphi (\vec{c},w_{0}) &amp; &amp; &amp; \text{TESIS}2\text{REEMPLAZO}(5,6)\\ \;8. &amp; w_{0}\leq 0\rightarrow \varphi (\vec{c},w_{0}) &amp; &amp; &amp; \text{CONCLUSION}\\ \;9. &amp; \tilde{\varphi }(\vec{c},0) &amp; &amp; &amp; \text{GENERALIZACION}(8)\\ 10. &amp; \;\;\;\tilde{\varphi }(\vec{c},v_{0}) &amp; &amp; &amp; \text{HIPOTESIS}3\\ 11. &amp; \;\;\;\;\;\;w_{0}&lt;v_{0}+1 &amp; &amp; &amp; \text{HIPOTESIS}4\\ 12. &amp; \;\;\;\;\;\;\forall x,y\;x&lt;y+1\rightarrow x\leq y &amp; &amp; &amp; \text{TEOREMA}\\ 13. &amp; \;\;\;\;\;\;w_{0}&lt;v_{0}+1\rightarrow w_{0}\leq v_{0} &amp; &amp; &amp; \text{PARTICULARIZACION}(12)\\ 14. &amp; \;\;\;\;\;\;w_{0}\leq v_{0} &amp; &amp; &amp; \text{MODUSPONENS}(11,13)\\ 15. &amp; \;\;\;\;\;\;w_{0}\leq v_{0}\rightarrow \varphi (\vec{c},w_{0}) &amp; &amp; &amp; \text{PARTICULARIZACION}(10)\\ 16. &amp; \;\;\;\;\;\;\varphi (\vec{c},w_{0}) &amp; &amp; &amp; \text{TESIS}4\text{MODUSPONENS}(14,15)\\ 17. &amp; \;\;\;w_{0}&lt;v_{0}+1\rightarrow \varphi (\vec{c},w_{0}) &amp; &amp; &amp; \text{CONCLUSION}\\ 18. &amp; \;\;\;\forall w\;w&lt;v_{0}+1\rightarrow \varphi (\vec{c},w) &amp; &amp; &amp; \text{GENERALIZACION}(17)\\ 19. &amp; \;\;\;\forall v(\forall w(w&lt;v\rightarrow \varphi (\vec{c},w))\rightarrow \varphi (\vec{c},v)) &amp; &amp; &amp; \text{CONJUNCIONELIMINACION}(1)\\ 20. &amp; \;\;\;(\forall w(w&lt;v_{0}+1\rightarrow \varphi (\vec{c},w))\rightarrow \varphi (\vec{c},v_{0}+1)) &amp; &amp; &amp; \text{PARTICULARIZACION}(19)\\ 21. &amp; \;\;\;\varphi (\vec{c},v_{0}+1) &amp; &amp; &amp; \text{MODUSPONENS}(18,20)\\ 22. &amp; \;\;\;\;\;\;w_{0}\leq v_{0}+1 &amp; &amp; &amp; \text{HIPOTESIS}5\\ 23. &amp; \;\;\;\;\;\;\forall x,y\;x\leq y+1\rightarrow (x\leq y\vee x\equiv y+1) &amp; &amp; &amp; \text{TEOREMA}\\ 24. &amp; \;\;\;\;\;\;w_{0}\leq v_{0}+1\rightarrow (w_{0}\leq v_{0}\vee w_{0}\equiv v_{0}+1) &amp; &amp; &amp; \text{PARTICULARIZACION}(23)\\ 25. &amp; \;\;\;\;\;\;(w_{0}\leq v_{0}\vee w_{0}\equiv v_{0}+1) &amp; &amp; &amp; \text{MODUSPONENS}(22,24)\\ 26. &amp; \;\;\;\;\;\;w_{0}\leq v_{0}\rightarrow \varphi (\vec{c},w_{0}) &amp; &amp; &amp; \text{PARTICULARIZACION}(10)\\ 27. &amp; \;\;\;\;\;\;\;\;\;w_{0}\equiv v_{0}+1 &amp; &amp; &amp; \text{HIPOTESIS}6\\ 28. &amp; \;\;\;\;\;\;\;\;\;\varphi (\vec{c},w_{0}) &amp; &amp; &amp; \text{TESIS}6\text{REEMPLAZO}(21,27)\\ 29. &amp; \;\;\;w_{0}\equiv v_{0}+1\rightarrow \varphi (\vec{c},w_{0}) &amp; &amp; &amp; \text{CONCLUSION}\\ 30. &amp; \;\;\;\;\;\;\varphi (\vec{c},w_{0}) &amp; &amp; &amp; \text{TESIS}5\text{DISJUNCIONELIM}(25,26,29)\\ 31. &amp; \;\;\;w_{0}\leq v_{0}+1\rightarrow \varphi (\vec{c},w_{0}) &amp; &amp; &amp; \text{CONCLUSION}\\ 32. &amp; \;\;\;\tilde{\varphi }(\vec{c},v_{0}+1) &amp; &amp; &amp; \text{TESIS}3\text{GENERALIZACION}(31)\\ 33. &amp; \tilde{\varphi }(\vec{c},v_{0})\rightarrow \tilde{\varphi }(\vec{c},v_{0}+1) &amp; &amp; &amp; \text{CONCLUSION}\\ 34. &amp; \forall v\tilde{\varphi }(\vec{c},v)\rightarrow \tilde{\varphi }(\vec{c},v+1) &amp; &amp; &amp; \text{GENERALIZACION}(33)\\ 35. &amp; \tilde{\varphi }(\vec{c},0)\wedge \forall v\tilde{\varphi }(\vec{c},v)\rightarrow \tilde{\varphi }(\vec{c},v+1) &amp; &amp; &amp; \text{CONJUNCIONINTRODUCCION}(9,34)\\ 36. &amp; Ind_{\tilde{\varphi },v_{1},...,v_{n},v} &amp; &amp; &amp; \text{AXIOMAPROPIO}\\ 37. &amp; (\tilde{\varphi }(\vec{c},0)\wedge \forall v(\tilde{\varphi }(\vec{c},v)\rightarrow \tilde{\varphi }(\vec{c},v+1))\rightarrow \forall v\tilde{\varphi }(\vec{c},v) &amp; &amp; &amp; \text{PARTICULARIZACION}(36)\\ 38. &amp; \forall v\tilde{\varphi }(\vec{c},v) &amp; &amp; &amp; \text{MODUSPONENS}(35,37)\\ 39. &amp; \tilde{\varphi }(\vec{c},v_{0}) &amp; &amp; &amp; \text{PARTICULARIZACION}(38)\\ 40. &amp; v_{0}\leq v_{0}\rightarrow \varphi (\vec{c},v_{0}) &amp; &amp; &amp; \text{PARTICULARIZACION}(39)\\ 41. &amp; \forall x\;x\leq x &amp; &amp; &amp; \text{AXIOMAPROPIO}\\ 42. &amp; v_{0}\leq v_{0} &amp; &amp; &amp; \text{PARTICULARIZACION}(41)\\ 43. &amp; \varphi (\vec{c},v_{0}) &amp; &amp; &amp; \text{MODUSPONENS}(40,42)\\ 44. &amp; \forall v\varphi (\vec{c},v) &amp; &amp; &amp; \text{TESIS}1\text{GENERALIZACION}(43)\\ 45. &amp; (\varphi (\vec{c},0)\wedge \forall v(\forall w(w&lt;v\rightarrow \varphi (\vec{c},w))\rightarrow \varphi (\vec{c},v)))\rightarrow \forall v\varphi (\vec{c},v) &amp; &amp; &amp; \text{CONCLUSION}\\ 46. &amp; \forall \vec{v}((\varphi (\vec{v},0)\wedge \forall v(\forall w(w&lt;v\rightarrow \varphi (\vec{v},w))\rightarrow \varphi (\vec{v},v)))\rightarrow \forall v\varphi (\vec{v},v)) &amp; &amp; &amp; \text{GENERALIZACION}(45) \end{array} \]                                                                                          □
</p>
   </div>
<!-- l. 17801 --><p class='indent'>   @@finpagina@@

</p><!-- l. 17806 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>8.11   </span> <a id='x1-2050008.11'></a>Logica ecuacional</h4>
<!-- l. 17808 --><p class='noindent'>Dados \(t,s\in T^{\tau }\), con \(t\approx s\) denotaremos la siguiente sentencia de tipo \(\tau \): \[ \forall x_{1}...\forall x_{n}\;(t\equiv s) \] donde \(n\) es el menor \(j\) tal que
\(\{x_{1},...,x_{j}\}\) contiene a todas las variables que ocurren en \(t\) y \(s\). Notese que este \(n\) es \(0\) cuando \(t\) y \(s\) son
terminos cerrados, es decir que \(t\approx s\) denota a la sentencia \((t\equiv s)\), cuando \(t,s\in T_{c}^{\tau }\). Las sentencias \(t\approx s\), con \(t,s\in T^{\tau }\),
seran llamadas <span class='cmti-10'>identidades de tipo</span> \(\tau \). Notese que \(\mathbf{A}\models t\approx s\) sii \(t^{\mathbf{A}}[\vec{a}]=s^{\mathbf{A}}[\vec{a}]\), para cada \(\vec{a}\in A^{\mathbf{N}}\). Tambien, si \(t=_{d}t(x_{1},...,x_{m})\) y \(s=_{d}s(x_{1},...,x_{m})\),
entonces dado una \(\tau \)-algebra \(\mathbf{A}\), tenemos que \(\mathbf{A}\models t\approx s\) sii \(t^{\mathbf{A}}\left [a_{1},...,a_{m}\right ]=s^{\mathbf{A}}\left [a_{1},...,a_{m}\right ]\), para cada \((a_{1},...,a_{m})\in A^{m}\). (Independientemente
de que \(m\) sea el menor \(j\) tal que \(\{x_{1},...,x_{j}\}\) contiene a las variables que ocurren en \(t\) y
\(s\).)
</p><!-- l. 17827 --><p class='indent'>   Una teoria de primer orden \((\Sigma ,\tau )\) sera llamada <span class='cmti-10'>ecuacional </span>si \(\tau \) es un tipo algebraico y
cada elemento de \(\Sigma \) es una identidad de tipo \(\tau \). Por supuesto, el teorema de completitud
de Godel nos garantiza que si \(T\) es una teoria ecuacional y \(T\vDash t\approx s\), entonces hay una
prueba formal de \(t\approx s\) en \(T\). Sin envargo, en dicha prueba formal puede haber
sentencias las cuales no sean identidades. Una pregunta interesante es la
siguiente:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-205001x8.11'>¿Hay una nocion de ”prueba ecuacional” la cual sea:
     </li>
     <li class='enumerate' id='x1-205002x8.11'>Correcta: si hay una prueba ecuacional de \(t\approx s\) en \(T\), entonces \(t\approx s\) es verdadera en
     cada modelo de \(T\)
     </li>
     <li class='enumerate' id='x1-205003x8.11'>Completa: si \(T\vDash t\approx s\), entonces hay una prueba ecuacional de \(t\approx s\) en \(T\)?</li></ol>
<!-- l. 17841 --><p class='noindent'>En esta seccion veremos que, tal como lo probo Birkhoff, esto es posible y que la nocion
de prueba ecuacional que se puede dar es muy natural y simple, es decir si sabemos
que en una teoria todos los axiomas son identidades, entonces a los fines de probar
identidades las pruebas de primer orden clasicas pueden ser reemplazadas por
pruebas con un formato mucho mas amigable.
</p><!-- l. 17848 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>8.11.1   </span> <a id='x1-2060008.11.1'></a>Pruebas ecuacionales</h5>
<!-- l. 17850 --><p class='noindent'>Primero introducimos una serie de conjuntos los cuales poseen informacion deductiva
ecuacional basica. Sea \[ TransEc^{\tau }=\{(t\approx s,s\approx p,t\approx p):t,s,p\in T^{\tau }\} \] Diremos que \(\varphi \) <span class='cmti-10'>se deduce de</span> \(\psi _{1}\)y \(\psi _{2}\) <span class='cmti-10'>por la regla de transitividad
</span><span class='cmti-10'>ecuacional, respecto a</span> \(\tau \) para expresar que \((\psi _{1},\psi _{2},\varphi )\in TransEc^{\tau }\). Sea \[ SimEc^{\tau }=\{(t\approx s,s\approx t):t,s\in T^{\tau }\} \] Diremos que \(\varphi \) <span class='cmti-10'>se deduce de</span> \(\psi _{1}\) <span class='cmti-10'>por la
</span><span class='cmti-10'>regla de simetria ecuacional, respecto a</span> \(\tau \) para expresar que \((\psi _{1},\varphi )\in SimEc^{\tau }\). Sea \[ \begin{array}{c} SubsEc^{\tau }=\{(t\approx s,t(p_{1},...,p_{n})\approx s(p_{1},...,p_{n})):t=_{d}t(x_{1},...,x_{n})\\ s=_{d}s(x_{1},...,x_{n})\ \mathrm{y}\ p_{1},...,p_{n}\in T^{\tau }\} \end{array} \] Diremos que \(\varphi \) <span class='cmti-10'>se
</span><span class='cmti-10'>deduce de</span> \(\psi _{1}\) <span class='cmti-10'>por la regla de substitucion ecuacional, respecto a</span> \(\tau \) para expresar que \((\psi _{1},\varphi )\in SubsEc^{\tau }\). Sea
\[ \begin{array}{c} ReempEc^{\tau }=\{(t\approx s,r\approx \tilde{r}):t,s,r\in T^{\tau }\ \text{\textrm{y}}\ \tilde{r}=\mathrm{resultado}\\ \mathrm{de\ reemplazar\ algunas\ ocurrencias\ de\ }t\ \mathrm{en\ }r\ \mathrm{por\ }s\} \end{array} \] Diremos que \(\varphi \) <span class='cmti-10'>se deduce de</span> \(\psi _{1}\) <span class='cmti-10'>por la regla de reemplazo ecuacional, respecto a</span> \(\tau \) para
expresar que \((\psi _{1},\varphi )\in ReempEc^{\tau }\).
</p><!-- l. 17884 --><p class='indent'>   La identidad \(x_{1}\approx x_{1}\) sera llamada <span class='cmti-10'>axioma logico ecuacional de tipo</span> \(\tau \). Notese que dicha
identidad no es ni mas ni menos que la sentencia \(\forall x_{1}(x_{1}\equiv x_{1})\) la cual es universalmente
valida.

</p>
<!-- l. 17891 --><p class='noindent'><span class='paragraphHead'><a id='x1-2070008.11.1'></a><span class='cmbx-10'>Definicion de prueba ecuacional</span></span>
   Dada una teoria ecuacional \((\Sigma ,\tau )\) y una identidad \(p\approx q\) de tipo \(\tau \), una <span class='cmti-10'>prueba ecuacional </span>de \(p\approx q\)
en \((\Sigma ,\tau )\) sera una palabra \(\mathbf{\varphi }\in S^{\tau +}\) tal que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-207001x8.11.1'>Cada \(\mathbf{\varphi }_{k}\), con \(k=1,...,n(\mathbf{\varphi })\), es una identidad de tipo \(\tau \) y \(\mathbf{\varphi }_{n(\mathbf{\varphi })}=p\approx q\)
     </li>
     <li class='enumerate' id='x1-207002x8.11.1'>Para cada \(k=1,...,n(\mathbf{\varphi })\), se da alguna de las siguientes
         <ol class='enumerate2'>
         <li class='enumerate' id='x1-207003x8.11.1'>\(\mathbf{\varphi }_{k}=x_{1}\approx x_{1}\)
         </li>
         <li class='enumerate' id='x1-207004x8.11.1'>\(\mathbf{\varphi }_{k}\in \Sigma \)
         </li>
         <li class='enumerate' id='x1-207005x8.11.1'>hay \(i,j&lt;k\) tales que \(\mathbf{\varphi }_{k}\) se deduce por la regla de transitividad ecuacional a
         partir de \(\mathbf{\varphi }_{i}\) y \(\mathbf{\varphi }_{j}\)
         </li>
         <li class='enumerate' id='x1-207006x8.11.1'>hay \(i&lt;k\) tal que \(\mathbf{\varphi }_{k}\) se deduce por la regla de simetria ecuacional a partir
         de \(\mathbf{\varphi }_{i}\)
         </li>
         <li class='enumerate' id='x1-207007x8.11.1'>hay \(i&lt;k\) tal que \(\mathbf{\varphi }_{k}\) se deduce por la regla de substitucion ecuacional a partir
         de \(\mathbf{\varphi }_{i}\)
         </li>
         <li class='enumerate' id='x1-207008x8.11.1'>hay \(i&lt;k\) tal que \(\mathbf{\varphi }_{k}\) se deduce por la regla de reemplazo ecuacional a partir
         de \(\mathbf{\varphi }_{i}\)</li></ol>
     </li></ol>
<!-- l. 17915 --><p class='noindent'>Escribiremos \((\Sigma ,\tau )\vdash _{ec}p\approx q\) cuando haya una prueba ecuacional de \(p\approx q\) en \((\Sigma ,\tau )\).
</p><!-- l. 17921 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>8.11.2   </span> <a id='x1-2080008.11.2'></a>Correccion ecuacional</h5>
<!-- l. 17923 --><p class='noindent'>Para probar que el concepto de prueba ecuacional es correcto nos hara falta el
siguiente lema.
</p>
   <div class='newtheorem'>
<!-- l. 17925 --><p class='noindent'><span class='head'>
<a id='x1-208001r240'></a>

<span class='cmbx-10'>Lema 240.</span>  </span><span class='cmti-10'>Todas las reglas introducidas en la seccion anterior son universales
</span><span class='cmti-10'>en el sentido que si</span> \(\varphi \) <span class='cmti-10'>se deduce de</span> \(\psi _{1},...,\psi _{k}\) <span class='cmti-10'>por alguna de estas reglas, entonces</span> \(\left ((\psi _{1}\wedge ...\wedge \psi _{k})\rightarrow \varphi \right )\) <span class='cmti-10'>es una
</span><span class='cmti-10'>sentencia universalmente valida.</span>
</p>
   </div>
<!-- l. 17932 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17933 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Veamos que la regla de reemplazo es universal. Basta con ver por induccion en
\(k\) que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-208002x8.11.2'>Teo\(_{k}\): Sean \(t,s\in T^{\tau }\), \(r\in T_{k}^{\tau }\) y sea \(\mathbf{A}\) una \(\tau \)-algebra tal que \(t^{\mathbf{A}}[\vec{a}]=s^{\mathbf{A}}[\vec{a}]\), para cada \(\vec{a}\in A^{\mathbf{N}}\). Entonces \(r^{\mathbf{A}}[\vec{a}]=\tilde{r}^{\mathbf{A}}[\vec{a}]\), para cada
     \(\vec{a}\in A^{\mathbf{N}}\), donde \(\tilde{r}\) es el resultado de reemplazar algunas ocurrencias de \(t\) en \(r\) por \(s.\)</li></ol>
<!-- l. 17942 --><p class='noindent'>La prueba de Teo\(_{0}\) es dejada al lector. Asumamos que vale Teo\(_{k}\) y probemos que vale Teo\(_{k+1}\).
Sean \(t,s\in T^{\tau }\), \(r\in T_{k+1}^{\tau }-T_{k}^{\tau }\) y sea \(\mathbf{A}\) una \(\tau \)-algebra tal que \(t^{\mathbf{A}}[\vec{a}]=s^{\mathbf{A}}[\vec{a}]\), para cada \(\vec{a}\in A^{\mathbf{N}}\). Sea \(\tilde{r}\) el resultado de reemplazar
algunas ocurrencias de \(t\) en \(r\) por \(s\). El caso \(t=r\) es trivial. Supongamos entonces que \(t\neq r\).
Supongamos \(r=f(r_{1},...,r_{n})\), con \(r_{1},...,r_{n}\in T_{k}^{\tau }\) y \(f\in \mathcal{F}_{n}\). Notese que por Lema <a href='#x1-165001r180'>180<!-- tex4ht:ref: reemp-ter-en-ter  --></a> tenemos que \(\tilde{r}=f(\tilde{r}_{1},...,\tilde{r}_{n})\), donde cada \(\tilde{r}_{i}\) es el
resultado de reemplazar algunas ocurrencias de \(t\) en \(r_{i}\) por \(s\). Para \(\vec{a}\in A^{\mathbf{N}}\) se tiene que \[ \begin{array}{cclll} r^{\mathbf{A}}[\vec{a}] &amp; = &amp; f(r_{1},...,r_{n})^{\mathbf{A}}[\vec{a}]\\ &amp; = &amp; f^{\mathbf{A}}(r_{1}^{\mathbf{A}}[\vec{a}],...,r_{n}^{\mathbf{A}}[\vec{a}])\\ &amp; = &amp; f^{\mathbf{A}}(\tilde{r}_{1}^{\mathbf{A}}[\vec{a}],...,\tilde{r}_{n}^{\mathbf{A}}[\vec{a}]) &amp; &amp; \text{por Teo}_{k}\\ &amp; = &amp; f(\tilde{r}_{1},...,\tilde{r}_{n})^{\mathbf{A}}[\vec{a}]\\ &amp; = &amp; \tilde{r}^{\mathbf{A}}[\vec{a}] \end{array} \] lo cual
prueba Teo\(_{k+1}\)
</p><!-- l. 17965 --><p class='indent'>   Veamos que la regla de substitucion es universal. Supongamos \(\mathbf{A}\models t\approx s\), con \(t=_{d}t(x_{1},...,x_{n})\) y \(s=_{d}s(x_{1},...,x_{n})\). Veremos
que entonces \(\mathbf{A}\models t(p_{1},...,p_{n})\approx s(p_{1},...,p_{n}).\) Supongamos que \(p_{i}=_{d}p_{i}(x_{1},...,x_{m})\), para cada \(i=1,...,n.\) Por (a) del Lema <a href='#x1-182001r203'>203<!-- tex4ht:ref: reemp-term  --></a>, tenemos que
</p><div class='eqnarray'>\begin{eqnarray*} t(p_{1},...,p_{n}) &amp; = &amp; _{d}t(p_{1},...,p_{n})(x_{1},...,x_{m})\\ s(p_{1},...,p_{n}) &amp; = &amp; _{d}s(p_{1},...,p_{n})(x_{1},...,x_{m}) \end{eqnarray*}
</div>Sea \(\vec{a}\in A^{m}\). Tenemos que \[ \begin{array}{rcl} t(p_{1},...,p_{n})^{\mathbf{A}}\left [\vec{a}\right ] &amp; = &amp; t^{\mathbf{A}}\left [p_{1}^{\mathbf{A}}\left [\vec{a}\right ],...,p_{n}^{\mathbf{A}}\left [\vec{a}\right ]\right ]\\ &amp; = &amp; s^{\mathbf{A}}\left [p_{1}^{\mathbf{A}}\left [\vec{a}\right ],...,p_{n}^{\mathbf{A}}\left [\vec{a}\right ]\right ]\\ &amp; = &amp; s(p_{1},...,p_{n})^{\mathbf{A}}\left [\vec{a}\right ] \end{array} \] lo cual nos dice que \(\mathbf{A}\models t(p_{1},...,p_{n})\approx s(p_{1},...,p_{n})\)                                                 □
   </div>
   <div class='newtheorem'>
<!-- l. 17986 --><p class='noindent'><span class='head'>
<a id='x1-208003r241'></a>
<span class='cmbx-10'>Teorema 241 </span>(Correccion)<span class='cmbx-10'>.</span>  </span><span class='cmti-10'>Si</span> \((\Sigma ,\tau )\vdash _{ec}p\approx q\)<span class='cmti-10'>, entonces</span> \((\Sigma ,\tau )\models p\approx q\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 17990 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 17991 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Sea \(\mathbf{\varphi }\) una prueba ecuacional de \(p\approx q\) en \((\Sigma ,\tau )\). Usando el lema anterior se puede
probar facilmente por induccion en \(i\) que \((\Sigma ,\tau )\models \mathbf{\varphi }_{i}\), por lo cual \((\Sigma ,\tau )\models p\approx q\)                               □
</p>
   </div>
<!-- l. 17999 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>8.11.3   </span> <a id='x1-2090008.11.3'></a>Completitud ecuacional</h5>
<!-- l. 18001 --><p class='noindent'>Para probar que el concepto de prueba ecuacional es completo nos haran falta
algunos resultados basicos que tienen interes por si mismos.
</p>
<!-- l. 18007 --><p class='noindent'><span class='paragraphHead'><a id='x1-2100008.11.3'></a><span class='cmbx-10'>El algebra de terminos</span></span>
   Dado un tipo algebraico \(\tau \), hay una forma natural de definir un algebra \(\mathbf{T}^{\tau }\) cuyo
universo es \(T^{\tau }\), de la siguiente manera
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-210001x8.11.3'>\(c^{\mathbf{T}^{\tau }}=c\), para cada \(c\in \mathcal{C}\)
     </li>
     <li class='enumerate' id='x1-210002x8.11.3'>\(f^{\mathbf{T}^{\tau }}(t_{1},...,t_{n})=f(t_{1},...,t_{n})\), para todo \(t_{1},...,t_{n}\in T^{\tau }\), \(f\in \mathcal{F}_{n}\).</li></ol>
<!-- l. 18017 --><p class='noindent'>Llamaremos a \(\mathbf{T}^{\tau }\) el <span class='cmti-10'>algebra de terminos de tipo</span> \(\tau \).
</p>
   <div class='newtheorem'>
<!-- l. 18019 --><p class='noindent'><span class='head'>
<a id='x1-210003r242'></a>
<span class='cmbx-10'>Ejemplo 242.</span>  </span>Supongamos \(\tau =(\emptyset ,\{f\},\emptyset ,\{(f,1)\}).\) Entonces el universo de \(\mathbf{T}^{\tau }\) es
</p><!-- l. 18023 --><p class='indent'>   \(\{x_{1},f(x_{1}),f(f(x_{1})),...\}\cup \)
</p><!-- l. 18025 --><p class='indent'>   \(\{x_{2},f(x_{2}),f(f(x_{2})),...\}\cup \)
</p><!-- l. 18027 --><p class='indent'>   \(\{x_{3},f(x_{3}),f(f(x_{3})),...\}\cup \)
</p><!-- l. 18029 --><p class='indent'>   \(\;\;\;\;\;\;\;\;\;\;\vdots \)
</p><!-- l. 18031 --><p class='noindent'>La funcion que interpreta a \(f\) en \(\mathbf{T}^{\tau }\) es la que a cada elemento del conjunto anterior le
asigna el primer elemento que esta a su derecha. Notese entonces que \(\mathbf{T}^{\tau }\) resulta
isomorfa al algebra \(\mathbf{A}\) definida por </p><div class='eqnarray'>\begin{eqnarray*} A &amp; = &amp; \mathbf{N}\times \mathbf{N}\\ f^{\mathbf{A}}((n,m)) &amp; = &amp; (n,m+1) \end{eqnarray*}
</div>

   </div>
   <div class='newtheorem'>
<!-- l. 18043 --><p class='noindent'><span class='head'>
<a id='x1-210004r243'></a>
<span class='cmbx-10'>Lema 243.</span>  </span><span class='cmti-10'>Dados</span> \(t_{1},...,t_{n}\)<span class='cmti-10'>,</span>\(\;t=_{d}t(x_{1},...,x_{n})\in T^{\tau }\)<span class='cmti-10'>, se tiene que</span> \(t^{\mathbf{T}^{\tau }}[t_{1},...,t_{n}]=t(t_{1},...,t_{n})\)<span class='cmbxti-10'>.</span>
</p>
   </div>
<!-- l. 18048 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18049 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Para cada \(k\geq 0\), sea
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-210005x8.11.3'>Teo\(_{k}\): Dados \(t_{1},...,t_{n}\in T^{\tau }\) y \(t=_{d}t(x_{1},...,x_{n})\in T_{k}^{\tau }\), se tiene que \(t^{\mathbf{T}^{\tau }}[t_{1},...,t_{n}]=t(t_{1},...,t_{n})\)<span class='cmbx-10'>.</span></li></ol>
<!-- l. 18054 --><p class='noindent'>Veamos que es cierto Teo\(_{0}\). Hay dos casos
</p><!-- l. 18056 --><p class='noindent'>Caso \(t=_{d}t(x_{1},...,x_{n})=c\in \mathcal{C}\).
</p><!-- l. 18058 --><p class='indent'>   Entonces tenemos \[ \begin{array}{cll} t^{\mathbf{T}^{\tau }}[t_{1},...,t_{n}] &amp; = &amp; c^{\mathbf{T}^{\tau }}\\ &amp; = &amp; c\\ &amp; = &amp; t(t_{1},...,t_{n}) \end{array} \]
</p><!-- l. 18067 --><p class='indent'>   Caso \(t=_{d}t(x_{1},...,x_{n})=x_{i}\), para algun \(i\).
</p><!-- l. 18069 --><p class='indent'>   Entonces tenemos \[ \begin{array}{cll} t^{\mathbf{T}^{\tau }}[t_{1},...,t_{n}] &amp; = &amp; t_{i}\\ &amp; = &amp; t(t_{1},...,t_{n}) \end{array} \] Veamos que Teo\(_{k}\) implica Teo\(_{k+1}\). Supongamos que vale Teo\(_{k}\). Sean \(t_{1},...,t_{n}\in T^{\tau }\)
y \(t=_{d}t(x_{1},...,x_{n})\in T_{k+1}^{\tau }-T_{k}^{\tau }\). Hay \(f\in \mathcal{F}_{m}\), con \(m\geq 1\), y terminos \(s_{1},...,s_{m}\in T_{k}^{\tau }\) tales que \(t=f(s_{1},...,s_{m})\). Notese que \(s_{i}=_{d}s_{i}(x_{1},...,x_{n})\), \(i=1,...,m\). Tenemos entonces que \[ \begin{array}{lll} t^{\mathbf{T}^{\tau }}[t_{1},...,t_{n}] &amp; = &amp; f(s_{1},...,s_{m})^{\mathbf{T}^{\tau }}[t_{1},...,t_{n}]\\ &amp; = &amp; f^{\mathbf{T}^{\tau }}(s_{1}^{\mathbf{T}^{\tau }}[t_{1},...,t_{n}],...,s_{m}^{\mathbf{T}^{\tau }}[t_{1},...,t_{n}])\\ &amp; = &amp; f^{\mathbf{T}^{\tau }}(s_{1}(t_{1},...,t_{n}),...,s_{m}(t_{1},...,t_{n}))\\ &amp; = &amp; f(s_{1}(t_{1},...,t_{n}),...,s_{m}(t_{1},...,t_{n}))\\ &amp; = &amp; t(t_{1},...,t_{n}) \end{array} \] con lo
cual vale Teo\(_{k+1}\)                                                                                     □
</p>
   </div>
<!-- l. 18094 --><p class='indent'>   El algebra de terminos tiene la siguiente propiedad fundamental:
</p>
   <div class='newtheorem'>
<!-- l. 18095 --><p class='noindent'><span class='head'>
<a id='x1-210006r244'></a>
<span class='cmbx-10'>Lema 244 </span>(Universal Maping Property)<span class='cmbx-10'>.</span>  </span><span class='cmti-10'>Si</span> \(\mathbf{A}\) <span class='cmti-10'>es cualquier</span> \(\tau \)<span class='cmti-10'>-algebra y</span> \(F:Var\rightarrow A\)<span class='cmti-10'>, es una
</span><span class='cmti-10'>funcion cualquiera, entonces</span> \(F\) <span class='cmti-10'>puede ser extendida a un homomorfismo</span> \(\bar{F}:\mathbf{T}^{\tau }\rightarrow \mathbf{A}\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 18101 --><p class='indent'>
</p>

   <div class='proof'>
<!-- l. 18102 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Definamos \(\bar{F}\) de la siguiente manera: \[ \bar{F}(t)=t^{\mathbf{A}}[(F(x_{1}),F(x_{2}),...)] \] Es claro que \(\bar{F}\) extiende a \(F\). Veamos
que es un homomorfismo. Dada \(c\in \mathcal{C}\), tenemos que \[ \begin{array}{lll} \bar{F}(c^{\mathbf{T}^{\tau }}) &amp; = &amp; \bar{F}(c)\\ &amp; = &amp; c^{\mathbf{A}}[(F(x_{1}),F(x_{2}),...)]\\ &amp; = &amp; c^{\mathbf{A}} \end{array} \] Dados \(f\in \mathcal{F}_{n}\), \(t_{1},...,t_{n}\in T^{\tau }\) tenemos que \[ \begin{array}{lll} \bar{F}(f^{\mathbf{T}^{\tau }}(t_{1},...,t_{n})) &amp; = &amp; \bar{F}(f(t_{1},...,t_{n}))\\ &amp; = &amp; f(t_{1},...,t_{n})^{\mathbf{A}}[(F(x_{1}),F(x_{2}),...)]\\ &amp; = &amp; f^{\mathbf{A}}(t_{1}^{\mathbf{A}}[(F(x_{1}),F(x_{2}),...)],...,t_{n}^{\mathbf{A}}[(F(x_{1}),F(x_{2}),...)])\\ &amp; = &amp; f^{\mathbf{A}}(\bar{F}(t_{1}),...,\bar{F}(t_{n})) \end{array} \] con lo
cual hemos probado que \(\bar{F}\) es un homomorfismo                                         □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 18129 --><p class='noindent'><span class='head'>
<a id='x1-210007r245'></a>
<span class='cmbx-10'>Teorema 245 </span>(Completitud ecuacional)<span class='cmbx-10'>.</span>  </span><span class='cmti-10'>Sea</span>  \((\Sigma ,\tau )\)  <span class='cmti-10'>una  teoria  ecuacional.  Si</span>  \((\Sigma ,\tau )\models p\approx q\)<span class='cmti-10'>,
</span><span class='cmti-10'>entonces</span> \((\Sigma ,\tau )\vdash _{ec}p\approx q.\)
</p>
   </div>
<!-- l. 18134 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18135 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \((\Sigma ,\tau )\models p\approx q.\) Sea \(\theta \) la siguiente relacion binaria sobre \(T^{\tau }\): \[ \theta =\{(t,s):(\Sigma ,\tau )\vdash _{ec}t\approx s\}. \] Dejamos al lector
probar que \(\theta \) es una congruencia de \(\mathbf{T}^{\tau }\). Veamos que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-210008x8.11.3'>\(t^{\mathbf{T}^{\tau }/\theta }[t_{1}/\theta ,...,t_{n}/\theta ]=t(t_{1},...,t_{n})/\theta \), para todo \(t_{1},...,t_{n}\), \(t=_{d}t(x_{1},...,x_{n})\)</li></ol>
<!-- l. 18146 --><p class='noindent'>Por Corolario <a href='#x1-178006r197'>197<!-- tex4ht:ref: v(t,a1,...)/tita  --></a> tenemos que \[ t^{\mathbf{T}^{\tau }/\theta }[t_{1}/\theta ,...,t_{n}/\theta ]=t^{\mathbf{T}^{\tau }}[t_{1},...,t_{n}]/\theta \] Pero por Lema <a href='#x1-210004r243'>243<!-- tex4ht:ref: v(t,t1,t2,...)  --></a> tenemos que \(t^{\mathbf{T}^{\tau }}[t_{1},...,t_{n}]=t(t_{1},...,t_{n})\) por lo cual (*) es
verdadera.
</p><!-- l. 18153 --><p class='indent'>   Veamos que \(\mathbf{T}^{\tau }/\theta \models \Sigma .\) Sea \(t\approx s\) un elemento de \(\Sigma \), con \(t=_{d}t(x_{1},...,x_{n})\) y \(s=_{d}s(x_{1},...,x_{n}).\) Veremos que \(\mathbf{T}^{\tau }/\theta \models t\approx s\), es decir veremos que \[ t^{\mathbf{T}^{\tau }/\theta }[t_{1}/\theta ,...,t_{n}/\theta ]=s^{\mathbf{T}^{\tau }/\theta }[t_{1}/\theta ,...,t_{n}/\theta ] \]
para todo \(t_{1}/\theta ,...,t_{n}/\theta \in T^{\tau }/\theta \). Notese que \[ (\Sigma ,\tau )\vdash _{ec}t(t_{1},...,t_{n})\approx s(t_{1},...,t_{n}) \] por lo cual \(t(t_{1},...,t_{n})/\theta =s(t_{1},...,t_{n})/\theta .\) Por (*) tenemos entonces \[ t^{\mathbf{T}^{\tau }/\theta }[t_{1}/\theta ,...,t_{n}/\theta ]=t(t_{1},...,t_{n})/\theta =s(t_{1},...,t_{n})/\theta =s^{\mathbf{T}^{\tau }/\theta }[t_{1}/\theta ,...,t_{n}/\theta ], \] lo cual nos dice que \(\mathbf{T}^{\tau }/\theta \)
satisface la identidad \(t\approx s.\)
</p><!-- l. 18173 --><p class='indent'>   Ya que \(\mathbf{T}^{\tau }/\theta \models \Sigma \), por hipotesis tenemos que \(\mathbf{T}^{\tau }/\theta \models p\approx q.\) Es decir que si \(p=_{d}p(x_{1},...,x_{n})\) y \(q=_{d}q(x_{1},...,x_{n})\) tenemos que \(p^{\mathbf{T}^{\tau }/\theta }[t_{1}/\theta ,...,t_{n}/\theta ]=q^{\mathbf{T}^{\tau }/\theta }[t_{1}/\theta ,...,t_{n}/\theta ]\), para todo \(t_{1},...,t_{n}\in T^{\tau }\).
En particular, tomando \(t_{i}=x_{i}\), \(i=1,...,n\) tenemos que \[ p^{\mathbf{T}^{\tau }/\theta }[x_{1}/\theta ,...,x_{n}/\theta ]=q^{\mathbf{T}^{\tau }/\theta }[x_{1}/\theta ,...,x_{n}/\theta ] \] lo cual por (*) nos dice que \(p/\theta =q/\theta \), produciendo
\((\Sigma ,\tau )\vdash _{ec}p\approx q\).                                                                                                     □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 18184 --><p class='noindent'><span class='head'>
<a id='x1-210009r246'></a>

<span class='cmbx-10'>Corollary 246.</span>  </span><span class='cmti-10'>Sea</span> \((\Sigma ,\tau )\) <span class='cmti-10'>una teoria ecuacional. Si</span> \((\Sigma ,\tau )\vdash p\approx q\)<span class='cmti-10'>, entonces</span> \((\Sigma ,\tau )\vdash _{ec}p\approx q\)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 18189 --><p class='indent'>   @@finpagina@@
</p><!-- l. 18195 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>8.12   </span> <a id='x1-2110008.12'></a>Teorema de incompletitud</h4>
<!-- l. 18197 --><p class='noindent'>Sea \[ Verd_{\mathbf{\omega }}=\{\varphi \in S^{\tau _{A}}:\mathbf{\omega }\models \varphi \}. \] Notese que por el teorema de correccion tenemos que todo teorema de \(Arit\)
pertenece a \(Verd_{\mathbf{\omega }}\). Como puede notarse a medida que uno se va familiarizando con la
teoria \(Arit\), todos los resultados clasicos de la aritmetica los cuales pueden ser enunciados
por medio de una sentencia de \(Verd_{\mathbf{\omega }}\) son en realidad teoremas de \(Arit\). Sin envargo Godel
probo en su famoso teorema de incompletitud (1931) que hay una sentencia de \(Verd_{\mathbf{\omega }}\) la
cual no es un teorema de \(Arit\). Por años nadie fue capaz de dar una sentencia de \(Verd_{\mathbf{\omega }}\) la
cual tenga un genuino interes aritmetico y la cual no sea un teorema de
\(Arit\). Recien en 1977 Paris y Harrington dieron el primer ejemplo de una tal
sentencia. Una ves sabido que los axiomas de \(Arit\) no son suficientemente poderosos
como para probar toda sentencia verdadera en \(\mathbf{\omega }\), una pregunta interesante
es
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-211001x8.12'>Hay un conjunto ”razonable” de axiomas \(\Gamma \subseteq Verd_{\mathbf{\omega }}\) tal que toda sentencia de \(Verd_{\mathbf{\omega }}\) es un
     teorema de \((\Gamma ,\tau _{A})\)</li></ol>
<!-- l. 18220 --><p class='noindent'>Una respuesta negativa a este problema tambien es dada por el teorema de
incompletitud de Godel. En esta seccion daremos una prueba basada en las ideas de
la computabilidad.
</p><!-- l. 18227 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>8.12.1   </span> <a id='x1-2120008.12.1'></a>Analisis de recursividad del lenguaje de primer orden</h5>
<!-- l. 18229 --><p class='noindent'>En esta seccion estudiaremos la recursividad de la sintaxis de \(\tau _{A}\). Los resultados
obtenidos valen para un tipo cualquiera y hemos elejido a \(\tau _{A}\) solo para facilitar la
exposicion.
</p><!-- l. 18233 --><p class='indent'>   Analizaremos la recursividad del concepto de prueba formal en una teoria de la
forma \((\Sigma ,\tau _{A})\), donde \(\Sigma \) es un conjunto recursivamente enumerable. Para hacer mas concreto
el tratamiento supondremos que los nombres de constante auxiliares en las pruebas
formales estaran siempre en el conjunto \[ Aux=\{\triangle \Box \triangle ,\triangle \Box \Box \triangle ,\triangle \Box \Box \Box \triangle ,...\} \] Esto no afectara nuestro analisis ya que es
claro que toda prueba formal de una teoria de la forma \((\Sigma ,\tau _{A})\) puede ser reemplazada por
una que sus nombres de constante auxiliares esten en \(Aux\). Es decir que las sentencias

involucradas en las pruebas formales que consideraremos seran sentencias de tipo \(\tau _{A}^{e}\)
donde \[ \tau _{A}^{e}=(\{0,1\}\cup Aux,\{+^{2},.^{2}\},\{\leq ^{2}\},a) \] Sea \(\mathcal{A}\) el alfabeto formado por los siguientes simbolos \[ \forall \ \ \exists \ \ \lnot \ \ \vee \ \ \wedge \ \ \rightarrow \ \ \leftrightarrow \ \ (\ \ )\ \ ,\ \ \equiv \ \ 0\ \ 1\ \ +\ \ .\ \ \leq \ \ \triangle \ \ \Box \ \ \mathsf{X}\ \ \mathit{0}\ \ \mathit{1}\ \ ...\ \ \mathit{9}\ \ \mathbf{0}\ \ \mathbf{1}\ \ ...\ \ \mathbf{9} \] Notese que los simbolos
del alfabeto \(\mathcal{A}\) son justamente los simbolos que ocurren en las formulas de tipo
\(\tau _{A}^{e}\).
</p>
   <div class='newtheorem'>
<!-- l. 18255 --><p class='noindent'><span class='head'>
<a id='x1-212001r247'></a>
<span class='cmbx-10'>Lema 247.</span>  </span><span class='cmti-10'>Los conjuntos</span> \(T^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(F^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(T^{\tau _{A}}\) <span class='cmti-10'>y</span> \(F^{\tau _{A}}\) <span class='cmti-10'>son</span> \(\mathcal{A}\)<span class='cmti-10'>-recursivos.</span>
</p>
   </div>
<!-- l. 18260 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18261 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese  que  los  conjuntos  \(T^{\tau _{A}^{e}}\),  \(F^{\tau _{A}^{e}}\),  \(T^{\tau _{A}}\)  y  \(F^{\tau _{A}}\)  son  \(\mathcal{A}\)-efectivamente  computables
(justifique). Entonces la Tesis de Church nos garantiza que dichos conjuntos son
\(\mathcal{A}\)-recursivos.
</p><!-- l. 18266 --><p class='indent'>   A continuacion daremos una prueba de que dichos conjuntos son en realidad
\(\mathcal{A}\)-primitivos recursivos. Veamos por ejemplo que \(T^{\tau _{A}^{e}}\) es \(\mathcal{A}\)-primitivo recursivo. Fijemos un
orden total \(\leq \) sobre \(\mathcal{A}\). Sea \(P=\lambda x[\ast ^{\leq }(x)\in T^{\tau _{A}^{e}}]\). Notese que \(P(0)=0\) y \(P(x+1)=1\) si y solo si se da alguna de las
siguientes
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-212002x8.12.1'>\(\ast ^{\leq }(x+1)\in \{0,1\}\cup Aux\)
     </li>
     <li class='enumerate' id='x1-212003x8.12.1'>\((\exists u,v\in \omega )\ast ^{\leq }(x+1)=+(\ast ^{\leq }(u),\ast ^{\leq }(v))\wedge (P^{\downarrow }(x))_{u+1}\wedge (P^{\downarrow }(x))_{v+1}\)
     </li>
     <li class='enumerate' id='x1-212004x8.12.1'>\((\exists u,v\in \omega )\ast ^{\leq }(x+1)=\mathrm{.}(\ast ^{\leq }(u),\ast ^{\leq }(v))\wedge (P^{\downarrow }(x))_{u+1}\wedge (P^{\downarrow }(x))_{v+1}\)</li></ol>
<!-- l. 18277 --><p class='noindent'>Por el Lema <a href='#x1-96001r80'>80<!-- tex4ht:ref: f-flecha  --></a> tenemos que \(P\) es \(\mathcal{A}\)-p.r., por lo cual \(\chi _{T^{\tau _{A}^{e}}}^{\mathcal{A}^{\ast }}=P\circ \#^{\leq }\) lo es. Notese que \[ t\in T^{\tau _{A}}\text{ sii }t\in T^{\tau _{A}^{e}}\wedge \triangle \text{ no ocurre en }t\wedge \Box \text{ no ocurre en }t \] por lo cual \(T^{\tau _{A}}\) es
\(\mathcal{A}\)-p.r.                                                                                                □
</p>
   </div>
<!-- l. 18287 --><p class='indent'>   Recordemos que en la Subseccion <a href='#x1-1690005.5'>5.5<!-- tex4ht:ref: VariablesLibres  --></a> definimos cuando \("v\mathit{\ ocurre\ libremente\ en\ }\varphi \mathit{\ a\ partir\ de\ }i"\), para el caso en
que \(v\in Var\), \(\varphi \in F^{\tau }\) y \(i\in \{1,...,\left \vert \varphi \right \vert \}\). Extendamos esta definicion diciendo que cuando \(v\in Var\), \(\varphi \in F^{\tau }\) y \(i\in \omega -\{1,...,\left \vert \varphi \right \vert \}\), se da que
\(v\mathit{\ no\ ocurre\ libremente\ en\ }\varphi \mathit{\ a\ partir\ de\ }i\).
</p>

   <div class='newtheorem'>
<!-- l. 18296 --><p class='noindent'><span class='head'>
<a id='x1-212005r248'></a>
<span class='cmbx-10'>Lema 248.</span>  </span><span class='cmti-10'>Los siguientes predicados son</span> \(\mathcal{A}\)<span class='cmti-10'>-r.</span>
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-212006x248'>\("v\)<span class='cmti-10'> ocurre libremente en </span>\(\varphi \) <span class='cmti-10'>a partir de</span> \(i":\omega \times Var\times F^{\tau _{A}^{e}}\rightarrow \omega \)
     </li>
     <li class='enumerate' id='x1-212007x248'>\("v\in Li(\varphi )":Var\times F^{\tau _{A}^{e}}\rightarrow \omega \)
     </li>
     <li class='enumerate' id='x1-212008x248'>\("v\) <span class='cmti-10'>es sustituible por</span> \(t\) <span class='cmti-10'>en</span> \(\varphi ":Var\times T^{\tau _{A}^{e}}\times F^{\tau _{A}^{e}}\rightarrow \omega \)</li></ol>
   </div>
<!-- l. 18305 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18306 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que los predicados dados en (1), (2) y (3) son \(\mathcal{A}\)-efectivamente
computables (justifique). Entonces la Tesis de Church nos garantiza que dichos
predicados son \(\mathcal{A}\)-recursivos.
</p><!-- l. 18310 --><p class='indent'>   En realidad dichos predicados son \(\mathcal{A}\)-p.r.. Veamos por ejemplo que \(P:\omega \times Var\times F^{\tau _{A}^{e}}\rightarrow \omega \), dado por \[ P(i,v,\varphi )=\left \{ \begin{array}{ccl} 1 &amp; &amp; \text{si }v\mathit{\ }\text{ocurre libremente en}\mathit{\ }\varphi \text{ a partir de }i\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \] es
\(\mathcal{A}\)-p.r.. Sea \(R:\mathbf{N}\times Var\rightarrow \omega \) el predicado dado por \(R(x,v)=1\) si y solo si \(\ast ^{\leq }((x)_{1})\in F^{\tau _{A}^{e}}\) y \(v\mathit{\ }\)ocurre libremente en\(\mathit{\ }\ast ^{\leq }((x)_{1})\) a partir de \((x)_{2}\). Sea
\(\bar{R}=R\cup C_{0}^{1,1}|_{\{0\}\times Var}\). \(\mathrm{Nex}=\{\wedge ,\vee ,\rightarrow ,\leftrightarrow \}\). Notese que \(F_{0}^{\tau _{A}^{e}}\) es \(\mathcal{A}\)-p.r. ya que \[ F_{0}^{\tau _{A}^{e}}=F^{\tau _{A}^{e}}\cap (\mathcal{A}-\{\forall ,\exists ,\lnot ,\vee ,\wedge ,\rightarrow ,\leftrightarrow \})^{\ast } \] Notese que \(\bar{R}(0,v)=0\), para cada \(v\in Var\) y que \(\bar{R}(x+1,v)=1\) si y solo si \((x+1)_{2}\geq 1\) y se da
alguna de las siguientes:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-212009x8.12.1'>\(\ast ^{\leq }((x+1)_{1})\in F_{0}^{\tau _{A}^{e}}\wedge v\) ocurre en \(\ast ^{\leq }((x+1)_{1})\) a partir de \((x+1)_{2}\)
     </li>
     <li class='enumerate' id='x1-212010x8.12.1'>\((\exists \varphi _{1},\varphi _{2}\in F^{\tau _{A}^{e}})(\exists \eta \in \mathrm{Nex})\ast ^{\leq }((x+1)_{1})=(\varphi _{1}\eta \varphi _{2})\wedge \)
     <!-- l. 18335 --><p class='noindent'>\(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \left ((\bar{R}^{\downarrow }(x,v))_{\left \langle \#^{\leq }(\varphi _{1}),(x+1)_{2}-1\right \rangle +1}=1\vee (\bar{R}^{\downarrow }(x,v))_{\left \langle \#^{\leq }(\varphi _{2}),(x+1)_{2}-\left \vert (\varphi _{1}\eta \right \vert \right \rangle +1}=1\right )\)
     </p></li>
     <li class='enumerate' id='x1-212011x8.12.1'>\((\exists \varphi _{1}\in F^{\tau _{A}^{e}})\ast ^{\leq }((x+1)_{1})=\lnot \varphi _{1}\wedge (\bar{R}^{\downarrow }(x,v))_{\left \langle \#^{\leq }(\varphi _{1}),(x+1)_{2}-1\right \rangle +1}=1\)
     </li>
     <li class='enumerate' id='x1-212012x8.12.1'>\((\exists \varphi _{1}\in F^{\tau _{A}^{e}})(\exists w\in Var)(Q\in \{\forall ,\exists \})\;w\neq v\wedge \)
     <!-- l. 18339 --><p class='noindent'>\(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ast ^{\leq }((x+1)_{1})=Qw\varphi _{1}\wedge (\bar{R}^{\downarrow }(x,v))_{\left \langle \#^{\leq }(\varphi _{1}),(x+1)_{2}-\left \vert (Qw\right \vert \right \rangle +1}=1\)
</p>
     </li></ol>

<!-- l. 18342 --><p class='noindent'>Es decir que por el Lema <a href='#x1-96001r80'>80<!-- tex4ht:ref: f-flecha  --></a> tenemos que \(\bar{R}\) es \(\mathcal{A}\)-p.r.. Notese que para \((i,v,\varphi )\in \omega \times Var\times F^{\tau _{A}^{e}}\), tenemos \(P(i,v,\varphi )=\bar{R}(\left \langle \#^{\leq }(\varphi ),i\right \rangle ,v)\).
Ahora es facil obtener la funcion \(P\) haciendo composiciones adecuadas con
\(\bar{R}\).                                                                                                     □
</p>
   </div>
<!-- l. 18350 --><p class='indent'>   Dados \(v\in Var\) y \(t,s\in T^{\tau _{A}^{e}}\), usaremos \(\downarrow _{v}^{t}(s)\) para denotar el resultado de reemplazar simultaneamente
cada ocurrencia de \(v\) en \(s\) por \(t\). Similarmente, si \(\varphi \in F^{\tau _{A}^{e}}\), usaremos \(\downarrow _{v}^{t}(\varphi )\) para denotar el
resultado de reemplazar simultaneamente cada ocurrencia libre de \(v\) en \(\varphi \) por
\(t\).
</p>
   <div class='newtheorem'>
<!-- l. 18356 --><p class='noindent'><span class='head'>
<a id='x1-212013r249'></a>
<span class='cmbx-10'>Lema 249.</span>  </span><span class='cmti-10'>Las funciones</span> \(\lambda svt[\downarrow _{v}^{t}(s)]\) <span class='cmti-10'>y</span> \(\lambda \varphi vt[\downarrow _{v}^{t}(\varphi )]\) <span class='cmti-10'>son</span> \(\mathcal{A}\)<span class='cmti-10'>-r.</span>
</p>
   </div>
<!-- l. 18361 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18362 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que las funciones \(\lambda svt[\downarrow _{v}^{t}(s)]\) y \(\lambda \varphi vt[\downarrow _{v}^{t}(\varphi )]\) son \(\mathcal{A}\)-efectivamente computables (justifique).
Entonces la Tesis de Church nos garantiza que dichas funciones son \(\mathcal{A}\)-recursivas.
</p><!-- l. 18366 --><p class='indent'>   En realidad son \(\mathcal{A}\)-p.r.. Veamos por ejemplo que \(\lambda svt[\downarrow _{v}^{t}(s)]\) es \(\mathcal{A}\)-p.r.. Sea \(\leq \) un orden
total sobre \(\mathcal{A}\). Sea \(h:\omega \times Var\times T^{\tau _{A}^{e}}\rightarrow \omega \) dada por \[ h(x,v,t)=\left \{ \begin{array}{ccc} \#^{\leq }(\downarrow _{v}^{t}(\ast ^{\leq }(x))) &amp; &amp; \text{si }\ast ^{\leq }(x)\in T^{\tau _{A}^{e}}\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \] Sea \(P:\mathbf{N}\times \omega \times Var\times T^{\tau _{A}^{e}}\times \mathcal{A}^{\ast }\rightarrow \omega \) tal que \(P(A,x,v,t,\alpha )=1\) si y solo si se da alguna de las
siguientes
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-212014x8.12.1'>\(\ast ^{\leq }(x+1)\notin T^{\tau _{A}^{e}}\wedge \alpha =\varepsilon \)
     </li>
     <li class='enumerate' id='x1-212015x8.12.1'>\(\ast ^{\leq }(x+1)=v\wedge \alpha =t\)
     </li>
     <li class='enumerate' id='x1-212016x8.12.1'>\(\ast ^{\leq }(x+1)\in (\{0,1\}\cup Aux)-\{v\}\wedge \alpha =\ast ^{\leq }(x+1)\)
     </li>
     <li class='enumerate' id='x1-212017x8.12.1'>\((\exists r,s\in T^{\tau _{A}^{e}})\ast ^{\leq }(x+1)=+(r,s)\wedge \alpha =+(\ast ^{\leq }((A)_{\#^{\leq }(r)+1}),\ast ^{\leq }((A)_{\#^{\leq }(s)+1}))\)
     </li>
     <li class='enumerate' id='x1-212018x8.12.1'>\((\exists r,s\in T^{\tau _{A}^{e}})\ast ^{\leq }(x+1)=\mathrm{.}(r,s)\wedge \alpha =\mathrm{.}(\ast ^{\leq }((A)_{\#^{\leq }(r)+1}),\ast ^{\leq }((A)_{\#^{\leq }(s)+1}))\)</li></ol>

<!-- l. 18385 --><p class='noindent'>Sea \(\bar{P}=P\cup C_{0}^{2,2}|_{\{0\}\times \omega \times Var\times T^{\tau _{A}^{e}}\times \mathcal{A}^{\ast }}\). Notese que \(\bar{P}(h^{\downarrow }(x,v,t),x,v,t,\alpha )=1\) si y solo si ya sea \(\ast ^{\leq }(x+1)\notin T^{\tau _{A}^{e}}\) y \(\alpha =\varepsilon \) o \(\ast ^{\leq }(x+1)\in T^{\tau _{A}^{e}}\) y \(\alpha =\mathrm{\downarrow }_{v}^{t}(\ast ^{\leq }(x+1))\). Tenemos entonces </p><div class='eqnarray'>\begin{eqnarray*} h(0,v,t) &amp; = &amp; 0\\ h(x+1,v,t) &amp; = &amp; \#^{\leq }(\min _{\alpha }^{\leq }\bar{P}(h^{\downarrow }(x,v,t),x,v,t,\alpha )), \end{eqnarray*}
</div>por lo cual el Lema <a href='#x1-96001r80'>80<!-- tex4ht:ref: f-flecha  --></a> nos dice que \(h\) es \(\mathcal{A}\)-p.r. Ahora es facil obtener la funcion \(\lambda svt[\downarrow _{v}^{t}(s)]:T^{\tau _{A}^{e}}\times Var\times T^{\tau _{A}^{e}}\rightarrow T^{\tau _{A}^{e}}\)
haciendo composiciones adecuadas con \(h\).                                                 □
   </div>
   <div class='newtheorem'>
<!-- l. 18400 --><p class='noindent'><span class='head'>
<a id='x1-212019r250'></a>
<span class='cmbx-10'>Lema 250.</span>  </span><span class='cmti-10'>El predicado</span> \(R:\mathcal{A}^{4}\rightarrow \omega \)<span class='cmti-10'>, dado por </span>\[ R(\alpha ,\beta ,\gamma ,\zeta )=\left \{ \begin{array}{cccl} \begin{array}{c} 1\\ \;\\end{array} &amp; &amp; &amp; \begin{array}{cl} \text{si }\beta = &amp; \text{resultado de reemplazar una}\\ &amp; \text{ocurrencia de }\gamma \text{ en }\alpha \text{ por }\zeta \end{array}\\ 0 &amp; &amp; &amp; \text{ caso contrario} \end{array}\right . \] <span class='cmti-10'>es</span> \(\mathcal{A}\)<span class='cmti-10'>-r..</span>
</p>
   </div>
<!-- l. 18418 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18419 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Notese que el predicado \(R\) es \(\mathcal{A}\)-efectivamente computable. Entonces la Tesis
de Church nos garantiza que \(R\) es \(\mathcal{A}\)-recursivo.
</p><!-- l. 18422 --><p class='indent'>   En realidad \(R\) es \(\mathcal{A}\)-p.r. y esto puede verse facilmente ya que \(R(\alpha ,\beta ,\gamma ,\zeta )=1\) sii existen \(\alpha _{1},\alpha _{2}\) tales
que \(\alpha =\alpha _{1}\gamma \alpha _{2}\) y \(\beta =\alpha _{1}\zeta \alpha _{2}\).                                                                                            □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 18428 --><p class='noindent'><span class='head'>
<a id='x1-212020r251'></a>
<span class='cmbx-10'>Lema 251.</span>  </span><span class='cmti-10'>Los conjuntos</span> \(ModPon^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(Elec^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(Reem^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(ConjInt^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(ConjElim^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(EquivInt^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(DisjElim^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(DisjInt^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(EquivElim^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(Generaliz^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(Commut^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(Trans^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(Exist^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(Evoc^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(Absur^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(DivPorCas^{\tau _{A}^{e}}\)<span class='cmti-10'>,</span> \(Partic^{\tau _{A}^{e}}\) <span class='cmti-10'>son</span> \(\mathcal{A}\)<span class='cmti-10'>-r..</span>
</p>
   </div>
<!-- l. 18437 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18438 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Dejamos al lector una prueba via la Tesis de Church. En realidad
dichos conjuntos son \(\mathcal{A}\)-p.r.. Veremos, por ejemplo que \(Reem^{\tau _{A}^{e}}\) es \(\mathcal{A}\)-p.r.. Basta con ver
que \(Reem1^{\tau _{A}^{e}}\) y \(Reem2^{\tau _{A}^{e}}\) lo son. Veremos que \(Reem2^{\tau _{A}^{e}}\) es \(\mathcal{A}\)-p.r.. Sea \(Q:F^{\tau _{A}^{e}}\times F^{\tau _{A}^{e}}\times F^{\tau _{A}^{e}}\rightarrow \omega \) el predicado tal que \(Q(\psi ,\varphi ,\sigma )=1\) si y solo
si

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-212021x8.12.1'>\((\exists \alpha \in (\forall Var)^{\ast })(\exists \psi _{1},\psi _{2}\in F^{\tau _{A}^{e}})\ \psi =\alpha (\psi _{1}\leftrightarrow \psi _{2})\wedge \)
     </li>
     <li class='enumerate' id='x1-212022x8.12.1'>\(\ \ \ \ \ Li(\psi _{1})=Li(\psi _{2})\wedge \left ((\forall v\in Var)\ v\notin Li(\psi _{1})\vee v\text{ ocurre en }\alpha \right )\)
     </li>
     <li class='enumerate' id='x1-212023x8.12.1'>          \(\left ((\forall v\in Var)\ v\text{ no ocurre en }\alpha \vee v\in Li(\psi _{1})\right )\wedge R(\varphi ,\sigma ,\psi _{1},\psi _{2})\)</li></ol>
<!-- l. 18449 --><p class='noindent'>(\(R\) es el predicado dado por el Lema <a href='#x1-212019r250'>250<!-- tex4ht:ref: reemp-formulas  --></a>). Es facil ver que \(Q\) es \(\mathcal{A}\)-p.r. y que \(\chi _{Reem2^{\tau _{A}^{e}}}^{\mathcal{A}^{4}}=Q|_{S^{\tau _{A}^{e}}\times S^{\tau _{A}^{e}}\times S^{\tau _{A}^{e}}}\).           □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 18454 --><p class='noindent'><span class='head'>
<a id='x1-212024r252'></a>
<span class='cmbx-10'>Lema 252.</span>  </span><span class='cmti-10'>El predicado</span> \("\psi \) <span class='cmti-10'>se deduce de</span> \(\varphi \) <span class='cmti-10'>por generalizacion con constante</span> \(c\)<span class='cmti-10'>, con
</span><span class='cmti-10'>respecto a</span> \(\tau _{A}^{e}":S^{\tau _{A}^{e}}\times S^{\tau _{A}^{e}}\times Aux\rightarrow \omega \) <span class='cmti-10'>es</span> \(\mathcal{A}\)<span class='cmti-10'>-r..</span>
</p>
   </div>
<!-- l. 18460 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18461 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es  claro  que  el  predicado  en  cuestion  es  \(\mathcal{A}\)-efectivamente  computable
(justifique). Por la Tesis de Church tenemos entonces que dicho predicado es \(\mathcal{A}\)-r.
</p><!-- l. 18465 --><p class='indent'>   Para probar que en realidad dicho predicado es \(\mathcal{A}\)-p.r., notese que: \(\psi \) se deduce de \(\varphi \)
por generalizacion con constante \(c\) si y solo si hay una formula \(\gamma \) y una variable \(v\) tales
que
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-212025x8.12.1'>\(Li(\gamma )=\{v\}\)
     </li>
     <li class='enumerate' id='x1-212026x8.12.1'>cada ocurrencia de \(v\) en \(\gamma \) es libre
     </li>
     <li class='enumerate' id='x1-212027x8.12.1'>\(c\) no ocurre en \(\gamma \)
     </li>
     <li class='enumerate' id='x1-212028x8.12.1'>\(\varphi =\mathrm{\downarrow }_{v}^{c}(\gamma )\wedge \psi =\forall v\gamma \)</li></ol>
                                                                 □

   </div>
   <div class='newtheorem'>
<!-- l. 18478 --><p class='noindent'><span class='head'>
<a id='x1-212029r253'></a>
<span class='cmbx-10'>Lema 253.</span>  </span><span class='cmti-10'>El predicado</span> \("\psi \) <span class='cmti-10'>se deduce de</span> \(\varphi \) <span class='cmti-10'>por eleccion con constante</span> \(e\)<span class='cmti-10'>, con respecto
</span><span class='cmti-10'>a</span> \(\tau _{A}^{e}":S^{\tau _{A}^{e}}\times S^{\tau _{A}^{e}}\times Aux\rightarrow \omega \) <span class='cmti-10'>es</span> \(\mathcal{A}\)<span class='cmti-10'>-r..</span>
</p>
   </div>
<!-- l. 18484 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18485 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es  claro  que  el  predicado  en  cuestion  es  \(\mathcal{A}\)-efectivamente  computable
(justifique). Por la Tesis de Church tenemos entonces que dicho predicado es \(\mathcal{A}\)-r.
</p><!-- l. 18489 --><p class='indent'>   Dejamos al lector probar que en realidad dicho predicado es \(\mathcal{A}\)-p.r.            □
</p>
   </div>
<!-- l. 18493 --><p class='indent'>   Recordemos que \[ AxLog^{\tau _{A}^{e}}=\{\varphi \in S^{\tau _{A}^{e}}:\varphi \text{ es un axioma logico de tipo }\tau _{A}^{e}\} \]
</p>
   <div class='newtheorem'>
<!-- l. 18498 --><p class='noindent'><span class='head'>
<a id='x1-212030r254'></a>
<span class='cmbx-10'>Lema 254.</span>  </span>\(AxLog^{\tau _{A}^{e}}\) <span class='cmti-10'>es</span> \(\mathcal{A}\)<span class='cmti-10'>-r..</span>
</p>
   </div>
<!-- l. 18502 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18503 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es  claro  que  el  conjunto  en  cuestion  es  \(\mathcal{A}\)-efectivamente  computable
(justifique). Por la Tesis de Church tenemos entonces que dicho conjunto es \(\mathcal{A}\)-r.
</p><!-- l. 18507 --><p class='indent'>   Dejamos al lector probar que en realidad dicho conjunto es \(\mathcal{A}\)-p.r. La prueba
es completamente analoga a la prueba de que \(\mathrm{Ins}^{\Sigma }\) es un conjunto \((\Sigma \cup \Sigma _{p})\)-p.r. (Lema <a href='#x1-115003r95'>95<!-- tex4ht:ref: Ins-es-pr  --></a>)   □

</p>
   </div>
   <div class='newtheorem'>
<!-- l. 18513 --><p class='noindent'><span class='head'>
<a id='x1-212031r255'></a>
<span class='cmbx-10'>Lema 255.</span>  </span><span class='cmti-10'>Sea</span> \(\Sigma \) <span class='cmti-10'>un alfabeto finito. Sea</span> \(S\subseteq \Sigma ^{\ast }\) <span class='cmti-10'>un conjunto</span> \(\Sigma \)<span class='cmti-10'>-r.. El conjunto</span> \(S^{+}\) <span class='cmti-10'>es</span> \(\Sigma \)<span class='cmti-10'>-r.</span>
</p>
   </div>
<!-- l. 18518 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18519 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que \(S\) es \(\Sigma \)-r., tenemos que \(S\) es \(\Sigma \)-efectivamente computable. Es facil ver
que entonces \(S^{+}\) es \(\Sigma \)-efectivamente computable. Por la Tesis de Church tenemos
entonces que \(S\) es \(\Sigma \)-recursivo.
</p><!-- l. 18523 --><p class='indent'>   Ya que \(\alpha \in S^{+}\) si y solo si \[ (\exists z\in \mathbf{N})(\forall i\in \mathbf{N})_{i\leq Lt(z)}\ast ^{\leq }((z)_{i})\in S\wedge \alpha =\mathrm{\subset }_{i=1}^{Lt(z)}\ast ^{\leq }((z)_{i}) \] se puede probar tambien este lema sin usar la Tesis de
Church. Dejamos al lector los detalles.                                                   □
</p>
   </div>
<!-- l. 18532 --><p class='indent'>   Recordemos que dada \(\mathbf{\varphi }\in S^{\tau _{A}^{e}+}\), usamos \(n(\mathbf{\varphi })\) y \(\mathbf{\varphi }_{1},...,\mathbf{\varphi }_{n(\mathbf{\varphi })}\) para denotar los unicos \(n\) y \(\varphi _{1},...,\varphi _{n}\) tales que \(\mathbf{\varphi }=\varphi _{1}...\varphi _{n}\) (la
unicidad es garantizada en Lema <a href='#x1-193001r212'>212<!-- tex4ht:ref: secuencia de sentencias  --></a>). Extendamos esta notacion definiendo \(\mathbf{\varphi }_{i}=\varepsilon \) para \(i=0\) o
\(i&gt;n(\mathbf{\varphi })\).
</p>
   <div class='newtheorem'>
<!-- l. 18539 --><p class='noindent'><span class='head'>
<a id='x1-212032r256'></a>
<span class='cmbx-10'>Lema 256.</span>  </span><span class='cmti-10'>Las funciones </span>\[ \begin{array}{ccc} S^{\tau _{A}^{e}+} &amp; \rightarrow &amp; \omega \\ \mathbf{\varphi } &amp; \rightarrow &amp; n(\mathbf{\varphi }) \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{ccc} \omega \times S^{\tau _{A}^{e}+} &amp; \rightarrow &amp; S^{\tau _{A}^{e}}\cup \{\varepsilon \}\\ (i,\mathbf{\varphi }) &amp; \rightarrow &amp; \mathbf{\varphi }_{i} \end{array} \] <span class='cmti-10'>son</span> \(\mathcal{A}\)<span class='cmti-10'>-r.</span>
</p>
   </div>
<!-- l. 18553 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18554 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Es claro que la funciones en cuestion son \(\mathcal{A}\)-efectivamente computables
(justifique). Por la Tesis de Church tenemos entonces que son \(\mathcal{A}\)-r.
</p><!-- l. 18558 --><p class='indent'>   Dejamos al lector probar que en realidad dicho conjunto es \(\mathcal{A}\)-p.r. La prueba es
completamente analoga a la prueba de que \(\lambda \mathcal{P}\left [n(\mathcal{P})\right ]\) y \(\lambda i\mathcal{P}\left [I_{i}^{\mathcal{P}}\right ]\) son funciones \((\Sigma \cup \Sigma _{p})\)-p.r. (Lema <a href='#x1-115005r97'>97<!-- tex4ht:ref: Pro-es-pr  --></a>)   □
</p>
   </div>
<!-- l. 18565 --><p class='indent'>   Recordemos que dada \(\mathbf{J}\in Just^{+}\), usamos \(n(\mathbf{J})\) y \(\mathbf{J}_{1},...,\mathbf{J}_{n(\mathbf{J})}\) para denotar los unicos \(n\) y \(J_{1},...,J_{n}\) tales que \(\mathbf{J}=J_{1}...J_{n}\) (la
unicidad es garantizada en Lema <a href='#x1-192001r211'>211<!-- tex4ht:ref: secuencia de justificaciones  --></a>). Extendamos esta notacion definiendo \(\mathbf{J}_{i}=\varepsilon \) para \(i=0\) o
\(i&gt;n(\mathbf{J})\).
</p><!-- l. 18572 --><p class='indent'>   Sea \(\mathcal{B}\) el alfabeto que consiste en todos los simbolos que ocurren en alguna palabra
de \(Just\). Es decir \(\mathcal{B}\) consiste de los simbolos \[ (\ )\ ,\ 0\ 1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ \text{A\ B\ C\ D\ E\ G\ H\ I\ J\ L\ M\ N\ O\ P\ Q\ R\ S\ T\ U\ V\ X Z} \]
</p>
   <div class='newtheorem'>
<!-- l. 18579 --><p class='noindent'><span class='head'>
<a id='x1-212033r257'></a>
<span class='cmbx-10'>Lema 257.</span>  </span>\(Just\) <span class='cmti-10'>es</span> \(\mathcal{B}\)<span class='cmti-10'>-r. Las funciones </span>\[ \begin{array}{ccc} Just^{+} &amp; \rightarrow &amp; \omega \\ \mathbf{J} &amp; \rightarrow &amp; n(\mathbf{J}) \end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{ccc} \omega \times Just^{+} &amp; \rightarrow &amp; Just\cup \{\varepsilon \}\\ (i,\mathbf{J}) &amp; \rightarrow &amp; \mathbf{J}_{i} \end{array} \] <span class='cmti-10'>son</span> \(\mathcal{B}\)<span class='cmti-10'>-r.</span>
</p>
   </div>
<!-- l. 18593 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18594 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es claro que la funciones en cuestion son \(\mathcal{B}\)-efectivamente computables
(justifique). Por la Tesis de Church tenemos entonces que son \(\mathcal{B}\)-r.                 □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 18600 --><p class='noindent'><span class='head'>
<a id='x1-212034r258'></a>
<span class='cmbx-10'>Lema 258.</span>  </span><span class='cmti-10'>El predicado</span> \("\left \langle i,j\right \rangle \in \mathcal{B}^{\mathbf{J}}":\omega \times \omega \times Just^{+}\rightarrow \omega \) <span class='cmti-10'>es</span> \(\mathcal{B}\)<span class='cmti-10'>-r</span>
</p>
   </div>
<!-- l. 18605 --><p class='indent'>
</p>

   <div class='proof'>
<!-- l. 18606 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es claro que dicho predicado es \(\mathcal{B}\)-efectivamente computable (justifique).
Por la Tesis de Church tenemos entonces que es \(\mathcal{B}\)-r.                                   □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 18611 --><p class='noindent'><span class='head'>
<a id='x1-212035r259'></a>
<span class='cmbx-10'>Lema 259.</span>  </span><span class='cmti-10'>El conjunto</span> \(\{\mathbf{J}\in Just^{+}:\mathbf{J}\) <span class='cmti-10'>es balanceada</span>\(\}\) <span class='cmti-10'>es</span> \(\mathcal{B}\)<span class='cmti-10'>-r.</span>
</p>
   </div>
<!-- l. 18616 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18617 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es claro que dicho conjunto es \(\mathcal{B}\)-efectivamente computable (justifique).
Por la Tesis de Church tenemos entonces que es \(\mathcal{B}\)-r.                                   □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 18622 --><p class='noindent'><span class='head'>
<a id='x1-212036r260'></a>
<span class='cmbx-10'>Lema 260.</span>  </span><span class='cmti-10'>Los predicados </span>\[ \begin{array}{rcl} \omega \times S^{\tau _{A}^{e}}\times S^{\tau _{A}^{e}+}\times Just^{+} &amp; \rightarrow &amp; \omega \\ (i,\varphi ,\mathbf{\varphi },\mathbf{J}) &amp; \rightarrow &amp; \left \{ \begin{array}{ccl} 1 &amp; &amp; \text{si }(\mathbf{\varphi },\mathbf{J})\text{ es adecuado y }\varphi \text{ es hipotesis de }\mathbf{\varphi }_{i}\text{ en }(\mathbf{\varphi },\mathbf{J})\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \end{array} \] \[ \begin{array}{rcl} \omega \times \omega \times S^{\tau _{A}^{e}+}\times Just^{+} &amp; \rightarrow &amp; \omega \\ (i,\varphi ,\mathbf{\varphi },\mathbf{J}) &amp; \rightarrow &amp; \left \{ \begin{array}{ccl} 1 &amp; &amp; \text{si }(\mathbf{\varphi },\mathbf{J})\text{ es adecuado y }i\text{ es anterior a }j\text{ en }(\mathbf{\varphi },\mathbf{J})\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \end{array} \] <span class='cmti-10'>son</span> \((\mathcal{A}\cup \mathcal{B})\)<span class='cmti-10'>-r..</span>
</p>
   </div>
<!-- l. 18645 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18646 --><p class='indent'>   <span class='head'>

<span class='cmti-10'>Proof.</span> </span>Es claro que los predicados en cuestion son \((\mathcal{A}\cup \mathcal{B})\)-efectivamente computables
(justifique). Por la Tesis de Church tenemos entonces que dichos predicados son
\((\mathcal{A}\cup \mathcal{B})\)-r.                                                                                                   □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 18652 --><p class='noindent'><span class='head'>
<a id='x1-212037r261'></a>
<span class='cmbx-10'>Lema 261.</span>  </span><span class='cmti-10'>El predicado </span>\[ \begin{array}{rcl} Aux\times Aux\times S^{\tau _{A}^{e}+}\times Just^{+} &amp; \rightarrow &amp; \omega \\ (e,d,\mathbf{\varphi },\mathbf{J}) &amp; \rightarrow &amp; \left \{ \begin{array}{ccl} 1 &amp; &amp; \text{si }(\mathbf{\varphi },\mathbf{J})\text{ es adecuado y }e\text{ depende de }d\text{ en }(\mathbf{\varphi },\mathbf{J})\\ 0 &amp; &amp; \text{caso contrario} \end{array}\right . \end{array} \] <span class='cmti-10'>es</span> \((\mathcal{A}\cup \mathcal{B})\)<span class='cmti-10'>-r..</span>
</p>
   </div>
<!-- l. 18666 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18667 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Es  claro  que  el  predicado  en  cuestion  es  \((\mathcal{A}\cup \mathcal{B})\)-efectivamente  computable
(justifique). Por la Tesis de Church tenemos entonces que dicho predicado es
\((\mathcal{A}\cup \mathcal{B})\)-r.                                                                                                   □
</p>
   </div>
<!-- l. 18673 --><p class='indent'>   Dada una teoria de la forma \((\Sigma ,\tau _{A})\), diremos que una prueba formal \((\mathbf{\varphi },\mathbf{J})\) de \(\varphi \) en \((\Sigma ,\tau _{A})\) es
<span class='cmti-10'>normal </span>si solo usa nombres de ctes auxiliares de \(Aux\), es decir si \(\mathbf{\varphi }\in S^{\tau _{A}^{e}+}\). Definamos
\[ Pruebas_{(\Sigma ,\tau _{A})}=\{(\mathbf{\varphi },\mathbf{J}):\exists \varphi \ (\mathbf{\varphi },\mathbf{J})\text{ es una prueba normal de }\varphi \text{ en }(\Sigma ,\tau _{A})\} \]
</p>
   <div class='newtheorem'>
<!-- l. 18681 --><p class='noindent'><span class='head'>
<a id='x1-212038r262'></a>
<span class='cmbx-10'>Lema 262.</span>  </span><span class='cmti-10'>Sea</span> \((\Sigma ,\tau _{A})\) <span class='cmti-10'>una teoria tal que</span> \(\Sigma \) <span class='cmti-10'>es</span> \(\mathcal{A}\)<span class='cmti-10'>-r.e. (resp.</span> \(\mathcal{A}\)<span class='cmti-10'>-recursivo). Entonces</span> \(Pruebas_{(\Sigma ,\tau _{A})}\) <span class='cmti-10'>es</span>
\((\mathcal{A}\cup \mathcal{B})\)<span class='cmti-10'>-r.e. (resp.</span> \((\mathcal{A}\cup \mathcal{B})\)<span class='cmti-10'>-recursivo).</span>
</p>
   </div>
<!-- l. 18687 --><p class='indent'>
</p>
   <div class='proof'>

<!-- l. 18688 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos  que  \(\Sigma \)  es  \(\mathcal{A}\)-r.e..  Claramente  entonces  \(\Sigma \)  es  \(\mathcal{A}\)-efectivamente
computable por lo cual hay una funcion \(g:\omega \rightarrow \Sigma \) la cual es \(\mathcal{A}\)-efectivamente computable y
suryectiva. Sea \(\leq \) un orden total sobre \(\mathcal{A}\cup \mathcal{B}\). A continuacion describimos como hacer
un procedimiento efectivo enumere a \(Pruebas_{(\Sigma ,\tau _{A})}\). Dejamos al lector completar los detalles.
Dada una prueba formal \((\mathbf{\varphi },\mathbf{J})\) cualquiera, definamos \[ Ax((\mathbf{\varphi },\mathbf{J}))=\{\mathbf{\varphi }_{i}:\text{existe }\alpha \text{ tal que }\mathbf{J}_{i}=\alpha \mathrm{AXIOMAPROPIO}\} \]
</p><!-- l. 18700 --><p class='indent'>   Etapa 1
</p><!-- l. 18702 --><p class='noindent'>Si \(x=0\), detenerse y dar como salida \(((0\equiv 0),\mathrm{AXIOMALOGICO})\). En caso contrario ir a Etapa 2
</p><!-- l. 18705 --><p class='indent'>   Etapa 2.
</p><!-- l. 18707 --><p class='noindent'>Si \((\ast ^{\leq }((x)_{1}),\ast ^{\leq }((x)_{2}))\) es una prueba formal y \(Ax((\ast ^{\leq }((x)_{1}),\ast ^{\leq }((x)_{2})))\subseteq \{g(0),...,g((x)_{3})\}\), entonces detenerse y dar como salida \((\ast ^{\leq }((x)_{1}),\ast ^{\leq }((x)_{2}))\). Caso contrario
detenerse y dar como salida \(((0\equiv 0),\mathrm{AXIOMALOGICO})\)
</p><!-- l. 18712 --><p class='indent'>   Por la Tesis de Church tenemos entonces que \(Pruebas_{(\Sigma ,\tau _{A})}\) es \((\mathcal{A}\cup \mathcal{B})\)-r.e.                           □
</p>
   </div>
<!-- l. 18717 --><p class='indent'>   Dada una teoria \((\Sigma ,\tau _{A})\), definamos \[ Teo_{(\Sigma ,\tau _{A})}=\{\varphi \in S^{\tau _{A}}:(\Sigma ,\tau _{A})\vdash \varphi \} \]
</p>
   <div class='newtheorem'>
<!-- l. 18722 --><p class='noindent'><span class='head'>
<a id='x1-212039r263'></a>
<span class='cmbx-10'>Proposition 263.</span>  </span><span class='cmti-10'>Si</span> \((\Sigma ,\tau _{A})\) <span class='cmti-10'>es una teoria tal que</span> \(\Sigma \) <span class='cmti-10'>es</span> \(\mathcal{A}\)<span class='cmti-10'>-r.e., entonces</span> \(Teo_{(\Sigma ,\tau _{A})}\) <span class='cmti-10'>es</span> \(\mathcal{A}\)<span class='cmti-10'>-r.e.</span>
</p>
   </div>
<!-- l. 18728 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18729 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Como  se  vio  en  el  lema  anterior,  tenemos  que  \(Pruebas_{(\Sigma ,\tau _{A})}\)  es  \((\mathcal{A}\cup \mathcal{B})\)-efectivamente
enumerable.  Es  facil  ahora,  usando  un  procedimiento  efectivo  que  enumere
a  \(Pruebas_{(\Sigma ,\tau _{A})}\),  diseñar  un  procedimiento  efectivo  que  enumere  a  \(Teo_{(\Sigma ,\tau _{A})}\).  Es  decir  que  \(Teo_{(\Sigma ,\tau _{A})}\)  es
\(\mathcal{A}\)-efectivamente enumerable, lo cual por la Tesis de Church nos dice que es \(\mathcal{A}\)-r.e.
</p><!-- l. 18736 --><p class='indent'>   A continuacion daremos una prueba que no usa la Tesis de Church. Ya que \(Pruebas_{(\Sigma ,\tau _{A})}\)
es \((\mathcal{A}\cup \mathcal{B})\)-r.e. (lema anterior) tenemos que hay una funcion \(F:\omega \rightarrow S^{\tau _{A}^{e}+}\times Just^{+}\) la cual cumple que \(p_{1}^{0,2}\circ F\) y \(p_{2}^{0,2}\circ F\) son
\((\mathcal{A}\cup \mathcal{B})\)-r. y ademas \(I_{F}=Pruebas_{(\Sigma ,\tau _{A})}\). Sea \[ \begin{array}{rcl} g:S^{\tau _{A}^{e}+} &amp; \rightarrow &amp; S^{\tau _{A}^{e}}\\ \mathbf{\varphi } &amp; \rightarrow &amp; \mathbf{\varphi }_{n(\mathbf{\varphi })} \end{array} \] Por lemas anteriores \(g\) es \(\mathcal{A}\)-r.. Notese que \(I_{(g\circ p_{1}^{0,2}\circ F)}=Teo_{(\Sigma ,\tau _{A})}\), lo cual dice que \(Teo_{(\Sigma ,\tau _{A})}\) es
\((\mathcal{A}\cup \mathcal{B})\)-r.e. (Teorema <a href='#x1-134010r126'>126<!-- tex4ht:ref: equivalencias-r.e.  --></a>). Por el teorema de independencia del alfabeto tenemos que
\(Teo_{(\Sigma ,\tau _{A})}\) es \(\mathcal{A}\)-r.e..                                                                                           □

</p>
   </div>
<!-- l. 18756 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>8.12.2   </span> <a id='x1-2130008.12.2'></a>Funciones representables</h5>
<!-- l. 18758 --><p class='noindent'>Sea \(n\geq 1\). Una funcion \(f:D_{f}\subseteq \omega ^{n}\rightarrow \omega \) sera llamada <span class='cmti-10'>representable </span>si hay una formula \(\varphi =_{d}\varphi (v_{1},...,v_{n},v)\in F^{\tau _{A}}\), la cual cumpla \[ \mathbf{\omega }\models \varphi \left [k_{1},...,k_{n},k\right ]\mathrm{\ si\ y\ solo\ si\ }f(k_{1},...,k_{n})=k \]
cualesquiera sean \(k_{1},...,k_{n},k\in \omega \). En tal caso diremos que la formula \(\varphi \) <span class='cmti-10'>representa </span>a la funcion \(f\), con
respecto a la declaracion \(\varphi =_{d}\varphi (v_{1},...,v_{n},v)\). Notese que cuando \((k_{1},...,k_{n})\notin D_{f}\) entonces debera suceder que \(\mathbf{\omega }\nvDash \varphi \left [k_{1},...,k_{n},k\right ]\),
cualquiera sea \(k\in \omega \). Cabe destacar que una formula \(\varphi \) puede representar a \(f\), con respecto a
una declaracion y con respecto a otra declaracion puede no representarla. Por
ejemplo la formula \((x_{3}\equiv x_{1}+x_{2})\) representa a la operacion suma con respecto a las declaraciones \(\varphi =_{d}\varphi (x_{1},x_{2},x_{3})\) y
\(\varphi =_{d}\varphi (x_{2},x_{1},x_{3})\) pero con respecto a la declaracion \(\varphi =_{d}\varphi (x_{3},x_{2},x_{1})\) no representa a dicha operacion. Para dar otro
ejemplo, tomemos \(\varphi =(x_{5}\equiv 1)\). Entonces
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-213001x8.12.2'>Con respecto a la declaracion \(\varphi =_{d}\varphi (x_{2},x_{5})\) la formula \(\varphi \) representa a la funcion con
     dominio \(\omega \) y valor constantemente 1
     </li>
     <li class='enumerate' id='x1-213002x8.12.2'>Con respecto a la declaracion \(\varphi =_{d}\varphi (x_{10},x_{5})\) la formula \(\varphi \) representa a la funcion con
     dominio \(\omega \) y valor constantemente 1
     </li>
     <li class='enumerate' id='x1-213003x8.12.2'>Con respecto a la declaracion \(\varphi =_{d}\varphi (x_{2},x_{6},x_{5})\) la formula \(\varphi \) representa a la funcion con
     dominio \(\omega ^{2}\) y valor constantemente 1</li></ol>
<!-- l. 18788 --><p class='noindent'>El concepto de funcion representable sera clave en nuestra prueba del teorema de
incompletitud. El resultado clave desde el cual sale facilmente el teorema de
incompletitud es la Proposicion <a href='#x1-214004r269'>269<!-- tex4ht:ref: verd no es r.e.  --></a> en la que se prueba que el conjunto \(Verd_{\mathbf{\omega }}\) no es
\(\mathcal{A}\)-r.e..Para probar dicha proposicion primero probaremos que toda funcion \(\emptyset \)-recursiva
es representable. Aqui es clave una funcion introducida por Godel. Sea \[ \beta =\lambda xyi[R(x,y(i+1)+1)] \] donde \[ \begin{array}[t]{rll} R:\omega \times \mathbf{N} &amp; \rightarrow &amp; \omega \\ (x,y) &amp; \rightarrow &amp; \text{resto de la division de }x\text{ por }y \end{array} \]
Notese que \(D_{\beta }=\omega ^{3}\). Esta funcion, conocida como la <span class='cmti-10'>funcion</span> \(\beta \)<span class='cmti-10'> de Godel</span>, es representable ya
que por ejemplo la formula \[ \varphi =\exists x_{5}\;(x_{1}\equiv x_{5}.(x_{2}.(x_{3}+1)+1)+x_{4}\wedge x_{4}&lt;x_{2}.(x_{3}+1)+1) \] la representa, con respecto a la declaracion \(\varphi =_{d}\varphi (x_{1},x_{2},x_{3},x_{4})\). Ahora
veremos un lema que muestra que la funcion \(\beta \) tiene una propiedad sorprendente en el
sentido de que cualquier sucesion finita de elementos de \(\omega \) es producida por \(\beta \) si
fijamos adecuadamente sus dos primeras entradas. Dados \(x,y\in \omega \), diremos que \(x\) e \(y\) son
<span class='cmti-10'>coprimos </span>cuando \(1\) sea el unico elemento de \(\omega \) que divide a ambos. Notese
que \(x\) e \(y\) no son son coprimos sii existe un numero primo \(p\in \omega \) que los divide a
ambos
</p>
   <div class='newtheorem'>
<!-- l. 18819 --><p class='noindent'><span class='head'>
<a id='x1-213004r264'></a>

<span class='cmbx-10'>Lema 264.</span>  </span><span class='cmti-10'>Cualesquiera sean</span> \(z_{0},...,z_{n}\in \omega \)<span class='cmti-10'>,</span> \(n\geq 0\)<span class='cmti-10'>, hay</span> \(x,y\in \omega \)<span class='cmti-10'>, tales que</span> \(\beta (x,y,i)=z_{i}\)<span class='cmti-10'>,</span> \(i=0,...,n\)
</p>
   </div>
<!-- l. 18824 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18825 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Dados \(x,y,m\in \omega \) con \(m\geq 1\), usaremos \(x\equiv y(m)\) para expresar que \(x\) es congruente a \(y\) modulo \(m\), es decir
para expresar que \(x-y\) es divisible por \(m\). Usaremos en esta prueba el Teorema Chino del
Resto:
     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-213005x8.12.2'>Dados \(m_{0},...,m_{n},z_{0},...,z_{n}\in \omega \) tales que \(m_{0},...,m_{n}\) son coprimos de a pares, hay un \(x\in \omega \) tal que \(x\equiv z_{i}(m_{i})\), para \(i=0,...,n.\)</li></ol>
<!-- l. 18834 --><p class='noindent'>Sea \(y=\max (z_{0},...,z_{n},n)!\). Sean \(m_{i}=y(i+1)+1\), \(i=0,...,n\). Veamos que \(m_{0},...,m_{n}\) son coprimos de a pares. Supongamos \(p\) divide a \(m_{i}\) y a \(m_{j}\) con \(i&lt;j\).
Entonces \(p\) divide a \(m_{j}-m_{i}=y(j-i)\) y ya que \(p\) no puede dividir a \(y\), tenemos que \(p\) divide a \(j-i\).
Pero ya que \(j-i&lt;n\) tenemos que \(p&lt;n\) lo cual es absurdo ya que implicaria que \(p\) divide
\(y\).
</p><!-- l. 18841 --><p class='indent'>   Por el Teorema Chino del Resto hay un \(x\) tal que \(x\equiv z_{i}(m_{i})\), para \(i=0,...,n\). Ya que \(z_{i}&lt;m_{i}\), tenemos que
\[ \beta (x,y,i)=R(x,y(i+1)+1)=R(x,m_{i})=z_{i}\text{, }i=0,...,n\text{.} \]                                                                 □
</p>
   </div>
<!-- l. 18849 --><p class='indent'>   El lema anterior nos permite probar:
</p>
   <div class='newtheorem'>
<!-- l. 18850 --><p class='noindent'><span class='head'>
<a id='x1-213006r265'></a>
<span class='cmbx-10'>Proposition 265.</span>  </span><span class='cmti-10'>Si</span> \(h\) <span class='cmti-10'>es</span> \(\emptyset \)<span class='cmti-10'>-recursiva, entonces</span> \(h\) <span class='cmti-10'>es representable</span>
</p>
   </div>
<!-- l. 18854 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18855 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(f:S_{1}\times ...\times S_{n}\rightarrow \omega \) y \(g:\omega \times \omega \times S_{1}\times ...\times S_{n}\rightarrow \omega \) son representables, con \(S_{1},...,S_{n}\subseteq \omega \) y \(n\geq 0\). Probaremos que entonces \(R(f,g):\omega \times S_{1}\times ...\times S_{n}\rightarrow \omega \) lo es.
Para esto primero notese que para \(t,x_{1},...,x_{n},z\in \omega \), las siguientes son equivalentes

     </p><ol class='enumerate1'>
     <li class='enumerate' id='x1-213007x8.12.2'>\(R(f,g)(t,\vec{x})=z\)
     </li>
     <li class='enumerate' id='x1-213008x8.12.2'>Hay \(z_{0},...,z_{t}\in \omega \) tales que <div class='eqnarray'>\begin{eqnarray*} z_{0} &amp; = &amp; f(\vec{x})\\ z_{i+1} &amp; = &amp; g(z_{i},i,\vec{x})\text{, }i=0,...,t-1\\ z_{t} &amp; = &amp; z \end{eqnarray*}
     </div>
     </li>
     <li class='enumerate' id='x1-213009x8.12.2'>Hay \(x,y\in \omega \) tales que <div class='eqnarray'>\begin{eqnarray*} \beta (x,y,0) &amp; = &amp; f(\vec{x})\\ \beta (x,y,i+1) &amp; = &amp; g(\beta (x,y,i),i,\vec{x})\text{, }i=0,...,t-1\\ \beta (x,y,t) &amp; = &amp; z \end{eqnarray*}
     </div></li></ol>
<!-- l. 18875 --><p class='noindent'>Sean \(\varphi _{\beta }\), \(\varphi _{f}\) y \(\varphi _{g}\) formulas que representen a las funciones \(\beta \), \(f\) y \(g\), con respecto a las declaraciones
</p><div class='eqnarray'>\begin{eqnarray*} \varphi _{\beta } &amp; = &amp; _{d}\varphi _{\beta }(x_{1},x_{2},x_{3},x_{4})\\ \varphi _{f} &amp; = &amp; _{d}\varphi _{f}(x_{1},...,x_{n},x_{n+1})\\ \varphi _{g} &amp; = &amp; _{d}\varphi _{g}(x_{1},...,x_{n+2},x_{n+3}) \end{eqnarray*}
</div>respectivamente. Sean \(v_{1},...,v_{n+1},v\), \(y_{1},y_{2},y_{3},y_{4},z_{1},z_{2}\) variables todas distintas y tales que cada una de las
variebles libres de \(\varphi _{\beta }\), \(\varphi _{f}\) y \(\varphi _{g}\) es sustituible por cada una de las variables \(v_{1},...,v_{n+1},v\), \(y_{1},y_{2},y_{3},y_{4},z_{1},z_{2}\). Sea \(\varphi _{R(f,g)}\) la siguiente
formula
     <ol class='enumerate1'>
     <li class='enumerate' id='x1-213010x8.12.2'>\(\exists z_{1},z_{2}\;(\exists y_{1}\varphi _{\beta }(z_{1},z_{2},0,y_{1})\wedge \varphi _{f}(v_{2},...,v_{n+1},y_{1}))\wedge \)
     </li>
     <li class='enumerate' id='x1-213011x8.12.2'>\(\ \ \ \ \ \ \ \ \ \varphi _{\beta }(z_{1},z_{2},v_{1},v)\wedge \forall y_{2}(y_{2}&lt;v_{1}\rightarrow \exists y_{3},y_{4}\;\varphi _{\beta }(z_{1},z_{2},y_{2}+1,y_{3})\wedge \)
     </li>
     <li class='enumerate' id='x1-213012x8.12.2'>\(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \varphi _{\beta }(z_{1},z_{2},y_{2},y_{4})\wedge \varphi _{g}(y_{4},y_{2},v_{2},...,v_{n+1},y_{3}))\)</li></ol>
<!-- l. 18893 --><p class='noindent'>Es facil usando (3) ver que la formula \(\varphi _{R(f,g)}\) representa a \(R(f,g)\), con respecto a la declaracion
\(\varphi _{R(f,g)}=_{d}\varphi _{R(f,g)}(v_{1},...,v_{n+1},v)\).
</p><!-- l. 18896 --><p class='indent'>   En forma analoga se puede probar que las reglas de composicion y minimizacion
preservan representabilidad por lo cual ya que los elementos de \(\mathrm{R}_{0}^{\emptyset }\) son representables,
por induccion tenemos que lo es toda funcion \(\emptyset \)-r.                                      □
</p>
   </div>
<!-- l. 18903 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>8.12.3   </span> <a id='x1-2140008.12.3'></a>Prueba del teorema de incompletitud</h5>
<!-- l. 18905 --><p class='noindent'>Nuestra estrategia sera probar que \(Verd_{\mathbf{\omega }}\) no es \(\mathcal{A}\)-r.e., para lo cual necesitamos los siguientes
dos lemas. El primero consiste en dar una funcion total numerica la cual codifique al
predicado \("\)el programa \(\mathcal{P}\) se detiene luego de \(t\) pasos, partiendo del estado
\(((0,0,...),(\mathcal{P},\varepsilon ,...))"\).
</p>
   <div class='newtheorem'>
<!-- l. 18910 --><p class='noindent'><span class='head'>
<a id='x1-214001r266'></a>

<span class='cmbx-10'>Lema 266.</span>  </span><span class='cmti-10'>Hay un predicado</span> \(P:\omega \times \omega \rightarrow \omega \) <span class='cmti-10'>el cual es</span> \(\emptyset \)<span class='cmti-10'>-p.r. y tal que el predicado</span> \(Q=\lambda x\left [(\exists t\in \omega )P(t,x)\right ]:\omega \rightarrow \omega \) <span class='cmti-10'>no es</span> \(\emptyset \)<span class='cmti-10'>-r.</span>
</p>
   </div>
<!-- l. 18916 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18917 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Sea \(\Sigma =\Sigma _{p}\). Recordemos que el predicado \[ P_{1}=\lambda t\mathcal{P}\left [i^{0,1}(t,\mathcal{P},\mathcal{P})=n(\mathcal{P})+1\right ] \] es \(\Sigma _{p}\)-p.r. ya que la funcion \(i^{0,1}\) lo es.
Notese que el dominio de \(P_{1}\) es \(\omega \times \mathrm{Pro}^{\Sigma _{p}}\). Por Lema <a href='#x1-135002r133'>133<!-- tex4ht:ref: autohalt  --></a> tenemos que \[ AutoHalt^{\Sigma _{p}}=\lambda \mathcal{P}\left [(\exists t\in \omega )\;P_{1}(t,\mathcal{P})\right ] \] no es \(\Sigma _{p}\)-recursivo.
Sea \(\leq \) un orden total sobre \(\Sigma _{p}\). Definamos \(P:\omega \times \omega \rightarrow \omega \) de la siguiente manera \[ P(t,x)=\left \{ \begin{array}{ccc} P_{1}(t,\ast ^{\leq }(x)) &amp; \text{si} &amp; \ast ^{\leq }(x)\in \mathrm{Pro}^{\Sigma _{p}}\\ 0 &amp; \text{si} &amp; \ast ^{\leq }(x)\notin \mathrm{Pro}^{\Sigma _{p}} \end{array}\right . \] Claramente \(P\) es
\(\Sigma _{p}\)-p.r., por lo cual el teorema de independencia del alfabeto nos dice que \(P\) es \(\emptyset \)-p.r..
Sea \(Q=\lambda x\left [(\exists t\in \omega )P(t,x)\right ]\). Notese que \[ AutoHalt^{\Sigma _{p}}=Q\circ \#^{\leq }\mathrm{|}_{\mathrm{Pro}^{\Sigma _{p}}} \] lo cual dice que \(Q\) no es \(\Sigma _{p}\)-r. ya que de serlo, el predicado \(AutoHalt^{\Sigma _{p}}\) lo
seria. Por el teorema de independencia del alfabeto tenemos entonces que \(Q\) no
es \(\emptyset \)-recursivo.                                                                                     □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 18946 --><p class='noindent'><span class='head'>
<a id='x1-214002r267'></a>
<span class='cmbx-10'>Corollary 267.</span>  </span><span class='cmti-10'>No toda funcion representable es</span> \(\emptyset \)<span class='cmti-10'>-recursiva</span>
</p>
   </div>
<!-- l. 18950 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18951 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Dejamos como ejercicio para el lector probar que el predicado \(Q\) del lema
anterior es representable, lo cual completa la prueba de este corolario ya que \(Q\)
no es \(\emptyset \)-recursivo.                                                                                 □
</p>
   </div>
<!-- l. 18957 --><p class='indent'>   Recordemos que para \(\alpha \in \Sigma ^{\ast }\), definimos \[ ^{\curvearrowright }\alpha =\left \{ \begin{array}{lll} \left [\alpha \right ]_{2}...\left [\alpha \right ]_{\left \vert \alpha \right \vert } &amp; \text{si} &amp; \left \vert \alpha \right \vert \geq 2\\ \varepsilon &amp; \text{si} &amp; \left \vert \alpha \right \vert \leq 1 \end{array}\right . \]
</p>
   <div class='newtheorem'>

<!-- l. 18965 --><p class='noindent'><span class='head'>
<a id='x1-214003r268'></a>
<span class='cmbx-10'>Lema 268.</span>  </span><span class='cmti-10'>Si</span> \(Verd_{\mathbf{\omega }}\) <span class='cmti-10'>es</span> \(\mathcal{A}\)<span class='cmti-10'>-r.e., entonces es</span> \(\mathcal{A}\)<span class='cmti-10'>-r.</span>
</p>
   </div>
<!-- l. 18969 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18970 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Supongamos \(Verd_{\mathbf{\omega }}\) es \(\mathcal{A}\)-r. e. Sea \(f:\omega \rightarrow Verd_{\mathbf{\omega }}\) una funcion sobre y \(\mathcal{A}\)-r. Sea \(g:S^{\tau _{A}}\rightarrow S^{\tau _{A}}\), dada por \[ g(\varphi )=\left \{ \begin{array}{ccc} ^{\curvearrowright }\varphi &amp; \;\; &amp; \text{si }\left [\varphi \right ]_{1}=\lnot \\ \lnot \varphi &amp; \;\; &amp; \text{caso contrario} \end{array}\right . \] Notar
que \(g\) es \(\mathcal{A}\)-p.r. por lo cual \(g\circ f\) es \(\mathcal{A}\)-r. Ya que \(I_{g\circ f}=S^{\tau _{A}}-Verd_{\mathbf{\omega }}\) (justifique), tenemos que \(S^{\tau _{A}}-Verd_{\mathbf{\omega }}\) es \(\mathcal{A}\)-r. e., por lo
cual \[ \mathcal{A}^{\ast }-Verd_{\mathbf{\omega }}=(\mathcal{A}^{\ast }-S^{\tau _{A}})\cup (S^{\tau _{A}}-Verd_{\mathbf{\omega }}) \] lo es. Es decir que \(Verd_{\mathbf{\omega }}\) y su complemento son \(\mathcal{A}\)-r.e. por lo cual \(Verd_{\mathbf{\omega }}\) es \(\mathcal{A}\)-r.          □
</p>
   </div>
<!-- l. 18991 --><p class='indent'>   Ahora podemos probar el importante resultado anunciado.
</p>
   <div class='newtheorem'>
<!-- l. 18992 --><p class='noindent'><span class='head'>
<a id='x1-214004r269'></a>
<span class='cmbx-10'>Proposition 269.</span>  </span>\(Verd_{\mathbf{\omega }}\) <span class='cmti-10'>no es</span> \(\mathcal{A}\)<span class='cmti-10'>-r.e.</span>
</p>
   </div>
<!-- l. 18996 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 18997 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Por el Lema <a href='#x1-214001r266'>266<!-- tex4ht:ref: halt-codificado  --></a> hay un predicado \(\emptyset \)-p.r., \(P:\omega \times \omega \rightarrow \omega \) tal que el predicado \(Q=\lambda x\left [(\exists t\in \omega )P(t,x)\right ]:\omega \rightarrow \omega \) no es
\(\emptyset \)-recursivo. Notese que \(Q\) tampoco es \(\mathcal{A}\)-recursivo. Ya que \(P\) es representable, hay una
formula \(\varphi =_{d}\varphi (v_{1},v_{2},v)\in F^{\tau _{A}}\) la cual cumple \[ \mathbf{\omega }\models \varphi \left [t,x,k\right ]\text{ si y solo si }P(t,x)=k \] cualesquiera sean \(t,x,k\in \omega .\) Sea \(\psi =\varphi (v_{1},v_{2},1)\). Declaremos \(\psi =_{d}\psi (v_{1},v_{2})\). Tenemos entonces
\[ \mathbf{\omega }\models \psi \left [t,x\right ]\text{ si y solo si }P(t,x)=1 \] cualesquiera sean \(t,x\in \omega .\) Sea \(\psi _{0}=\exists v_{1}\ \psi (v_{1},v_{2})\). Declaremos \(\psi _{0}=_{d}\psi _{0}(v_{2})\). Tenemos entonces \[ \mathbf{\omega }\models \psi _{0}\left [x\right ]\text{ si y solo si }Q(x)=1 \] cualesquiera sea \(x\in \omega \). Por
el lema de reemplazo tenemos que para \(x\in \omega \), \[ \mathbf{\omega }\models \psi _{0}\left [x\right ]\text{ si y solo si }\mathbf{\omega }\models \psi _{0}(\widehat{x}) \] (justifique), por lo cual \[ \mathbf{\omega }\models \psi _{0}(\widehat{x})\text{ si y solo si }Q(x)=1 \] cualesquiera
sea \(x\in \omega \). Ya que \(\psi _{0}(\widehat{x})\) es una sentencia, \[ \psi _{0}(\widehat{x})\in Verd_{\mathbf{\omega }}\text{ si y solo si }Q(x)=1 \] Sea \(h:\omega \rightarrow \mathcal{A}^{\ast }\), dada por \(h(x)=\psi _{0}(\widehat{x})\). Es facil ver que \(h\) es \(\mathcal{A}\)-recursiva.
Ya que \(Q=\chi _{Verd_{\mathbf{\omega }}}^{\mathcal{A}^{\ast }}\circ h\) y \(Q\) no es \(\mathcal{A}\)-recursivo, tenemos que \(\chi _{Verd_{\mathbf{\omega }}}^{\mathcal{A}^{\ast }}\) no es \(\mathcal{A}\)-recursiva, es decir que \(Verd_{\mathbf{\omega }}\) es un
conjunto no \(\mathcal{A}\)-recursivo. El lema anterior nos dice entonces que es \(Verd_{\mathbf{\omega }}\) no es \(\mathcal{A}\)-r.e..   □

</p>
   </div>
<!-- l. 19038 --><p class='indent'>   Ahora si, estamos en condiciones de probar facilmente el famoso resultado de
Godel.
</p>
   <div class='newtheorem'>
<!-- l. 19040 --><p class='noindent'><span class='head'>
<a id='x1-214005r270'></a>
<span class='cmbx-10'>Teorema 270 </span>(Teorema de incompletitud)<span class='cmbx-10'>.</span>  </span><span class='cmti-10'>Si</span> \(\Sigma \subseteq Verd_{\mathbf{\omega }}\) <span class='cmti-10'>es</span> \(\mathcal{A}\)<span class='cmti-10'>-r.e., entonces</span> \(Teo_{(\Sigma ,\tau _{A})}\subsetneq Verd_{\mathbf{\omega }}\)
</p>
   </div>
<!-- l. 19045 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 19046 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Ya que \(\mathbf{\omega }\) es un modelo de \((\Sigma ,\tau _{A})\), por el Teorema de Correccion, tenemos que \(Teo_{(\Sigma ,\tau _{A})}\subseteq Verd_{\mathbf{\omega }}\).
Ya que \(Teo_{(\Sigma ,\tau _{A})}\) es \(\mathcal{A}\)-r.e (Proposicion <a href='#x1-212039r263'>263<!-- tex4ht:ref: teoremas son r.e.  --></a>) y \(Verd_{\mathbf{\omega }}\) no lo es, tenemos que \(Teo_{(\Sigma ,\tau _{A})}\neq Verd_{\mathbf{\omega }}\).                        □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 19052 --><p class='noindent'><span class='head'>
<a id='x1-214006r271'></a>
<span class='cmbx-10'>Corollary 271.</span>  </span><span class='cmti-10'>Existe</span> \(\varphi \in S^{\tau _{A}}\) <span class='cmti-10'>tal que</span> \(Arit\nvdash \varphi \) <span class='cmti-10'>y</span> \(Arit\nvdash \lnot \varphi \)<span class='cmti-10'>.</span>
</p>
   </div>
<!-- l. 19057 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 19058 --><p class='indent'>   <span class='head'>
<span class='cmti-10'>Proof.</span> </span>Dejamos al lector la prueba de que el conjunto \(\Sigma _{A}\) es \(\mathcal{A}\)-r.e.. Una ves probado
esto, podemos aplicar el teorema anterior a la teoria \(Arit=(\Sigma _{A},\tau _{A})\), lo cual nos dice que \(Teo_{Arit}\subsetneq Verd_{\mathbf{\omega }}\). Sea
\(\varphi \in Verd_{\mathbf{\omega }}-Teo_{Arit}\). O sea que \(Arit\nvdash \varphi \) y \(\varphi \in Verd_{\mathbf{\omega }}\). Ya que \(\lnot \varphi \notin Verd_{\mathbf{\omega }}\), tenemos que \(\lnot \varphi \notin Teo_{Arit}\), es decir \(Arit\nvdash \lnot \varphi \).                                      □
</p>
   </div>
    
</body> 
</html>